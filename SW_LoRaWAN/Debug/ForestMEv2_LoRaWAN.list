
ForestMEv2_LoRaWAN.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000138  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00016608  08000138  08000138  00001138  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000010bc  08016740  08016740  00017740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .USER_embedded_Keys 000000d8  080177fc  080177fc  000187fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  080178d4  080178d4  00019178  2**0
                  CONTENTS
  5 .ARM          00000008  080178d4  080178d4  000188d4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  080178dc  080178dc  00019178  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  080178dc  080178dc  000188dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000004  080178e0  080178e0  000188e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .data         00000178  20000000  080178e4  00019000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00001be4  20000178  08017a5c  00019178  2**3
                  ALLOC
 11 ._user_heap_stack 00000604  20001d5c  08017a5c  00019d5c  2**0
                  ALLOC
 12 .ARM.attributes 0000002a  00000000  00000000  00019178  2**0
                  CONTENTS, READONLY
 13 .debug_info   0006be6a  00000000  00000000  000191a2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000e9cf  00000000  00000000  0008500c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loclists 0002bd27  00000000  00000000  000939db  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00002b30  00000000  00000000  000bf708  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 000063df  00000000  00000000  000c2238  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0002aaf2  00000000  00000000  000c8617  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00062a9f  00000000  00000000  000f3109  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000d1124  00000000  00000000  00155ba8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  00226ccc  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00008698  00000000  00000000  00226d10  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 0000007f  00000000  00000000  0022f3a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000138 <__do_global_dtors_aux>:
 8000138:	b510      	push	{r4, lr}
 800013a:	4c05      	ldr	r4, [pc, #20]	@ (8000150 <__do_global_dtors_aux+0x18>)
 800013c:	7823      	ldrb	r3, [r4, #0]
 800013e:	b933      	cbnz	r3, 800014e <__do_global_dtors_aux+0x16>
 8000140:	4b04      	ldr	r3, [pc, #16]	@ (8000154 <__do_global_dtors_aux+0x1c>)
 8000142:	b113      	cbz	r3, 800014a <__do_global_dtors_aux+0x12>
 8000144:	4804      	ldr	r0, [pc, #16]	@ (8000158 <__do_global_dtors_aux+0x20>)
 8000146:	f3af 8000 	nop.w
 800014a:	2301      	movs	r3, #1
 800014c:	7023      	strb	r3, [r4, #0]
 800014e:	bd10      	pop	{r4, pc}
 8000150:	20000178 	.word	0x20000178
 8000154:	00000000 	.word	0x00000000
 8000158:	08016728 	.word	0x08016728

0800015c <frame_dummy>:
 800015c:	b508      	push	{r3, lr}
 800015e:	4b03      	ldr	r3, [pc, #12]	@ (800016c <frame_dummy+0x10>)
 8000160:	b11b      	cbz	r3, 800016a <frame_dummy+0xe>
 8000162:	4903      	ldr	r1, [pc, #12]	@ (8000170 <frame_dummy+0x14>)
 8000164:	4803      	ldr	r0, [pc, #12]	@ (8000174 <frame_dummy+0x18>)
 8000166:	f3af 8000 	nop.w
 800016a:	bd08      	pop	{r3, pc}
 800016c:	00000000 	.word	0x00000000
 8000170:	2000017c 	.word	0x2000017c
 8000174:	08016728 	.word	0x08016728

08000178 <strlen>:
 8000178:	4603      	mov	r3, r0
 800017a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800017e:	2a00      	cmp	r2, #0
 8000180:	d1fb      	bne.n	800017a <strlen+0x2>
 8000182:	1a18      	subs	r0, r3, r0
 8000184:	3801      	subs	r0, #1
 8000186:	4770      	bx	lr

08000188 <__aeabi_drsub>:
 8000188:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 800018c:	e002      	b.n	8000194 <__adddf3>
 800018e:	bf00      	nop

08000190 <__aeabi_dsub>:
 8000190:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

08000194 <__adddf3>:
 8000194:	b530      	push	{r4, r5, lr}
 8000196:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800019a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800019e:	ea94 0f05 	teq	r4, r5
 80001a2:	bf08      	it	eq
 80001a4:	ea90 0f02 	teqeq	r0, r2
 80001a8:	bf1f      	itttt	ne
 80001aa:	ea54 0c00 	orrsne.w	ip, r4, r0
 80001ae:	ea55 0c02 	orrsne.w	ip, r5, r2
 80001b2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80001b6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80001ba:	f000 80e2 	beq.w	8000382 <__adddf3+0x1ee>
 80001be:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80001c2:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80001c6:	bfb8      	it	lt
 80001c8:	426d      	neglt	r5, r5
 80001ca:	dd0c      	ble.n	80001e6 <__adddf3+0x52>
 80001cc:	442c      	add	r4, r5
 80001ce:	ea80 0202 	eor.w	r2, r0, r2
 80001d2:	ea81 0303 	eor.w	r3, r1, r3
 80001d6:	ea82 0000 	eor.w	r0, r2, r0
 80001da:	ea83 0101 	eor.w	r1, r3, r1
 80001de:	ea80 0202 	eor.w	r2, r0, r2
 80001e2:	ea81 0303 	eor.w	r3, r1, r3
 80001e6:	2d36      	cmp	r5, #54	@ 0x36
 80001e8:	bf88      	it	hi
 80001ea:	bd30      	pophi	{r4, r5, pc}
 80001ec:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80001f0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80001f4:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 80001f8:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80001fc:	d002      	beq.n	8000204 <__adddf3+0x70>
 80001fe:	4240      	negs	r0, r0
 8000200:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000204:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000208:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800020c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000210:	d002      	beq.n	8000218 <__adddf3+0x84>
 8000212:	4252      	negs	r2, r2
 8000214:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000218:	ea94 0f05 	teq	r4, r5
 800021c:	f000 80a7 	beq.w	800036e <__adddf3+0x1da>
 8000220:	f1a4 0401 	sub.w	r4, r4, #1
 8000224:	f1d5 0e20 	rsbs	lr, r5, #32
 8000228:	db0d      	blt.n	8000246 <__adddf3+0xb2>
 800022a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800022e:	fa22 f205 	lsr.w	r2, r2, r5
 8000232:	1880      	adds	r0, r0, r2
 8000234:	f141 0100 	adc.w	r1, r1, #0
 8000238:	fa03 f20e 	lsl.w	r2, r3, lr
 800023c:	1880      	adds	r0, r0, r2
 800023e:	fa43 f305 	asr.w	r3, r3, r5
 8000242:	4159      	adcs	r1, r3
 8000244:	e00e      	b.n	8000264 <__adddf3+0xd0>
 8000246:	f1a5 0520 	sub.w	r5, r5, #32
 800024a:	f10e 0e20 	add.w	lr, lr, #32
 800024e:	2a01      	cmp	r2, #1
 8000250:	fa03 fc0e 	lsl.w	ip, r3, lr
 8000254:	bf28      	it	cs
 8000256:	f04c 0c02 	orrcs.w	ip, ip, #2
 800025a:	fa43 f305 	asr.w	r3, r3, r5
 800025e:	18c0      	adds	r0, r0, r3
 8000260:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000264:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000268:	d507      	bpl.n	800027a <__adddf3+0xe6>
 800026a:	f04f 0e00 	mov.w	lr, #0
 800026e:	f1dc 0c00 	rsbs	ip, ip, #0
 8000272:	eb7e 0000 	sbcs.w	r0, lr, r0
 8000276:	eb6e 0101 	sbc.w	r1, lr, r1
 800027a:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 800027e:	d31b      	bcc.n	80002b8 <__adddf3+0x124>
 8000280:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 8000284:	d30c      	bcc.n	80002a0 <__adddf3+0x10c>
 8000286:	0849      	lsrs	r1, r1, #1
 8000288:	ea5f 0030 	movs.w	r0, r0, rrx
 800028c:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000290:	f104 0401 	add.w	r4, r4, #1
 8000294:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000298:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 800029c:	f080 809a 	bcs.w	80003d4 <__adddf3+0x240>
 80002a0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80002a4:	bf08      	it	eq
 80002a6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80002aa:	f150 0000 	adcs.w	r0, r0, #0
 80002ae:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80002b2:	ea41 0105 	orr.w	r1, r1, r5
 80002b6:	bd30      	pop	{r4, r5, pc}
 80002b8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80002bc:	4140      	adcs	r0, r0
 80002be:	eb41 0101 	adc.w	r1, r1, r1
 80002c2:	3c01      	subs	r4, #1
 80002c4:	bf28      	it	cs
 80002c6:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80002ca:	d2e9      	bcs.n	80002a0 <__adddf3+0x10c>
 80002cc:	f091 0f00 	teq	r1, #0
 80002d0:	bf04      	itt	eq
 80002d2:	4601      	moveq	r1, r0
 80002d4:	2000      	moveq	r0, #0
 80002d6:	fab1 f381 	clz	r3, r1
 80002da:	bf08      	it	eq
 80002dc:	3320      	addeq	r3, #32
 80002de:	f1a3 030b 	sub.w	r3, r3, #11
 80002e2:	f1b3 0220 	subs.w	r2, r3, #32
 80002e6:	da0c      	bge.n	8000302 <__adddf3+0x16e>
 80002e8:	320c      	adds	r2, #12
 80002ea:	dd08      	ble.n	80002fe <__adddf3+0x16a>
 80002ec:	f102 0c14 	add.w	ip, r2, #20
 80002f0:	f1c2 020c 	rsb	r2, r2, #12
 80002f4:	fa01 f00c 	lsl.w	r0, r1, ip
 80002f8:	fa21 f102 	lsr.w	r1, r1, r2
 80002fc:	e00c      	b.n	8000318 <__adddf3+0x184>
 80002fe:	f102 0214 	add.w	r2, r2, #20
 8000302:	bfd8      	it	le
 8000304:	f1c2 0c20 	rsble	ip, r2, #32
 8000308:	fa01 f102 	lsl.w	r1, r1, r2
 800030c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000310:	bfdc      	itt	le
 8000312:	ea41 010c 	orrle.w	r1, r1, ip
 8000316:	4090      	lslle	r0, r2
 8000318:	1ae4      	subs	r4, r4, r3
 800031a:	bfa2      	ittt	ge
 800031c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000320:	4329      	orrge	r1, r5
 8000322:	bd30      	popge	{r4, r5, pc}
 8000324:	ea6f 0404 	mvn.w	r4, r4
 8000328:	3c1f      	subs	r4, #31
 800032a:	da1c      	bge.n	8000366 <__adddf3+0x1d2>
 800032c:	340c      	adds	r4, #12
 800032e:	dc0e      	bgt.n	800034e <__adddf3+0x1ba>
 8000330:	f104 0414 	add.w	r4, r4, #20
 8000334:	f1c4 0220 	rsb	r2, r4, #32
 8000338:	fa20 f004 	lsr.w	r0, r0, r4
 800033c:	fa01 f302 	lsl.w	r3, r1, r2
 8000340:	ea40 0003 	orr.w	r0, r0, r3
 8000344:	fa21 f304 	lsr.w	r3, r1, r4
 8000348:	ea45 0103 	orr.w	r1, r5, r3
 800034c:	bd30      	pop	{r4, r5, pc}
 800034e:	f1c4 040c 	rsb	r4, r4, #12
 8000352:	f1c4 0220 	rsb	r2, r4, #32
 8000356:	fa20 f002 	lsr.w	r0, r0, r2
 800035a:	fa01 f304 	lsl.w	r3, r1, r4
 800035e:	ea40 0003 	orr.w	r0, r0, r3
 8000362:	4629      	mov	r1, r5
 8000364:	bd30      	pop	{r4, r5, pc}
 8000366:	fa21 f004 	lsr.w	r0, r1, r4
 800036a:	4629      	mov	r1, r5
 800036c:	bd30      	pop	{r4, r5, pc}
 800036e:	f094 0f00 	teq	r4, #0
 8000372:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 8000376:	bf06      	itte	eq
 8000378:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 800037c:	3401      	addeq	r4, #1
 800037e:	3d01      	subne	r5, #1
 8000380:	e74e      	b.n	8000220 <__adddf3+0x8c>
 8000382:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000386:	bf18      	it	ne
 8000388:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800038c:	d029      	beq.n	80003e2 <__adddf3+0x24e>
 800038e:	ea94 0f05 	teq	r4, r5
 8000392:	bf08      	it	eq
 8000394:	ea90 0f02 	teqeq	r0, r2
 8000398:	d005      	beq.n	80003a6 <__adddf3+0x212>
 800039a:	ea54 0c00 	orrs.w	ip, r4, r0
 800039e:	bf04      	itt	eq
 80003a0:	4619      	moveq	r1, r3
 80003a2:	4610      	moveq	r0, r2
 80003a4:	bd30      	pop	{r4, r5, pc}
 80003a6:	ea91 0f03 	teq	r1, r3
 80003aa:	bf1e      	ittt	ne
 80003ac:	2100      	movne	r1, #0
 80003ae:	2000      	movne	r0, #0
 80003b0:	bd30      	popne	{r4, r5, pc}
 80003b2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80003b6:	d105      	bne.n	80003c4 <__adddf3+0x230>
 80003b8:	0040      	lsls	r0, r0, #1
 80003ba:	4149      	adcs	r1, r1
 80003bc:	bf28      	it	cs
 80003be:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 80003c2:	bd30      	pop	{r4, r5, pc}
 80003c4:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80003c8:	bf3c      	itt	cc
 80003ca:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80003ce:	bd30      	popcc	{r4, r5, pc}
 80003d0:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80003d4:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80003d8:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80003dc:	f04f 0000 	mov.w	r0, #0
 80003e0:	bd30      	pop	{r4, r5, pc}
 80003e2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003e6:	bf1a      	itte	ne
 80003e8:	4619      	movne	r1, r3
 80003ea:	4610      	movne	r0, r2
 80003ec:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80003f0:	bf1c      	itt	ne
 80003f2:	460b      	movne	r3, r1
 80003f4:	4602      	movne	r2, r0
 80003f6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80003fa:	bf06      	itte	eq
 80003fc:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000400:	ea91 0f03 	teqeq	r1, r3
 8000404:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000408:	bd30      	pop	{r4, r5, pc}
 800040a:	bf00      	nop

0800040c <__aeabi_ui2d>:
 800040c:	f090 0f00 	teq	r0, #0
 8000410:	bf04      	itt	eq
 8000412:	2100      	moveq	r1, #0
 8000414:	4770      	bxeq	lr
 8000416:	b530      	push	{r4, r5, lr}
 8000418:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800041c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000420:	f04f 0500 	mov.w	r5, #0
 8000424:	f04f 0100 	mov.w	r1, #0
 8000428:	e750      	b.n	80002cc <__adddf3+0x138>
 800042a:	bf00      	nop

0800042c <__aeabi_i2d>:
 800042c:	f090 0f00 	teq	r0, #0
 8000430:	bf04      	itt	eq
 8000432:	2100      	moveq	r1, #0
 8000434:	4770      	bxeq	lr
 8000436:	b530      	push	{r4, r5, lr}
 8000438:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800043c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000440:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 8000444:	bf48      	it	mi
 8000446:	4240      	negmi	r0, r0
 8000448:	f04f 0100 	mov.w	r1, #0
 800044c:	e73e      	b.n	80002cc <__adddf3+0x138>
 800044e:	bf00      	nop

08000450 <__aeabi_f2d>:
 8000450:	0042      	lsls	r2, r0, #1
 8000452:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8000456:	ea4f 0131 	mov.w	r1, r1, rrx
 800045a:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800045e:	bf1f      	itttt	ne
 8000460:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 8000464:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8000468:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 800046c:	4770      	bxne	lr
 800046e:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 8000472:	bf08      	it	eq
 8000474:	4770      	bxeq	lr
 8000476:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 800047a:	bf04      	itt	eq
 800047c:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000480:	4770      	bxeq	lr
 8000482:	b530      	push	{r4, r5, lr}
 8000484:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8000488:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 800048c:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000490:	e71c      	b.n	80002cc <__adddf3+0x138>
 8000492:	bf00      	nop

08000494 <__aeabi_ul2d>:
 8000494:	ea50 0201 	orrs.w	r2, r0, r1
 8000498:	bf08      	it	eq
 800049a:	4770      	bxeq	lr
 800049c:	b530      	push	{r4, r5, lr}
 800049e:	f04f 0500 	mov.w	r5, #0
 80004a2:	e00a      	b.n	80004ba <__aeabi_l2d+0x16>

080004a4 <__aeabi_l2d>:
 80004a4:	ea50 0201 	orrs.w	r2, r0, r1
 80004a8:	bf08      	it	eq
 80004aa:	4770      	bxeq	lr
 80004ac:	b530      	push	{r4, r5, lr}
 80004ae:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 80004b2:	d502      	bpl.n	80004ba <__aeabi_l2d+0x16>
 80004b4:	4240      	negs	r0, r0
 80004b6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80004ba:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80004be:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80004c2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80004c6:	f43f aed8 	beq.w	800027a <__adddf3+0xe6>
 80004ca:	f04f 0203 	mov.w	r2, #3
 80004ce:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80004d2:	bf18      	it	ne
 80004d4:	3203      	addne	r2, #3
 80004d6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80004da:	bf18      	it	ne
 80004dc:	3203      	addne	r2, #3
 80004de:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80004e2:	f1c2 0320 	rsb	r3, r2, #32
 80004e6:	fa00 fc03 	lsl.w	ip, r0, r3
 80004ea:	fa20 f002 	lsr.w	r0, r0, r2
 80004ee:	fa01 fe03 	lsl.w	lr, r1, r3
 80004f2:	ea40 000e 	orr.w	r0, r0, lr
 80004f6:	fa21 f102 	lsr.w	r1, r1, r2
 80004fa:	4414      	add	r4, r2
 80004fc:	e6bd      	b.n	800027a <__adddf3+0xe6>
 80004fe:	bf00      	nop

08000500 <__gedf2>:
 8000500:	f04f 3cff 	mov.w	ip, #4294967295
 8000504:	e006      	b.n	8000514 <__cmpdf2+0x4>
 8000506:	bf00      	nop

08000508 <__ledf2>:
 8000508:	f04f 0c01 	mov.w	ip, #1
 800050c:	e002      	b.n	8000514 <__cmpdf2+0x4>
 800050e:	bf00      	nop

08000510 <__cmpdf2>:
 8000510:	f04f 0c01 	mov.w	ip, #1
 8000514:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000518:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800051c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000520:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000524:	bf18      	it	ne
 8000526:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800052a:	d01b      	beq.n	8000564 <__cmpdf2+0x54>
 800052c:	b001      	add	sp, #4
 800052e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000532:	bf0c      	ite	eq
 8000534:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000538:	ea91 0f03 	teqne	r1, r3
 800053c:	bf02      	ittt	eq
 800053e:	ea90 0f02 	teqeq	r0, r2
 8000542:	2000      	moveq	r0, #0
 8000544:	4770      	bxeq	lr
 8000546:	f110 0f00 	cmn.w	r0, #0
 800054a:	ea91 0f03 	teq	r1, r3
 800054e:	bf58      	it	pl
 8000550:	4299      	cmppl	r1, r3
 8000552:	bf08      	it	eq
 8000554:	4290      	cmpeq	r0, r2
 8000556:	bf2c      	ite	cs
 8000558:	17d8      	asrcs	r0, r3, #31
 800055a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800055e:	f040 0001 	orr.w	r0, r0, #1
 8000562:	4770      	bx	lr
 8000564:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000568:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800056c:	d102      	bne.n	8000574 <__cmpdf2+0x64>
 800056e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000572:	d107      	bne.n	8000584 <__cmpdf2+0x74>
 8000574:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000578:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800057c:	d1d6      	bne.n	800052c <__cmpdf2+0x1c>
 800057e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000582:	d0d3      	beq.n	800052c <__cmpdf2+0x1c>
 8000584:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000588:	4770      	bx	lr
 800058a:	bf00      	nop

0800058c <__aeabi_cdrcmple>:
 800058c:	4684      	mov	ip, r0
 800058e:	4610      	mov	r0, r2
 8000590:	4662      	mov	r2, ip
 8000592:	468c      	mov	ip, r1
 8000594:	4619      	mov	r1, r3
 8000596:	4663      	mov	r3, ip
 8000598:	e000      	b.n	800059c <__aeabi_cdcmpeq>
 800059a:	bf00      	nop

0800059c <__aeabi_cdcmpeq>:
 800059c:	b501      	push	{r0, lr}
 800059e:	f7ff ffb7 	bl	8000510 <__cmpdf2>
 80005a2:	2800      	cmp	r0, #0
 80005a4:	bf48      	it	mi
 80005a6:	f110 0f00 	cmnmi.w	r0, #0
 80005aa:	bd01      	pop	{r0, pc}

080005ac <__aeabi_dcmpeq>:
 80005ac:	f84d ed08 	str.w	lr, [sp, #-8]!
 80005b0:	f7ff fff4 	bl	800059c <__aeabi_cdcmpeq>
 80005b4:	bf0c      	ite	eq
 80005b6:	2001      	moveq	r0, #1
 80005b8:	2000      	movne	r0, #0
 80005ba:	f85d fb08 	ldr.w	pc, [sp], #8
 80005be:	bf00      	nop

080005c0 <__aeabi_dcmplt>:
 80005c0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80005c4:	f7ff ffea 	bl	800059c <__aeabi_cdcmpeq>
 80005c8:	bf34      	ite	cc
 80005ca:	2001      	movcc	r0, #1
 80005cc:	2000      	movcs	r0, #0
 80005ce:	f85d fb08 	ldr.w	pc, [sp], #8
 80005d2:	bf00      	nop

080005d4 <__aeabi_dcmple>:
 80005d4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80005d8:	f7ff ffe0 	bl	800059c <__aeabi_cdcmpeq>
 80005dc:	bf94      	ite	ls
 80005de:	2001      	movls	r0, #1
 80005e0:	2000      	movhi	r0, #0
 80005e2:	f85d fb08 	ldr.w	pc, [sp], #8
 80005e6:	bf00      	nop

080005e8 <__aeabi_dcmpge>:
 80005e8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80005ec:	f7ff ffce 	bl	800058c <__aeabi_cdrcmple>
 80005f0:	bf94      	ite	ls
 80005f2:	2001      	movls	r0, #1
 80005f4:	2000      	movhi	r0, #0
 80005f6:	f85d fb08 	ldr.w	pc, [sp], #8
 80005fa:	bf00      	nop

080005fc <__aeabi_dcmpgt>:
 80005fc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000600:	f7ff ffc4 	bl	800058c <__aeabi_cdrcmple>
 8000604:	bf34      	ite	cc
 8000606:	2001      	movcc	r0, #1
 8000608:	2000      	movcs	r0, #0
 800060a:	f85d fb08 	ldr.w	pc, [sp], #8
 800060e:	bf00      	nop

08000610 <__aeabi_d2iz>:
 8000610:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000614:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8000618:	d215      	bcs.n	8000646 <__aeabi_d2iz+0x36>
 800061a:	d511      	bpl.n	8000640 <__aeabi_d2iz+0x30>
 800061c:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8000620:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000624:	d912      	bls.n	800064c <__aeabi_d2iz+0x3c>
 8000626:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800062a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800062e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000632:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000636:	fa23 f002 	lsr.w	r0, r3, r2
 800063a:	bf18      	it	ne
 800063c:	4240      	negne	r0, r0
 800063e:	4770      	bx	lr
 8000640:	f04f 0000 	mov.w	r0, #0
 8000644:	4770      	bx	lr
 8000646:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800064a:	d105      	bne.n	8000658 <__aeabi_d2iz+0x48>
 800064c:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
 8000650:	bf08      	it	eq
 8000652:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
 8000656:	4770      	bx	lr
 8000658:	f04f 0000 	mov.w	r0, #0
 800065c:	4770      	bx	lr
 800065e:	bf00      	nop

08000660 <__aeabi_frsub>:
 8000660:	f080 4000 	eor.w	r0, r0, #2147483648	@ 0x80000000
 8000664:	e002      	b.n	800066c <__addsf3>
 8000666:	bf00      	nop

08000668 <__aeabi_fsub>:
 8000668:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000

0800066c <__addsf3>:
 800066c:	0042      	lsls	r2, r0, #1
 800066e:	bf1f      	itttt	ne
 8000670:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000674:	ea92 0f03 	teqne	r2, r3
 8000678:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 800067c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000680:	d06a      	beq.n	8000758 <__addsf3+0xec>
 8000682:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000686:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 800068a:	bfc1      	itttt	gt
 800068c:	18d2      	addgt	r2, r2, r3
 800068e:	4041      	eorgt	r1, r0
 8000690:	4048      	eorgt	r0, r1
 8000692:	4041      	eorgt	r1, r0
 8000694:	bfb8      	it	lt
 8000696:	425b      	neglt	r3, r3
 8000698:	2b19      	cmp	r3, #25
 800069a:	bf88      	it	hi
 800069c:	4770      	bxhi	lr
 800069e:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
 80006a2:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80006a6:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
 80006aa:	bf18      	it	ne
 80006ac:	4240      	negne	r0, r0
 80006ae:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80006b2:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 80006b6:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
 80006ba:	bf18      	it	ne
 80006bc:	4249      	negne	r1, r1
 80006be:	ea92 0f03 	teq	r2, r3
 80006c2:	d03f      	beq.n	8000744 <__addsf3+0xd8>
 80006c4:	f1a2 0201 	sub.w	r2, r2, #1
 80006c8:	fa41 fc03 	asr.w	ip, r1, r3
 80006cc:	eb10 000c 	adds.w	r0, r0, ip
 80006d0:	f1c3 0320 	rsb	r3, r3, #32
 80006d4:	fa01 f103 	lsl.w	r1, r1, r3
 80006d8:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 80006dc:	d502      	bpl.n	80006e4 <__addsf3+0x78>
 80006de:	4249      	negs	r1, r1
 80006e0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80006e4:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 80006e8:	d313      	bcc.n	8000712 <__addsf3+0xa6>
 80006ea:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 80006ee:	d306      	bcc.n	80006fe <__addsf3+0x92>
 80006f0:	0840      	lsrs	r0, r0, #1
 80006f2:	ea4f 0131 	mov.w	r1, r1, rrx
 80006f6:	f102 0201 	add.w	r2, r2, #1
 80006fa:	2afe      	cmp	r2, #254	@ 0xfe
 80006fc:	d251      	bcs.n	80007a2 <__addsf3+0x136>
 80006fe:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
 8000702:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000706:	bf08      	it	eq
 8000708:	f020 0001 	biceq.w	r0, r0, #1
 800070c:	ea40 0003 	orr.w	r0, r0, r3
 8000710:	4770      	bx	lr
 8000712:	0049      	lsls	r1, r1, #1
 8000714:	eb40 0000 	adc.w	r0, r0, r0
 8000718:	3a01      	subs	r2, #1
 800071a:	bf28      	it	cs
 800071c:	f5b0 0f00 	cmpcs.w	r0, #8388608	@ 0x800000
 8000720:	d2ed      	bcs.n	80006fe <__addsf3+0x92>
 8000722:	fab0 fc80 	clz	ip, r0
 8000726:	f1ac 0c08 	sub.w	ip, ip, #8
 800072a:	ebb2 020c 	subs.w	r2, r2, ip
 800072e:	fa00 f00c 	lsl.w	r0, r0, ip
 8000732:	bfaa      	itet	ge
 8000734:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000738:	4252      	neglt	r2, r2
 800073a:	4318      	orrge	r0, r3
 800073c:	bfbc      	itt	lt
 800073e:	40d0      	lsrlt	r0, r2
 8000740:	4318      	orrlt	r0, r3
 8000742:	4770      	bx	lr
 8000744:	f092 0f00 	teq	r2, #0
 8000748:	f481 0100 	eor.w	r1, r1, #8388608	@ 0x800000
 800074c:	bf06      	itte	eq
 800074e:	f480 0000 	eoreq.w	r0, r0, #8388608	@ 0x800000
 8000752:	3201      	addeq	r2, #1
 8000754:	3b01      	subne	r3, #1
 8000756:	e7b5      	b.n	80006c4 <__addsf3+0x58>
 8000758:	ea4f 0341 	mov.w	r3, r1, lsl #1
 800075c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000760:	bf18      	it	ne
 8000762:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000766:	d021      	beq.n	80007ac <__addsf3+0x140>
 8000768:	ea92 0f03 	teq	r2, r3
 800076c:	d004      	beq.n	8000778 <__addsf3+0x10c>
 800076e:	f092 0f00 	teq	r2, #0
 8000772:	bf08      	it	eq
 8000774:	4608      	moveq	r0, r1
 8000776:	4770      	bx	lr
 8000778:	ea90 0f01 	teq	r0, r1
 800077c:	bf1c      	itt	ne
 800077e:	2000      	movne	r0, #0
 8000780:	4770      	bxne	lr
 8000782:	f012 4f7f 	tst.w	r2, #4278190080	@ 0xff000000
 8000786:	d104      	bne.n	8000792 <__addsf3+0x126>
 8000788:	0040      	lsls	r0, r0, #1
 800078a:	bf28      	it	cs
 800078c:	f040 4000 	orrcs.w	r0, r0, #2147483648	@ 0x80000000
 8000790:	4770      	bx	lr
 8000792:	f112 7200 	adds.w	r2, r2, #33554432	@ 0x2000000
 8000796:	bf3c      	itt	cc
 8000798:	f500 0000 	addcc.w	r0, r0, #8388608	@ 0x800000
 800079c:	4770      	bxcc	lr
 800079e:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 80007a2:	f043 40fe 	orr.w	r0, r3, #2130706432	@ 0x7f000000
 80007a6:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80007aa:	4770      	bx	lr
 80007ac:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80007b0:	bf16      	itet	ne
 80007b2:	4608      	movne	r0, r1
 80007b4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80007b8:	4601      	movne	r1, r0
 80007ba:	0242      	lsls	r2, r0, #9
 80007bc:	bf06      	itte	eq
 80007be:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80007c2:	ea90 0f01 	teqeq	r0, r1
 80007c6:	f440 0080 	orrne.w	r0, r0, #4194304	@ 0x400000
 80007ca:	4770      	bx	lr

080007cc <__aeabi_ui2f>:
 80007cc:	f04f 0300 	mov.w	r3, #0
 80007d0:	e004      	b.n	80007dc <__aeabi_i2f+0x8>
 80007d2:	bf00      	nop

080007d4 <__aeabi_i2f>:
 80007d4:	f010 4300 	ands.w	r3, r0, #2147483648	@ 0x80000000
 80007d8:	bf48      	it	mi
 80007da:	4240      	negmi	r0, r0
 80007dc:	ea5f 0c00 	movs.w	ip, r0
 80007e0:	bf08      	it	eq
 80007e2:	4770      	bxeq	lr
 80007e4:	f043 4396 	orr.w	r3, r3, #1258291200	@ 0x4b000000
 80007e8:	4601      	mov	r1, r0
 80007ea:	f04f 0000 	mov.w	r0, #0
 80007ee:	e01c      	b.n	800082a <__aeabi_l2f+0x2a>

080007f0 <__aeabi_ul2f>:
 80007f0:	ea50 0201 	orrs.w	r2, r0, r1
 80007f4:	bf08      	it	eq
 80007f6:	4770      	bxeq	lr
 80007f8:	f04f 0300 	mov.w	r3, #0
 80007fc:	e00a      	b.n	8000814 <__aeabi_l2f+0x14>
 80007fe:	bf00      	nop

08000800 <__aeabi_l2f>:
 8000800:	ea50 0201 	orrs.w	r2, r0, r1
 8000804:	bf08      	it	eq
 8000806:	4770      	bxeq	lr
 8000808:	f011 4300 	ands.w	r3, r1, #2147483648	@ 0x80000000
 800080c:	d502      	bpl.n	8000814 <__aeabi_l2f+0x14>
 800080e:	4240      	negs	r0, r0
 8000810:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000814:	ea5f 0c01 	movs.w	ip, r1
 8000818:	bf02      	ittt	eq
 800081a:	4684      	moveq	ip, r0
 800081c:	4601      	moveq	r1, r0
 800081e:	2000      	moveq	r0, #0
 8000820:	f043 43b6 	orr.w	r3, r3, #1526726656	@ 0x5b000000
 8000824:	bf08      	it	eq
 8000826:	f1a3 5380 	subeq.w	r3, r3, #268435456	@ 0x10000000
 800082a:	f5a3 0300 	sub.w	r3, r3, #8388608	@ 0x800000
 800082e:	fabc f28c 	clz	r2, ip
 8000832:	3a08      	subs	r2, #8
 8000834:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000838:	db10      	blt.n	800085c <__aeabi_l2f+0x5c>
 800083a:	fa01 fc02 	lsl.w	ip, r1, r2
 800083e:	4463      	add	r3, ip
 8000840:	fa00 fc02 	lsl.w	ip, r0, r2
 8000844:	f1c2 0220 	rsb	r2, r2, #32
 8000848:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 800084c:	fa20 f202 	lsr.w	r2, r0, r2
 8000850:	eb43 0002 	adc.w	r0, r3, r2
 8000854:	bf08      	it	eq
 8000856:	f020 0001 	biceq.w	r0, r0, #1
 800085a:	4770      	bx	lr
 800085c:	f102 0220 	add.w	r2, r2, #32
 8000860:	fa01 fc02 	lsl.w	ip, r1, r2
 8000864:	f1c2 0220 	rsb	r2, r2, #32
 8000868:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 800086c:	fa21 f202 	lsr.w	r2, r1, r2
 8000870:	eb43 0002 	adc.w	r0, r3, r2
 8000874:	bf08      	it	eq
 8000876:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 800087a:	4770      	bx	lr

0800087c <__aeabi_f2iz>:
 800087c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000880:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
 8000884:	d30f      	bcc.n	80008a6 <__aeabi_f2iz+0x2a>
 8000886:	f04f 039e 	mov.w	r3, #158	@ 0x9e
 800088a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 800088e:	d90d      	bls.n	80008ac <__aeabi_f2iz+0x30>
 8000890:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000894:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8000898:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
 800089c:	fa23 f002 	lsr.w	r0, r3, r2
 80008a0:	bf18      	it	ne
 80008a2:	4240      	negne	r0, r0
 80008a4:	4770      	bx	lr
 80008a6:	f04f 0000 	mov.w	r0, #0
 80008aa:	4770      	bx	lr
 80008ac:	f112 0f61 	cmn.w	r2, #97	@ 0x61
 80008b0:	d101      	bne.n	80008b6 <__aeabi_f2iz+0x3a>
 80008b2:	0242      	lsls	r2, r0, #9
 80008b4:	d105      	bne.n	80008c2 <__aeabi_f2iz+0x46>
 80008b6:	f010 4000 	ands.w	r0, r0, #2147483648	@ 0x80000000
 80008ba:	bf08      	it	eq
 80008bc:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
 80008c0:	4770      	bx	lr
 80008c2:	f04f 0000 	mov.w	r0, #0
 80008c6:	4770      	bx	lr

080008c8 <__aeabi_ldivmod>:
 80008c8:	b97b      	cbnz	r3, 80008ea <__aeabi_ldivmod+0x22>
 80008ca:	b972      	cbnz	r2, 80008ea <__aeabi_ldivmod+0x22>
 80008cc:	2900      	cmp	r1, #0
 80008ce:	bfbe      	ittt	lt
 80008d0:	2000      	movlt	r0, #0
 80008d2:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
 80008d6:	e006      	blt.n	80008e6 <__aeabi_ldivmod+0x1e>
 80008d8:	bf08      	it	eq
 80008da:	2800      	cmpeq	r0, #0
 80008dc:	bf1c      	itt	ne
 80008de:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
 80008e2:	f04f 30ff 	movne.w	r0, #4294967295
 80008e6:	f000 b9b5 	b.w	8000c54 <__aeabi_idiv0>
 80008ea:	f1ad 0c08 	sub.w	ip, sp, #8
 80008ee:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80008f2:	2900      	cmp	r1, #0
 80008f4:	db09      	blt.n	800090a <__aeabi_ldivmod+0x42>
 80008f6:	2b00      	cmp	r3, #0
 80008f8:	db1a      	blt.n	8000930 <__aeabi_ldivmod+0x68>
 80008fa:	f000 f84d 	bl	8000998 <__udivmoddi4>
 80008fe:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000902:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000906:	b004      	add	sp, #16
 8000908:	4770      	bx	lr
 800090a:	4240      	negs	r0, r0
 800090c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000910:	2b00      	cmp	r3, #0
 8000912:	db1b      	blt.n	800094c <__aeabi_ldivmod+0x84>
 8000914:	f000 f840 	bl	8000998 <__udivmoddi4>
 8000918:	f8dd e004 	ldr.w	lr, [sp, #4]
 800091c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000920:	b004      	add	sp, #16
 8000922:	4240      	negs	r0, r0
 8000924:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000928:	4252      	negs	r2, r2
 800092a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800092e:	4770      	bx	lr
 8000930:	4252      	negs	r2, r2
 8000932:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000936:	f000 f82f 	bl	8000998 <__udivmoddi4>
 800093a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800093e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000942:	b004      	add	sp, #16
 8000944:	4240      	negs	r0, r0
 8000946:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800094a:	4770      	bx	lr
 800094c:	4252      	negs	r2, r2
 800094e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000952:	f000 f821 	bl	8000998 <__udivmoddi4>
 8000956:	f8dd e004 	ldr.w	lr, [sp, #4]
 800095a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800095e:	b004      	add	sp, #16
 8000960:	4252      	negs	r2, r2
 8000962:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000966:	4770      	bx	lr

08000968 <__aeabi_uldivmod>:
 8000968:	b953      	cbnz	r3, 8000980 <__aeabi_uldivmod+0x18>
 800096a:	b94a      	cbnz	r2, 8000980 <__aeabi_uldivmod+0x18>
 800096c:	2900      	cmp	r1, #0
 800096e:	bf08      	it	eq
 8000970:	2800      	cmpeq	r0, #0
 8000972:	bf1c      	itt	ne
 8000974:	f04f 31ff 	movne.w	r1, #4294967295
 8000978:	f04f 30ff 	movne.w	r0, #4294967295
 800097c:	f000 b96a 	b.w	8000c54 <__aeabi_idiv0>
 8000980:	f1ad 0c08 	sub.w	ip, sp, #8
 8000984:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000988:	f000 f806 	bl	8000998 <__udivmoddi4>
 800098c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000990:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000994:	b004      	add	sp, #16
 8000996:	4770      	bx	lr

08000998 <__udivmoddi4>:
 8000998:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800099c:	9d08      	ldr	r5, [sp, #32]
 800099e:	460c      	mov	r4, r1
 80009a0:	2b00      	cmp	r3, #0
 80009a2:	d14e      	bne.n	8000a42 <__udivmoddi4+0xaa>
 80009a4:	4694      	mov	ip, r2
 80009a6:	458c      	cmp	ip, r1
 80009a8:	4686      	mov	lr, r0
 80009aa:	fab2 f282 	clz	r2, r2
 80009ae:	d962      	bls.n	8000a76 <__udivmoddi4+0xde>
 80009b0:	b14a      	cbz	r2, 80009c6 <__udivmoddi4+0x2e>
 80009b2:	f1c2 0320 	rsb	r3, r2, #32
 80009b6:	4091      	lsls	r1, r2
 80009b8:	fa20 f303 	lsr.w	r3, r0, r3
 80009bc:	fa0c fc02 	lsl.w	ip, ip, r2
 80009c0:	4319      	orrs	r1, r3
 80009c2:	fa00 fe02 	lsl.w	lr, r0, r2
 80009c6:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80009ca:	fa1f f68c 	uxth.w	r6, ip
 80009ce:	fbb1 f4f7 	udiv	r4, r1, r7
 80009d2:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80009d6:	fb07 1114 	mls	r1, r7, r4, r1
 80009da:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80009de:	fb04 f106 	mul.w	r1, r4, r6
 80009e2:	4299      	cmp	r1, r3
 80009e4:	d90a      	bls.n	80009fc <__udivmoddi4+0x64>
 80009e6:	eb1c 0303 	adds.w	r3, ip, r3
 80009ea:	f104 30ff 	add.w	r0, r4, #4294967295
 80009ee:	f080 8112 	bcs.w	8000c16 <__udivmoddi4+0x27e>
 80009f2:	4299      	cmp	r1, r3
 80009f4:	f240 810f 	bls.w	8000c16 <__udivmoddi4+0x27e>
 80009f8:	3c02      	subs	r4, #2
 80009fa:	4463      	add	r3, ip
 80009fc:	1a59      	subs	r1, r3, r1
 80009fe:	fa1f f38e 	uxth.w	r3, lr
 8000a02:	fbb1 f0f7 	udiv	r0, r1, r7
 8000a06:	fb07 1110 	mls	r1, r7, r0, r1
 8000a0a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000a0e:	fb00 f606 	mul.w	r6, r0, r6
 8000a12:	429e      	cmp	r6, r3
 8000a14:	d90a      	bls.n	8000a2c <__udivmoddi4+0x94>
 8000a16:	eb1c 0303 	adds.w	r3, ip, r3
 8000a1a:	f100 31ff 	add.w	r1, r0, #4294967295
 8000a1e:	f080 80fc 	bcs.w	8000c1a <__udivmoddi4+0x282>
 8000a22:	429e      	cmp	r6, r3
 8000a24:	f240 80f9 	bls.w	8000c1a <__udivmoddi4+0x282>
 8000a28:	4463      	add	r3, ip
 8000a2a:	3802      	subs	r0, #2
 8000a2c:	1b9b      	subs	r3, r3, r6
 8000a2e:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000a32:	2100      	movs	r1, #0
 8000a34:	b11d      	cbz	r5, 8000a3e <__udivmoddi4+0xa6>
 8000a36:	40d3      	lsrs	r3, r2
 8000a38:	2200      	movs	r2, #0
 8000a3a:	e9c5 3200 	strd	r3, r2, [r5]
 8000a3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000a42:	428b      	cmp	r3, r1
 8000a44:	d905      	bls.n	8000a52 <__udivmoddi4+0xba>
 8000a46:	b10d      	cbz	r5, 8000a4c <__udivmoddi4+0xb4>
 8000a48:	e9c5 0100 	strd	r0, r1, [r5]
 8000a4c:	2100      	movs	r1, #0
 8000a4e:	4608      	mov	r0, r1
 8000a50:	e7f5      	b.n	8000a3e <__udivmoddi4+0xa6>
 8000a52:	fab3 f183 	clz	r1, r3
 8000a56:	2900      	cmp	r1, #0
 8000a58:	d146      	bne.n	8000ae8 <__udivmoddi4+0x150>
 8000a5a:	42a3      	cmp	r3, r4
 8000a5c:	d302      	bcc.n	8000a64 <__udivmoddi4+0xcc>
 8000a5e:	4290      	cmp	r0, r2
 8000a60:	f0c0 80f0 	bcc.w	8000c44 <__udivmoddi4+0x2ac>
 8000a64:	1a86      	subs	r6, r0, r2
 8000a66:	eb64 0303 	sbc.w	r3, r4, r3
 8000a6a:	2001      	movs	r0, #1
 8000a6c:	2d00      	cmp	r5, #0
 8000a6e:	d0e6      	beq.n	8000a3e <__udivmoddi4+0xa6>
 8000a70:	e9c5 6300 	strd	r6, r3, [r5]
 8000a74:	e7e3      	b.n	8000a3e <__udivmoddi4+0xa6>
 8000a76:	2a00      	cmp	r2, #0
 8000a78:	f040 8090 	bne.w	8000b9c <__udivmoddi4+0x204>
 8000a7c:	eba1 040c 	sub.w	r4, r1, ip
 8000a80:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000a84:	fa1f f78c 	uxth.w	r7, ip
 8000a88:	2101      	movs	r1, #1
 8000a8a:	fbb4 f6f8 	udiv	r6, r4, r8
 8000a8e:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000a92:	fb08 4416 	mls	r4, r8, r6, r4
 8000a96:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000a9a:	fb07 f006 	mul.w	r0, r7, r6
 8000a9e:	4298      	cmp	r0, r3
 8000aa0:	d908      	bls.n	8000ab4 <__udivmoddi4+0x11c>
 8000aa2:	eb1c 0303 	adds.w	r3, ip, r3
 8000aa6:	f106 34ff 	add.w	r4, r6, #4294967295
 8000aaa:	d202      	bcs.n	8000ab2 <__udivmoddi4+0x11a>
 8000aac:	4298      	cmp	r0, r3
 8000aae:	f200 80cd 	bhi.w	8000c4c <__udivmoddi4+0x2b4>
 8000ab2:	4626      	mov	r6, r4
 8000ab4:	1a1c      	subs	r4, r3, r0
 8000ab6:	fa1f f38e 	uxth.w	r3, lr
 8000aba:	fbb4 f0f8 	udiv	r0, r4, r8
 8000abe:	fb08 4410 	mls	r4, r8, r0, r4
 8000ac2:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000ac6:	fb00 f707 	mul.w	r7, r0, r7
 8000aca:	429f      	cmp	r7, r3
 8000acc:	d908      	bls.n	8000ae0 <__udivmoddi4+0x148>
 8000ace:	eb1c 0303 	adds.w	r3, ip, r3
 8000ad2:	f100 34ff 	add.w	r4, r0, #4294967295
 8000ad6:	d202      	bcs.n	8000ade <__udivmoddi4+0x146>
 8000ad8:	429f      	cmp	r7, r3
 8000ada:	f200 80b0 	bhi.w	8000c3e <__udivmoddi4+0x2a6>
 8000ade:	4620      	mov	r0, r4
 8000ae0:	1bdb      	subs	r3, r3, r7
 8000ae2:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000ae6:	e7a5      	b.n	8000a34 <__udivmoddi4+0x9c>
 8000ae8:	f1c1 0620 	rsb	r6, r1, #32
 8000aec:	408b      	lsls	r3, r1
 8000aee:	fa22 f706 	lsr.w	r7, r2, r6
 8000af2:	431f      	orrs	r7, r3
 8000af4:	fa20 fc06 	lsr.w	ip, r0, r6
 8000af8:	fa04 f301 	lsl.w	r3, r4, r1
 8000afc:	ea43 030c 	orr.w	r3, r3, ip
 8000b00:	40f4      	lsrs	r4, r6
 8000b02:	fa00 f801 	lsl.w	r8, r0, r1
 8000b06:	0c38      	lsrs	r0, r7, #16
 8000b08:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8000b0c:	fbb4 fef0 	udiv	lr, r4, r0
 8000b10:	fa1f fc87 	uxth.w	ip, r7
 8000b14:	fb00 441e 	mls	r4, r0, lr, r4
 8000b18:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000b1c:	fb0e f90c 	mul.w	r9, lr, ip
 8000b20:	45a1      	cmp	r9, r4
 8000b22:	fa02 f201 	lsl.w	r2, r2, r1
 8000b26:	d90a      	bls.n	8000b3e <__udivmoddi4+0x1a6>
 8000b28:	193c      	adds	r4, r7, r4
 8000b2a:	f10e 3aff 	add.w	sl, lr, #4294967295
 8000b2e:	f080 8084 	bcs.w	8000c3a <__udivmoddi4+0x2a2>
 8000b32:	45a1      	cmp	r9, r4
 8000b34:	f240 8081 	bls.w	8000c3a <__udivmoddi4+0x2a2>
 8000b38:	f1ae 0e02 	sub.w	lr, lr, #2
 8000b3c:	443c      	add	r4, r7
 8000b3e:	eba4 0409 	sub.w	r4, r4, r9
 8000b42:	fa1f f983 	uxth.w	r9, r3
 8000b46:	fbb4 f3f0 	udiv	r3, r4, r0
 8000b4a:	fb00 4413 	mls	r4, r0, r3, r4
 8000b4e:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000b52:	fb03 fc0c 	mul.w	ip, r3, ip
 8000b56:	45a4      	cmp	ip, r4
 8000b58:	d907      	bls.n	8000b6a <__udivmoddi4+0x1d2>
 8000b5a:	193c      	adds	r4, r7, r4
 8000b5c:	f103 30ff 	add.w	r0, r3, #4294967295
 8000b60:	d267      	bcs.n	8000c32 <__udivmoddi4+0x29a>
 8000b62:	45a4      	cmp	ip, r4
 8000b64:	d965      	bls.n	8000c32 <__udivmoddi4+0x29a>
 8000b66:	3b02      	subs	r3, #2
 8000b68:	443c      	add	r4, r7
 8000b6a:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000b6e:	fba0 9302 	umull	r9, r3, r0, r2
 8000b72:	eba4 040c 	sub.w	r4, r4, ip
 8000b76:	429c      	cmp	r4, r3
 8000b78:	46ce      	mov	lr, r9
 8000b7a:	469c      	mov	ip, r3
 8000b7c:	d351      	bcc.n	8000c22 <__udivmoddi4+0x28a>
 8000b7e:	d04e      	beq.n	8000c1e <__udivmoddi4+0x286>
 8000b80:	b155      	cbz	r5, 8000b98 <__udivmoddi4+0x200>
 8000b82:	ebb8 030e 	subs.w	r3, r8, lr
 8000b86:	eb64 040c 	sbc.w	r4, r4, ip
 8000b8a:	fa04 f606 	lsl.w	r6, r4, r6
 8000b8e:	40cb      	lsrs	r3, r1
 8000b90:	431e      	orrs	r6, r3
 8000b92:	40cc      	lsrs	r4, r1
 8000b94:	e9c5 6400 	strd	r6, r4, [r5]
 8000b98:	2100      	movs	r1, #0
 8000b9a:	e750      	b.n	8000a3e <__udivmoddi4+0xa6>
 8000b9c:	f1c2 0320 	rsb	r3, r2, #32
 8000ba0:	fa20 f103 	lsr.w	r1, r0, r3
 8000ba4:	fa0c fc02 	lsl.w	ip, ip, r2
 8000ba8:	fa24 f303 	lsr.w	r3, r4, r3
 8000bac:	4094      	lsls	r4, r2
 8000bae:	430c      	orrs	r4, r1
 8000bb0:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000bb4:	fa00 fe02 	lsl.w	lr, r0, r2
 8000bb8:	fa1f f78c 	uxth.w	r7, ip
 8000bbc:	fbb3 f0f8 	udiv	r0, r3, r8
 8000bc0:	fb08 3110 	mls	r1, r8, r0, r3
 8000bc4:	0c23      	lsrs	r3, r4, #16
 8000bc6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000bca:	fb00 f107 	mul.w	r1, r0, r7
 8000bce:	4299      	cmp	r1, r3
 8000bd0:	d908      	bls.n	8000be4 <__udivmoddi4+0x24c>
 8000bd2:	eb1c 0303 	adds.w	r3, ip, r3
 8000bd6:	f100 36ff 	add.w	r6, r0, #4294967295
 8000bda:	d22c      	bcs.n	8000c36 <__udivmoddi4+0x29e>
 8000bdc:	4299      	cmp	r1, r3
 8000bde:	d92a      	bls.n	8000c36 <__udivmoddi4+0x29e>
 8000be0:	3802      	subs	r0, #2
 8000be2:	4463      	add	r3, ip
 8000be4:	1a5b      	subs	r3, r3, r1
 8000be6:	b2a4      	uxth	r4, r4
 8000be8:	fbb3 f1f8 	udiv	r1, r3, r8
 8000bec:	fb08 3311 	mls	r3, r8, r1, r3
 8000bf0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000bf4:	fb01 f307 	mul.w	r3, r1, r7
 8000bf8:	42a3      	cmp	r3, r4
 8000bfa:	d908      	bls.n	8000c0e <__udivmoddi4+0x276>
 8000bfc:	eb1c 0404 	adds.w	r4, ip, r4
 8000c00:	f101 36ff 	add.w	r6, r1, #4294967295
 8000c04:	d213      	bcs.n	8000c2e <__udivmoddi4+0x296>
 8000c06:	42a3      	cmp	r3, r4
 8000c08:	d911      	bls.n	8000c2e <__udivmoddi4+0x296>
 8000c0a:	3902      	subs	r1, #2
 8000c0c:	4464      	add	r4, ip
 8000c0e:	1ae4      	subs	r4, r4, r3
 8000c10:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8000c14:	e739      	b.n	8000a8a <__udivmoddi4+0xf2>
 8000c16:	4604      	mov	r4, r0
 8000c18:	e6f0      	b.n	80009fc <__udivmoddi4+0x64>
 8000c1a:	4608      	mov	r0, r1
 8000c1c:	e706      	b.n	8000a2c <__udivmoddi4+0x94>
 8000c1e:	45c8      	cmp	r8, r9
 8000c20:	d2ae      	bcs.n	8000b80 <__udivmoddi4+0x1e8>
 8000c22:	ebb9 0e02 	subs.w	lr, r9, r2
 8000c26:	eb63 0c07 	sbc.w	ip, r3, r7
 8000c2a:	3801      	subs	r0, #1
 8000c2c:	e7a8      	b.n	8000b80 <__udivmoddi4+0x1e8>
 8000c2e:	4631      	mov	r1, r6
 8000c30:	e7ed      	b.n	8000c0e <__udivmoddi4+0x276>
 8000c32:	4603      	mov	r3, r0
 8000c34:	e799      	b.n	8000b6a <__udivmoddi4+0x1d2>
 8000c36:	4630      	mov	r0, r6
 8000c38:	e7d4      	b.n	8000be4 <__udivmoddi4+0x24c>
 8000c3a:	46d6      	mov	lr, sl
 8000c3c:	e77f      	b.n	8000b3e <__udivmoddi4+0x1a6>
 8000c3e:	4463      	add	r3, ip
 8000c40:	3802      	subs	r0, #2
 8000c42:	e74d      	b.n	8000ae0 <__udivmoddi4+0x148>
 8000c44:	4606      	mov	r6, r0
 8000c46:	4623      	mov	r3, r4
 8000c48:	4608      	mov	r0, r1
 8000c4a:	e70f      	b.n	8000a6c <__udivmoddi4+0xd4>
 8000c4c:	3e02      	subs	r6, #2
 8000c4e:	4463      	add	r3, ip
 8000c50:	e730      	b.n	8000ab4 <__udivmoddi4+0x11c>
 8000c52:	bf00      	nop

08000c54 <__aeabi_idiv0>:
 8000c54:	4770      	bx	lr
 8000c56:	bf00      	nop

08000c58 <MX_ADC_Init>:

ADC_HandleTypeDef hadc;

/* ADC init function */
void MX_ADC_Init(void)
{
 8000c58:	b510      	push	{r4, lr}

  /* USER CODE END ADC_Init 1 */

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc.Instance = ADC;
 8000c5a:	4812      	ldr	r0, [pc, #72]	@ (8000ca4 <MX_ADC_Init+0x4c>)
 8000c5c:	4c12      	ldr	r4, [pc, #72]	@ (8000ca8 <MX_ADC_Init+0x50>)
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV1;
 8000c5e:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 8000c62:	2300      	movs	r3, #0
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV1;
 8000c64:	e9c0 4200 	strd	r4, r2, [r0]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000c68:	2104      	movs	r1, #4
  hadc.Init.LowPowerAutoWait = DISABLE;
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
  hadc.Init.ContinuousConvMode = DISABLE;
  hadc.Init.NbrOfConversion = 1;
 8000c6a:	2201      	movs	r2, #1
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000c6c:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000c70:	e9c0 3104 	strd	r3, r1, [r0, #16]
  hadc.Init.DiscontinuousConvMode = DISABLE;
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000c74:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
  hadc.Init.DMAContinuousRequests = DISABLE;
  hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_1CYCLE_5;
 8000c78:	e9c0 330c 	strd	r3, r3, [r0, #48]	@ 0x30
  hadc.Init.LowPowerAutoWait = DISABLE;
 8000c7c:	8303      	strh	r3, [r0, #24]
  hadc.Init.ContinuousConvMode = DISABLE;
 8000c7e:	7683      	strb	r3, [r0, #26]
  hadc.Init.NbrOfConversion = 1;
 8000c80:	61c2      	str	r2, [r0, #28]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 8000c82:	f880 3020 	strb.w	r3, [r0, #32]
  hadc.Init.DMAContinuousRequests = DISABLE;
 8000c86:	f880 302c 	strb.w	r3, [r0, #44]	@ 0x2c
  hadc.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_1CYCLE_5;
 8000c8a:	6383      	str	r3, [r0, #56]	@ 0x38
  hadc.Init.OversamplingMode = DISABLE;
 8000c8c:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  hadc.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 8000c90:	64c3      	str	r3, [r0, #76]	@ 0x4c
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 8000c92:	f003 ffc1 	bl	8004c18 <HAL_ADC_Init>
 8000c96:	b900      	cbnz	r0, 8000c9a <MX_ADC_Init+0x42>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 8000c98:	bd10      	pop	{r4, pc}
 8000c9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 8000c9e:	f000 bc11 	b.w	80014c4 <Error_Handler>
 8000ca2:	bf00      	nop
 8000ca4:	20000194 	.word	0x20000194
 8000ca8:	40012400 	.word	0x40012400

08000cac <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 8000cac:	4b0e      	ldr	r3, [pc, #56]	@ (8000ce8 <HAL_ADC_MspInit+0x3c>)
 8000cae:	6802      	ldr	r2, [r0, #0]
 8000cb0:	429a      	cmp	r2, r3
 8000cb2:	d000      	beq.n	8000cb6 <HAL_ADC_MspInit+0xa>
 8000cb4:	4770      	bx	lr
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8000cb6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
{
 8000cba:	b500      	push	{lr}
 8000cbc:	6e19      	ldr	r1, [r3, #96]	@ 0x60
 8000cbe:	f441 7100 	orr.w	r1, r1, #512	@ 0x200
 8000cc2:	6619      	str	r1, [r3, #96]	@ 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8000cc4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8000cc6:	b083      	sub	sp, #12
  /* USER CODE END ADC_MspInit 0 */
    /* ADC clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();

    /* ADC interrupt Init */
    HAL_NVIC_SetPriority(ADC_IRQn, 0, 0);
 8000cc8:	2200      	movs	r2, #0
 8000cca:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8000cce:	9301      	str	r3, [sp, #4]
 8000cd0:	2012      	movs	r0, #18
 8000cd2:	4611      	mov	r1, r2
  (void)tmpreg;
 8000cd4:	9b01      	ldr	r3, [sp, #4]
 8000cd6:	f004 fcc7 	bl	8005668 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 8000cda:	2012      	movs	r0, #18
  /* USER CODE BEGIN ADC_MspInit 1 */

  /* USER CODE END ADC_MspInit 1 */
  }
}
 8000cdc:	b003      	add	sp, #12
 8000cde:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 8000ce2:	f004 bcfd 	b.w	80056e0 <HAL_NVIC_EnableIRQ>
 8000ce6:	bf00      	nop
 8000ce8:	40012400 	.word	0x40012400

08000cec <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 8000cec:	4b06      	ldr	r3, [pc, #24]	@ (8000d08 <HAL_ADC_MspDeInit+0x1c>)
 8000cee:	6802      	ldr	r2, [r0, #0]
 8000cf0:	429a      	cmp	r2, r3
 8000cf2:	d000      	beq.n	8000cf6 <HAL_ADC_MspDeInit+0xa>
    HAL_NVIC_DisableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC_MspDeInit 1 */

  /* USER CODE END ADC_MspDeInit 1 */
  }
}
 8000cf4:	4770      	bx	lr
  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 8000cf6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
    HAL_NVIC_DisableIRQ(ADC_IRQn);
 8000cfa:	2012      	movs	r0, #18
 8000cfc:	6e13      	ldr	r3, [r2, #96]	@ 0x60
 8000cfe:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8000d02:	6613      	str	r3, [r2, #96]	@ 0x60
 8000d04:	f004 bcfa 	b.w	80056fc <HAL_NVIC_DisableIRQ>
 8000d08:	40012400 	.word	0x40012400

08000d0c <ADC_ReadChannels>:
/* USER CODE BEGIN PrFD */

/* USER CODE END PrFD */

static uint32_t ADC_ReadChannels(uint32_t channel)
{
 8000d0c:	b510      	push	{r4, lr}
 8000d0e:	b084      	sub	sp, #16
  /* USER CODE BEGIN ADC_ReadChannels_1 */

  /* USER CODE END ADC_ReadChannels_1 */
  uint32_t ADCxConvertedValues = 0;
  ADC_ChannelConfTypeDef sConfig = {0};
 8000d10:	2300      	movs	r3, #0
{
 8000d12:	4604      	mov	r4, r0
  ADC_ChannelConfTypeDef sConfig = {0};
 8000d14:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8000d18:	9303      	str	r3, [sp, #12]

  MX_ADC_Init();
 8000d1a:	f7ff ff9d 	bl	8000c58 <MX_ADC_Init>

  /* Start Calibration */
  if (HAL_ADCEx_Calibration_Start(&hadc) != HAL_OK)
 8000d1e:	4816      	ldr	r0, [pc, #88]	@ (8000d78 <ADC_ReadChannels+0x6c>)
 8000d20:	f004 fbf6 	bl	8005510 <HAL_ADCEx_Calibration_Start>
 8000d24:	b9f0      	cbnz	r0, 8000d64 <ADC_ReadChannels+0x58>
    Error_Handler();
  }

  /* Configure Regular Channel */
  sConfig.Channel = channel;
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000d26:	2300      	movs	r3, #0
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000d28:	4813      	ldr	r0, [pc, #76]	@ (8000d78 <ADC_ReadChannels+0x6c>)
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
 8000d2a:	9303      	str	r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000d2c:	a901      	add	r1, sp, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000d2e:	e9cd 4301 	strd	r4, r3, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000d32:	f004 f98b 	bl	800504c <HAL_ADC_ConfigChannel>
 8000d36:	b9d8      	cbnz	r0, 8000d70 <ADC_ReadChannels+0x64>
  {
    Error_Handler();
  }

  if (HAL_ADC_Start(&hadc) != HAL_OK)
 8000d38:	480f      	ldr	r0, [pc, #60]	@ (8000d78 <ADC_ReadChannels+0x6c>)
 8000d3a:	f004 fb03 	bl	8005344 <HAL_ADC_Start>
 8000d3e:	b9a0      	cbnz	r0, 8000d6a <ADC_ReadChannels+0x5e>
  {
    /* Start Error */
    Error_Handler();
  }
  /** Wait for end of conversion */
  HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 8000d40:	f04f 31ff 	mov.w	r1, #4294967295
 8000d44:	480c      	ldr	r0, [pc, #48]	@ (8000d78 <ADC_ReadChannels+0x6c>)
 8000d46:	f004 f875 	bl	8004e34 <HAL_ADC_PollForConversion>

  /** Wait for end of conversion */
  HAL_ADC_Stop(&hadc);   /* it calls also ADC_Disable() */
 8000d4a:	480b      	ldr	r0, [pc, #44]	@ (8000d78 <ADC_ReadChannels+0x6c>)
 8000d4c:	f004 fbbc 	bl	80054c8 <HAL_ADC_Stop>

  ADCxConvertedValues = HAL_ADC_GetValue(&hadc);
 8000d50:	4809      	ldr	r0, [pc, #36]	@ (8000d78 <ADC_ReadChannels+0x6c>)
 8000d52:	f004 f8cf 	bl	8004ef4 <HAL_ADC_GetValue>
 8000d56:	4604      	mov	r4, r0

  HAL_ADC_DeInit(&hadc);
 8000d58:	4807      	ldr	r0, [pc, #28]	@ (8000d78 <ADC_ReadChannels+0x6c>)
 8000d5a:	f004 fb5b 	bl	8005414 <HAL_ADC_DeInit>

  return ADCxConvertedValues;
  /* USER CODE BEGIN ADC_ReadChannels_2 */

  /* USER CODE END ADC_ReadChannels_2 */
}
 8000d5e:	4620      	mov	r0, r4
 8000d60:	b004      	add	sp, #16
 8000d62:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000d64:	f000 fbae 	bl	80014c4 <Error_Handler>
 8000d68:	e7dd      	b.n	8000d26 <ADC_ReadChannels+0x1a>
    Error_Handler();
 8000d6a:	f000 fbab 	bl	80014c4 <Error_Handler>
 8000d6e:	e7e7      	b.n	8000d40 <ADC_ReadChannels+0x34>
    Error_Handler();
 8000d70:	f000 fba8 	bl	80014c4 <Error_Handler>
 8000d74:	e7e0      	b.n	8000d38 <ADC_ReadChannels+0x2c>
 8000d76:	bf00      	nop
 8000d78:	20000194 	.word	0x20000194

08000d7c <SYS_InitMeasurement>:
  hadc.Instance = ADC;
 8000d7c:	4b01      	ldr	r3, [pc, #4]	@ (8000d84 <SYS_InitMeasurement+0x8>)
 8000d7e:	4a02      	ldr	r2, [pc, #8]	@ (8000d88 <SYS_InitMeasurement+0xc>)
 8000d80:	601a      	str	r2, [r3, #0]
}
 8000d82:	4770      	bx	lr
 8000d84:	20000194 	.word	0x20000194
 8000d88:	40012400 	.word	0x40012400

08000d8c <SYS_GetTemperatureLevel>:
{
 8000d8c:	b530      	push	{r4, r5, lr}
 8000d8e:	b083      	sub	sp, #12
  __IO int16_t temperatureDegreeC = 0;
 8000d90:	2300      	movs	r3, #0
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 8000d92:	482c      	ldr	r0, [pc, #176]	@ (8000e44 <SYS_GetTemperatureLevel+0xb8>)
  __IO int16_t temperatureDegreeC = 0;
 8000d94:	f8ad 3006 	strh.w	r3, [sp, #6]
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 8000d98:	f7ff ffb8 	bl	8000d0c <ADC_ReadChannels>
  if (measuredLevel == 0)
 8000d9c:	4604      	mov	r4, r0
 8000d9e:	b168      	cbz	r0, 8000dbc <SYS_GetTemperatureLevel+0x30>
    if ((uint32_t)*VREFINT_CAL_ADDR != (uint32_t)0xFFFFU)
 8000da0:	4b29      	ldr	r3, [pc, #164]	@ (8000e48 <SYS_GetTemperatureLevel+0xbc>)
 8000da2:	f8b3 30aa 	ldrh.w	r3, [r3, #170]	@ 0xaa
 8000da6:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8000daa:	4293      	cmp	r3, r2
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 8000dac:	bf16      	itet	ne
 8000dae:	f640 42e4 	movwne	r2, #3300	@ 0xce4
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 8000db2:	4b26      	ldreq	r3, [pc, #152]	@ (8000e4c <SYS_GetTemperatureLevel+0xc0>)
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 8000db4:	4353      	mulne	r3, r2
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 8000db6:	fbb3 f3f0 	udiv	r3, r3, r0
 8000dba:	b29c      	uxth	r4, r3
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_TEMPSENSOR);
 8000dbc:	4824      	ldr	r0, [pc, #144]	@ (8000e50 <SYS_GetTemperatureLevel+0xc4>)
 8000dbe:	f7ff ffa5 	bl	8000d0c <ADC_ReadChannels>
  if (((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) != 0)
 8000dc2:	4b21      	ldr	r3, [pc, #132]	@ (8000e48 <SYS_GetTemperatureLevel+0xbc>)
 8000dc4:	f8b3 20c8 	ldrh.w	r2, [r3, #200]	@ 0xc8
 8000dc8:	f8b3 10a8 	ldrh.w	r1, [r3, #168]	@ 0xa8
 8000dcc:	428a      	cmp	r2, r1
 8000dce:	d01c      	beq.n	8000e0a <SYS_GetTemperatureLevel+0x7e>
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE(batteryLevelmV,
 8000dd0:	fb04 f300 	mul.w	r3, r4, r0
 8000dd4:	4d1f      	ldr	r5, [pc, #124]	@ (8000e54 <SYS_GetTemperatureLevel+0xc8>)
 8000dd6:	089b      	lsrs	r3, r3, #2
 8000dd8:	fba5 5303 	umull	r5, r3, r5, r3
 8000ddc:	ebc1 1353 	rsb	r3, r1, r3, lsr #5
 8000de0:	2064      	movs	r0, #100	@ 0x64
 8000de2:	fb00 f303 	mul.w	r3, r0, r3
 8000de6:	1a52      	subs	r2, r2, r1
 8000de8:	fb93 f3f2 	sdiv	r3, r3, r2
 8000dec:	331e      	adds	r3, #30
 8000dee:	b21b      	sxth	r3, r3
 8000df0:	f8ad 3006 	strh.w	r3, [sp, #6]
  temperatureDegreeC <<= 8;
 8000df4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000df8:	b25b      	sxtb	r3, r3
 8000dfa:	021b      	lsls	r3, r3, #8
 8000dfc:	f8ad 3006 	strh.w	r3, [sp, #6]
  return (int16_t) temperatureDegreeC;
 8000e00:	f8bd 0006 	ldrh.w	r0, [sp, #6]
}
 8000e04:	b200      	sxth	r0, r0
 8000e06:	b003      	add	sp, #12
 8000e08:	bd30      	pop	{r4, r5, pc}
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 8000e0a:	4b13      	ldr	r3, [pc, #76]	@ (8000e58 <SYS_GetTemperatureLevel+0xcc>)
 8000e0c:	fb04 f000 	mul.w	r0, r4, r0
 8000e10:	fba3 2300 	umull	r2, r3, r3, r0
 8000e14:	1ac0      	subs	r0, r0, r3
 8000e16:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 8000e1a:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8000e1e:	0adb      	lsrs	r3, r3, #11
 8000e20:	fb02 f303 	mul.w	r3, r2, r3
 8000e24:	f5a3 2339 	sub.w	r3, r3, #757760	@ 0xb9000
 8000e28:	4a0c      	ldr	r2, [pc, #48]	@ (8000e5c <SYS_GetTemperatureLevel+0xd0>)
 8000e2a:	f5a3 630c 	sub.w	r3, r3, #2240	@ 0x8c0
 8000e2e:	fb82 1203 	smull	r1, r2, r2, r3
 8000e32:	17db      	asrs	r3, r3, #31
 8000e34:	ebc3 23a2 	rsb	r3, r3, r2, asr #10
 8000e38:	331e      	adds	r3, #30
 8000e3a:	b21b      	sxth	r3, r3
 8000e3c:	f8ad 3006 	strh.w	r3, [sp, #6]
 8000e40:	e7d8      	b.n	8000df4 <SYS_GetTemperatureLevel+0x68>
 8000e42:	bf00      	nop
 8000e44:	b4002000 	.word	0xb4002000
 8000e48:	1fff7500 	.word	0x1fff7500
 8000e4c:	004c08d8 	.word	0x004c08d8
 8000e50:	b0001000 	.word	0xb0001000
 8000e54:	09ee009f 	.word	0x09ee009f
 8000e58:	00100101 	.word	0x00100101
 8000e5c:	68db8bad 	.word	0x68db8bad

08000e60 <SYS_GetBatteryLevel>:
{
 8000e60:	b508      	push	{r3, lr}
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 8000e62:	4809      	ldr	r0, [pc, #36]	@ (8000e88 <SYS_GetBatteryLevel+0x28>)
 8000e64:	f7ff ff52 	bl	8000d0c <ADC_ReadChannels>
  if (measuredLevel == 0)
 8000e68:	b168      	cbz	r0, 8000e86 <SYS_GetBatteryLevel+0x26>
    if ((uint32_t)*VREFINT_CAL_ADDR != (uint32_t)0xFFFFU)
 8000e6a:	4b08      	ldr	r3, [pc, #32]	@ (8000e8c <SYS_GetBatteryLevel+0x2c>)
 8000e6c:	f8b3 30aa 	ldrh.w	r3, [r3, #170]	@ 0xaa
 8000e70:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8000e74:	4293      	cmp	r3, r2
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 8000e76:	bf16      	itet	ne
 8000e78:	f640 42e4 	movwne	r2, #3300	@ 0xce4
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 8000e7c:	4b04      	ldreq	r3, [pc, #16]	@ (8000e90 <SYS_GetBatteryLevel+0x30>)
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 8000e7e:	4353      	mulne	r3, r2
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 8000e80:	fbb3 f3f0 	udiv	r3, r3, r0
 8000e84:	b298      	uxth	r0, r3
}
 8000e86:	bd08      	pop	{r3, pc}
 8000e88:	b4002000 	.word	0xb4002000
 8000e8c:	1fff7500 	.word	0x1fff7500
 8000e90:	004c08d8 	.word	0x004c08d8

08000e94 <MX_DMA_Init>:
  SET_BIT(RCC->AHB1ENR, Periphs);
 8000e94:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8000e98:	b510      	push	{r4, lr}
 8000e9a:	6c99      	ldr	r1, [r3, #72]	@ 0x48
 8000e9c:	f041 0104 	orr.w	r1, r1, #4
 8000ea0:	6499      	str	r1, [r3, #72]	@ 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8000ea2:	6c9c      	ldr	r4, [r3, #72]	@ 0x48
 8000ea4:	b082      	sub	sp, #8
 8000ea6:	f004 0404 	and.w	r4, r4, #4
 8000eaa:	9401      	str	r4, [sp, #4]
  (void)tmpreg;
 8000eac:	9c01      	ldr	r4, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 8000eae:	6c9c      	ldr	r4, [r3, #72]	@ 0x48
 8000eb0:	f044 0401 	orr.w	r4, r4, #1
 8000eb4:	649c      	str	r4, [r3, #72]	@ 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8000eb6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 8000eb8:	2200      	movs	r2, #0
 8000eba:	f003 0301 	and.w	r3, r3, #1
 8000ebe:	9300      	str	r3, [sp, #0]
 8000ec0:	200b      	movs	r0, #11
 8000ec2:	4611      	mov	r1, r2
  (void)tmpreg;
 8000ec4:	9b00      	ldr	r3, [sp, #0]
 8000ec6:	f004 fbcf 	bl	8005668 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8000eca:	200b      	movs	r0, #11

}
 8000ecc:	b002      	add	sp, #8
 8000ece:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8000ed2:	f004 bc05 	b.w	80056e0 <HAL_NVIC_EnableIRQ>
 8000ed6:	bf00      	nop

08000ed8 <FLASH_IF_Write>:
  /* USER CODE END FLASH_IF_DeInit_2 */
  return ret_status;
}

FLASH_IF_StatusTypedef FLASH_IF_Write(void *pDestination, const void *pSource, uint32_t uLength)
{
 8000ed8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000edc:	b089      	sub	sp, #36	@ 0x24
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_ERROR;
  /* USER CODE BEGIN FLASH_IF_Write_1 */

  /* USER CODE END FLASH_IF_Write_1 */
  if (IS_FLASH_MAIN_MEM_ADDRESS((uint32_t)pDestination))
 8000ede:	f1b0 6f00 	cmp.w	r0, #134217728	@ 0x8000000
{
 8000ee2:	9201      	str	r2, [sp, #4]
  if (IS_FLASH_MAIN_MEM_ADDRESS((uint32_t)pDestination))
 8000ee4:	f0c0 810b 	bcc.w	80010fe <FLASH_IF_Write+0x226>
 8000ee8:	4f8c      	ldr	r7, [pc, #560]	@ (800111c <FLASH_IF_Write+0x244>)
 8000eea:	4d8d      	ldr	r5, [pc, #564]	@ (8001120 <FLASH_IF_Write+0x248>)
 8000eec:	f8d7 35e0 	ldr.w	r3, [r7, #1504]	@ 0x5e0
 8000ef0:	ea05 2383 	and.w	r3, r5, r3, lsl #10
 8000ef4:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 8000ef8:	3b01      	subs	r3, #1
 8000efa:	4298      	cmp	r0, r3
 8000efc:	4606      	mov	r6, r0
 8000efe:	f200 80fe 	bhi.w	80010fe <FLASH_IF_Write+0x226>
  uint32_t number_pages;
  uint32_t current_dest;
  uint32_t current_source;
  uint32_t current_length;

  if ((pDestination == NULL) || (pSource == NULL) || !IS_ADDR_ALIGNED_64BITS(uLength)
 8000f02:	460c      	mov	r4, r1
 8000f04:	2900      	cmp	r1, #0
 8000f06:	f000 8100 	beq.w	800110a <FLASH_IF_Write+0x232>
 8000f0a:	ea40 0302 	orr.w	r3, r0, r2
      || !IS_ADDR_ALIGNED_64BITS((uint32_t)pDestination))
 8000f0e:	075b      	lsls	r3, r3, #29
 8000f10:	f040 80fb 	bne.w	800110a <FLASH_IF_Write+0x232>
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_LOCK_ERROR;
  /* USER CODE BEGIN FLASH_IF_INT_Clear_Error_1 */

  /* USER CODE END FLASH_IF_INT_Clear_Error_1 */
  /* Unlock the Program memory */
  if (HAL_FLASH_Unlock() == HAL_OK)
 8000f14:	f004 fee2 	bl	8005cdc <HAL_FLASH_Unlock>
 8000f18:	2800      	cmp	r0, #0
 8000f1a:	f040 80ed 	bne.w	80010f8 <FLASH_IF_Write+0x220>
  {
    /* Clear all FLASH flags */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8000f1e:	4b81      	ldr	r3, [pc, #516]	@ (8001124 <FLASH_IF_Write+0x24c>)
 8000f20:	699a      	ldr	r2, [r3, #24]
 8000f22:	f24c 31fa 	movw	r1, #50170	@ 0xc3fa
 8000f26:	f042 4240 	orr.w	r2, r2, #3221225472	@ 0xc0000000
 8000f2a:	619a      	str	r2, [r3, #24]
 8000f2c:	6119      	str	r1, [r3, #16]
    /* Unlock the Program memory */
    if (HAL_FLASH_Lock() == HAL_OK)
 8000f2e:	f004 fee9 	bl	8005d04 <HAL_FLASH_Lock>
 8000f32:	2800      	cmp	r0, #0
 8000f34:	f040 80e0 	bne.w	80010f8 <FLASH_IF_Write+0x220>
    if (HAL_FLASH_Unlock() == HAL_OK)
 8000f38:	f004 fed0 	bl	8005cdc <HAL_FLASH_Unlock>
 8000f3c:	2800      	cmp	r0, #0
 8000f3e:	f040 80db 	bne.w	80010f8 <FLASH_IF_Write+0x220>
      start_page_index = PAGE_INDEX(uDest);
 8000f42:	f8d7 35e0 	ldr.w	r3, [r7, #1504]	@ 0x5e0
 8000f46:	ea05 2583 	and.w	r5, r5, r3, lsl #10
      number_pages = PAGE_INDEX(uDest + uLength - 1U) - start_page_index + 1U;
 8000f4a:	9b01      	ldr	r3, [sp, #4]
 8000f4c:	f103 4378 	add.w	r3, r3, #4160749568	@ 0xf8000000
 8000f50:	3b01      	subs	r3, #1
 8000f52:	4433      	add	r3, r6
      start_page_index = PAGE_INDEX(uDest);
 8000f54:	f106 4278 	add.w	r2, r6, #4160749568	@ 0xf8000000
      number_pages = PAGE_INDEX(uDest + uLength - 1U) - start_page_index + 1U;
 8000f58:	fbb3 f1f5 	udiv	r1, r3, r5
 8000f5c:	fb05 3311 	mls	r3, r5, r1, r3
 8000f60:	ea4f 2cd3 	mov.w	ip, r3, lsr #11
      start_page_index = PAGE_INDEX(uDest);
 8000f64:	4613      	mov	r3, r2
 8000f66:	f10c 0101 	add.w	r1, ip, #1
 8000f6a:	fbb2 f2f5 	udiv	r2, r2, r5
 8000f6e:	fb05 3312 	mls	r3, r5, r2, r3
      number_pages = PAGE_INDEX(uDest + uLength - 1U) - start_page_index + 1U;
 8000f72:	eba1 22d3 	sub.w	r2, r1, r3, lsr #11
      if (number_pages > 1)
 8000f76:	2a01      	cmp	r2, #1
        length = FLASH_PAGE_SIZE - (uDest % FLASH_PAGE_SIZE);
 8000f78:	bf88      	it	hi
 8000f7a:	f3c6 080a 	ubfxhi	r8, r6, #0, #11
      start_page_index = PAGE_INDEX(uDest);
 8000f7e:	ea4f 2bd3 	mov.w	fp, r3, lsr #11
        length = FLASH_PAGE_SIZE - (uDest % FLASH_PAGE_SIZE);
 8000f82:	bf94      	ite	ls
 8000f84:	f8dd 8004 	ldrls.w	r8, [sp, #4]
 8000f88:	f5c8 6800 	rsbhi	r8, r8, #2048	@ 0x800
      for (page_index = start_page_index; page_index < (start_page_index + number_pages); page_index++)
 8000f8c:	458b      	cmp	fp, r1
 8000f8e:	f080 80b1 	bcs.w	80010f4 <FLASH_IF_Write+0x21c>
  uint32_t uSource = (uint32_t)pSource;
 8000f92:	46b2      	mov	sl, r6
 8000f94:	f8cd c00c 	str.w	ip, [sp, #12]
 8000f98:	9400      	str	r4, [sp, #0]
 8000f9a:	4637      	mov	r7, r6
  for (index = 0; index < uLength; index += 8)
 8000f9c:	f1a7 0108 	sub.w	r1, r7, #8
 8000fa0:	f1b8 0f00 	cmp.w	r8, #0
 8000fa4:	d103      	bne.n	8000fae <FLASH_IF_Write+0xd6>
 8000fa6:	e069      	b.n	800107c <FLASH_IF_Write+0x1a4>
 8000fa8:	4543      	cmp	r3, r8
 8000faa:	f080 809f 	bcs.w	80010ec <FLASH_IF_Write+0x214>
    pStart = (void *)((uint32_t)pStart + 8U);
 8000fae:	460b      	mov	r3, r1
    if (*(uint64_t *)pStart != UINT64_MAX)
 8000fb0:	f851 0f08 	ldr.w	r0, [r1, #8]!
 8000fb4:	684a      	ldr	r2, [r1, #4]
  for (index = 0; index < uLength; index += 8)
 8000fb6:	3310      	adds	r3, #16
    if (*(uint64_t *)pStart != UINT64_MAX)
 8000fb8:	f1b2 3fff 	cmp.w	r2, #4294967295
 8000fbc:	bf08      	it	eq
 8000fbe:	f1b0 3fff 	cmpeq.w	r0, #4294967295
  for (index = 0; index < uLength; index += 8)
 8000fc2:	eba3 0307 	sub.w	r3, r3, r7
    if (*(uint64_t *)pStart != UINT64_MAX)
 8000fc6:	d0ef      	beq.n	8000fa8 <FLASH_IF_Write+0xd0>
          if (pAllocatedBuffer == NULL)
 8000fc8:	4b57      	ldr	r3, [pc, #348]	@ (8001128 <FLASH_IF_Write+0x250>)
 8000fca:	6818      	ldr	r0, [r3, #0]
 8000fcc:	2800      	cmp	r0, #0
 8000fce:	f000 8099 	beq.w	8001104 <FLASH_IF_Write+0x22c>
          FLASH_IF_INT_Read(pAllocatedBuffer, (const void *)page_address, FLASH_PAGE_SIZE);
 8000fd2:	ea4f 25cb 	mov.w	r5, fp, lsl #11
  if ((pDestination == NULL) || (pSource == NULL))
 8000fd6:	f115 6400 	adds.w	r4, r5, #134217728	@ 0x8000000
          UTIL_MEM_cpy_8(&pAllocatedBuffer[uDest % FLASH_PAGE_SIZE], (const void *)uSource, length);
 8000fda:	fa1f f688 	uxth.w	r6, r8
 8000fde:	f3ca 090a 	ubfx	r9, sl, #0, #11
  if ((pDestination == NULL) || (pSource == NULL))
 8000fe2:	f000 8095 	beq.w	8001110 <FLASH_IF_Write+0x238>
  UTIL_MEM_cpy_8(pDestination, pSource, uLength);
 8000fe6:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8000fea:	4621      	mov	r1, r4
 8000fec:	f013 fe60 	bl	8014cb0 <UTIL_MEM_cpy_8>
          UTIL_MEM_cpy_8(&pAllocatedBuffer[uDest % FLASH_PAGE_SIZE], (const void *)uSource, length);
 8000ff0:	4b4d      	ldr	r3, [pc, #308]	@ (8001128 <FLASH_IF_Write+0x250>)
 8000ff2:	9900      	ldr	r1, [sp, #0]
 8000ff4:	6818      	ldr	r0, [r3, #0]
 8000ff6:	4632      	mov	r2, r6
 8000ff8:	4448      	add	r0, r9
 8000ffa:	f013 fe59 	bl	8014cb0 <UTIL_MEM_cpy_8>
  uint32_t page_error = 0U;
 8000ffe:	2300      	movs	r3, #0
 8001000:	9304      	str	r3, [sp, #16]
  if (HAL_FLASH_Unlock() == HAL_OK)
 8001002:	f004 fe6b 	bl	8005cdc <HAL_FLASH_Unlock>
 8001006:	bb80      	cbnz	r0, 800106a <FLASH_IF_Write+0x192>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8001008:	4a46      	ldr	r2, [pc, #280]	@ (8001124 <FLASH_IF_Write+0x24c>)
 800100a:	6993      	ldr	r3, [r2, #24]
 800100c:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 8001010:	6193      	str	r3, [r2, #24]
 8001012:	f24c 33fa 	movw	r3, #50170	@ 0xc3fa
 8001016:	6113      	str	r3, [r2, #16]
    if (HAL_FLASH_Lock() == HAL_OK)
 8001018:	f004 fe74 	bl	8005d04 <HAL_FLASH_Lock>
 800101c:	bb28      	cbnz	r0, 800106a <FLASH_IF_Write+0x192>
    if (HAL_FLASH_Unlock() == HAL_OK)
 800101e:	f004 fe5d 	bl	8005cdc <HAL_FLASH_Unlock>
 8001022:	bb10      	cbnz	r0, 800106a <FLASH_IF_Write+0x192>
      erase_init.Page = PAGE_INDEX(uStart);
 8001024:	483d      	ldr	r0, [pc, #244]	@ (800111c <FLASH_IF_Write+0x244>)
 8001026:	4a3e      	ldr	r2, [pc, #248]	@ (8001120 <FLASH_IF_Write+0x248>)
      erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
 8001028:	2302      	movs	r3, #2
 800102a:	9305      	str	r3, [sp, #20]
      erase_init.Page = PAGE_INDEX(uStart);
 800102c:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	@ 0x5e0
 8001030:	ea02 2181 	and.w	r1, r2, r1, lsl #10
 8001034:	fbb5 f3f1 	udiv	r3, r5, r1
 8001038:	fb01 5313 	mls	r3, r1, r3, r5
 800103c:	0adb      	lsrs	r3, r3, #11
 800103e:	9306      	str	r3, [sp, #24]
      erase_init.NbPages = PAGE_INDEX(uStart + uLength - 1U) - erase_init.Page + 1U;
 8001040:	f8d0 15e0 	ldr.w	r1, [r0, #1504]	@ 0x5e0
 8001044:	f205 75ff 	addw	r5, r5, #2047	@ 0x7ff
 8001048:	ea02 2281 	and.w	r2, r2, r1, lsl #10
 800104c:	fbb5 f1f2 	udiv	r1, r5, r2
 8001050:	fb02 5511 	mls	r5, r2, r1, r5
 8001054:	ebc3 23d5 	rsb	r3, r3, r5, lsr #11
 8001058:	3301      	adds	r3, #1
      hal_status = HAL_FLASHEx_Erase(&erase_init, &page_error);
 800105a:	a904      	add	r1, sp, #16
 800105c:	a805      	add	r0, sp, #20
      erase_init.NbPages = PAGE_INDEX(uStart + uLength - 1U) - erase_init.Page + 1U;
 800105e:	9307      	str	r3, [sp, #28]
      hal_status = HAL_FLASHEx_Erase(&erase_init, &page_error);
 8001060:	f004 fe8e 	bl	8005d80 <HAL_FLASHEx_Erase>
      if (hal_status != HAL_OK)
 8001064:	b1f0      	cbz	r0, 80010a4 <FLASH_IF_Write+0x1cc>
      HAL_FLASH_Lock();
 8001066:	f004 fe4d 	bl	8005d04 <HAL_FLASH_Lock>
            ret_status = FLASH_IF_ERASE_ERROR;
 800106a:	f06f 0401 	mvn.w	r4, #1
      HAL_FLASH_Lock();
 800106e:	f004 fe49 	bl	8005d04 <HAL_FLASH_Lock>
}
 8001072:	4620      	mov	r0, r4
 8001074:	b009      	add	sp, #36	@ 0x24
 8001076:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800107a:	9f02      	ldr	r7, [sp, #8]
        uSource += length;
 800107c:	9a00      	ldr	r2, [sp, #0]
        length = ((uLength - length) > FLASH_PAGE_SIZE) ? FLASH_PAGE_SIZE : uLength - length;
 800107e:	9b01      	ldr	r3, [sp, #4]
        uSource += length;
 8001080:	4442      	add	r2, r8
        length = ((uLength - length) > FLASH_PAGE_SIZE) ? FLASH_PAGE_SIZE : uLength - length;
 8001082:	eba3 0308 	sub.w	r3, r3, r8
        uSource += length;
 8001086:	9200      	str	r2, [sp, #0]
      for (page_index = start_page_index; page_index < (start_page_index + number_pages); page_index++)
 8001088:	9a03      	ldr	r2, [sp, #12]
        length = ((uLength - length) > FLASH_PAGE_SIZE) ? FLASH_PAGE_SIZE : uLength - length;
 800108a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800108e:	bf28      	it	cs
 8001090:	f44f 6300 	movcs.w	r3, #2048	@ 0x800
      for (page_index = start_page_index; page_index < (start_page_index + number_pages); page_index++)
 8001094:	455a      	cmp	r2, fp
        uDest += length;
 8001096:	44c2      	add	sl, r8
        length = ((uLength - length) > FLASH_PAGE_SIZE) ? FLASH_PAGE_SIZE : uLength - length;
 8001098:	4698      	mov	r8, r3
      for (page_index = start_page_index; page_index < (start_page_index + number_pages); page_index++)
 800109a:	f10b 0301 	add.w	r3, fp, #1
 800109e:	d029      	beq.n	80010f4 <FLASH_IF_Write+0x21c>
 80010a0:	469b      	mov	fp, r3
 80010a2:	e77b      	b.n	8000f9c <FLASH_IF_Write+0xc4>
      HAL_FLASH_Lock();
 80010a4:	f004 fe2e 	bl	8005d04 <HAL_FLASH_Lock>
          current_source = (uint32_t)pAllocatedBuffer;
 80010a8:	4b1f      	ldr	r3, [pc, #124]	@ (8001128 <FLASH_IF_Write+0x250>)
 80010aa:	681e      	ldr	r6, [r3, #0]
          current_length = FLASH_PAGE_SIZE;
 80010ac:	f44f 6900 	mov.w	r9, #2048	@ 0x800
        for (address_offset = 0U; address_offset < current_length; address_offset += 8U)
 80010b0:	9702      	str	r7, [sp, #8]
 80010b2:	2500      	movs	r5, #0
 80010b4:	4627      	mov	r7, r4
 80010b6:	e00d      	b.n	80010d4 <FLASH_IF_Write+0x1fc>
            if (*(uint64_t *)current_dest != *(uint64_t *)(current_source + address_offset))
 80010b8:	e9d7 0100 	ldrd	r0, r1, [r7]
 80010bc:	5972      	ldr	r2, [r6, r5]
 80010be:	6863      	ldr	r3, [r4, #4]
 80010c0:	4299      	cmp	r1, r3
 80010c2:	bf08      	it	eq
 80010c4:	4290      	cmpeq	r0, r2
        for (address_offset = 0U; address_offset < current_length; address_offset += 8U)
 80010c6:	f105 0508 	add.w	r5, r5, #8
            current_dest = current_dest + 8U;
 80010ca:	f107 0708 	add.w	r7, r7, #8
            if (*(uint64_t *)current_dest != *(uint64_t *)(current_source + address_offset))
 80010ce:	d10a      	bne.n	80010e6 <FLASH_IF_Write+0x20e>
        for (address_offset = 0U; address_offset < current_length; address_offset += 8U)
 80010d0:	45a9      	cmp	r9, r5
 80010d2:	d9d2      	bls.n	800107a <FLASH_IF_Write+0x1a2>
                                *((uint64_t *)(current_source + address_offset))) == HAL_OK)
 80010d4:	1974      	adds	r4, r6, r5
          if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, current_dest,
 80010d6:	e9d4 2300 	ldrd	r2, r3, [r4]
 80010da:	4639      	mov	r1, r7
 80010dc:	2001      	movs	r0, #1
 80010de:	f004 fd5d 	bl	8005b9c <HAL_FLASH_Program>
 80010e2:	2800      	cmp	r0, #0
 80010e4:	d0e8      	beq.n	80010b8 <FLASH_IF_Write+0x1e0>
 80010e6:	f06f 0403 	mvn.w	r4, #3
 80010ea:	e7c0      	b.n	800106e <FLASH_IF_Write+0x196>
 80010ec:	9e00      	ldr	r6, [sp, #0]
 80010ee:	4654      	mov	r4, sl
 80010f0:	46c1      	mov	r9, r8
 80010f2:	e7dd      	b.n	80010b0 <FLASH_IF_Write+0x1d8>
 80010f4:	2400      	movs	r4, #0
 80010f6:	e7ba      	b.n	800106e <FLASH_IF_Write+0x196>
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_LOCK_ERROR;
 80010f8:	f06f 0404 	mvn.w	r4, #4
 80010fc:	e7b9      	b.n	8001072 <FLASH_IF_Write+0x19a>
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_ERROR;
 80010fe:	f04f 34ff 	mov.w	r4, #4294967295
 8001102:	e7b6      	b.n	8001072 <FLASH_IF_Write+0x19a>
            ret_status = FLASH_IF_PARAM_ERROR;
 8001104:	f06f 0405 	mvn.w	r4, #5
 8001108:	e7b1      	b.n	800106e <FLASH_IF_Write+0x196>
    return FLASH_IF_PARAM_ERROR;
 800110a:	f06f 0405 	mvn.w	r4, #5
  return ret_status;
 800110e:	e7b0      	b.n	8001072 <FLASH_IF_Write+0x19a>
          UTIL_MEM_cpy_8(&pAllocatedBuffer[uDest % FLASH_PAGE_SIZE], (const void *)uSource, length);
 8001110:	9900      	ldr	r1, [sp, #0]
 8001112:	4632      	mov	r2, r6
 8001114:	4448      	add	r0, r9
 8001116:	f013 fdcb 	bl	8014cb0 <UTIL_MEM_cpy_8>
  if (pStart == NULL)
 800111a:	e7a6      	b.n	800106a <FLASH_IF_Write+0x192>
 800111c:	1fff7000 	.word	0x1fff7000
 8001120:	03fffc00 	.word	0x03fffc00
 8001124:	58004000 	.word	0x58004000
 8001128:	200001f8 	.word	0x200001f8

0800112c <FLASH_IF_Read>:
  if (IS_FLASH_MAIN_MEM_ADDRESS((uint32_t)pSource))
 800112c:	f1b1 6f00 	cmp.w	r1, #134217728	@ 0x8000000
 8001130:	d311      	bcc.n	8001156 <FLASH_IF_Read+0x2a>
{
 8001132:	b538      	push	{r3, r4, r5, lr}
  if (IS_FLASH_MAIN_MEM_ADDRESS((uint32_t)pSource))
 8001134:	4b0c      	ldr	r3, [pc, #48]	@ (8001168 <FLASH_IF_Read+0x3c>)
 8001136:	f8d3 55e0 	ldr.w	r5, [r3, #1504]	@ 0x5e0
 800113a:	4b0c      	ldr	r3, [pc, #48]	@ (800116c <FLASH_IF_Read+0x40>)
 800113c:	ea03 2385 	and.w	r3, r3, r5, lsl #10
 8001140:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 8001144:	3b01      	subs	r3, #1
 8001146:	4299      	cmp	r1, r3
 8001148:	d808      	bhi.n	800115c <FLASH_IF_Read+0x30>
  if ((pDestination == NULL) || (pSource == NULL))
 800114a:	b150      	cbz	r0, 8001162 <FLASH_IF_Read+0x36>
  UTIL_MEM_cpy_8(pDestination, pSource, uLength);
 800114c:	b292      	uxth	r2, r2
 800114e:	f013 fdaf 	bl	8014cb0 <UTIL_MEM_cpy_8>
  return ret_status;
 8001152:	2000      	movs	r0, #0
}
 8001154:	bd38      	pop	{r3, r4, r5, pc}
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_ERROR;
 8001156:	f04f 30ff 	mov.w	r0, #4294967295
}
 800115a:	4770      	bx	lr
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_ERROR;
 800115c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001160:	bd38      	pop	{r3, r4, r5, pc}
    return FLASH_IF_PARAM_ERROR;
 8001162:	f06f 0005 	mvn.w	r0, #5
}
 8001166:	bd38      	pop	{r3, r4, r5, pc}
 8001168:	1fff7000 	.word	0x1fff7000
 800116c:	03fffc00 	.word	0x03fffc00

08001170 <FLASH_IF_Erase>:
{
 8001170:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (IS_FLASH_MAIN_MEM_ADDRESS((uint32_t)pStart))
 8001172:	f1b0 6f00 	cmp.w	r0, #134217728	@ 0x8000000
{
 8001176:	b085      	sub	sp, #20
  if (IS_FLASH_MAIN_MEM_ADDRESS((uint32_t)pStart))
 8001178:	d352      	bcc.n	8001220 <FLASH_IF_Erase+0xb0>
 800117a:	4e2b      	ldr	r6, [pc, #172]	@ (8001228 <FLASH_IF_Erase+0xb8>)
 800117c:	4d2b      	ldr	r5, [pc, #172]	@ (800122c <FLASH_IF_Erase+0xbc>)
 800117e:	f8d6 35e0 	ldr.w	r3, [r6, #1504]	@ 0x5e0
 8001182:	ea05 2383 	and.w	r3, r5, r3, lsl #10
 8001186:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 800118a:	3b01      	subs	r3, #1
 800118c:	4298      	cmp	r0, r3
 800118e:	4607      	mov	r7, r0
 8001190:	d846      	bhi.n	8001220 <FLASH_IF_Erase+0xb0>
  uint32_t page_error = 0U;
 8001192:	2300      	movs	r3, #0
 8001194:	460c      	mov	r4, r1
 8001196:	9300      	str	r3, [sp, #0]
  if (HAL_FLASH_Unlock() == HAL_OK)
 8001198:	f004 fda0 	bl	8005cdc <HAL_FLASH_Unlock>
 800119c:	2800      	cmp	r0, #0
 800119e:	d13c      	bne.n	800121a <FLASH_IF_Erase+0xaa>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 80011a0:	4b23      	ldr	r3, [pc, #140]	@ (8001230 <FLASH_IF_Erase+0xc0>)
 80011a2:	699a      	ldr	r2, [r3, #24]
 80011a4:	f24c 31fa 	movw	r1, #50170	@ 0xc3fa
 80011a8:	f042 4240 	orr.w	r2, r2, #3221225472	@ 0xc0000000
 80011ac:	619a      	str	r2, [r3, #24]
 80011ae:	6119      	str	r1, [r3, #16]
    if (HAL_FLASH_Lock() == HAL_OK)
 80011b0:	f004 fda8 	bl	8005d04 <HAL_FLASH_Lock>
 80011b4:	bb88      	cbnz	r0, 800121a <FLASH_IF_Erase+0xaa>
    if (HAL_FLASH_Unlock() == HAL_OK)
 80011b6:	f004 fd91 	bl	8005cdc <HAL_FLASH_Unlock>
 80011ba:	bb70      	cbnz	r0, 800121a <FLASH_IF_Erase+0xaa>
      erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
 80011bc:	2302      	movs	r3, #2
 80011be:	9301      	str	r3, [sp, #4]
      erase_init.Page = PAGE_INDEX(uStart);
 80011c0:	f8d6 25e0 	ldr.w	r2, [r6, #1504]	@ 0x5e0
 80011c4:	f107 4378 	add.w	r3, r7, #4160749568	@ 0xf8000000
 80011c8:	ea05 2282 	and.w	r2, r5, r2, lsl #10
 80011cc:	fbb3 f1f2 	udiv	r1, r3, r2
 80011d0:	fb02 3311 	mls	r3, r2, r1, r3
 80011d4:	0adb      	lsrs	r3, r3, #11
 80011d6:	9302      	str	r3, [sp, #8]
      erase_init.NbPages = PAGE_INDEX(uStart + uLength - 1U) - erase_init.Page + 1U;
 80011d8:	f8d6 25e0 	ldr.w	r2, [r6, #1504]	@ 0x5e0
 80011dc:	f104 4478 	add.w	r4, r4, #4160749568	@ 0xf8000000
 80011e0:	3c01      	subs	r4, #1
 80011e2:	443c      	add	r4, r7
 80011e4:	ea05 2582 	and.w	r5, r5, r2, lsl #10
 80011e8:	fbb4 f2f5 	udiv	r2, r4, r5
 80011ec:	fb05 4412 	mls	r4, r5, r2, r4
 80011f0:	ebc3 23d4 	rsb	r3, r3, r4, lsr #11
 80011f4:	3301      	adds	r3, #1
      hal_status = HAL_FLASHEx_Erase(&erase_init, &page_error);
 80011f6:	4669      	mov	r1, sp
 80011f8:	a801      	add	r0, sp, #4
      erase_init.NbPages = PAGE_INDEX(uStart + uLength - 1U) - erase_init.Page + 1U;
 80011fa:	9303      	str	r3, [sp, #12]
      hal_status = HAL_FLASHEx_Erase(&erase_init, &page_error);
 80011fc:	f004 fdc0 	bl	8005d80 <HAL_FLASHEx_Erase>
      if (hal_status != HAL_OK)
 8001200:	4604      	mov	r4, r0
 8001202:	b920      	cbnz	r0, 800120e <FLASH_IF_Erase+0x9e>
      HAL_FLASH_Lock();
 8001204:	f004 fd7e 	bl	8005d04 <HAL_FLASH_Lock>
}
 8001208:	4620      	mov	r0, r4
 800120a:	b005      	add	sp, #20
 800120c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret_status = (hal_status == HAL_BUSY) ? FLASH_IF_BUSY : FLASH_IF_ERASE_ERROR;
 800120e:	2802      	cmp	r0, #2
 8001210:	bf14      	ite	ne
 8001212:	f06f 0401 	mvnne.w	r4, #1
 8001216:	2401      	moveq	r4, #1
 8001218:	e7f4      	b.n	8001204 <FLASH_IF_Erase+0x94>
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_LOCK_ERROR;
 800121a:	f06f 0404 	mvn.w	r4, #4
 800121e:	e7f3      	b.n	8001208 <FLASH_IF_Erase+0x98>
  FLASH_IF_StatusTypedef ret_status = FLASH_IF_ERROR;
 8001220:	f04f 34ff 	mov.w	r4, #4294967295
 8001224:	e7f0      	b.n	8001208 <FLASH_IF_Erase+0x98>
 8001226:	bf00      	nop
 8001228:	1fff7000 	.word	0x1fff7000
 800122c:	03fffc00 	.word	0x03fffc00
 8001230:	58004000 	.word	0x58004000

08001234 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8001234:	b530      	push	{r4, r5, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001236:	2400      	movs	r4, #0
{
 8001238:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800123a:	e9cd 4404 	strd	r4, r4, [sp, #16]
 800123e:	e9cd 4406 	strd	r4, r4, [sp, #24]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8001242:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001246:	9408      	str	r4, [sp, #32]
 8001248:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 800124a:	f041 0102 	orr.w	r1, r1, #2
 800124e:	64d9      	str	r1, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001250:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8001252:	f001 0102 	and.w	r1, r1, #2
 8001256:	9103      	str	r1, [sp, #12]
  (void)tmpreg;
 8001258:	9903      	ldr	r1, [sp, #12]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800125a:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 800125c:	f041 0101 	orr.w	r1, r1, #1
 8001260:	64d9      	str	r1, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001262:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8001264:	f001 0101 	and.w	r1, r1, #1
 8001268:	9102      	str	r1, [sp, #8]
  (void)tmpreg;
 800126a:	9902      	ldr	r1, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800126c:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 800126e:	f041 0104 	orr.w	r1, r1, #4
 8001272:	64d9      	str	r1, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001274:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001276:	f003 0304 	and.w	r3, r3, #4
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
 800127a:	4622      	mov	r2, r4
 800127c:	9301      	str	r3, [sp, #4]
 800127e:	2120      	movs	r1, #32
 8001280:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
  (void)tmpreg;
 8001284:	9b01      	ldr	r3, [sp, #4]

  /*Configure GPIO pin : PA5 */
  GPIO_InitStruct.Pin = GPIO_PIN_5;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001286:	2501      	movs	r5, #1
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
 8001288:	f004 ff3e 	bl	8006108 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800128c:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 800128e:	2320      	movs	r3, #32
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001290:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001294:	e9cd 3504 	strd	r3, r5, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001298:	e9cd 4406 	strd	r4, r4, [sp, #24]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800129c:	f004 fdd2 	bl	8005e44 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA6 PA7 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 80012a0:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
 80012a4:	22c0      	movs	r2, #192	@ 0xc0
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80012a6:	a904      	add	r1, sp, #16
 80012a8:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 80012ac:	e9cd 2304 	strd	r2, r3, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80012b0:	9506      	str	r5, [sp, #24]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80012b2:	f004 fdc7 	bl	8005e44 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
 80012b6:	4622      	mov	r2, r4
 80012b8:	4621      	mov	r1, r4
 80012ba:	2016      	movs	r0, #22
 80012bc:	f004 f9d4 	bl	8005668 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 80012c0:	2016      	movs	r0, #22
 80012c2:	f004 fa0d 	bl	80056e0 <HAL_NVIC_EnableIRQ>

}
 80012c6:	b00b      	add	sp, #44	@ 0x2c
 80012c8:	bd30      	pop	{r4, r5, pc}
 80012ca:	bf00      	nop

080012cc <MX_I2C1_Init>:

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 80012cc:	b510      	push	{r4, lr}
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 80012ce:	4818      	ldr	r0, [pc, #96]	@ (8001330 <MX_I2C1_Init+0x64>)
 80012d0:	4c18      	ldr	r4, [pc, #96]	@ (8001334 <MX_I2C1_Init+0x68>)
  hi2c1.Init.Timing = 0x00000E14;
 80012d2:	2300      	movs	r3, #0
 80012d4:	f640 6114 	movw	r1, #3604	@ 0xe14
 80012d8:	2201      	movs	r2, #1
 80012da:	e9c0 4100 	strd	r4, r1, [r0]
 80012de:	e9c0 3202 	strd	r3, r2, [r0, #8]
 80012e2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80012e6:	e9c0 3306 	strd	r3, r3, [r0, #24]
 80012ea:	6203      	str	r3, [r0, #32]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 80012ec:	f005 f880 	bl	80063f0 <HAL_I2C_Init>
 80012f0:	b950      	cbnz	r0, 8001308 <MX_I2C1_Init+0x3c>
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80012f2:	480f      	ldr	r0, [pc, #60]	@ (8001330 <MX_I2C1_Init+0x64>)
 80012f4:	2100      	movs	r1, #0
 80012f6:	f005 fb21 	bl	800693c <HAL_I2CEx_ConfigAnalogFilter>
 80012fa:	b968      	cbnz	r0, 8001318 <MX_I2C1_Init+0x4c>
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 80012fc:	480c      	ldr	r0, [pc, #48]	@ (8001330 <MX_I2C1_Init+0x64>)
 80012fe:	2100      	movs	r1, #0
 8001300:	f005 fb46 	bl	8006990 <HAL_I2CEx_ConfigDigitalFilter>
 8001304:	b980      	cbnz	r0, 8001328 <MX_I2C1_Init+0x5c>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 8001306:	bd10      	pop	{r4, pc}
    Error_Handler();
 8001308:	f000 f8dc 	bl	80014c4 <Error_Handler>
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800130c:	4808      	ldr	r0, [pc, #32]	@ (8001330 <MX_I2C1_Init+0x64>)
 800130e:	2100      	movs	r1, #0
 8001310:	f005 fb14 	bl	800693c <HAL_I2CEx_ConfigAnalogFilter>
 8001314:	2800      	cmp	r0, #0
 8001316:	d0f1      	beq.n	80012fc <MX_I2C1_Init+0x30>
    Error_Handler();
 8001318:	f000 f8d4 	bl	80014c4 <Error_Handler>
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 800131c:	4804      	ldr	r0, [pc, #16]	@ (8001330 <MX_I2C1_Init+0x64>)
 800131e:	2100      	movs	r1, #0
 8001320:	f005 fb36 	bl	8006990 <HAL_I2CEx_ConfigDigitalFilter>
 8001324:	2800      	cmp	r0, #0
 8001326:	d0ee      	beq.n	8001306 <MX_I2C1_Init+0x3a>
}
 8001328:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 800132c:	f000 b8ca 	b.w	80014c4 <Error_Handler>
 8001330:	20000200 	.word	0x20000200
 8001334:	40005400 	.word	0x40005400

08001338 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8001338:	b510      	push	{r4, lr}
 800133a:	4604      	mov	r4, r0
 800133c:	b096      	sub	sp, #88	@ 0x58

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800133e:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001340:	2238      	movs	r2, #56	@ 0x38
 8001342:	a808      	add	r0, sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001344:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8001348:	e9cd 1104 	strd	r1, r1, [sp, #16]
 800134c:	9106      	str	r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800134e:	f014 febb 	bl	80160c8 <memset>
  if(i2cHandle->Instance==I2C1)
 8001352:	4b1b      	ldr	r3, [pc, #108]	@ (80013c0 <HAL_I2C_MspInit+0x88>)
 8001354:	6822      	ldr	r2, [r4, #0]
 8001356:	429a      	cmp	r2, r3
 8001358:	d001      	beq.n	800135e <HAL_I2C_MspInit+0x26>
    __HAL_RCC_I2C1_CLK_ENABLE();
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
 800135a:	b016      	add	sp, #88	@ 0x58
 800135c:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 800135e:	2240      	movs	r2, #64	@ 0x40
    PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 8001360:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001364:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 8001366:	9208      	str	r2, [sp, #32]
    PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 8001368:	930d      	str	r3, [sp, #52]	@ 0x34
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800136a:	f006 fa2b 	bl	80077c4 <HAL_RCCEx_PeriphCLKConfig>
 800136e:	bb18      	cbnz	r0, 80013b8 <HAL_I2C_MspInit+0x80>
  SET_BIT(RCC->AHB2ENR, Periphs);
 8001370:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8001374:	22c0      	movs	r2, #192	@ 0xc0
 8001376:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001378:	4812      	ldr	r0, [pc, #72]	@ (80013c4 <HAL_I2C_MspInit+0x8c>)
 800137a:	f043 0302 	orr.w	r3, r3, #2
 800137e:	64e3      	str	r3, [r4, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001380:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8001382:	f003 0302 	and.w	r3, r3, #2
 8001386:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8001388:	2312      	movs	r3, #18
 800138a:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800138e:	2200      	movs	r2, #0
 8001390:	2300      	movs	r3, #0
 8001392:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001396:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8001398:	2304      	movs	r3, #4
 800139a:	9306      	str	r3, [sp, #24]
  (void)tmpreg;
 800139c:	9a01      	ldr	r2, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800139e:	f004 fd51 	bl	8005e44 <HAL_GPIO_Init>
  SET_BIT(RCC->APB1ENR1, Periphs);
 80013a2:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80013a4:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80013a8:	65a3      	str	r3, [r4, #88]	@ 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 80013aa:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80013ac:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80013b0:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 80013b2:	9b00      	ldr	r3, [sp, #0]
}
 80013b4:	b016      	add	sp, #88	@ 0x58
 80013b6:	bd10      	pop	{r4, pc}
      Error_Handler();
 80013b8:	f000 f884 	bl	80014c4 <Error_Handler>
 80013bc:	e7d8      	b.n	8001370 <HAL_I2C_MspInit+0x38>
 80013be:	bf00      	nop
 80013c0:	40005400 	.word	0x40005400
 80013c4:	48000400 	.word	0x48000400

080013c8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80013c8:	b530      	push	{r4, r5, lr}
 80013ca:	b09b      	sub	sp, #108	@ 0x6c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80013cc:	2400      	movs	r4, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80013ce:	2248      	movs	r2, #72	@ 0x48
 80013d0:	2100      	movs	r1, #0
 80013d2:	a808      	add	r0, sp, #32
 80013d4:	f014 fe78 	bl	80160c8 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80013d8:	e9cd 4402 	strd	r4, r4, [sp, #8]
 80013dc:	e9cd 4404 	strd	r4, r4, [sp, #16]
 80013e0:	e9cd 4406 	strd	r4, r4, [sp, #24]

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 80013e4:	f005 fb00 	bl	80069e8 <HAL_PWR_EnableBkUpAccess>
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 80013e8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80013ec:	a808      	add	r0, sp, #32
 80013ee:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80013f2:	f023 0318 	bic.w	r3, r3, #24
 80013f6:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 80013fa:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
 80013fe:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 8001402:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8001406:	f8c2 3400 	str.w	r3, [r2, #1024]	@ 0x400
 800140a:	f8d2 3400 	ldr.w	r3, [r2, #1024]	@ 0x400
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 800140e:	9411      	str	r4, [sp, #68]	@ 0x44
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8001410:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 8001414:	9301      	str	r3, [sp, #4]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 8001416:	2224      	movs	r2, #36	@ 0x24
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8001418:	2381      	movs	r3, #129	@ 0x81
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 800141a:	9208      	str	r2, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800141c:	930b      	str	r3, [sp, #44]	@ 0x2c
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 800141e:	2201      	movs	r2, #1
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 8001420:	2360      	movs	r3, #96	@ 0x60
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8001422:	e9cd 3412 	strd	r3, r4, [sp, #72]	@ 0x48
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8001426:	9901      	ldr	r1, [sp, #4]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8001428:	9210      	str	r2, [sp, #64]	@ 0x40
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800142a:	f005 fc49 	bl	8006cc0 <HAL_RCC_OscConfig>
 800142e:	b108      	cbz	r0, 8001434 <SystemClock_Config+0x6c>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001430:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8001432:	e7fe      	b.n	8001432 <SystemClock_Config+0x6a>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
 8001434:	4601      	mov	r1, r0
 8001436:	234f      	movs	r3, #79	@ 0x4f
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8001438:	2400      	movs	r4, #0
 800143a:	2500      	movs	r5, #0
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 800143c:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800143e:	e9cd 4506 	strd	r4, r5, [sp, #24]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 8001442:	e9cd 3102 	strd	r3, r1, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8001446:	e9cd 1104 	strd	r1, r1, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 800144a:	f005 ff1b 	bl	8007284 <HAL_RCC_ClockConfig>
 800144e:	b108      	cbz	r0, 8001454 <SystemClock_Config+0x8c>
 8001450:	b672      	cpsid	i
  while (1)
 8001452:	e7fe      	b.n	8001452 <SystemClock_Config+0x8a>
}
 8001454:	b01b      	add	sp, #108	@ 0x6c
 8001456:	bd30      	pop	{r4, r5, pc}

08001458 <main>:
{
 8001458:	b508      	push	{r3, lr}
  HAL_Init();
 800145a:	f003 fb8b 	bl	8004b74 <HAL_Init>
  SystemClock_Config();
 800145e:	f7ff ffb3 	bl	80013c8 <SystemClock_Config>
  MX_GPIO_Init();
 8001462:	f7ff fee7 	bl	8001234 <MX_GPIO_Init>
  MX_DMA_Init();
 8001466:	f7ff fd15 	bl	8000e94 <MX_DMA_Init>
  MX_I2C1_Init();
 800146a:	f7ff ff2f 	bl	80012cc <MX_I2C1_Init>
  MX_LPUART1_UART_Init();
 800146e:	f000 fd79 	bl	8001f64 <MX_LPUART1_UART_Init>
  MX_LoRaWAN_Init();
 8001472:	f008 fb17 	bl	8009aa4 <MX_LoRaWAN_Init>
  MX_ADC_Init();
 8001476:	f7ff fbef 	bl	8000c58 <MX_ADC_Init>
  my_sensor_init(&hi2c1, 0);
 800147a:	4803      	ldr	r0, [pc, #12]	@ (8001488 <main+0x30>)
 800147c:	2100      	movs	r1, #0
 800147e:	f000 f8e5 	bl	800164c <my_sensor_init>
    MX_LoRaWAN_Process();
 8001482:	f008 fb17 	bl	8009ab4 <MX_LoRaWAN_Process>
  while (1)
 8001486:	e7fc      	b.n	8001482 <main+0x2a>
 8001488:	20000200 	.word	0x20000200

0800148c <debug_print>:
}
 800148c:	4770      	bx	lr
 800148e:	bf00      	nop

08001490 <UpdateLoRaWANPayload>:
{
 8001490:	b510      	push	{r4, lr}
	HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
 8001492:	2120      	movs	r1, #32
{
 8001494:	4604      	mov	r4, r0
	HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
 8001496:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800149a:	f004 fe3b 	bl	8006114 <HAL_GPIO_TogglePin>
	HAL_Delay(time_ms);
 800149e:	2064      	movs	r0, #100	@ 0x64
 80014a0:	f000 fb9a 	bl	8001bd8 <HAL_Delay>
	HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
 80014a4:	2120      	movs	r1, #32
 80014a6:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80014aa:	f004 fe33 	bl	8006114 <HAL_GPIO_TogglePin>
    bme_data = get_BME_data();
 80014ae:	f000 f941 	bl	8001734 <get_BME_data>
 80014b2:	4b03      	ldr	r3, [pc, #12]	@ (80014c0 <UpdateLoRaWANPayload+0x30>)
    make_packet(bme_data, my_buffer);
 80014b4:	4621      	mov	r1, r4
}
 80014b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    bme_data = get_BME_data();
 80014ba:	6018      	str	r0, [r3, #0]
    make_packet(bme_data, my_buffer);
 80014bc:	f000 b804 	b.w	80014c8 <make_packet>
 80014c0:	20000254 	.word	0x20000254

080014c4 <Error_Handler>:
 80014c4:	b672      	cpsid	i
  while (1)
 80014c6:	e7fe      	b.n	80014c6 <Error_Handler+0x2>

080014c8 <make_packet>:
void make_packet(struct bme68x_data *bme_data, uint8_t* my_buffer)
{
	packet_length = 0;
	my_buffer[packet_length++] = (uint8_t) SENDER_ID;

	my_buffer[packet_length++] = (uint8_t) ((bme_data->temperature >> 8) & mask);
 80014c8:	4b1d      	ldr	r3, [pc, #116]	@ (8001540 <make_packet+0x78>)
	my_buffer[packet_length++] = (uint8_t) SENDER_ID;
 80014ca:	2201      	movs	r2, #1
 80014cc:	700a      	strb	r2, [r1, #0]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->temperature >> 8) & mask);
 80014ce:	f990 2007 	ldrsb.w	r2, [r0, #7]
{
 80014d2:	b410      	push	{r4}
	my_buffer[packet_length++] = (uint8_t) ((bme_data->temperature >> 8) & mask);
 80014d4:	681c      	ldr	r4, [r3, #0]
 80014d6:	4022      	ands	r2, r4
 80014d8:	704a      	strb	r2, [r1, #1]
	my_buffer[packet_length++] = (uint8_t) (bme_data->temperature & mask);
 80014da:	88c4      	ldrh	r4, [r0, #6]
 80014dc:	681a      	ldr	r2, [r3, #0]
 80014de:	4022      	ands	r2, r4
 80014e0:	708a      	strb	r2, [r1, #2]

	my_buffer[packet_length++] = (uint8_t) ((bme_data->pressure >> 24) & mask);
 80014e2:	7ac2      	ldrb	r2, [r0, #11]
 80014e4:	681c      	ldr	r4, [r3, #0]
 80014e6:	4022      	ands	r2, r4
 80014e8:	70ca      	strb	r2, [r1, #3]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->pressure >> 16) & mask);
 80014ea:	781b      	ldrb	r3, [r3, #0]
 80014ec:	8942      	ldrh	r2, [r0, #10]

#if(SENSE_GAS)
	my_buffer[packet_length++] = (uint8_t) ((bme_data->gas_resistance >> 24) & mask);
	my_buffer[packet_length++] = (uint8_t) ((bme_data->gas_resistance >> 16) & mask);
	my_buffer[packet_length++] = (uint8_t) ((bme_data->gas_resistance >> 8) & mask);
	my_buffer[packet_length++] = (uint8_t) (bme_data->gas_resistance & mask);
 80014ee:	4c15      	ldr	r4, [pc, #84]	@ (8001544 <make_packet+0x7c>)
	my_buffer[packet_length++] = (uint8_t) ((bme_data->pressure >> 16) & mask);
 80014f0:	401a      	ands	r2, r3
 80014f2:	710a      	strb	r2, [r1, #4]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->pressure >> 8) & mask);
 80014f4:	6882      	ldr	r2, [r0, #8]
 80014f6:	ea03 2212 	and.w	r2, r3, r2, lsr #8
 80014fa:	714a      	strb	r2, [r1, #5]
	my_buffer[packet_length++] = (uint8_t) (bme_data->pressure & mask);
 80014fc:	6882      	ldr	r2, [r0, #8]
 80014fe:	401a      	ands	r2, r3
 8001500:	718a      	strb	r2, [r1, #6]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->humidity >> 24) & mask);
 8001502:	7bc2      	ldrb	r2, [r0, #15]
 8001504:	401a      	ands	r2, r3
 8001506:	71ca      	strb	r2, [r1, #7]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->humidity >> 16) & mask);
 8001508:	89c2      	ldrh	r2, [r0, #14]
 800150a:	401a      	ands	r2, r3
 800150c:	720a      	strb	r2, [r1, #8]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->humidity >> 8) & mask);
 800150e:	68c2      	ldr	r2, [r0, #12]
 8001510:	ea03 2212 	and.w	r2, r3, r2, lsr #8
 8001514:	724a      	strb	r2, [r1, #9]
	my_buffer[packet_length++] = (uint8_t) (bme_data->humidity & mask);
 8001516:	68c2      	ldr	r2, [r0, #12]
 8001518:	401a      	ands	r2, r3
 800151a:	728a      	strb	r2, [r1, #10]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->gas_resistance >> 24) & mask);
 800151c:	7cc2      	ldrb	r2, [r0, #19]
 800151e:	401a      	ands	r2, r3
 8001520:	72ca      	strb	r2, [r1, #11]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->gas_resistance >> 16) & mask);
 8001522:	8a42      	ldrh	r2, [r0, #18]
 8001524:	401a      	ands	r2, r3
 8001526:	730a      	strb	r2, [r1, #12]
	my_buffer[packet_length++] = (uint8_t) ((bme_data->gas_resistance >> 8) & mask);
 8001528:	6902      	ldr	r2, [r0, #16]
 800152a:	ea03 2212 	and.w	r2, r3, r2, lsr #8
 800152e:	734a      	strb	r2, [r1, #13]
	my_buffer[packet_length++] = (uint8_t) (bme_data->gas_resistance & mask);
 8001530:	7c00      	ldrb	r0, [r0, #16]
 8001532:	220f      	movs	r2, #15
 8001534:	4003      	ands	r3, r0
 8001536:	7022      	strb	r2, [r4, #0]
#if(USE_MAX_LENGTH)
	for(; packet_length < PAYLOAD_MAX_LENGTH;) {
		packet_buffer[packet_length++] = 0;
	}
#endif
}
 8001538:	bc10      	pop	{r4}
	my_buffer[packet_length++] = (uint8_t) (bme_data->gas_resistance & mask);
 800153a:	738b      	strb	r3, [r1, #14]
}
 800153c:	4770      	bx	lr
 800153e:	bf00      	nop
 8001540:	20000000 	.word	0x20000000
 8001544:	20000258 	.word	0x20000258

08001548 <bme68x_i2c_read>:

/**************************/
/*** INTERFACE FUNCTIONS***/
/**************************/
BME68X_INTF_RET_TYPE bme68x_i2c_read(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf_ptr)
{
 8001548:	b530      	push	{r4, r5, lr}
	if(HAL_I2C_Mem_Read(my_hi2c, *((uint16_t *)intf_ptr), reg_addr, 1, (uint8_t *) reg_data, len, HAL_MAX_DELAY) == HAL_OK) {return BME68X_OK;}
 800154a:	881c      	ldrh	r4, [r3, #0]
 800154c:	4d0a      	ldr	r5, [pc, #40]	@ (8001578 <bme68x_i2c_read+0x30>)
{
 800154e:	b085      	sub	sp, #20
	if(HAL_I2C_Mem_Read(my_hi2c, *((uint16_t *)intf_ptr), reg_addr, 1, (uint8_t *) reg_data, len, HAL_MAX_DELAY) == HAL_OK) {return BME68X_OK;}
 8001550:	b292      	uxth	r2, r2
{
 8001552:	4684      	mov	ip, r0
	if(HAL_I2C_Mem_Read(my_hi2c, *((uint16_t *)intf_ptr), reg_addr, 1, (uint8_t *) reg_data, len, HAL_MAX_DELAY) == HAL_OK) {return BME68X_OK;}
 8001554:	9100      	str	r1, [sp, #0]
 8001556:	9201      	str	r2, [sp, #4]
 8001558:	4621      	mov	r1, r4
 800155a:	f04f 34ff 	mov.w	r4, #4294967295
 800155e:	6828      	ldr	r0, [r5, #0]
 8001560:	9402      	str	r4, [sp, #8]
 8001562:	2301      	movs	r3, #1
 8001564:	4662      	mov	r2, ip
 8001566:	f005 f8bf 	bl	80066e8 <HAL_I2C_Mem_Read>
 800156a:	2800      	cmp	r0, #0
	else {return BME68X_E_COM_FAIL;}
}
 800156c:	bf14      	ite	ne
 800156e:	f06f 0001 	mvnne.w	r0, #1
 8001572:	2000      	moveq	r0, #0
 8001574:	b005      	add	sp, #20
 8001576:	bd30      	pop	{r4, r5, pc}
 8001578:	2000028c 	.word	0x2000028c

0800157c <bme68x_i2c_write>:

BME68X_INTF_RET_TYPE bme68x_i2c_write(uint8_t reg_addr, const uint8_t *reg_data, uint32_t len, void *intf_ptr)
{
 800157c:	b530      	push	{r4, r5, lr}
	if(HAL_I2C_Mem_Write(my_hi2c, *((uint16_t *)intf_ptr), reg_addr, 1, (uint8_t *) reg_data, len, HAL_MAX_DELAY) == HAL_OK) {return BME68X_OK;}
 800157e:	881c      	ldrh	r4, [r3, #0]
 8001580:	4d0a      	ldr	r5, [pc, #40]	@ (80015ac <bme68x_i2c_write+0x30>)
{
 8001582:	b085      	sub	sp, #20
	if(HAL_I2C_Mem_Write(my_hi2c, *((uint16_t *)intf_ptr), reg_addr, 1, (uint8_t *) reg_data, len, HAL_MAX_DELAY) == HAL_OK) {return BME68X_OK;}
 8001584:	b292      	uxth	r2, r2
{
 8001586:	4684      	mov	ip, r0
	if(HAL_I2C_Mem_Write(my_hi2c, *((uint16_t *)intf_ptr), reg_addr, 1, (uint8_t *) reg_data, len, HAL_MAX_DELAY) == HAL_OK) {return BME68X_OK;}
 8001588:	9100      	str	r1, [sp, #0]
 800158a:	9201      	str	r2, [sp, #4]
 800158c:	4621      	mov	r1, r4
 800158e:	f04f 34ff 	mov.w	r4, #4294967295
 8001592:	6828      	ldr	r0, [r5, #0]
 8001594:	9402      	str	r4, [sp, #8]
 8001596:	2301      	movs	r3, #1
 8001598:	4662      	mov	r2, ip
 800159a:	f004 ff7d 	bl	8006498 <HAL_I2C_Mem_Write>
 800159e:	2800      	cmp	r0, #0
	else {return BME68X_E_COM_FAIL;}
}
 80015a0:	bf14      	ite	ne
 80015a2:	f06f 0001 	mvnne.w	r0, #1
 80015a6:	2000      	moveq	r0, #0
 80015a8:	b005      	add	sp, #20
 80015aa:	bd30      	pop	{r4, r5, pc}
 80015ac:	2000028c 	.word	0x2000028c

080015b0 <bme68x_delay_us>:

void bme68x_delay_us(uint32_t period, void *intf_ptr)
{
	HAL_Delay(period/1000); // je crois que c est ok pcq la fonction est utilisee pour des delais de 5ms a 1s
 80015b0:	4b02      	ldr	r3, [pc, #8]	@ (80015bc <bme68x_delay_us+0xc>)
 80015b2:	fba3 3000 	umull	r3, r0, r3, r0
 80015b6:	0980      	lsrs	r0, r0, #6
 80015b8:	f000 bb0e 	b.w	8001bd8 <HAL_Delay>
 80015bc:	10624dd3 	.word	0x10624dd3

080015c0 <bme68x_check_rslt>:
/**************************/


/*** Utilitary function to print error code ***/
void bme68x_check_rslt(const char* api_name, int8_t rslt)
{
 80015c0:	b510      	push	{r4, lr}
 80015c2:	460c      	mov	r4, r1
#if(VERBOSE)
	debug_print(api_name);
 80015c4:	f7ff ff62 	bl	800148c <debug_print>
    switch (rslt)
 80015c8:	1d61      	adds	r1, r4, #5
 80015ca:	2907      	cmp	r1, #7
 80015cc:	d828      	bhi.n	8001620 <bme68x_check_rslt+0x60>
 80015ce:	e8df f001 	tbb	[pc, r1]
 80015d2:	0e09      	.short	0x0e09
 80015d4:	221d1813 	.word	0x221d1813
 80015d8:	0427      	.short	0x0427
        default:
        	debug_print(" : Unknown error code\r\n");
            break;
    }
#endif
}
 80015da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	debug_print(" : No new data found\r\n");
 80015de:	4813      	ldr	r0, [pc, #76]	@ (800162c <bme68x_check_rslt+0x6c>)
 80015e0:	f7ff bf54 	b.w	800148c <debug_print>
}
 80015e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	debug_print(" : Self test error\r\n");
 80015e8:	4811      	ldr	r0, [pc, #68]	@ (8001630 <bme68x_check_rslt+0x70>)
 80015ea:	f7ff bf4f 	b.w	800148c <debug_print>
}
 80015ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	debug_print(" : Incorrect length parameter\r\n");
 80015f2:	4810      	ldr	r0, [pc, #64]	@ (8001634 <bme68x_check_rslt+0x74>)
 80015f4:	f7ff bf4a 	b.w	800148c <debug_print>
}
 80015f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	debug_print(" : Device not found\r\n");
 80015fc:	480e      	ldr	r0, [pc, #56]	@ (8001638 <bme68x_check_rslt+0x78>)
 80015fe:	f7ff bf45 	b.w	800148c <debug_print>
}
 8001602:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	debug_print(" : Communication failure\r\n");
 8001606:	480d      	ldr	r0, [pc, #52]	@ (800163c <bme68x_check_rslt+0x7c>)
 8001608:	f7ff bf40 	b.w	800148c <debug_print>
}
 800160c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            debug_print(" : Null pointer\r\n");
 8001610:	480b      	ldr	r0, [pc, #44]	@ (8001640 <bme68x_check_rslt+0x80>)
 8001612:	f7ff bf3b 	b.w	800148c <debug_print>
}
 8001616:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	debug_print(" : Success\r\n");
 800161a:	480a      	ldr	r0, [pc, #40]	@ (8001644 <bme68x_check_rslt+0x84>)
 800161c:	f7ff bf36 	b.w	800148c <debug_print>
}
 8001620:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	debug_print(" : Unknown error code\r\n");
 8001624:	4808      	ldr	r0, [pc, #32]	@ (8001648 <bme68x_check_rslt+0x88>)
 8001626:	f7ff bf31 	b.w	800148c <debug_print>
 800162a:	bf00      	nop
 800162c:	080168b8 	.word	0x080168b8
 8001630:	080168a0 	.word	0x080168a0
 8001634:	08016868 	.word	0x08016868
 8001638:	08016888 	.word	0x08016888
 800163c:	0801684c 	.word	0x0801684c
 8001640:	08016838 	.word	0x08016838
 8001644:	08016828 	.word	0x08016828
 8001648:	080168d0 	.word	0x080168d0

0800164c <my_sensor_init>:

void my_sensor_init(I2C_HandleTypeDef *hi2c, uint8_t perform_selftest)
{
	my_hi2c = hi2c;
 800164c:	4a27      	ldr	r2, [pc, #156]	@ (80016ec <my_sensor_init+0xa0>)
{
 800164e:	b538      	push	{r3, r4, r5, lr}
    	bme->read = &bme68x_i2c_read;
 8001650:	4c27      	ldr	r4, [pc, #156]	@ (80016f0 <my_sensor_init+0xa4>)
	my_hi2c = hi2c;
 8001652:	6010      	str	r0, [r2, #0]
    	bme->read = &bme68x_i2c_read;
 8001654:	4a27      	ldr	r2, [pc, #156]	@ (80016f4 <my_sensor_init+0xa8>)
 8001656:	6422      	str	r2, [r4, #64]	@ 0x40
    	bme->write = &bme68x_i2c_write;
 8001658:	4a27      	ldr	r2, [pc, #156]	@ (80016f8 <my_sensor_init+0xac>)
 800165a:	6462      	str	r2, [r4, #68]	@ 0x44
    	bme->intf = BME68X_I2C_INTF;
 800165c:	2201      	movs	r2, #1
    	dev_addr = BME68X_I2C_ADDR_LOW<<1;
 800165e:	4b27      	ldr	r3, [pc, #156]	@ (80016fc <my_sensor_init+0xb0>)
    	bme->intf = BME68X_I2C_INTF;
 8001660:	7322      	strb	r2, [r4, #12]
    	bme->delay_us = &bme68x_delay_us;
 8001662:	4a27      	ldr	r2, [pc, #156]	@ (8001700 <my_sensor_init+0xb4>)
	debug_print(api_name);
 8001664:	4827      	ldr	r0, [pc, #156]	@ (8001704 <my_sensor_init+0xb8>)
    	bme->delay_us = &bme68x_delay_us;
 8001666:	64a2      	str	r2, [r4, #72]	@ 0x48
{
 8001668:	460d      	mov	r5, r1
    	bme->amb_temp = 20; /* The ambient temperature in deg C is used for defining the heater temperature */
 800166a:	2214      	movs	r2, #20
    	dev_addr = BME68X_I2C_ADDR_LOW<<1;
 800166c:	21ec      	movs	r1, #236	@ 0xec
 800166e:	7019      	strb	r1, [r3, #0]
    	bme->intf_ptr = &dev_addr;
 8001670:	6063      	str	r3, [r4, #4]
    	bme->amb_temp = 20; /* The ambient temperature in deg C is used for defining the heater temperature */
 8001672:	73a2      	strb	r2, [r4, #14]
	debug_print(api_name);
 8001674:	f7ff ff0a 	bl	800148c <debug_print>
        	debug_print(" : Success\r\n");
 8001678:	4823      	ldr	r0, [pc, #140]	@ (8001708 <my_sensor_init+0xbc>)
 800167a:	f7ff ff07 	bl	800148c <debug_print>
	int8_t rslt;

	rslt = bme68x_interface_init(&bme680_dev);
	bme68x_check_rslt("BME680 interface init", rslt);

	rslt = bme68x_init(&bme680_dev);
 800167e:	4620      	mov	r0, r4
 8001680:	f000 ff78 	bl	8002574 <bme68x_init>
 8001684:	4601      	mov	r1, r0
	bme68x_check_rslt("BME680 init", rslt);
 8001686:	4821      	ldr	r0, [pc, #132]	@ (800170c <my_sensor_init+0xc0>)
 8001688:	f7ff ff9a 	bl	80015c0 <bme68x_check_rslt>

	if(perform_selftest) {
 800168c:	bb15      	cbnz	r5, 80016d4 <my_sensor_init+0x88>
		rslt = bme68x_selftest_check(&bme680_dev);
		bme68x_check_rslt("BME680 selftest check", rslt);
	}

	conf.filter = FILTER;
	conf.odr = ODR;
 800168e:	4820      	ldr	r0, [pc, #128]	@ (8001710 <my_sensor_init+0xc4>)
	conf.os_hum  = OS_HUM;
 8001690:	4b20      	ldr	r3, [pc, #128]	@ (8001714 <my_sensor_init+0xc8>)
	conf.os_pres = OS_PRES;
	conf.os_temp = OS_TEMP;
	rslt = bme68x_set_conf(&conf, &bme680_dev);
 8001692:	4917      	ldr	r1, [pc, #92]	@ (80016f0 <my_sensor_init+0xa4>)
	conf.os_hum  = OS_HUM;
 8001694:	6003      	str	r3, [r0, #0]
	conf.odr = ODR;
 8001696:	2208      	movs	r2, #8
 8001698:	7102      	strb	r2, [r0, #4]
	rslt = bme68x_set_conf(&conf, &bme680_dev);
 800169a:	f001 faf5 	bl	8002c88 <bme68x_set_conf>
 800169e:	4601      	mov	r1, r0
	bme68x_check_rslt("bme68x_set_conf", rslt);
 80016a0:	481d      	ldr	r0, [pc, #116]	@ (8001718 <my_sensor_init+0xcc>)
 80016a2:	f7ff ff8d 	bl	80015c0 <bme68x_check_rslt>

#if(SENSE_GAS)
	heatr_conf.enable = BME68X_ENABLE;
 80016a6:	491d      	ldr	r1, [pc, #116]	@ (800171c <my_sensor_init+0xd0>)
	heatr_conf.heatr_temp = HEATR_TEMP;   // heater T° set to 300 °C
 80016a8:	4b1d      	ldr	r3, [pc, #116]	@ (8001720 <my_sensor_init+0xd4>)
	heatr_conf.heatr_dur = HEATR_DUR;     // heating duration set to 50 ms
	rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, &bme680_dev);
 80016aa:	4a11      	ldr	r2, [pc, #68]	@ (80016f0 <my_sensor_init+0xa4>)
	heatr_conf.heatr_temp = HEATR_TEMP;   // heater T° set to 300 °C
 80016ac:	f8c1 3002 	str.w	r3, [r1, #2]
	heatr_conf.enable = BME68X_ENABLE;
 80016b0:	2001      	movs	r0, #1
 80016b2:	7008      	strb	r0, [r1, #0]
	rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, &bme680_dev);
 80016b4:	f002 fb18 	bl	8003ce8 <bme68x_set_heatr_conf>
 80016b8:	4601      	mov	r1, r0
	bme68x_check_rslt("bme68x_set_heatr_conf", rslt);
 80016ba:	481a      	ldr	r0, [pc, #104]	@ (8001724 <my_sensor_init+0xd8>)
 80016bc:	f7ff ff80 	bl	80015c0 <bme68x_check_rslt>
	heatr_conf.enable = BME68X_DISABLE;
	rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, &bme680_dev);
	bme68x_check_rslt("bme68x_set_heatr_conf", rslt);
#endif

	rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, &bme680_dev);
 80016c0:	490b      	ldr	r1, [pc, #44]	@ (80016f0 <my_sensor_init+0xa4>)
 80016c2:	2000      	movs	r0, #0
 80016c4:	f001 fa7a 	bl	8002bbc <bme68x_set_op_mode>
	bme68x_check_rslt("bme68x_set_op_mode", rslt);
}
 80016c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, &bme680_dev);
 80016cc:	4601      	mov	r1, r0
	bme68x_check_rslt("bme68x_set_op_mode", rslt);
 80016ce:	4816      	ldr	r0, [pc, #88]	@ (8001728 <my_sensor_init+0xdc>)
 80016d0:	f7ff bf76 	b.w	80015c0 <bme68x_check_rslt>
		debug_print("BME680 selftest check begin...\r\n");
 80016d4:	4815      	ldr	r0, [pc, #84]	@ (800172c <my_sensor_init+0xe0>)
 80016d6:	f7ff fed9 	bl	800148c <debug_print>
		rslt = bme68x_selftest_check(&bme680_dev);
 80016da:	4620      	mov	r0, r4
 80016dc:	f002 ffd8 	bl	8004690 <bme68x_selftest_check>
 80016e0:	4601      	mov	r1, r0
		bme68x_check_rslt("BME680 selftest check", rslt);
 80016e2:	4813      	ldr	r0, [pc, #76]	@ (8001730 <my_sensor_init+0xe4>)
 80016e4:	f7ff ff6c 	bl	80015c0 <bme68x_check_rslt>
 80016e8:	e7d1      	b.n	800168e <my_sensor_init+0x42>
 80016ea:	bf00      	nop
 80016ec:	2000028c 	.word	0x2000028c
 80016f0:	20000290 	.word	0x20000290
 80016f4:	08001549 	.word	0x08001549
 80016f8:	0800157d 	.word	0x0800157d
 80016fc:	20000289 	.word	0x20000289
 8001700:	080015b1 	.word	0x080015b1
 8001704:	080168e8 	.word	0x080168e8
 8001708:	08016828 	.word	0x08016828
 800170c:	08016900 	.word	0x08016900
 8001710:	20000284 	.word	0x20000284
 8001714:	00010301 	.word	0x00010301
 8001718:	08016948 	.word	0x08016948
 800171c:	20000270 	.word	0x20000270
 8001720:	0032012c 	.word	0x0032012c
 8001724:	08016958 	.word	0x08016958
 8001728:	08016970 	.word	0x08016970
 800172c:	0801690c 	.word	0x0801690c
 8001730:	08016930 	.word	0x08016930

08001734 <get_BME_data>:
#endif
	}
}

struct bme68x_data *get_BME_data()
{
 8001734:	b570      	push	{r4, r5, r6, lr}
	int8_t rslt;
	uint32_t del_period;

	rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &bme680_dev);
 8001736:	4c21      	ldr	r4, [pc, #132]	@ (80017bc <get_BME_data+0x88>)
//	print_int(del_period);
//	debug_print("\r\n");

	bme680_dev.delay_us(del_period, bme680_dev.intf_ptr);

	rslt = bme68x_get_data(BME68X_FORCED_MODE, &data, &n_fields, &bme680_dev);
 8001738:	4e21      	ldr	r6, [pc, #132]	@ (80017c0 <get_BME_data+0x8c>)
 800173a:	4d22      	ldr	r5, [pc, #136]	@ (80017c4 <get_BME_data+0x90>)
{
 800173c:	b086      	sub	sp, #24
	rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &bme680_dev);
 800173e:	4621      	mov	r1, r4
 8001740:	2001      	movs	r0, #1
 8001742:	f001 fa3b 	bl	8002bbc <bme68x_set_op_mode>
 8001746:	4601      	mov	r1, r0
	bme68x_check_rslt("bme68x_set_op_mode", rslt);
 8001748:	481f      	ldr	r0, [pc, #124]	@ (80017c8 <get_BME_data+0x94>)
 800174a:	f7ff ff39 	bl	80015c0 <bme68x_check_rslt>
	del_period = bme68x_get_meas_dur(BME68X_FORCED_MODE, &conf, &bme680_dev) + (heatr_conf.heatr_dur * 1000);
 800174e:	4622      	mov	r2, r4
 8001750:	491e      	ldr	r1, [pc, #120]	@ (80017cc <get_BME_data+0x98>)
 8001752:	2001      	movs	r0, #1
 8001754:	f001 fdda 	bl	800330c <bme68x_get_meas_dur>
 8001758:	4b1d      	ldr	r3, [pc, #116]	@ (80017d0 <get_BME_data+0x9c>)
	bme680_dev.delay_us(del_period, bme680_dev.intf_ptr);
 800175a:	6861      	ldr	r1, [r4, #4]
	del_period = bme68x_get_meas_dur(BME68X_FORCED_MODE, &conf, &bme680_dev) + (heatr_conf.heatr_dur * 1000);
 800175c:	889b      	ldrh	r3, [r3, #4]
 800175e:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
	bme680_dev.delay_us(del_period, bme680_dev.intf_ptr);
 8001762:	fb02 0003 	mla	r0, r2, r3, r0
 8001766:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8001768:	4798      	blx	r3
	rslt = bme68x_get_data(BME68X_FORCED_MODE, &data, &n_fields, &bme680_dev);
 800176a:	4623      	mov	r3, r4
 800176c:	4632      	mov	r2, r6
 800176e:	4629      	mov	r1, r5
 8001770:	2001      	movs	r0, #1
 8001772:	f001 fe43 	bl	80033fc <bme68x_get_data>
 8001776:	4601      	mov	r1, r0
	bme68x_check_rslt("bme68x_get_data", rslt);
 8001778:	4816      	ldr	r0, [pc, #88]	@ (80017d4 <get_BME_data+0xa0>)
 800177a:	f7ff ff21 	bl	80015c0 <bme68x_check_rslt>
	APP_PRINTF("T [C*100]\t P [Pa]\t\t H [%%*1000]\t Gas R [ohm]\t Status\n");
 800177e:	2200      	movs	r2, #0

#if(VERBOSE)
	print_data_bme(n_fields);
 8001780:	7834      	ldrb	r4, [r6, #0]
	APP_PRINTF("T [C*100]\t P [Pa]\t\t H [%%*1000]\t Gas R [ohm]\t Status\n");
 8001782:	4b15      	ldr	r3, [pc, #84]	@ (80017d8 <get_BME_data+0xa4>)
 8001784:	4611      	mov	r1, r2
 8001786:	4610      	mov	r0, r2
 8001788:	f014 f934 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
	if (n_fields) {
 800178c:	b914      	cbnz	r4, 8001794 <get_BME_data+0x60>
#endif

	return &data;
}
 800178e:	480d      	ldr	r0, [pc, #52]	@ (80017c4 <get_BME_data+0x90>)
 8001790:	b006      	add	sp, #24
 8001792:	bd70      	pop	{r4, r5, r6, pc}
		APP_PRINTF("%d\t\t %u\t\t %u\t\t %u\t\t 0x%x\r\n",
 8001794:	e9d5 4303 	ldrd	r4, r3, [r5, #12]
 8001798:	7829      	ldrb	r1, [r5, #0]
 800179a:	e9cd 3103 	strd	r3, r1, [sp, #12]
 800179e:	68a8      	ldr	r0, [r5, #8]
 80017a0:	f9b5 1006 	ldrsh.w	r1, [r5, #6]
 80017a4:	9100      	str	r1, [sp, #0]
 80017a6:	2200      	movs	r2, #0
 80017a8:	e9cd 0401 	strd	r0, r4, [sp, #4]
 80017ac:	4b0b      	ldr	r3, [pc, #44]	@ (80017dc <get_BME_data+0xa8>)
 80017ae:	4611      	mov	r1, r2
 80017b0:	4610      	mov	r0, r2
 80017b2:	f014 f91f 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 80017b6:	4803      	ldr	r0, [pc, #12]	@ (80017c4 <get_BME_data+0x90>)
 80017b8:	b006      	add	sp, #24
 80017ba:	bd70      	pop	{r4, r5, r6, pc}
 80017bc:	20000290 	.word	0x20000290
 80017c0:	20000259 	.word	0x20000259
 80017c4:	2000025c 	.word	0x2000025c
 80017c8:	08016970 	.word	0x08016970
 80017cc:	20000284 	.word	0x20000284
 80017d0:	20000270 	.word	0x20000270
 80017d4:	080169d8 	.word	0x080169d8
 80017d8:	08016984 	.word	0x08016984
 80017dc:	080169bc 	.word	0x080169bc

080017e0 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 80017e0:	b510      	push	{r4, lr}
 80017e2:	b08c      	sub	sp, #48	@ 0x30

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 80017e4:	222c      	movs	r2, #44	@ 0x2c
 80017e6:	2100      	movs	r1, #0
 80017e8:	4668      	mov	r0, sp
 80017ea:	f014 fc6d 	bl	80160c8 <memset>

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 80017ee:	481b      	ldr	r0, [pc, #108]	@ (800185c <MX_RTC_Init+0x7c>)
 80017f0:	491b      	ldr	r1, [pc, #108]	@ (8001860 <MX_RTC_Init+0x80>)
 80017f2:	6001      	str	r1, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 80017f4:	221f      	movs	r2, #31
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 80017f6:	2300      	movs	r3, #0
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 80017f8:	6082      	str	r2, [r0, #8]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 80017fa:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80017fe:	e9c0 3206 	strd	r3, r2, [r0, #24]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 8001802:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 8001806:	2200      	movs	r2, #0
 8001808:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800180c:	e9c0 2308 	strd	r2, r3, [r0, #32]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8001810:	f006 fa80 	bl	8007d14 <HAL_RTC_Init>
 8001814:	b9a0      	cbnz	r0, 8001840 <MX_RTC_Init+0x60>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 8001816:	4811      	ldr	r0, [pc, #68]	@ (800185c <MX_RTC_Init+0x7c>)
 8001818:	f006 fb10 	bl	8007e3c <HAL_RTCEx_SetSSRU_IT>
 800181c:	b9b8      	cbnz	r0, 800184e <MX_RTC_Init+0x6e>
    Error_Handler();
  }

  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 800181e:	2200      	movs	r2, #0
  sAlarm.AlarmTime.SubSeconds = 0x0;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8001820:	f04f 5400 	mov.w	r4, #536870912	@ 0x20000000
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
  sAlarm.Alarm = RTC_ALARM_A;
 8001824:	f44f 7380 	mov.w	r3, #256	@ 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8001828:	480c      	ldr	r0, [pc, #48]	@ (800185c <MX_RTC_Init+0x7c>)
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 800182a:	9207      	str	r2, [sp, #28]
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 800182c:	4669      	mov	r1, sp
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 800182e:	e9cd 2405 	strd	r2, r4, [sp, #20]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 8001832:	9201      	str	r2, [sp, #4]
  sAlarm.Alarm = RTC_ALARM_A;
 8001834:	930a      	str	r3, [sp, #40]	@ 0x28
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8001836:	f006 f8dd 	bl	80079f4 <HAL_RTC_SetAlarm_IT>
 800183a:	b958      	cbnz	r0, 8001854 <MX_RTC_Init+0x74>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 800183c:	b00c      	add	sp, #48	@ 0x30
 800183e:	bd10      	pop	{r4, pc}
    Error_Handler();
 8001840:	f7ff fe40 	bl	80014c4 <Error_Handler>
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 8001844:	4805      	ldr	r0, [pc, #20]	@ (800185c <MX_RTC_Init+0x7c>)
 8001846:	f006 faf9 	bl	8007e3c <HAL_RTCEx_SetSSRU_IT>
 800184a:	2800      	cmp	r0, #0
 800184c:	d0e7      	beq.n	800181e <MX_RTC_Init+0x3e>
    Error_Handler();
 800184e:	f7ff fe39 	bl	80014c4 <Error_Handler>
 8001852:	e7e4      	b.n	800181e <MX_RTC_Init+0x3e>
    Error_Handler();
 8001854:	f7ff fe36 	bl	80014c4 <Error_Handler>
}
 8001858:	b00c      	add	sp, #48	@ 0x30
 800185a:	bd10      	pop	{r4, pc}
 800185c:	200002e0 	.word	0x200002e0
 8001860:	40002800 	.word	0x40002800

08001864 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 8001864:	b510      	push	{r4, lr}
 8001866:	4604      	mov	r4, r0
 8001868:	b090      	sub	sp, #64	@ 0x40

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800186a:	2238      	movs	r2, #56	@ 0x38
 800186c:	2100      	movs	r1, #0
 800186e:	a802      	add	r0, sp, #8
 8001870:	f014 fc2a 	bl	80160c8 <memset>
  if(rtcHandle->Instance==RTC)
 8001874:	4b1a      	ldr	r3, [pc, #104]	@ (80018e0 <HAL_RTC_MspInit+0x7c>)
 8001876:	6822      	ldr	r2, [r4, #0]
 8001878:	429a      	cmp	r2, r3
 800187a:	d001      	beq.n	8001880 <HAL_RTC_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 800187c:	b010      	add	sp, #64	@ 0x40
 800187e:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8001880:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8001884:	f44f 7380 	mov.w	r3, #256	@ 0x100
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001888:	a802      	add	r0, sp, #8
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800188a:	9202      	str	r2, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800188c:	930f      	str	r3, [sp, #60]	@ 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800188e:	f005 ff99 	bl	80077c4 <HAL_RCCEx_PeriphCLKConfig>
 8001892:	bb10      	cbnz	r0, 80018da <HAL_RTC_MspInit+0x76>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 8001894:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
    HAL_NVIC_SetPriority(TAMP_STAMP_LSECSS_SSRU_IRQn, 0, 0);
 8001898:	2200      	movs	r2, #0
 800189a:	f8d3 0090 	ldr.w	r0, [r3, #144]	@ 0x90
 800189e:	f440 4000 	orr.w	r0, r0, #32768	@ 0x8000
 80018a2:	f8c3 0090 	str.w	r0, [r3, #144]	@ 0x90
  SET_BIT(RCC->APB1ENR1, Periphs);
 80018a6:	6d9c      	ldr	r4, [r3, #88]	@ 0x58
 80018a8:	f444 6480 	orr.w	r4, r4, #1024	@ 0x400
 80018ac:	659c      	str	r4, [r3, #88]	@ 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 80018ae:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80018b0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80018b4:	4611      	mov	r1, r2
 80018b6:	9301      	str	r3, [sp, #4]
 80018b8:	2002      	movs	r0, #2
  (void)tmpreg;
 80018ba:	9b01      	ldr	r3, [sp, #4]
 80018bc:	f003 fed4 	bl	8005668 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TAMP_STAMP_LSECSS_SSRU_IRQn);
 80018c0:	2002      	movs	r0, #2
 80018c2:	f003 ff0d 	bl	80056e0 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 80018c6:	2200      	movs	r2, #0
 80018c8:	4611      	mov	r1, r2
 80018ca:	202a      	movs	r0, #42	@ 0x2a
 80018cc:	f003 fecc 	bl	8005668 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 80018d0:	202a      	movs	r0, #42	@ 0x2a
 80018d2:	f003 ff05 	bl	80056e0 <HAL_NVIC_EnableIRQ>
}
 80018d6:	b010      	add	sp, #64	@ 0x40
 80018d8:	bd10      	pop	{r4, pc}
      Error_Handler();
 80018da:	f7ff fdf3 	bl	80014c4 <Error_Handler>
 80018de:	e7d9      	b.n	8001894 <HAL_RTC_MspInit+0x30>
 80018e0:	40002800 	.word	0x40002800

080018e4 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 80018e4:	4770      	bx	lr
 80018e6:	bf00      	nop

080018e8 <PWR_EnterStopMode>:

  /* USER CODE END ExitOffMode_1 */
}

void PWR_EnterStopMode(void)
{
 80018e8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 80018ea:	f003 f95b 	bl	8004ba4 <HAL_SuspendTick>
  * @rmtoll EXTSCR       C1CSSF        LL_PWR_ClearFlag_C1STOP_C1STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C1STOP_C1STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C1CSSF);
 80018ee:	4b04      	ldr	r3, [pc, #16]	@ (8001900 <PWR_EnterStopMode+0x18>)
 80018f0:	2001      	movs	r0, #1
 80018f2:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 80018f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 80018fa:	f005 b8dd 	b.w	8006ab8 <HAL_PWREx_EnterSTOP2Mode>
 80018fe:	bf00      	nop
 8001900:	58000400 	.word	0x58000400

08001904 <PWR_ExitSleepMode>:
{
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Resume sysTick */
  HAL_ResumeTick();
 8001904:	f003 b956 	b.w	8004bb4 <HAL_ResumeTick>

08001908 <PWR_ExitStopMode>:
{
 8001908:	b508      	push	{r3, lr}
  HAL_ResumeTick();
 800190a:	f003 f953 	bl	8004bb4 <HAL_ResumeTick>
}
 800190e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  vcom_Resume();
 8001912:	f000 bc53 	b.w	80021bc <vcom_Resume>
 8001916:	bf00      	nop

08001918 <PWR_EnterSleepMode>:
{
 8001918:	b508      	push	{r3, lr}
  HAL_SuspendTick();
 800191a:	f003 f943 	bl	8004ba4 <HAL_SuspendTick>
}
 800191e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 8001922:	2101      	movs	r1, #1
 8001924:	2000      	movs	r0, #0
 8001926:	f005 b867 	b.w	80069f8 <HAL_PWR_EnterSLEEPMode>
 800192a:	bf00      	nop

0800192c <PWR_ExitOffMode>:
void PWR_ExitOffMode(void)
 800192c:	4770      	bx	lr
 800192e:	bf00      	nop

08001930 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001930:	b508      	push	{r3, lr}

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* RCC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(RCC_IRQn, 0, 0);
 8001932:	2200      	movs	r2, #0
 8001934:	2005      	movs	r0, #5
 8001936:	4611      	mov	r1, r2
 8001938:	f003 fe96 	bl	8005668 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RCC_IRQn);

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800193c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_NVIC_EnableIRQ(RCC_IRQn);
 8001940:	2005      	movs	r0, #5
 8001942:	f003 becd 	b.w	80056e0 <HAL_NVIC_EnableIRQ>
 8001946:	bf00      	nop

08001948 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8001948:	e7fe      	b.n	8001948 <NMI_Handler>
 800194a:	bf00      	nop

0800194c <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800194c:	e7fe      	b.n	800194c <HardFault_Handler>
 800194e:	bf00      	nop

08001950 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001950:	e7fe      	b.n	8001950 <MemManage_Handler>
 8001952:	bf00      	nop

08001954 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001954:	e7fe      	b.n	8001954 <BusFault_Handler>
 8001956:	bf00      	nop

08001958 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001958:	e7fe      	b.n	8001958 <UsageFault_Handler>
 800195a:	bf00      	nop

0800195c <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800195c:	4770      	bx	lr
 800195e:	bf00      	nop

08001960 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
 8001960:	4770      	bx	lr
 8001962:	bf00      	nop

08001964 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 8001964:	4770      	bx	lr
 8001966:	bf00      	nop

08001968 <SysTick_Handler>:
}

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
 8001968:	4770      	bx	lr
 800196a:	bf00      	nop

0800196c <TAMP_STAMP_LSECSS_SSRU_IRQHandler>:
void TAMP_STAMP_LSECSS_SSRU_IRQHandler(void)
{
  /* USER CODE BEGIN TAMP_STAMP_LSECSS_SSRU_IRQn 0 */

  /* USER CODE END TAMP_STAMP_LSECSS_SSRU_IRQn 0 */
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 800196c:	4801      	ldr	r0, [pc, #4]	@ (8001974 <TAMP_STAMP_LSECSS_SSRU_IRQHandler+0x8>)
 800196e:	f006 ba8f 	b.w	8007e90 <HAL_RTCEx_SSRUIRQHandler>
 8001972:	bf00      	nop
 8001974:	200002e0 	.word	0x200002e0

08001978 <RCC_IRQHandler>:
}

/**
  * @brief This function handles RCC Interrupt.
  */
void RCC_IRQHandler(void)
 8001978:	4770      	bx	lr
 800197a:	bf00      	nop

0800197c <DMA1_Channel1_IRQHandler>:
void DMA1_Channel1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_lpuart1_tx);
 800197c:	4801      	ldr	r0, [pc, #4]	@ (8001984 <DMA1_Channel1_IRQHandler+0x8>)
 800197e:	f004 b8b5 	b.w	8005aec <HAL_DMA_IRQHandler>
 8001982:	bf00      	nop
 8001984:	20000338 	.word	0x20000338

08001988 <ADC_IRQHandler>:
void ADC_IRQHandler(void)
{
  /* USER CODE BEGIN ADC_IRQn 0 */

  /* USER CODE END ADC_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc);
 8001988:	4801      	ldr	r0, [pc, #4]	@ (8001990 <ADC_IRQHandler+0x8>)
 800198a:	f003 babd 	b.w	8004f08 <HAL_ADC_IRQHandler>
 800198e:	bf00      	nop
 8001990:	20000194 	.word	0x20000194

08001994 <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI Lines [9:5] Interrupt.
  */
void EXTI9_5_IRQHandler(void)
{
 8001994:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_6);
 8001996:	2040      	movs	r0, #64	@ 0x40
 8001998:	f004 fbc6 	bl	8006128 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_7);
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 800199c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_7);
 80019a0:	2080      	movs	r0, #128	@ 0x80
 80019a2:	f004 bbc1 	b.w	8006128 <HAL_GPIO_EXTI_IRQHandler>
 80019a6:	bf00      	nop

080019a8 <LPUART1_IRQHandler>:
void LPUART1_IRQHandler(void)
{
  /* USER CODE BEGIN LPUART1_IRQn 0 */

  /* USER CODE END LPUART1_IRQn 0 */
  HAL_UART_IRQHandler(&hlpuart1);
 80019a8:	4801      	ldr	r0, [pc, #4]	@ (80019b0 <LPUART1_IRQHandler+0x8>)
 80019aa:	f007 b8d5 	b.w	8008b58 <HAL_UART_IRQHandler>
 80019ae:	bf00      	nop
 80019b0:	20000398 	.word	0x20000398

080019b4 <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler(void)
{
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 80019b4:	4801      	ldr	r0, [pc, #4]	@ (80019bc <RTC_Alarm_IRQHandler+0x8>)
 80019b6:	f006 b949 	b.w	8007c4c <HAL_RTC_AlarmIRQHandler>
 80019ba:	bf00      	nop
 80019bc:	200002e0 	.word	0x200002e0

080019c0 <SUBGHZ_Radio_IRQHandler>:
void SUBGHZ_Radio_IRQHandler(void)
{
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 80019c0:	4801      	ldr	r0, [pc, #4]	@ (80019c8 <SUBGHZ_Radio_IRQHandler+0x8>)
 80019c2:	f006 bc97 	b.w	80082f4 <HAL_SUBGHZ_IRQHandler>
 80019c6:	bf00      	nop
 80019c8:	20000318 	.word	0x20000318

080019cc <MX_SUBGHZ_Init>:
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 80019cc:	4805      	ldr	r0, [pc, #20]	@ (80019e4 <MX_SUBGHZ_Init+0x18>)
{
 80019ce:	b508      	push	{r3, lr}
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 80019d0:	2308      	movs	r3, #8
 80019d2:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 80019d4:	f006 fa82 	bl	8007edc <HAL_SUBGHZ_Init>
 80019d8:	b900      	cbnz	r0, 80019dc <MX_SUBGHZ_Init+0x10>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 80019da:	bd08      	pop	{r3, pc}
 80019dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 80019e0:	f7ff bd70 	b.w	80014c4 <Error_Handler>
 80019e4:	20000318 	.word	0x20000318

080019e8 <HAL_SUBGHZ_MspInit>:
  * @retval None
  */
__STATIC_INLINE void LL_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB3ENR, Periphs);
 80019e8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 80019ec:	b500      	push	{lr}
 80019ee:	6e59      	ldr	r1, [r3, #100]	@ 0x64
 80019f0:	f041 0101 	orr.w	r1, r1, #1
 80019f4:	6659      	str	r1, [r3, #100]	@ 0x64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB3ENR, Periphs);
 80019f6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80019f8:	b083      	sub	sp, #12
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 80019fa:	2200      	movs	r2, #0
 80019fc:	f003 0301 	and.w	r3, r3, #1
 8001a00:	9301      	str	r3, [sp, #4]
 8001a02:	2032      	movs	r0, #50	@ 0x32
 8001a04:	4611      	mov	r1, r2
  (void)tmpreg;
 8001a06:	9b01      	ldr	r3, [sp, #4]
 8001a08:	f003 fe2e 	bl	8005668 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 8001a0c:	2032      	movs	r0, #50	@ 0x32
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 8001a0e:	b003      	add	sp, #12
 8001a10:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 8001a14:	f003 be64 	b.w	80056e0 <HAL_NVIC_EnableIRQ>

08001a18 <tiny_snprintf_like.constprop.0>:
  /* USER CODE BEGIN UTIL_LPM_SetStopMode_2 */

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
 8001a18:	b40c      	push	{r2, r3}
 8001a1a:	b500      	push	{lr}
 8001a1c:	b083      	sub	sp, #12
{
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
 8001a1e:	ab05      	add	r3, sp, #20
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 8001a20:	4a04      	ldr	r2, [pc, #16]	@ (8001a34 <tiny_snprintf_like.constprop.0+0x1c>)
  va_start(vaArgs, strFormat);
 8001a22:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 8001a24:	2110      	movs	r1, #16
 8001a26:	f013 fa7d 	bl	8014f24 <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 8001a2a:	b003      	add	sp, #12
 8001a2c:	f85d eb04 	ldr.w	lr, [sp], #4
 8001a30:	b002      	add	sp, #8
 8001a32:	4770      	bx	lr
 8001a34:	08016a00 	.word	0x08016a00

08001a38 <TimestampNow>:
{
 8001a38:	b530      	push	{r4, r5, lr}
 8001a3a:	b085      	sub	sp, #20
 8001a3c:	4604      	mov	r4, r0
  SysTime_t curtime = SysTimeGet();
 8001a3e:	a802      	add	r0, sp, #8
{
 8001a40:	460d      	mov	r5, r1
  SysTime_t curtime = SysTimeGet();
 8001a42:	f013 f9e5 	bl	8014e10 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 8001a46:	f9bd 100c 	ldrsh.w	r1, [sp, #12]
 8001a4a:	9b02      	ldr	r3, [sp, #8]
 8001a4c:	4a05      	ldr	r2, [pc, #20]	@ (8001a64 <TimestampNow+0x2c>)
 8001a4e:	9100      	str	r1, [sp, #0]
 8001a50:	4620      	mov	r0, r4
 8001a52:	2110      	movs	r1, #16
 8001a54:	f7ff ffe0 	bl	8001a18 <tiny_snprintf_like.constprop.0>
  *size = strlen((char *)buff);
 8001a58:	4620      	mov	r0, r4
 8001a5a:	f7fe fb8d 	bl	8000178 <strlen>
 8001a5e:	8028      	strh	r0, [r5, #0]
}
 8001a60:	b005      	add	sp, #20
 8001a62:	bd30      	pop	{r4, r5, pc}
 8001a64:	08016a00 	.word	0x08016a00

08001a68 <SystemApp_Init>:
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 8001a68:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
{
 8001a6c:	b510      	push	{r4, lr}
 8001a6e:	6893      	ldr	r3, [r2, #8]
 8001a70:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8001a74:	6093      	str	r3, [r2, #8]
  UTIL_TIMER_Init();
 8001a76:	f013 fe03 	bl	8015680 <UTIL_TIMER_Init>
  SYS_TimerInitialisedFlag = 1;
 8001a7a:	4b0e      	ldr	r3, [pc, #56]	@ (8001ab4 <SystemApp_Init+0x4c>)
 8001a7c:	2401      	movs	r4, #1
 8001a7e:	701c      	strb	r4, [r3, #0]
  DBG_Init();
 8001a80:	f000 f8b0 	bl	8001be4 <DBG_Init>
  UTIL_ADV_TRACE_Init();
 8001a84:	f013 ff34 	bl	80158f0 <UTIL_ADV_TRACE_Init>
  UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 8001a88:	480b      	ldr	r0, [pc, #44]	@ (8001ab8 <SystemApp_Init+0x50>)
 8001a8a:	f013 ff4b 	bl	8015924 <UTIL_ADV_TRACE_RegisterTimeStampFunction>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8001a8e:	4b0b      	ldr	r3, [pc, #44]	@ (8001abc <SystemApp_Init+0x54>)
 8001a90:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8001a94:	611a      	str	r2, [r3, #16]
  UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
 8001a96:	2003      	movs	r0, #3
 8001a98:	f013 ff4a 	bl	8015930 <UTIL_ADV_TRACE_SetVerboseLevel>
  SYS_InitMeasurement();
 8001a9c:	f7ff f96e 	bl	8000d7c <SYS_InitMeasurement>
  EnvSensors_Init();
 8001aa0:	f000 f8ce 	bl	8001c40 <EnvSensors_Init>
  UTIL_LPM_Init();
 8001aa4:	f013 f8a2 	bl	8014bec <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 8001aa8:	4621      	mov	r1, r4
 8001aaa:	4620      	mov	r0, r4
}
 8001aac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 8001ab0:	f013 b8be 	b.w	8014c30 <UTIL_LPM_SetOffMode>
 8001ab4:	20000324 	.word	0x20000324
 8001ab8:	08001a39 	.word	0x08001a39
 8001abc:	58004000 	.word	0x58004000

08001ac0 <UTIL_SEQ_Idle>:
  UTIL_LPM_EnterLowPower();
 8001ac0:	f013 b8ce 	b.w	8014c60 <UTIL_LPM_EnterLowPower>

08001ac4 <GetBatteryLevel>:
{
 8001ac4:	b508      	push	{r3, lr}
  batteryLevelmV = (uint16_t) SYS_GetBatteryLevel();
 8001ac6:	f7ff f9cb 	bl	8000e60 <SYS_GetBatteryLevel>
  if (batteryLevelmV > VDD_BAT)
 8001aca:	f640 33b8 	movw	r3, #3000	@ 0xbb8
 8001ace:	4298      	cmp	r0, r3
 8001ad0:	d80f      	bhi.n	8001af2 <GetBatteryLevel+0x2e>
  else if (batteryLevelmV < VDD_MIN)
 8001ad2:	f5b0 6fe1 	cmp.w	r0, #1800	@ 0x708
 8001ad6:	d201      	bcs.n	8001adc <GetBatteryLevel+0x18>
    batteryLevel = 0;
 8001ad8:	2000      	movs	r0, #0
}
 8001ada:	bd08      	pop	{r3, pc}
    batteryLevel = (((uint32_t)(batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT - VDD_MIN));
 8001adc:	f5a0 60e1 	sub.w	r0, r0, #1800	@ 0x708
 8001ae0:	4b05      	ldr	r3, [pc, #20]	@ (8001af8 <GetBatteryLevel+0x34>)
 8001ae2:	ebc0 10c0 	rsb	r0, r0, r0, lsl #7
 8001ae6:	0040      	lsls	r0, r0, #1
 8001ae8:	fba3 3000 	umull	r3, r0, r3, r0
 8001aec:	f3c0 10c7 	ubfx	r0, r0, #7, #8
}
 8001af0:	bd08      	pop	{r3, pc}
    batteryLevel = LORAWAN_MAX_BAT;
 8001af2:	20fe      	movs	r0, #254	@ 0xfe
}
 8001af4:	bd08      	pop	{r3, pc}
 8001af6:	bf00      	nop
 8001af8:	1b4e81b5 	.word	0x1b4e81b5

08001afc <GetTemperatureLevel>:
{
 8001afc:	b500      	push	{lr}
 8001afe:	b087      	sub	sp, #28
  EnvSensors_Read(&sensor_data);
 8001b00:	4668      	mov	r0, sp
 8001b02:	f000 f881 	bl	8001c08 <EnvSensors_Read>
  temperatureLevel = (int16_t)(sensor_data.temperature);
 8001b06:	9801      	ldr	r0, [sp, #4]
 8001b08:	f7fe feb8 	bl	800087c <__aeabi_f2iz>
}
 8001b0c:	b200      	sxth	r0, r0
 8001b0e:	b007      	add	sp, #28
 8001b10:	f85d fb04 	ldr.w	pc, [sp], #4

08001b14 <GetUniqueId>:
{
 8001b14:	b538      	push	{r3, r4, r5, lr}
 8001b16:	4b1b      	ldr	r3, [pc, #108]	@ (8001b84 <GetUniqueId+0x70>)
 8001b18:	f8d3 2580 	ldr.w	r2, [r3, #1408]	@ 0x580
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 8001b1c:	1c51      	adds	r1, r2, #1
{
 8001b1e:	4604      	mov	r4, r0
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 8001b20:	d00f      	beq.n	8001b42 <GetUniqueId+0x2e>
    id[4] = (val >> 24) & 0xFF;
 8001b22:	ba11      	rev	r1, r2
 8001b24:	6041      	str	r1, [r0, #4]
    id[3] = val & 0xFF;
 8001b26:	f8d3 2584 	ldr.w	r2, [r3, #1412]	@ 0x584
 8001b2a:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 8001b2c:	f8d3 0584 	ldr.w	r0, [r3, #1412]	@ 0x584
    id[2] = val & 0xFF;
 8001b30:	f3c0 2207 	ubfx	r2, r0, #8, #8
    id[1] = (val >> 8) & 0xFF;
 8001b34:	f3c0 4307 	ubfx	r3, r0, #16, #8
    id[0] = (val >> 16) & 0xFF;
 8001b38:	0e00      	lsrs	r0, r0, #24
    id[2] = (ID_2_val) >> 16;
 8001b3a:	70a2      	strb	r2, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 8001b3c:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 8001b3e:	7020      	strb	r0, [r4, #0]
}
 8001b40:	bd38      	pop	{r3, r4, r5, pc}
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 8001b42:	f003 f83f 	bl	8004bc4 <HAL_GetUIDw0>
 8001b46:	4605      	mov	r5, r0
 8001b48:	f003 f848 	bl	8004bdc <HAL_GetUIDw2>
 8001b4c:	4405      	add	r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 8001b4e:	f003 f83f 	bl	8004bd0 <HAL_GetUIDw1>
    id[3] = (ID_2_val) >> 24;
 8001b52:	2300      	movs	r3, #0
 8001b54:	0e02      	lsrs	r2, r0, #24
 8001b56:	f362 0307 	bfi	r3, r2, #0, #8
 8001b5a:	f365 230f 	bfi	r3, r5, #8, #8
    id[5] = (ID_1_3_val) >> 8;
 8001b5e:	0a2a      	lsrs	r2, r5, #8
    id[3] = (ID_2_val) >> 24;
 8001b60:	f362 4317 	bfi	r3, r2, #16, #8
    id[6] = (ID_1_3_val) >> 16;
 8001b64:	0c2a      	lsrs	r2, r5, #16
    id[3] = (ID_2_val) >> 24;
 8001b66:	f362 631f 	bfi	r3, r2, #24, #8
    id[7] = (ID_1_3_val) >> 24;
 8001b6a:	0e2d      	lsrs	r5, r5, #24
    id[2] = (ID_2_val) >> 16;
 8001b6c:	f3c0 4207 	ubfx	r2, r0, #16, #8
    id[3] = (ID_2_val) >> 24;
 8001b70:	f8c4 3003 	str.w	r3, [r4, #3]
    id[1] = (ID_2_val) >> 8;
 8001b74:	f3c0 2307 	ubfx	r3, r0, #8, #8
    id[0] = (ID_2_val);
 8001b78:	b2c0      	uxtb	r0, r0
    id[7] = (ID_1_3_val) >> 24;
 8001b7a:	71e5      	strb	r5, [r4, #7]
    id[2] = (ID_2_val) >> 16;
 8001b7c:	70a2      	strb	r2, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 8001b7e:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 8001b80:	7020      	strb	r0, [r4, #0]
}
 8001b82:	bd38      	pop	{r3, r4, r5, pc}
 8001b84:	1fff7000 	.word	0x1fff7000

08001b88 <GetDevAddr>:
{
 8001b88:	b538      	push	{r3, r4, r5, lr}
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 8001b8a:	4b09      	ldr	r3, [pc, #36]	@ (8001bb0 <GetDevAddr+0x28>)
 8001b8c:	f8d3 3580 	ldr.w	r3, [r3, #1408]	@ 0x580
  *devAddr = LL_FLASH_GetUDN();
 8001b90:	6003      	str	r3, [r0, #0]
  if (*devAddr == 0xFFFFFFFF)
 8001b92:	3301      	adds	r3, #1
 8001b94:	d000      	beq.n	8001b98 <GetDevAddr+0x10>
}
 8001b96:	bd38      	pop	{r3, r4, r5, pc}
    *devAddr = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 8001b98:	4604      	mov	r4, r0
 8001b9a:	f003 f813 	bl	8004bc4 <HAL_GetUIDw0>
 8001b9e:	4605      	mov	r5, r0
 8001ba0:	f003 f816 	bl	8004bd0 <HAL_GetUIDw1>
 8001ba4:	4045      	eors	r5, r0
 8001ba6:	f003 f819 	bl	8004bdc <HAL_GetUIDw2>
 8001baa:	4045      	eors	r5, r0
 8001bac:	6025      	str	r5, [r4, #0]
}
 8001bae:	bd38      	pop	{r3, r4, r5, pc}
 8001bb0:	1fff7000 	.word	0x1fff7000

08001bb4 <UTIL_ADV_TRACE_PreSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 8001bb4:	2101      	movs	r1, #1
 8001bb6:	2002      	movs	r0, #2
 8001bb8:	f013 b822 	b.w	8014c00 <UTIL_LPM_SetStopMode>

08001bbc <UTIL_ADV_TRACE_PostSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 8001bbc:	2100      	movs	r1, #0
 8001bbe:	2002      	movs	r0, #2
 8001bc0:	f013 b81e 	b.w	8014c00 <UTIL_LPM_SetStopMode>

08001bc4 <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 8001bc4:	2000      	movs	r0, #0
 8001bc6:	4770      	bx	lr

08001bc8 <HAL_GetTick>:
  uint32_t ret = 0;
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  if (SYS_TimerInitialisedFlag == 0)
 8001bc8:	4b02      	ldr	r3, [pc, #8]	@ (8001bd4 <HAL_GetTick+0xc>)
 8001bca:	7818      	ldrb	r0, [r3, #0]
 8001bcc:	b900      	cbnz	r0, 8001bd0 <HAL_GetTick+0x8>
  }
  /* USER CODE BEGIN HAL_GetTick_2 */

  /* USER CODE END HAL_GetTick_2 */
  return ret;
}
 8001bce:	4770      	bx	lr
    ret = TIMER_IF_GetTimerValue();
 8001bd0:	f000 b944 	b.w	8001e5c <TIMER_IF_GetTimerValue>
 8001bd4:	20000324 	.word	0x20000324

08001bd8 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 8001bd8:	b082      	sub	sp, #8
 8001bda:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 8001bdc:	9801      	ldr	r0, [sp, #4]
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 8001bde:	b002      	add	sp, #8
  TIMER_IF_DelayMs(Delay);
 8001be0:	f000 b98e 	b.w	8001f00 <TIMER_IF_DelayMs>

08001be4 <DBG_Init>:
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->IMR2, ExtiLine);
 8001be4:	4a07      	ldr	r2, [pc, #28]	@ (8001c04 <DBG_Init+0x20>)

/**
  * @brief Initializes the SW probes pins and the monitor RF pins via Alternate Function
  */
void DBG_Init(void)
{
 8001be6:	b508      	push	{r3, lr}
 8001be8:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8001bec:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001bf0:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  HAL_DBGMCU_DisableDBGStandbyMode();
#elif defined (DEBUGGER_ENABLED) && ( DEBUGGER_ENABLED == 1 )
  /*Debug power up request wakeup CBDGPWRUPREQ*/
  LL_EXTI_EnableIT_32_63(LL_EXTI_LINE_46);
  /* Disabled HAL_DBGMCU_  */
  HAL_DBGMCU_EnableDBGSleepMode();
 8001bf4:	f002 fff8 	bl	8004be8 <HAL_DBGMCU_EnableDBGSleepMode>
  HAL_DBGMCU_EnableDBGStopMode();
 8001bf8:	f002 fffe 	bl	8004bf8 <HAL_DBGMCU_EnableDBGStopMode>
#endif /* DEBUG_RF_BUSY_ENABLED */

  /* USER CODE BEGIN DBG_Init_3 */

  /* USER CODE END DBG_Init_3 */
}
 8001bfc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DBGMCU_EnableDBGStandbyMode();
 8001c00:	f003 b802 	b.w	8004c08 <HAL_DBGMCU_EnableDBGStandbyMode>
 8001c04:	58000800 	.word	0x58000800

08001c08 <EnvSensors_Read>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t EnvSensors_Read(sensor_t *sensor_data)
{
 8001c08:	b510      	push	{r4, lr}
 8001c0a:	4604      	mov	r4, r0
#if (USE_IKS01A3_ENV_SENSOR_LPS22HH_0 == 1)
  IKS01A3_ENV_SENSOR_GetValue(IKS01A3_LPS22HH_0, ENV_PRESSURE, &PRESSURE_Value);
  IKS01A3_ENV_SENSOR_GetValue(IKS01A3_LPS22HH_0, ENV_TEMPERATURE, &TEMPERATURE_Value);
#endif /* USE_IKS01A3_ENV_SENSOR_LPS22HH_0 */
#else
  TEMPERATURE_Value = (SYS_GetTemperatureLevel() >> 8);
 8001c0c:	f7ff f8be 	bl	8000d8c <SYS_GetTemperatureLevel>
#endif  /* SENSOR_ENABLED */

  sensor_data->humidity    = HUMIDITY_Value;
 8001c10:	4b07      	ldr	r3, [pc, #28]	@ (8001c30 <EnvSensors_Read+0x28>)
 8001c12:	60a3      	str	r3, [r4, #8]
  TEMPERATURE_Value = (SYS_GetTemperatureLevel() >> 8);
 8001c14:	f340 200f 	sbfx	r0, r0, #8, #16
 8001c18:	f7fe fddc 	bl	80007d4 <__aeabi_i2f>
  sensor_data->temperature = TEMPERATURE_Value;
  sensor_data->pressure    = PRESSURE_Value;

  sensor_data->latitude  = (int32_t)((STSOP_LATTITUDE  * MAX_GPS_POS) / 90);
 8001c1c:	4a05      	ldr	r2, [pc, #20]	@ (8001c34 <EnvSensors_Read+0x2c>)
 8001c1e:	4b06      	ldr	r3, [pc, #24]	@ (8001c38 <EnvSensors_Read+0x30>)
  sensor_data->pressure    = PRESSURE_Value;
 8001c20:	4906      	ldr	r1, [pc, #24]	@ (8001c3c <EnvSensors_Read+0x34>)
  TEMPERATURE_Value = (SYS_GetTemperatureLevel() >> 8);
 8001c22:	6060      	str	r0, [r4, #4]
  sensor_data->latitude  = (int32_t)((STSOP_LATTITUDE  * MAX_GPS_POS) / 90);
 8001c24:	e9c4 2303 	strd	r2, r3, [r4, #12]
  sensor_data->pressure    = PRESSURE_Value;
 8001c28:	6021      	str	r1, [r4, #0]
  sensor_data->longitude = (int32_t)((STSOP_LONGITUDE  * MAX_GPS_POS) / 180);

  return 0;
  /* USER CODE END EnvSensors_Read */
}
 8001c2a:	2000      	movs	r0, #0
 8001c2c:	bd10      	pop	{r4, pc}
 8001c2e:	bf00      	nop
 8001c30:	42480000 	.word	0x42480000
 8001c34:	003e090d 	.word	0x003e090d
 8001c38:	000503ab 	.word	0x000503ab
 8001c3c:	447a0000 	.word	0x447a0000

08001c40 <EnvSensors_Init>:
#elif !defined (SENSOR_ENABLED)
#error SENSOR_ENABLED not defined
#endif /* SENSOR_ENABLED  */
  /* USER CODE END EnvSensors_Init */
  return ret;
}
 8001c40:	2000      	movs	r0, #0
 8001c42:	4770      	bx	lr

08001c44 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001c44:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c46:	1e16      	subs	r6, r2, #0
 8001c48:	dd07      	ble.n	8001c5a <_read+0x16>
 8001c4a:	460c      	mov	r4, r1
 8001c4c:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 8001c4e:	f3af 8000 	nop.w
 8001c52:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c56:	42a5      	cmp	r5, r4
 8001c58:	d1f9      	bne.n	8001c4e <_read+0xa>
	}

return len;
}
 8001c5a:	4630      	mov	r0, r6
 8001c5c:	bd70      	pop	{r4, r5, r6, pc}
 8001c5e:	bf00      	nop

08001c60 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8001c60:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c62:	1e16      	subs	r6, r2, #0
 8001c64:	dd07      	ble.n	8001c76 <_write+0x16>
 8001c66:	460c      	mov	r4, r1
 8001c68:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 8001c6a:	f814 0b01 	ldrb.w	r0, [r4], #1
 8001c6e:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c72:	42ac      	cmp	r4, r5
 8001c74:	d1f9      	bne.n	8001c6a <_write+0xa>
	}
	return len;
}
 8001c76:	4630      	mov	r0, r6
 8001c78:	bd70      	pop	{r4, r5, r6, pc}
 8001c7a:	bf00      	nop

08001c7c <_close>:

int _close(int file)
{
	return -1;
}
 8001c7c:	f04f 30ff 	mov.w	r0, #4294967295
 8001c80:	4770      	bx	lr
 8001c82:	bf00      	nop

08001c84 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8001c84:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8001c88:	604b      	str	r3, [r1, #4]
	return 0;
}
 8001c8a:	2000      	movs	r0, #0
 8001c8c:	4770      	bx	lr
 8001c8e:	bf00      	nop

08001c90 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8001c90:	2001      	movs	r0, #1
 8001c92:	4770      	bx	lr

08001c94 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8001c94:	2000      	movs	r0, #0
 8001c96:	4770      	bx	lr

08001c98 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001c98:	490c      	ldr	r1, [pc, #48]	@ (8001ccc <_sbrk+0x34>)
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001c9a:	4a0d      	ldr	r2, [pc, #52]	@ (8001cd0 <_sbrk+0x38>)
  if (NULL == __sbrk_heap_end)
 8001c9c:	680b      	ldr	r3, [r1, #0]
{
 8001c9e:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001ca0:	4c0c      	ldr	r4, [pc, #48]	@ (8001cd4 <_sbrk+0x3c>)
 8001ca2:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8001ca4:	b12b      	cbz	r3, 8001cb2 <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001ca6:	4418      	add	r0, r3
 8001ca8:	4290      	cmp	r0, r2
 8001caa:	d807      	bhi.n	8001cbc <_sbrk+0x24>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8001cac:	6008      	str	r0, [r1, #0]

  return (void *)prev_heap_end;
}
 8001cae:	4618      	mov	r0, r3
 8001cb0:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8001cb2:	4b09      	ldr	r3, [pc, #36]	@ (8001cd8 <_sbrk+0x40>)
 8001cb4:	600b      	str	r3, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8001cb6:	4418      	add	r0, r3
 8001cb8:	4290      	cmp	r0, r2
 8001cba:	d9f7      	bls.n	8001cac <_sbrk+0x14>
    errno = ENOMEM;
 8001cbc:	f014 fa52 	bl	8016164 <__errno>
 8001cc0:	230c      	movs	r3, #12
 8001cc2:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8001cc4:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001cc8:	4618      	mov	r0, r3
 8001cca:	bd10      	pop	{r4, pc}
 8001ccc:	20000328 	.word	0x20000328
 8001cd0:	20010000 	.word	0x20010000
 8001cd4:	00000400 	.word	0x00000400
 8001cd8:	20001d60 	.word	0x20001d60

08001cdc <SystemInit>:

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 8001cdc:	4770      	bx	lr
 8001cde:	bf00      	nop

08001ce0 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 8001ce0:	4b04      	ldr	r3, [pc, #16]	@ (8001cf4 <TIMER_IF_SetTimerContext+0x14>)
 8001ce2:	689a      	ldr	r2, [r3, #8]
 8001ce4:	6898      	ldr	r0, [r3, #8]
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  uint32_t ssr = LL_RTC_TIME_GetSubSecond(RTC);
  /* read twice to make sure value it valid*/
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001ce6:	4282      	cmp	r2, r0
 8001ce8:	d1fb      	bne.n	8001ce2 <TIMER_IF_SetTimerContext+0x2>
  RtcTimerContext = GetTimerTicks();
 8001cea:	4b03      	ldr	r3, [pc, #12]	@ (8001cf8 <TIMER_IF_SetTimerContext+0x18>)
  {
    ssr = LL_RTC_TIME_GetSubSecond(RTC);
  }
  return UINT32_MAX - ssr;
 8001cec:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 8001cee:	6018      	str	r0, [r3, #0]
}
 8001cf0:	4770      	bx	lr
 8001cf2:	bf00      	nop
 8001cf4:	40002800 	.word	0x40002800
 8001cf8:	2000032c 	.word	0x2000032c

08001cfc <TIMER_IF_GetTimerContext>:
  return RtcTimerContext;
 8001cfc:	4b01      	ldr	r3, [pc, #4]	@ (8001d04 <TIMER_IF_GetTimerContext+0x8>)
}
 8001cfe:	6818      	ldr	r0, [r3, #0]
 8001d00:	4770      	bx	lr
 8001d02:	bf00      	nop
 8001d04:	2000032c 	.word	0x2000032c

08001d08 <TIMER_IF_GetTimerElapsedTime>:
 8001d08:	4b04      	ldr	r3, [pc, #16]	@ (8001d1c <TIMER_IF_GetTimerElapsedTime+0x14>)
 8001d0a:	689a      	ldr	r2, [r3, #8]
 8001d0c:	6898      	ldr	r0, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001d0e:	4282      	cmp	r2, r0
 8001d10:	d1fb      	bne.n	8001d0a <TIMER_IF_GetTimerElapsedTime+0x2>
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 8001d12:	4b03      	ldr	r3, [pc, #12]	@ (8001d20 <TIMER_IF_GetTimerElapsedTime+0x18>)
 8001d14:	681b      	ldr	r3, [r3, #0]
  return UINT32_MAX - ssr;
 8001d16:	43c0      	mvns	r0, r0
}
 8001d18:	1ac0      	subs	r0, r0, r3
 8001d1a:	4770      	bx	lr
 8001d1c:	40002800 	.word	0x40002800
 8001d20:	2000032c 	.word	0x2000032c

08001d24 <TIMER_IF_GetMinimumTimeout>:
}
 8001d24:	2003      	movs	r0, #3
 8001d26:	4770      	bx	lr

08001d28 <TIMER_IF_Convert_ms2Tick>:
{
 8001d28:	b508      	push	{r3, lr}
 8001d2a:	4601      	mov	r1, r0
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 8001d2c:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8001d30:	2300      	movs	r3, #0
 8001d32:	0280      	lsls	r0, r0, #10
 8001d34:	0d89      	lsrs	r1, r1, #22
 8001d36:	f7fe fe17 	bl	8000968 <__aeabi_uldivmod>
}
 8001d3a:	bd08      	pop	{r3, pc}

08001d3c <TIMER_IF_Convert_Tick2ms>:
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8001d3c:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8001d40:	fba0 0303 	umull	r0, r3, r0, r3
 8001d44:	0a80      	lsrs	r0, r0, #10
}
 8001d46:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 8001d4a:	4770      	bx	lr

08001d4c <TIMER_IF_StopTimer>:
{
 8001d4c:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 8001d4e:	4b07      	ldr	r3, [pc, #28]	@ (8001d6c <TIMER_IF_StopTimer+0x20>)
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001d50:	4c07      	ldr	r4, [pc, #28]	@ (8001d70 <TIMER_IF_StopTimer+0x24>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 8001d52:	2201      	movs	r2, #1
 8001d54:	65da      	str	r2, [r3, #92]	@ 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001d56:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8001d5a:	4620      	mov	r0, r4
 8001d5c:	f005 ff38 	bl	8007bd0 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001d60:	f04f 33ff 	mov.w	r3, #4294967295
 8001d64:	6323      	str	r3, [r4, #48]	@ 0x30
}
 8001d66:	2000      	movs	r0, #0
 8001d68:	bd10      	pop	{r4, pc}
 8001d6a:	bf00      	nop
 8001d6c:	40002800 	.word	0x40002800
 8001d70:	200002e0 	.word	0x200002e0

08001d74 <TIMER_IF_BkUp_Write_Seconds>:
{
 8001d74:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 8001d76:	2100      	movs	r1, #0
 8001d78:	4801      	ldr	r0, [pc, #4]	@ (8001d80 <TIMER_IF_BkUp_Write_Seconds+0xc>)
 8001d7a:	f006 b89f 	b.w	8007ebc <HAL_RTCEx_BKUPWrite>
 8001d7e:	bf00      	nop
 8001d80:	200002e0 	.word	0x200002e0

08001d84 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 8001d84:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 8001d86:	2101      	movs	r1, #1
 8001d88:	4801      	ldr	r0, [pc, #4]	@ (8001d90 <TIMER_IF_BkUp_Write_SubSeconds+0xc>)
 8001d8a:	f006 b897 	b.w	8007ebc <HAL_RTCEx_BKUPWrite>
 8001d8e:	bf00      	nop
 8001d90:	200002e0 	.word	0x200002e0

08001d94 <TIMER_IF_StartTimer>:
{
 8001d94:	b570      	push	{r4, r5, r6, lr}
 8001d96:	b08c      	sub	sp, #48	@ 0x30
  RTC_AlarmTypeDef sAlarm = {0};
 8001d98:	222c      	movs	r2, #44	@ 0x2c
{
 8001d9a:	4604      	mov	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 8001d9c:	2100      	movs	r1, #0
 8001d9e:	4668      	mov	r0, sp
 8001da0:	f014 f992 	bl	80160c8 <memset>
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001da4:	4d13      	ldr	r5, [pc, #76]	@ (8001df4 <TIMER_IF_StartTimer+0x60>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 8001da6:	4b14      	ldr	r3, [pc, #80]	@ (8001df8 <TIMER_IF_StartTimer+0x64>)
 8001da8:	2601      	movs	r6, #1
 8001daa:	65de      	str	r6, [r3, #92]	@ 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001dac:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8001db0:	4628      	mov	r0, r5
 8001db2:	f005 ff0d 	bl	8007bd0 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001db6:	f04f 33ff 	mov.w	r3, #4294967295
 8001dba:	632b      	str	r3, [r5, #48]	@ 0x30
  timeout += RtcTimerContext;
 8001dbc:	4b0f      	ldr	r3, [pc, #60]	@ (8001dfc <TIMER_IF_StartTimer+0x68>)
 8001dbe:	681b      	ldr	r3, [r3, #0]
 8001dc0:	441c      	add	r4, r3
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 8001dc2:	43e4      	mvns	r4, r4
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8001dc4:	2300      	movs	r3, #0
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 8001dc6:	9401      	str	r4, [sp, #4]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8001dc8:	f04f 5400 	mov.w	r4, #536870912	@ 0x20000000
 8001dcc:	e9cd 3405 	strd	r3, r4, [sp, #20]
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8001dd0:	9307      	str	r3, [sp, #28]
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8001dd2:	4632      	mov	r2, r6
  sAlarm.Alarm = RTC_ALARM_A;
 8001dd4:	f44f 7380 	mov.w	r3, #256	@ 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8001dd8:	4669      	mov	r1, sp
 8001dda:	4628      	mov	r0, r5
  sAlarm.Alarm = RTC_ALARM_A;
 8001ddc:	930a      	str	r3, [sp, #40]	@ 0x28
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8001dde:	f005 fe09 	bl	80079f4 <HAL_RTC_SetAlarm_IT>
 8001de2:	b910      	cbnz	r0, 8001dea <TIMER_IF_StartTimer+0x56>
}
 8001de4:	2000      	movs	r0, #0
 8001de6:	b00c      	add	sp, #48	@ 0x30
 8001de8:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 8001dea:	f7ff fb6b 	bl	80014c4 <Error_Handler>
}
 8001dee:	2000      	movs	r0, #0
 8001df0:	b00c      	add	sp, #48	@ 0x30
 8001df2:	bd70      	pop	{r4, r5, r6, pc}
 8001df4:	200002e0 	.word	0x200002e0
 8001df8:	40002800 	.word	0x40002800
 8001dfc:	2000032c 	.word	0x2000032c

08001e00 <TIMER_IF_GetTime>:
{
 8001e00:	b538      	push	{r3, r4, r5, lr}
 8001e02:	4b0e      	ldr	r3, [pc, #56]	@ (8001e3c <TIMER_IF_GetTime+0x3c>)
 8001e04:	689a      	ldr	r2, [r3, #8]
 8001e06:	689c      	ldr	r4, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001e08:	42a2      	cmp	r2, r4
{
 8001e0a:	4605      	mov	r5, r0
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001e0c:	d003      	beq.n	8001e16 <TIMER_IF_GetTime+0x16>
 8001e0e:	689a      	ldr	r2, [r3, #8]
 8001e10:	689c      	ldr	r4, [r3, #8]
 8001e12:	42a2      	cmp	r2, r4
 8001e14:	d1fb      	bne.n	8001e0e <TIMER_IF_GetTime+0xe>
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8001e16:	2102      	movs	r1, #2
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 8001e18:	43e4      	mvns	r4, r4
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8001e1a:	4809      	ldr	r0, [pc, #36]	@ (8001e40 <TIMER_IF_GetTime+0x40>)
 8001e1c:	f006 f856 	bl	8007ecc <HAL_RTCEx_BKUPRead>
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 8001e20:	f3c4 0209 	ubfx	r2, r4, #0, #10
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8001e24:	0153      	lsls	r3, r2, #5
 8001e26:	1a9b      	subs	r3, r3, r2
 8001e28:	009b      	lsls	r3, r3, #2
 8001e2a:	189b      	adds	r3, r3, r2
 8001e2c:	f3c3 13d5 	ubfx	r3, r3, #7, #22
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 8001e30:	0aa4      	lsrs	r4, r4, #10
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 8001e32:	802b      	strh	r3, [r5, #0]
}
 8001e34:	ea44 5080 	orr.w	r0, r4, r0, lsl #22
 8001e38:	bd38      	pop	{r3, r4, r5, pc}
 8001e3a:	bf00      	nop
 8001e3c:	40002800 	.word	0x40002800
 8001e40:	200002e0 	.word	0x200002e0

08001e44 <TIMER_IF_BkUp_Read_Seconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 8001e44:	4801      	ldr	r0, [pc, #4]	@ (8001e4c <TIMER_IF_BkUp_Read_Seconds+0x8>)
 8001e46:	2100      	movs	r1, #0
 8001e48:	f006 b840 	b.w	8007ecc <HAL_RTCEx_BKUPRead>
 8001e4c:	200002e0 	.word	0x200002e0

08001e50 <TIMER_IF_BkUp_Read_SubSeconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 8001e50:	4801      	ldr	r0, [pc, #4]	@ (8001e58 <TIMER_IF_BkUp_Read_SubSeconds+0x8>)
 8001e52:	2101      	movs	r1, #1
 8001e54:	f006 b83a 	b.w	8007ecc <HAL_RTCEx_BKUPRead>
 8001e58:	200002e0 	.word	0x200002e0

08001e5c <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 8001e5c:	4b06      	ldr	r3, [pc, #24]	@ (8001e78 <TIMER_IF_GetTimerValue+0x1c>)
 8001e5e:	7818      	ldrb	r0, [r3, #0]
 8001e60:	b148      	cbz	r0, 8001e76 <TIMER_IF_GetTimerValue+0x1a>
 8001e62:	4b06      	ldr	r3, [pc, #24]	@ (8001e7c <TIMER_IF_GetTimerValue+0x20>)
 8001e64:	6898      	ldr	r0, [r3, #8]
 8001e66:	689a      	ldr	r2, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001e68:	4282      	cmp	r2, r0
 8001e6a:	d003      	beq.n	8001e74 <TIMER_IF_GetTimerValue+0x18>
 8001e6c:	689a      	ldr	r2, [r3, #8]
 8001e6e:	6898      	ldr	r0, [r3, #8]
 8001e70:	4282      	cmp	r2, r0
 8001e72:	d1fb      	bne.n	8001e6c <TIMER_IF_GetTimerValue+0x10>
  return UINT32_MAX - ssr;
 8001e74:	43c0      	mvns	r0, r0
}
 8001e76:	4770      	bx	lr
 8001e78:	20000330 	.word	0x20000330
 8001e7c:	40002800 	.word	0x40002800

08001e80 <TIMER_IF_Init>:
{
 8001e80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RTC_Initialized == false)
 8001e84:	4e1a      	ldr	r6, [pc, #104]	@ (8001ef0 <TIMER_IF_Init+0x70>)
 8001e86:	7837      	ldrb	r7, [r6, #0]
 8001e88:	b117      	cbz	r7, 8001e90 <TIMER_IF_Init+0x10>
}
 8001e8a:	2000      	movs	r0, #0
 8001e8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001e90:	4d18      	ldr	r5, [pc, #96]	@ (8001ef4 <TIMER_IF_Init+0x74>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 8001e92:	4c19      	ldr	r4, [pc, #100]	@ (8001ef8 <TIMER_IF_Init+0x78>)
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001e94:	f04f 38ff 	mov.w	r8, #4294967295
 8001e98:	f8c5 8030 	str.w	r8, [r5, #48]	@ 0x30
    MX_RTC_Init();
 8001e9c:	f7ff fca0 	bl	80017e0 <MX_RTC_Init>
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 8001ea0:	2301      	movs	r3, #1
 8001ea2:	65e3      	str	r3, [r4, #92]	@ 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001ea4:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8001ea8:	4628      	mov	r0, r5
 8001eaa:	f005 fe91 	bl	8007bd0 <HAL_RTC_DeactivateAlarm>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001eae:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8001eb2:	4628      	mov	r0, r5
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001eb4:	f8c5 8030 	str.w	r8, [r5, #48]	@ 0x30
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001eb8:	f005 fe8a 	bl	8007bd0 <HAL_RTC_DeactivateAlarm>
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 8001ebc:	4628      	mov	r0, r5
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001ebe:	f8c5 8030 	str.w	r8, [r5, #48]	@ 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 8001ec2:	f005 ff99 	bl	8007df8 <HAL_RTCEx_EnableBypassShadow>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 8001ec6:	463a      	mov	r2, r7
 8001ec8:	2102      	movs	r1, #2
 8001eca:	4628      	mov	r0, r5
 8001ecc:	f005 fff6 	bl	8007ebc <HAL_RTCEx_BKUPWrite>
 8001ed0:	68a3      	ldr	r3, [r4, #8]
 8001ed2:	68a2      	ldr	r2, [r4, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001ed4:	429a      	cmp	r2, r3
 8001ed6:	d003      	beq.n	8001ee0 <TIMER_IF_Init+0x60>
 8001ed8:	68a2      	ldr	r2, [r4, #8]
 8001eda:	68a3      	ldr	r3, [r4, #8]
 8001edc:	429a      	cmp	r2, r3
 8001ede:	d1fb      	bne.n	8001ed8 <TIMER_IF_Init+0x58>
  RtcTimerContext = GetTimerTicks();
 8001ee0:	4906      	ldr	r1, [pc, #24]	@ (8001efc <TIMER_IF_Init+0x7c>)
  return UINT32_MAX - ssr;
 8001ee2:	43db      	mvns	r3, r3
    RTC_Initialized = true;
 8001ee4:	2201      	movs	r2, #1
  RtcTimerContext = GetTimerTicks();
 8001ee6:	600b      	str	r3, [r1, #0]
    RTC_Initialized = true;
 8001ee8:	7032      	strb	r2, [r6, #0]
}
 8001eea:	2000      	movs	r0, #0
 8001eec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001ef0:	20000330 	.word	0x20000330
 8001ef4:	200002e0 	.word	0x200002e0
 8001ef8:	40002800 	.word	0x40002800
 8001efc:	2000032c 	.word	0x2000032c

08001f00 <TIMER_IF_DelayMs>:
{
 8001f00:	4601      	mov	r1, r0
 8001f02:	b508      	push	{r3, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 8001f04:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8001f08:	2300      	movs	r3, #0
 8001f0a:	0280      	lsls	r0, r0, #10
 8001f0c:	0d89      	lsrs	r1, r1, #22
 8001f0e:	f7fe fd2b 	bl	8000968 <__aeabi_uldivmod>
 8001f12:	4a0a      	ldr	r2, [pc, #40]	@ (8001f3c <TIMER_IF_DelayMs+0x3c>)
 8001f14:	6891      	ldr	r1, [r2, #8]
 8001f16:	6893      	ldr	r3, [r2, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001f18:	4299      	cmp	r1, r3
 8001f1a:	d1fb      	bne.n	8001f14 <TIMER_IF_DelayMs+0x14>
 8001f1c:	4a07      	ldr	r2, [pc, #28]	@ (8001f3c <TIMER_IF_DelayMs+0x3c>)
  return UINT32_MAX - ssr;
 8001f1e:	ea6f 0c03 	mvn.w	ip, r3
 8001f22:	6891      	ldr	r1, [r2, #8]
 8001f24:	6893      	ldr	r3, [r2, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8001f26:	4299      	cmp	r1, r3
 8001f28:	d1fb      	bne.n	8001f22 <TIMER_IF_DelayMs+0x22>
  return UINT32_MAX - ssr;
 8001f2a:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8001f2c:	eba3 030c 	sub.w	r3, r3, ip
 8001f30:	4283      	cmp	r3, r0
 8001f32:	d201      	bcs.n	8001f38 <TIMER_IF_DelayMs+0x38>
    __NOP();
 8001f34:	bf00      	nop
 8001f36:	e7f4      	b.n	8001f22 <TIMER_IF_DelayMs+0x22>
}
 8001f38:	bd08      	pop	{r3, pc}
 8001f3a:	bf00      	nop
 8001f3c:	40002800 	.word	0x40002800

08001f40 <HAL_RTC_AlarmAEventCallback>:
  UTIL_TIMER_IRQ_MAP_PROCESS();
 8001f40:	f013 bc48 	b.w	80157d4 <UTIL_TIMER_IRQ_Handler>

08001f44 <HAL_RTCEx_SSRUEventCallback>:
{
 8001f44:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8001f46:	4c06      	ldr	r4, [pc, #24]	@ (8001f60 <HAL_RTCEx_SSRUEventCallback+0x1c>)
 8001f48:	2102      	movs	r1, #2
 8001f4a:	4620      	mov	r0, r4
 8001f4c:	f005 ffbe 	bl	8007ecc <HAL_RTCEx_BKUPRead>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 8001f50:	2102      	movs	r1, #2
 8001f52:	1c42      	adds	r2, r0, #1
 8001f54:	4620      	mov	r0, r4
}
 8001f56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 8001f5a:	f005 bfaf 	b.w	8007ebc <HAL_RTCEx_BKUPWrite>
 8001f5e:	bf00      	nop
 8001f60:	200002e0 	.word	0x200002e0

08001f64 <MX_LPUART1_UART_Init>:
DMA_HandleTypeDef hdma_lpuart1_tx;

/* LPUART1 init function */

void MX_LPUART1_UART_Init(void)
{
 8001f64:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE END LPUART1_Init 0 */

  /* USER CODE BEGIN LPUART1_Init 1 */

  /* USER CODE END LPUART1_Init 1 */
  hlpuart1.Instance = LPUART1;
 8001f66:	4820      	ldr	r0, [pc, #128]	@ (8001fe8 <MX_LPUART1_UART_Init+0x84>)
 8001f68:	4c20      	ldr	r4, [pc, #128]	@ (8001fec <MX_LPUART1_UART_Init+0x88>)
  hlpuart1.Init.BaudRate = 115200;
 8001f6a:	f44f 31e1 	mov.w	r1, #115200	@ 0x1c200
  hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
 8001f6e:	2300      	movs	r3, #0
  hlpuart1.Init.BaudRate = 115200;
 8001f70:	e9c0 4100 	strd	r4, r1, [r0]
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
  hlpuart1.Init.Parity = UART_PARITY_NONE;
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
 8001f74:	220c      	movs	r2, #12
  hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001f76:	2400      	movs	r4, #0
 8001f78:	2500      	movs	r5, #0
 8001f7a:	e9c0 4508 	strd	r4, r5, [r0, #32]
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
 8001f7e:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
 8001f82:	e9c0 3204 	strd	r3, r2, [r0, #16]
 8001f86:	6183      	str	r3, [r0, #24]
  hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001f88:	6283      	str	r3, [r0, #40]	@ 0x28
  hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
 8001f8a:	6643      	str	r3, [r0, #100]	@ 0x64
  if (HAL_UART_Init(&hlpuart1) != HAL_OK)
 8001f8c:	f007 fc18 	bl	80097c0 <HAL_UART_Init>
 8001f90:	b970      	cbnz	r0, 8001fb0 <MX_LPUART1_UART_Init+0x4c>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001f92:	4815      	ldr	r0, [pc, #84]	@ (8001fe8 <MX_LPUART1_UART_Init+0x84>)
 8001f94:	2100      	movs	r1, #0
 8001f96:	f007 fd01 	bl	800999c <HAL_UARTEx_SetTxFifoThreshold>
 8001f9a:	b988      	cbnz	r0, 8001fc0 <MX_LPUART1_UART_Init+0x5c>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001f9c:	4812      	ldr	r0, [pc, #72]	@ (8001fe8 <MX_LPUART1_UART_Init+0x84>)
 8001f9e:	2100      	movs	r1, #0
 8001fa0:	f007 fd3e 	bl	8009a20 <HAL_UARTEx_SetRxFifoThreshold>
 8001fa4:	b9a0      	cbnz	r0, 8001fd0 <MX_LPUART1_UART_Init+0x6c>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
 8001fa6:	4810      	ldr	r0, [pc, #64]	@ (8001fe8 <MX_LPUART1_UART_Init+0x84>)
 8001fa8:	f007 fcda 	bl	8009960 <HAL_UARTEx_DisableFifoMode>
 8001fac:	b9b8      	cbnz	r0, 8001fde <MX_LPUART1_UART_Init+0x7a>
  }
  /* USER CODE BEGIN LPUART1_Init 2 */

  /* USER CODE END LPUART1_Init 2 */

}
 8001fae:	bd38      	pop	{r3, r4, r5, pc}
    Error_Handler();
 8001fb0:	f7ff fa88 	bl	80014c4 <Error_Handler>
  if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001fb4:	480c      	ldr	r0, [pc, #48]	@ (8001fe8 <MX_LPUART1_UART_Init+0x84>)
 8001fb6:	2100      	movs	r1, #0
 8001fb8:	f007 fcf0 	bl	800999c <HAL_UARTEx_SetTxFifoThreshold>
 8001fbc:	2800      	cmp	r0, #0
 8001fbe:	d0ed      	beq.n	8001f9c <MX_LPUART1_UART_Init+0x38>
    Error_Handler();
 8001fc0:	f7ff fa80 	bl	80014c4 <Error_Handler>
  if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001fc4:	4808      	ldr	r0, [pc, #32]	@ (8001fe8 <MX_LPUART1_UART_Init+0x84>)
 8001fc6:	2100      	movs	r1, #0
 8001fc8:	f007 fd2a 	bl	8009a20 <HAL_UARTEx_SetRxFifoThreshold>
 8001fcc:	2800      	cmp	r0, #0
 8001fce:	d0ea      	beq.n	8001fa6 <MX_LPUART1_UART_Init+0x42>
    Error_Handler();
 8001fd0:	f7ff fa78 	bl	80014c4 <Error_Handler>
  if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
 8001fd4:	4804      	ldr	r0, [pc, #16]	@ (8001fe8 <MX_LPUART1_UART_Init+0x84>)
 8001fd6:	f007 fcc3 	bl	8009960 <HAL_UARTEx_DisableFifoMode>
 8001fda:	2800      	cmp	r0, #0
 8001fdc:	d0e7      	beq.n	8001fae <MX_LPUART1_UART_Init+0x4a>
}
 8001fde:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 8001fe2:	f7ff ba6f 	b.w	80014c4 <Error_Handler>
 8001fe6:	bf00      	nop
 8001fe8:	20000398 	.word	0x20000398
 8001fec:	40008000 	.word	0x40008000

08001ff0 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001ff0:	b530      	push	{r4, r5, lr}
 8001ff2:	4604      	mov	r4, r0
 8001ff4:	b097      	sub	sp, #92	@ 0x5c

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001ff6:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001ff8:	2238      	movs	r2, #56	@ 0x38
 8001ffa:	a808      	add	r0, sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001ffc:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8002000:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8002004:	9106      	str	r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8002006:	f014 f85f 	bl	80160c8 <memset>
  if(uartHandle->Instance==LPUART1)
 800200a:	4b2b      	ldr	r3, [pc, #172]	@ (80020b8 <HAL_UART_MspInit+0xc8>)
 800200c:	6822      	ldr	r2, [r4, #0]
 800200e:	429a      	cmp	r2, r3
 8002010:	d001      	beq.n	8002016 <HAL_UART_MspInit+0x26>
    HAL_NVIC_EnableIRQ(LPUART1_IRQn);
  /* USER CODE BEGIN LPUART1_MspInit 1 */

  /* USER CODE END LPUART1_MspInit 1 */
  }
}
 8002012:	b017      	add	sp, #92	@ 0x5c
 8002014:	bd30      	pop	{r4, r5, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
 8002016:	2320      	movs	r3, #32
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002018:	eb0d 0003 	add.w	r0, sp, r3
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
 800201c:	9308      	str	r3, [sp, #32]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800201e:	f005 fbd1 	bl	80077c4 <HAL_RCCEx_PeriphCLKConfig>
 8002022:	2800      	cmp	r0, #0
 8002024:	d141      	bne.n	80020aa <HAL_UART_MspInit+0xba>
  SET_BIT(RCC->APB1ENR2, Periphs);
 8002026:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800202a:	a902      	add	r1, sp, #8
 800202c:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
    hdma_lpuart1_tx.Instance = DMA1_Channel1;
 800202e:	4d23      	ldr	r5, [pc, #140]	@ (80020bc <HAL_UART_MspInit+0xcc>)
 8002030:	f042 0201 	orr.w	r2, r2, #1
 8002034:	65da      	str	r2, [r3, #92]	@ 0x5c
  tmpreg = READ_BIT(RCC->APB1ENR2, Periphs);
 8002036:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8002038:	f002 0201 	and.w	r2, r2, #1
 800203c:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 800203e:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8002040:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8002042:	f042 0201 	orr.w	r2, r2, #1
 8002046:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8002048:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800204a:	f003 0301 	and.w	r3, r3, #1
 800204e:	9300      	str	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8002050:	220c      	movs	r2, #12
 8002052:	2302      	movs	r3, #2
 8002054:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8002058:	2200      	movs	r2, #0
  (void)tmpreg;
 800205a:	9b00      	ldr	r3, [sp, #0]
 800205c:	2300      	movs	r3, #0
 800205e:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002062:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
 8002066:	2308      	movs	r3, #8
 8002068:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800206a:	f003 feeb 	bl	8005e44 <HAL_GPIO_Init>
    hdma_lpuart1_tx.Init.Request = DMA_REQUEST_LPUART1_TX;
 800206e:	4914      	ldr	r1, [pc, #80]	@ (80020c0 <HAL_UART_MspInit+0xd0>)
 8002070:	2216      	movs	r2, #22
 8002072:	2300      	movs	r3, #0
 8002074:	e9c5 1200 	strd	r1, r2, [r5]
    if (HAL_DMA_Init(&hdma_lpuart1_tx) != HAL_OK)
 8002078:	4628      	mov	r0, r5
    hdma_lpuart1_tx.Init.Request = DMA_REQUEST_LPUART1_TX;
 800207a:	2110      	movs	r1, #16
 800207c:	2280      	movs	r2, #128	@ 0x80
 800207e:	e9c5 1302 	strd	r1, r3, [r5, #8]
 8002082:	e9c5 3305 	strd	r3, r3, [r5, #20]
 8002086:	e9c5 3307 	strd	r3, r3, [r5, #28]
 800208a:	612a      	str	r2, [r5, #16]
    if (HAL_DMA_Init(&hdma_lpuart1_tx) != HAL_OK)
 800208c:	f003 fb48 	bl	8005720 <HAL_DMA_Init>
 8002090:	b970      	cbnz	r0, 80020b0 <HAL_UART_MspInit+0xc0>
    HAL_NVIC_SetPriority(LPUART1_IRQn, 0, 0);
 8002092:	2200      	movs	r2, #0
 8002094:	4611      	mov	r1, r2
 8002096:	2026      	movs	r0, #38	@ 0x26
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_lpuart1_tx);
 8002098:	67e5      	str	r5, [r4, #124]	@ 0x7c
 800209a:	62ac      	str	r4, [r5, #40]	@ 0x28
    HAL_NVIC_SetPriority(LPUART1_IRQn, 0, 0);
 800209c:	f003 fae4 	bl	8005668 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LPUART1_IRQn);
 80020a0:	2026      	movs	r0, #38	@ 0x26
 80020a2:	f003 fb1d 	bl	80056e0 <HAL_NVIC_EnableIRQ>
}
 80020a6:	b017      	add	sp, #92	@ 0x5c
 80020a8:	bd30      	pop	{r4, r5, pc}
      Error_Handler();
 80020aa:	f7ff fa0b 	bl	80014c4 <Error_Handler>
 80020ae:	e7ba      	b.n	8002026 <HAL_UART_MspInit+0x36>
      Error_Handler();
 80020b0:	f7ff fa08 	bl	80014c4 <Error_Handler>
 80020b4:	e7ed      	b.n	8002092 <HAL_UART_MspInit+0xa2>
 80020b6:	bf00      	nop
 80020b8:	40008000 	.word	0x40008000
 80020bc:	20000338 	.word	0x20000338
 80020c0:	40020008 	.word	0x40020008

080020c4 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==LPUART1)
 80020c4:	4b0c      	ldr	r3, [pc, #48]	@ (80020f8 <HAL_UART_MspDeInit+0x34>)
 80020c6:	6802      	ldr	r2, [r0, #0]
 80020c8:	429a      	cmp	r2, r3
 80020ca:	d000      	beq.n	80020ce <HAL_UART_MspDeInit+0xa>
 80020cc:	4770      	bx	lr
  CLEAR_BIT(RCC->APB1ENR2, Periphs);
 80020ce:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
{
 80020d2:	b510      	push	{r4, lr}
 80020d4:	6dd3      	ldr	r3, [r2, #92]	@ 0x5c
 80020d6:	4604      	mov	r4, r0
 80020d8:	f023 0301 	bic.w	r3, r3, #1

    /**LPUART1 GPIO Configuration
    PA2     ------> LPUART1_TX
    PA3     ------> LPUART1_RX
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_3);
 80020dc:	210c      	movs	r1, #12
 80020de:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80020e2:	65d3      	str	r3, [r2, #92]	@ 0x5c
 80020e4:	f003 ff92 	bl	800600c <HAL_GPIO_DeInit>

    /* LPUART1 DMA DeInit */
    HAL_DMA_DeInit(uartHandle->hdmatx);
 80020e8:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 80020ea:	f003 fbb1 	bl	8005850 <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(LPUART1_IRQn);
  /* USER CODE BEGIN LPUART1_MspDeInit 1 */

  /* USER CODE END LPUART1_MspDeInit 1 */
  }
}
 80020ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(LPUART1_IRQn);
 80020f2:	2026      	movs	r0, #38	@ 0x26
 80020f4:	f003 bb02 	b.w	80056fc <HAL_NVIC_DisableIRQ>
 80020f8:	40008000 	.word	0x40008000

080020fc <vcom_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

UTIL_ADV_TRACE_Status_t vcom_Init(void (*cb)(void *))
{
 80020fc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Init_1 */

  /* USER CODE END vcom_Init_1 */
  TxCpltCallback = cb;
 80020fe:	4b07      	ldr	r3, [pc, #28]	@ (800211c <vcom_Init+0x20>)
 8002100:	6018      	str	r0, [r3, #0]
  MX_DMA_Init();
 8002102:	f7fe fec7 	bl	8000e94 <MX_DMA_Init>
  MX_LPUART1_UART_Init();
 8002106:	f7ff ff2d 	bl	8001f64 <MX_LPUART1_UART_Init>
  SET_BIT(EXTI->IMR1, ExtiLine);
 800210a:	4a05      	ldr	r2, [pc, #20]	@ (8002120 <vcom_Init+0x24>)
 800210c:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
 8002110:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
  LL_EXTI_EnableIT_0_31(LL_EXTI_LINE_28);
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Init_2 */

  /* USER CODE END vcom_Init_2 */
}
 8002114:	2000      	movs	r0, #0
 8002116:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 800211a:	bd08      	pop	{r3, pc}
 800211c:	20000430 	.word	0x20000430
 8002120:	58000800 	.word	0x58000800

08002124 <vcom_DeInit>:

UTIL_ADV_TRACE_Status_t vcom_DeInit(void)
{
 8002124:	b508      	push	{r3, lr}
  SET_BIT(RCC->APB1RSTR2, Periphs);
 8002126:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
  /* ##-1- Reset peripherals ################################################## */
  __HAL_RCC_LPUART1_FORCE_RESET();
  __HAL_RCC_LPUART1_RELEASE_RESET();

  /* ##-2- MspDeInit ################################################## */
  HAL_UART_MspDeInit(&hlpuart1);
 800212a:	4808      	ldr	r0, [pc, #32]	@ (800214c <vcom_DeInit+0x28>)
 800212c:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800212e:	f042 0201 	orr.w	r2, r2, #1
 8002132:	63da      	str	r2, [r3, #60]	@ 0x3c
  CLEAR_BIT(RCC->APB1RSTR2, Periphs);
 8002134:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8002136:	f022 0201 	bic.w	r2, r2, #1
 800213a:	63da      	str	r2, [r3, #60]	@ 0x3c
 800213c:	f7ff ffc2 	bl	80020c4 <HAL_UART_MspDeInit>

  /* ##-3- Disable the NVIC for DMA ########################################### */
  /* USER CODE BEGIN 1 */
  HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 8002140:	200f      	movs	r0, #15
 8002142:	f003 fadb 	bl	80056fc <HAL_NVIC_DisableIRQ>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE END 1 */
  /* USER CODE BEGIN vcom_DeInit_2 */

  /* USER CODE END vcom_DeInit_2 */
}
 8002146:	2000      	movs	r0, #0
 8002148:	bd08      	pop	{r3, pc}
 800214a:	bf00      	nop
 800214c:	20000398 	.word	0x20000398

08002150 <vcom_Trace_DMA>:

  /* USER CODE END vcom_Trace_2 */
}

UTIL_ADV_TRACE_Status_t vcom_Trace_DMA(uint8_t *p_data, uint16_t size)
{
 8002150:	b508      	push	{r3, lr}
 8002152:	4603      	mov	r3, r0
 8002154:	460a      	mov	r2, r1
  /* USER CODE BEGIN vcom_Trace_DMA_1 */

  /* USER CODE END vcom_Trace_DMA_1 */
  HAL_UART_Transmit_DMA(&hlpuart1, p_data, size);
 8002156:	4803      	ldr	r0, [pc, #12]	@ (8002164 <vcom_Trace_DMA+0x14>)
 8002158:	4619      	mov	r1, r3
 800215a:	f006 fc17 	bl	800898c <HAL_UART_Transmit_DMA>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Trace_DMA_2 */

  /* USER CODE END vcom_Trace_DMA_2 */
}
 800215e:	2000      	movs	r0, #0
 8002160:	bd08      	pop	{r3, pc}
 8002162:	bf00      	nop
 8002164:	20000398 	.word	0x20000398

08002168 <vcom_ReceiveInit>:

UTIL_ADV_TRACE_Status_t vcom_ReceiveInit(void (*RxCb)(uint8_t *rxChar, uint16_t size, uint8_t error))
{
 8002168:	b510      	push	{r4, lr}
 800216a:	b082      	sub	sp, #8

  /*record call back*/
  RxCpltCallback = RxCb;

  /*Set wakeUp event on start bit*/
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;
 800216c:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002170:	9300      	str	r3, [sp, #0]

  HAL_UARTEx_StopModeWakeUpSourceConfig(&hlpuart1, WakeUpSelection);
 8002172:	4c0f      	ldr	r4, [pc, #60]	@ (80021b0 <vcom_ReceiveInit+0x48>)
  RxCpltCallback = RxCb;
 8002174:	4b0f      	ldr	r3, [pc, #60]	@ (80021b4 <vcom_ReceiveInit+0x4c>)
  HAL_UARTEx_StopModeWakeUpSourceConfig(&hlpuart1, WakeUpSelection);
 8002176:	aa02      	add	r2, sp, #8
  RxCpltCallback = RxCb;
 8002178:	6018      	str	r0, [r3, #0]
  HAL_UARTEx_StopModeWakeUpSourceConfig(&hlpuart1, WakeUpSelection);
 800217a:	e912 0006 	ldmdb	r2, {r1, r2}
 800217e:	4620      	mov	r0, r4
 8002180:	f007 fb90 	bl	80098a4 <HAL_UARTEx_StopModeWakeUpSourceConfig>

  /* Make sure that no UART transfer is on-going */
  while (__HAL_UART_GET_FLAG(&hlpuart1, USART_ISR_BUSY) == SET);
 8002184:	6823      	ldr	r3, [r4, #0]
 8002186:	69da      	ldr	r2, [r3, #28]
 8002188:	03d1      	lsls	r1, r2, #15
 800218a:	d4fc      	bmi.n	8002186 <vcom_ReceiveInit+0x1e>

  /* Make sure that UART is ready to receive)   */
  while (__HAL_UART_GET_FLAG(&hlpuart1, USART_ISR_REACK) == RESET);
 800218c:	69da      	ldr	r2, [r3, #28]
 800218e:	0252      	lsls	r2, r2, #9
 8002190:	d5fc      	bpl.n	800218c <vcom_ReceiveInit+0x24>

  /* Enable USART interrupt */
  __HAL_UART_ENABLE_IT(&hlpuart1, UART_IT_WUF);
 8002192:	689a      	ldr	r2, [r3, #8]

  /*Enable wakeup from stop mode*/
  HAL_UARTEx_EnableStopMode(&hlpuart1);
 8002194:	4806      	ldr	r0, [pc, #24]	@ (80021b0 <vcom_ReceiveInit+0x48>)
  __HAL_UART_ENABLE_IT(&hlpuart1, UART_IT_WUF);
 8002196:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 800219a:	609a      	str	r2, [r3, #8]
  HAL_UARTEx_EnableStopMode(&hlpuart1);
 800219c:	f007 fbca 	bl	8009934 <HAL_UARTEx_EnableStopMode>

  /*Start LPUART receive on IT*/
  HAL_UART_Receive_IT(&hlpuart1, &charRx, 1);
 80021a0:	4905      	ldr	r1, [pc, #20]	@ (80021b8 <vcom_ReceiveInit+0x50>)
 80021a2:	4803      	ldr	r0, [pc, #12]	@ (80021b0 <vcom_ReceiveInit+0x48>)
 80021a4:	2201      	movs	r2, #1
 80021a6:	f006 fb37 	bl	8008818 <HAL_UART_Receive_IT>

  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_ReceiveInit_2 */

  /* USER CODE END vcom_ReceiveInit_2 */
}
 80021aa:	2000      	movs	r0, #0
 80021ac:	b002      	add	sp, #8
 80021ae:	bd10      	pop	{r4, pc}
 80021b0:	20000398 	.word	0x20000398
 80021b4:	2000042c 	.word	0x2000042c
 80021b8:	20000434 	.word	0x20000434

080021bc <vcom_Resume>:

void vcom_Resume(void)
{
 80021bc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Resume_1 */

  /* USER CODE END vcom_Resume_1 */
  /*to re-enable lost DMA settings*/
  if (HAL_DMA_Init(&hdma_lpuart1_tx) != HAL_OK)
 80021be:	4804      	ldr	r0, [pc, #16]	@ (80021d0 <vcom_Resume+0x14>)
 80021c0:	f003 faae 	bl	8005720 <HAL_DMA_Init>
 80021c4:	b900      	cbnz	r0, 80021c8 <vcom_Resume+0xc>
    Error_Handler();
  }
  /* USER CODE BEGIN vcom_Resume_2 */

  /* USER CODE END vcom_Resume_2 */
}
 80021c6:	bd08      	pop	{r3, pc}
 80021c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 80021cc:	f7ff b97a 	b.w	80014c4 <Error_Handler>
 80021d0:	20000338 	.word	0x20000338

080021d4 <HAL_UART_TxCpltCallback>:
{
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_1 */

  /* USER CODE END HAL_UART_TxCpltCallback_1 */
  /* buffer transmission complete*/
  if (huart->Instance == LPUART1)
 80021d4:	4b04      	ldr	r3, [pc, #16]	@ (80021e8 <HAL_UART_TxCpltCallback+0x14>)
 80021d6:	6802      	ldr	r2, [r0, #0]
 80021d8:	429a      	cmp	r2, r3
 80021da:	d000      	beq.n	80021de <HAL_UART_TxCpltCallback+0xa>
    TxCpltCallback(NULL);
  }
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_2 */

  /* USER CODE END HAL_UART_TxCpltCallback_2 */
}
 80021dc:	4770      	bx	lr
    TxCpltCallback(NULL);
 80021de:	4b03      	ldr	r3, [pc, #12]	@ (80021ec <HAL_UART_TxCpltCallback+0x18>)
 80021e0:	2000      	movs	r0, #0
 80021e2:	681b      	ldr	r3, [r3, #0]
 80021e4:	4718      	bx	r3
 80021e6:	bf00      	nop
 80021e8:	40008000 	.word	0x40008000
 80021ec:	20000430 	.word	0x20000430

080021f0 <HAL_UART_RxCpltCallback>:
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_1 */

  /* USER CODE END HAL_UART_RxCpltCallback_1 */
  if (huart->Instance == LPUART1)
 80021f0:	4b0b      	ldr	r3, [pc, #44]	@ (8002220 <HAL_UART_RxCpltCallback+0x30>)
 80021f2:	6802      	ldr	r2, [r0, #0]
 80021f4:	429a      	cmp	r2, r3
 80021f6:	d000      	beq.n	80021fa <HAL_UART_RxCpltCallback+0xa>
 80021f8:	4770      	bx	lr
  {
    if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart->ErrorCode))
 80021fa:	4b0a      	ldr	r3, [pc, #40]	@ (8002224 <HAL_UART_RxCpltCallback+0x34>)
 80021fc:	681b      	ldr	r3, [r3, #0]
{
 80021fe:	b510      	push	{r4, lr}
 8002200:	4604      	mov	r4, r0
    if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart->ErrorCode))
 8002202:	b12b      	cbz	r3, 8002210 <HAL_UART_RxCpltCallback+0x20>
 8002204:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
 8002208:	b912      	cbnz	r2, 8002210 <HAL_UART_RxCpltCallback+0x20>
    {
      RxCpltCallback(&charRx, 1, 0);
 800220a:	4807      	ldr	r0, [pc, #28]	@ (8002228 <HAL_UART_RxCpltCallback+0x38>)
 800220c:	2101      	movs	r1, #1
 800220e:	4798      	blx	r3
    }
    HAL_UART_Receive_IT(huart, &charRx, 1);
 8002210:	4620      	mov	r0, r4
 8002212:	4905      	ldr	r1, [pc, #20]	@ (8002228 <HAL_UART_RxCpltCallback+0x38>)
  }
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_2 */

  /* USER CODE END HAL_UART_RxCpltCallback_2 */
}
 8002214:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_UART_Receive_IT(huart, &charRx, 1);
 8002218:	2201      	movs	r2, #1
 800221a:	f006 bafd 	b.w	8008818 <HAL_UART_Receive_IT>
 800221e:	bf00      	nop
 8002220:	40008000 	.word	0x40008000
 8002224:	2000042c 	.word	0x2000042c
 8002228:	20000434 	.word	0x20000434

0800222c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800222c:	480d      	ldr	r0, [pc, #52]	@ (8002264 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800222e:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 8002230:	f7ff fd54 	bl	8001cdc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8002234:	480c      	ldr	r0, [pc, #48]	@ (8002268 <LoopForever+0x6>)
  ldr r1, =_edata
 8002236:	490d      	ldr	r1, [pc, #52]	@ (800226c <LoopForever+0xa>)
  ldr r2, =_sidata
 8002238:	4a0d      	ldr	r2, [pc, #52]	@ (8002270 <LoopForever+0xe>)
  movs r3, #0
 800223a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800223c:	e002      	b.n	8002244 <LoopCopyDataInit>

0800223e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800223e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8002240:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8002242:	3304      	adds	r3, #4

08002244 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8002244:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8002246:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8002248:	d3f9      	bcc.n	800223e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800224a:	4a0a      	ldr	r2, [pc, #40]	@ (8002274 <LoopForever+0x12>)
  ldr r4, =_ebss
 800224c:	4c0a      	ldr	r4, [pc, #40]	@ (8002278 <LoopForever+0x16>)
  movs r3, #0
 800224e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8002250:	e001      	b.n	8002256 <LoopFillZerobss>

08002252 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8002252:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8002254:	3204      	adds	r2, #4

08002256 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8002256:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8002258:	d3fb      	bcc.n	8002252 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800225a:	f013 ff89 	bl	8016170 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800225e:	f7ff f8fb 	bl	8001458 <main>

08002262 <LoopForever>:

LoopForever:
    b LoopForever
 8002262:	e7fe      	b.n	8002262 <LoopForever>
  ldr   r0, =_estack
 8002264:	20010000 	.word	0x20010000
  ldr r0, =_sdata
 8002268:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800226c:	20000178 	.word	0x20000178
  ldr r2, =_sidata
 8002270:	080178e4 	.word	0x080178e4
  ldr r2, =_sbss
 8002274:	20000178 	.word	0x20000178
  ldr r4, =_ebss
 8002278:	20001d5c 	.word	0x20001d5c

0800227c <AES_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800227c:	e7fe      	b.n	800227c <AES_IRQHandler>
	...

08002280 <calc_pressure>:
     * i.e Comparing value, pres_ovf_check = (1 << 31) >> 1
     */
    const int32_t pres_ovf_check = INT32_C(0x40000000);

    /*lint -save -e701 -e702 -e713 */
    var1 = (((int32_t)dev->calib.t_fine) >> 1) - 64000;
 8002280:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
{
 8002282:	b510      	push	{r4, lr}
    var1 = (((int32_t)dev->calib.t_fine) >> 1) - 64000;
 8002284:	ea4f 0c63 	mov.w	ip, r3, asr #1
 8002288:	f5ac 4c7a 	sub.w	ip, ip, #64000	@ 0xfa00
    var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)dev->calib.par_p6) >> 2;
 800228c:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8002290:	fb03 f303 	mul.w	r3, r3, r3
    var2 = (var2 >> 2) + ((int32_t)dev->calib.par_p4 << 16);
    var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)dev->calib.par_p3 << 5)) >> 3) +
           (((int32_t)dev->calib.par_p2 * var1) >> 1);
    var1 = var1 >> 18;
    var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
    pressure_comp = 1048576 - pres_adc;
 8002294:	f5c0 1280 	rsb	r2, r0, #1048576	@ 0x100000
    var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)dev->calib.par_p6) >> 2;
 8002298:	ea4f 2ee3 	mov.w	lr, r3, asr #11
    var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)dev->calib.par_p3 << 5)) >> 3) +
 800229c:	1358      	asrs	r0, r3, #13
 800229e:	f991 3028 	ldrsb.w	r3, [r1, #40]	@ 0x28
    var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)dev->calib.par_p6) >> 2;
 80022a2:	f991 402e 	ldrsb.w	r4, [r1, #46]	@ 0x2e
    var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)dev->calib.par_p3 << 5)) >> 3) +
 80022a6:	015b      	lsls	r3, r3, #5
 80022a8:	fb00 f303 	mul.w	r3, r0, r3
    var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
 80022ac:	f9b1 002c 	ldrsh.w	r0, [r1, #44]	@ 0x2c
 80022b0:	fb0c f000 	mul.w	r0, ip, r0
    var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)dev->calib.par_p6) >> 2;
 80022b4:	fb04 fe0e 	mul.w	lr, r4, lr
    var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
 80022b8:	0040      	lsls	r0, r0, #1
 80022ba:	eb00 00ae 	add.w	r0, r0, lr, asr #2
           (((int32_t)dev->calib.par_p2 * var1) >> 1);
 80022be:	f9b1 e026 	ldrsh.w	lr, [r1, #38]	@ 0x26
    var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)dev->calib.par_p3 << 5)) >> 3) +
 80022c2:	10db      	asrs	r3, r3, #3
           (((int32_t)dev->calib.par_p2 * var1) >> 1);
 80022c4:	fb0c fc0e 	mul.w	ip, ip, lr
    var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)dev->calib.par_p3 << 5)) >> 3) +
 80022c8:	eb03 036c 	add.w	r3, r3, ip, asr #1
    var1 = var1 >> 18;
 80022cc:	149b      	asrs	r3, r3, #18
    var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
 80022ce:	f8b1 c024 	ldrh.w	ip, [r1, #36]	@ 0x24
    {
        pressure_comp = ((pressure_comp << 1) / var1);
    }

    var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) * (pressure_comp >> 3)) >> 13)) >> 12;
    var2 = ((int32_t)(pressure_comp >> 2) * (int32_t)dev->calib.par_p8) >> 13;
 80022d2:	f9b1 e030 	ldrsh.w	lr, [r1, #48]	@ 0x30
    var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
 80022d6:	f503 4300 	add.w	r3, r3, #32768	@ 0x8000
 80022da:	fb0c f303 	mul.w	r3, ip, r3
    var2 = (var2 >> 2) + ((int32_t)dev->calib.par_p4 << 16);
 80022de:	f9b1 c02a 	ldrsh.w	ip, [r1, #42]	@ 0x2a
 80022e2:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80022e6:	eb0c 00a0 	add.w	r0, ip, r0, asr #2
    pressure_comp = (int32_t)((pressure_comp - (var2 >> 12)) * ((uint32_t)3125));
 80022ea:	eba2 3220 	sub.w	r2, r2, r0, asr #12
 80022ee:	f640 4035 	movw	r0, #3125	@ 0xc35
 80022f2:	fb00 f202 	mul.w	r2, r0, r2
    var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
 80022f6:	13db      	asrs	r3, r3, #15
    if (pressure_comp >= pres_ovf_check)
 80022f8:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
        pressure_comp = ((pressure_comp / var1) << 1);
 80022fc:	bfa7      	ittee	ge
 80022fe:	fb92 f3f3 	sdivge	r3, r2, r3
 8002302:	005b      	lslge	r3, r3, #1
        pressure_comp = ((pressure_comp << 1) / var1);
 8002304:	0052      	lsllt	r2, r2, #1
 8002306:	fb92 f3f3 	sdivlt	r3, r2, r3
    var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) * (pressure_comp >> 3)) >> 13)) >> 12;
 800230a:	10da      	asrs	r2, r3, #3
 800230c:	f9b1 0032 	ldrsh.w	r0, [r1, #50]	@ 0x32
 8002310:	fb02 f202 	mul.w	r2, r2, r2
 8002314:	1352      	asrs	r2, r2, #13
 8002316:	fb00 f202 	mul.w	r2, r0, r2
    var2 = ((int32_t)(pressure_comp >> 2) * (int32_t)dev->calib.par_p8) >> 13;
 800231a:	1098      	asrs	r0, r3, #2
 800231c:	fb0e f000 	mul.w	r0, lr, r0
    var3 =
        ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) *
 8002320:	ea4f 2c23 	mov.w	ip, r3, asr #8
    var2 = ((int32_t)(pressure_comp >> 2) * (int32_t)dev->calib.par_p8) >> 13;
 8002324:	1340      	asrs	r0, r0, #13
         (int32_t)dev->calib.par_p10) >> 17;
    pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 + ((int32_t)dev->calib.par_p7 << 7)) >> 4);
 8002326:	eb00 3022 	add.w	r0, r0, r2, asr #12
        ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) *
 800232a:	fb0c f20c 	mul.w	r2, ip, ip
 800232e:	fb0c f202 	mul.w	r2, ip, r2
         (int32_t)dev->calib.par_p10) >> 17;
 8002332:	f891 c034 	ldrb.w	ip, [r1, #52]	@ 0x34
    pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 + ((int32_t)dev->calib.par_p7 << 7)) >> 4);
 8002336:	f991 102f 	ldrsb.w	r1, [r1, #47]	@ 0x2f
        ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) *
 800233a:	fb0c f202 	mul.w	r2, ip, r2
    pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 + ((int32_t)dev->calib.par_p7 << 7)) >> 4);
 800233e:	eb00 4062 	add.w	r0, r0, r2, asr #17
 8002342:	eb00 10c1 	add.w	r0, r0, r1, lsl #7

    /*lint -restore */
    return (uint32_t)pressure_comp;
}
 8002346:	eb03 1020 	add.w	r0, r3, r0, asr #4
 800234a:	bd10      	pop	{r4, pc}

0800234c <calc_humidity>:

/* This internal API is used to calculate the humidity in integer */
static uint32_t calc_humidity(uint16_t hum_adc, const struct bme68x_dev *dev)
{
 800234c:	b570      	push	{r4, r5, r6, lr}
    int32_t var6;
    int32_t temp_scaled;
    int32_t calc_hum;

    /*lint -save -e702 -e704 */
    temp_scaled = (((int32_t)dev->calib.t_fine * 5) + 128) >> 8;
 800234e:	6b8a      	ldr	r2, [r1, #56]	@ 0x38
    var1 = (int32_t)(hum_adc - ((int32_t)((int32_t)dev->calib.par_h1 * 16))) -
           (((temp_scaled * (int32_t)dev->calib.par_h3) / ((int32_t)100)) >> 1);
    var2 =
        ((int32_t)dev->calib.par_h2 *
         (((temp_scaled * (int32_t)dev->calib.par_h4) / ((int32_t)100)) +
          (((temp_scaled * ((temp_scaled * (int32_t)dev->calib.par_h5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
 8002350:	f991 3016 	ldrsb.w	r3, [r1, #22]
 8002354:	4c2d      	ldr	r4, [pc, #180]	@ (800240c <calc_humidity+0xc0>)
         (((temp_scaled * (int32_t)dev->calib.par_h4) / ((int32_t)100)) +
 8002356:	f991 e015 	ldrsb.w	lr, [r1, #21]
    temp_scaled = (((int32_t)dev->calib.t_fine * 5) + 128) >> 8;
 800235a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800235e:	3280      	adds	r2, #128	@ 0x80
 8002360:	1212      	asrs	r2, r2, #8
          (((temp_scaled * ((temp_scaled * (int32_t)dev->calib.par_h5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
 8002362:	fb02 f303 	mul.w	r3, r2, r3
 8002366:	fb84 6503 	smull	r6, r5, r4, r3
 800236a:	17db      	asrs	r3, r3, #31
 800236c:	ebc3 1365 	rsb	r3, r3, r5, asr #5
 8002370:	fb02 f303 	mul.w	r3, r2, r3
         (((temp_scaled * (int32_t)dev->calib.par_h4) / ((int32_t)100)) +
 8002374:	fb02 fe0e 	mul.w	lr, r2, lr
          (((temp_scaled * ((temp_scaled * (int32_t)dev->calib.par_h5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
 8002378:	ea4f 1ca3 	mov.w	ip, r3, asr #6
 800237c:	fb84 5c0c 	smull	r5, ip, r4, ip
 8002380:	17db      	asrs	r3, r3, #31
         (((temp_scaled * (int32_t)dev->calib.par_h4) / ((int32_t)100)) +
 8002382:	fb84 650e 	smull	r6, r5, r4, lr
 8002386:	ea4f 7eee 	mov.w	lr, lr, asr #31
 800238a:	ebce 1e65 	rsb	lr, lr, r5, asr #5
          (((temp_scaled * ((temp_scaled * (int32_t)dev->calib.par_h5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
 800238e:	ebc3 136c 	rsb	r3, r3, ip, asr #5
         (((temp_scaled * (int32_t)dev->calib.par_h4) / ((int32_t)100)) +
 8002392:	4473      	add	r3, lr
        ((int32_t)dev->calib.par_h2 *
 8002394:	f8b1 e012 	ldrh.w	lr, [r1, #18]
           (((temp_scaled * (int32_t)dev->calib.par_h3) / ((int32_t)100)) >> 1);
 8002398:	f991 c014 	ldrsb.w	ip, [r1, #20]
          (((temp_scaled * ((temp_scaled * (int32_t)dev->calib.par_h5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
 800239c:	f503 4380 	add.w	r3, r3, #16384	@ 0x4000
        ((int32_t)dev->calib.par_h2 *
 80023a0:	fb0e f303 	mul.w	r3, lr, r3
    var1 = (int32_t)(hum_adc - ((int32_t)((int32_t)dev->calib.par_h1 * 16))) -
 80023a4:	f8b1 e010 	ldrh.w	lr, [r1, #16]
 80023a8:	eba0 100e 	sub.w	r0, r0, lr, lsl #4
          (int32_t)(1 << 14))) >> 10;
    var3 = var1 * var2;
    var4 = (int32_t)dev->calib.par_h6 << 7;
    var4 = ((var4) + ((temp_scaled * (int32_t)dev->calib.par_h7) / ((int32_t)100))) >> 4;
 80023ac:	f991 e018 	ldrsb.w	lr, [r1, #24]
           (((temp_scaled * (int32_t)dev->calib.par_h3) / ((int32_t)100)) >> 1);
 80023b0:	fb02 fc0c 	mul.w	ip, r2, ip
    var4 = ((var4) + ((temp_scaled * (int32_t)dev->calib.par_h7) / ((int32_t)100))) >> 4;
 80023b4:	fb02 f20e 	mul.w	r2, r2, lr
    var4 = (int32_t)dev->calib.par_h6 << 7;
 80023b8:	f891 e017 	ldrb.w	lr, [r1, #23]
           (((temp_scaled * (int32_t)dev->calib.par_h3) / ((int32_t)100)) >> 1);
 80023bc:	fb84 510c 	smull	r5, r1, r4, ip
 80023c0:	ea4f 7cec 	mov.w	ip, ip, asr #31
 80023c4:	ebcc 1c61 	rsb	ip, ip, r1, asr #5
    var1 = (int32_t)(hum_adc - ((int32_t)((int32_t)dev->calib.par_h1 * 16))) -
 80023c8:	eba0 006c 	sub.w	r0, r0, ip, asr #1
    var2 =
 80023cc:	129b      	asrs	r3, r3, #10
    var4 = ((var4) + ((temp_scaled * (int32_t)dev->calib.par_h7) / ((int32_t)100))) >> 4;
 80023ce:	fb84 1402 	smull	r1, r4, r4, r2
    var3 = var1 * var2;
 80023d2:	fb00 f303 	mul.w	r3, r0, r3
    var4 = ((var4) + ((temp_scaled * (int32_t)dev->calib.par_h7) / ((int32_t)100))) >> 4;
 80023d6:	17d2      	asrs	r2, r2, #31
 80023d8:	ebc2 1264 	rsb	r2, r2, r4, asr #5
    var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
 80023dc:	1399      	asrs	r1, r3, #14
    var4 = ((var4) + ((temp_scaled * (int32_t)dev->calib.par_h7) / ((int32_t)100))) >> 4;
 80023de:	eb02 12ce 	add.w	r2, r2, lr, lsl #7
    var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
 80023e2:	fb01 f101 	mul.w	r1, r1, r1
    var4 = ((var4) + ((temp_scaled * (int32_t)dev->calib.par_h7) / ((int32_t)100))) >> 4;
 80023e6:	1112      	asrs	r2, r2, #4
    var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
 80023e8:	1289      	asrs	r1, r1, #10
    var6 = (var4 * var5) >> 1;
 80023ea:	fb02 f101 	mul.w	r1, r2, r1
    calc_hum = (((var3 + var6) >> 10) * ((int32_t)1000)) >> 12;
 80023ee:	eb03 0061 	add.w	r0, r3, r1, asr #1
 80023f2:	1280      	asrs	r0, r0, #10
 80023f4:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 80023f8:	fb03 f000 	mul.w	r0, r3, r0
 80023fc:	1300      	asrs	r0, r0, #12
    {
        calc_hum = 0;
    }

    /*lint -restore */
    return (uint32_t)calc_hum;
 80023fe:	4b04      	ldr	r3, [pc, #16]	@ (8002410 <calc_humidity+0xc4>)
    else if (calc_hum < 0)
 8002400:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
 8002404:	4298      	cmp	r0, r3
 8002406:	bfa8      	it	ge
 8002408:	4618      	movge	r0, r3
 800240a:	bd70      	pop	{r4, r5, r6, pc}
 800240c:	51eb851f 	.word	0x51eb851f
 8002410:	000186a0 	.word	0x000186a0

08002414 <set_mem_page>:
/* This internal API is used to check the bme68x_dev for null pointers */
static int8_t null_ptr_check(const struct bme68x_dev *dev)
{
    int8_t rslt = BME68X_OK;

    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002414:	2900      	cmp	r1, #0
 8002416:	d038      	beq.n	800248a <set_mem_page+0x76>
{
 8002418:	b530      	push	{r4, r5, lr}
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800241a:	6c0d      	ldr	r5, [r1, #64]	@ 0x40
{
 800241c:	b083      	sub	sp, #12
 800241e:	460c      	mov	r4, r1
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002420:	b36d      	cbz	r5, 800247e <set_mem_page+0x6a>
 8002422:	6c4b      	ldr	r3, [r1, #68]	@ 0x44
 8002424:	b35b      	cbz	r3, 800247e <set_mem_page+0x6a>
 8002426:	6c8b      	ldr	r3, [r1, #72]	@ 0x48
 8002428:	b34b      	cbz	r3, 800247e <set_mem_page+0x6a>
        if (mem_page != dev->mem_page)
 800242a:	7b4b      	ldrb	r3, [r1, #13]
        if (reg_addr > 0x7f)
 800242c:	43c0      	mvns	r0, r0
 800242e:	f3c0 10c0 	ubfx	r0, r0, #7, #1
        if (mem_page != dev->mem_page)
 8002432:	ebb3 1f00 	cmp.w	r3, r0, lsl #4
        if (reg_addr > 0x7f)
 8002436:	ea4f 1200 	mov.w	r2, r0, lsl #4
        if (mem_page != dev->mem_page)
 800243a:	d01d      	beq.n	8002478 <set_mem_page+0x64>
            dev->mem_page = mem_page;
 800243c:	734a      	strb	r2, [r1, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 800243e:	684b      	ldr	r3, [r1, #4]
 8002440:	2201      	movs	r2, #1
 8002442:	f10d 0107 	add.w	r1, sp, #7
 8002446:	20f3      	movs	r0, #243	@ 0xf3
 8002448:	47a8      	blx	r5
 800244a:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 800244e:	b9c8      	cbnz	r0, 8002484 <set_mem_page+0x70>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8002450:	f89d 2007 	ldrb.w	r2, [sp, #7]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002454:	7b63      	ldrb	r3, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8002456:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002458:	f003 0310 	and.w	r3, r3, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 800245c:	f022 0210 	bic.w	r2, r2, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002460:	431a      	orrs	r2, r3
 8002462:	f88d 2007 	strb.w	r2, [sp, #7]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8002466:	6863      	ldr	r3, [r4, #4]
 8002468:	f10d 0107 	add.w	r1, sp, #7
 800246c:	2201      	movs	r2, #1
 800246e:	2073      	movs	r0, #115	@ 0x73
 8002470:	47a8      	blx	r5
 8002472:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 8002476:	b928      	cbnz	r0, 8002484 <set_mem_page+0x70>
    int8_t rslt = BME68X_OK;
 8002478:	2000      	movs	r0, #0
}
 800247a:	b003      	add	sp, #12
 800247c:	bd30      	pop	{r4, r5, pc}
    {
        /* Device structure pointer is not valid */
        rslt = BME68X_E_NULL_PTR;
 800247e:	f04f 30ff 	mov.w	r0, #4294967295
 8002482:	e7fa      	b.n	800247a <set_mem_page+0x66>
                rslt = BME68X_E_COM_FAIL;
 8002484:	f06f 0001 	mvn.w	r0, #1
 8002488:	e7f7      	b.n	800247a <set_mem_page+0x66>
        rslt = BME68X_E_NULL_PTR;
 800248a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800248e:	4770      	bx	lr

08002490 <bme68x_set_regs.constprop.0>:
int8_t bme68x_set_regs(const uint8_t *reg_addr, const uint8_t *reg_data, uint32_t len, struct bme68x_dev *dev)
 8002490:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002494:	b086      	sub	sp, #24
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 8002496:	2300      	movs	r3, #0
 8002498:	e9cd 3301 	strd	r3, r3, [sp, #4]
 800249c:	e9cd 3303 	strd	r3, r3, [sp, #12]
 80024a0:	9305      	str	r3, [sp, #20]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80024a2:	2a00      	cmp	r2, #0
 80024a4:	d062      	beq.n	800256c <bme68x_set_regs.constprop.0+0xdc>
 80024a6:	f8d2 8040 	ldr.w	r8, [r2, #64]	@ 0x40
 80024aa:	4614      	mov	r4, r2
 80024ac:	f1b8 0f00 	cmp.w	r8, #0
 80024b0:	d05c      	beq.n	800256c <bme68x_set_regs.constprop.0+0xdc>
 80024b2:	6c57      	ldr	r7, [r2, #68]	@ 0x44
 80024b4:	2f00      	cmp	r7, #0
 80024b6:	d059      	beq.n	800256c <bme68x_set_regs.constprop.0+0xdc>
 80024b8:	6c93      	ldr	r3, [r2, #72]	@ 0x48
 80024ba:	2b00      	cmp	r3, #0
 80024bc:	d056      	beq.n	800256c <bme68x_set_regs.constprop.0+0xdc>
    if ((rslt == BME68X_OK) && reg_addr && reg_data)
 80024be:	4605      	mov	r5, r0
 80024c0:	2800      	cmp	r0, #0
 80024c2:	d053      	beq.n	800256c <bme68x_set_regs.constprop.0+0xdc>
 80024c4:	460e      	mov	r6, r1
 80024c6:	2900      	cmp	r1, #0
 80024c8:	d050      	beq.n	800256c <bme68x_set_regs.constprop.0+0xdc>
                if (dev->intf == BME68X_SPI_INTF)
 80024ca:	7b12      	ldrb	r2, [r2, #12]
                    rslt = set_mem_page(reg_addr[index], dev);
 80024cc:	7800      	ldrb	r0, [r0, #0]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 80024ce:	6863      	ldr	r3, [r4, #4]
                if (dev->intf == BME68X_SPI_INTF)
 80024d0:	b17a      	cbz	r2, 80024f2 <bme68x_set_regs.constprop.0+0x62>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80024d2:	7832      	ldrb	r2, [r6, #0]
                    tmp_buff[(2 * index)] = reg_addr[index];
 80024d4:	f88d 0004 	strb.w	r0, [sp, #4]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80024d8:	f88d 2005 	strb.w	r2, [sp, #5]
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 80024dc:	2201      	movs	r2, #1
 80024de:	f10d 0105 	add.w	r1, sp, #5
 80024e2:	47b8      	blx	r7
 80024e4:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 80024e8:	2800      	cmp	r0, #0
 80024ea:	d13c      	bne.n	8002566 <bme68x_set_regs.constprop.0+0xd6>
}
 80024ec:	b006      	add	sp, #24
 80024ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (mem_page != dev->mem_page)
 80024f2:	7b61      	ldrb	r1, [r4, #13]
        if (reg_addr > 0x7f)
 80024f4:	43c2      	mvns	r2, r0
 80024f6:	f3c2 12c0 	ubfx	r2, r2, #7, #1
        if (mem_page != dev->mem_page)
 80024fa:	ebb1 1f02 	cmp.w	r1, r2, lsl #4
        if (reg_addr > 0x7f)
 80024fe:	ea4f 1c02 	mov.w	ip, r2, lsl #4
        if (mem_page != dev->mem_page)
 8002502:	d028      	beq.n	8002556 <bme68x_set_regs.constprop.0+0xc6>
            dev->mem_page = mem_page;
 8002504:	f884 c00d 	strb.w	ip, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8002508:	2201      	movs	r2, #1
 800250a:	f10d 0103 	add.w	r1, sp, #3
 800250e:	20f3      	movs	r0, #243	@ 0xf3
 8002510:	47c0      	blx	r8
 8002512:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 8002516:	bb30      	cbnz	r0, 8002566 <bme68x_set_regs.constprop.0+0xd6>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8002518:	f89d 0003 	ldrb.w	r0, [sp, #3]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 800251c:	7b63      	ldrb	r3, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 800251e:	6c67      	ldr	r7, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002520:	f003 0310 	and.w	r3, r3, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8002524:	f020 0010 	bic.w	r0, r0, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002528:	4318      	orrs	r0, r3
 800252a:	f88d 0003 	strb.w	r0, [sp, #3]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 800252e:	6863      	ldr	r3, [r4, #4]
 8002530:	2201      	movs	r2, #1
 8002532:	f10d 0103 	add.w	r1, sp, #3
 8002536:	2073      	movs	r0, #115	@ 0x73
 8002538:	47b8      	blx	r7
 800253a:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 800253e:	b990      	cbnz	r0, 8002566 <bme68x_set_regs.constprop.0+0xd6>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002540:	7828      	ldrb	r0, [r5, #0]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002542:	7832      	ldrb	r2, [r6, #0]
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 8002544:	6c67      	ldr	r7, [r4, #68]	@ 0x44
 8002546:	6863      	ldr	r3, [r4, #4]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002548:	f88d 2005 	strb.w	r2, [sp, #5]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 800254c:	f000 007f 	and.w	r0, r0, #127	@ 0x7f
 8002550:	f88d 0004 	strb.w	r0, [sp, #4]
            if (rslt == BME68X_OK)
 8002554:	e7c2      	b.n	80024dc <bme68x_set_regs.constprop.0+0x4c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002556:	7832      	ldrb	r2, [r6, #0]
 8002558:	f88d 2005 	strb.w	r2, [sp, #5]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 800255c:	f000 007f 	and.w	r0, r0, #127	@ 0x7f
 8002560:	f88d 0004 	strb.w	r0, [sp, #4]
            if (rslt == BME68X_OK)
 8002564:	e7ba      	b.n	80024dc <bme68x_set_regs.constprop.0+0x4c>
                rslt = BME68X_E_COM_FAIL;
 8002566:	f06f 0001 	mvn.w	r0, #1
 800256a:	e7bf      	b.n	80024ec <bme68x_set_regs.constprop.0+0x5c>
        rslt = BME68X_E_NULL_PTR;
 800256c:	f04f 30ff 	mov.w	r0, #4294967295
 8002570:	e7bc      	b.n	80024ec <bme68x_set_regs.constprop.0+0x5c>
 8002572:	bf00      	nop

08002574 <bme68x_init>:
{
 8002574:	b570      	push	{r4, r5, r6, lr}
 8002576:	b08c      	sub	sp, #48	@ 0x30
    uint8_t reg_addr = BME68X_REG_SOFT_RESET;
 8002578:	22e0      	movs	r2, #224	@ 0xe0
    uint8_t soft_rst_cmd = BME68X_SOFT_RESET_CMD;
 800257a:	23b6      	movs	r3, #182	@ 0xb6
    uint8_t reg_addr = BME68X_REG_SOFT_RESET;
 800257c:	f88d 2002 	strb.w	r2, [sp, #2]
    uint8_t soft_rst_cmd = BME68X_SOFT_RESET_CMD;
 8002580:	f88d 3003 	strb.w	r3, [sp, #3]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002584:	2800      	cmp	r0, #0
 8002586:	f000 8140 	beq.w	800280a <bme68x_init+0x296>
 800258a:	6c05      	ldr	r5, [r0, #64]	@ 0x40
 800258c:	4604      	mov	r4, r0
 800258e:	2d00      	cmp	r5, #0
 8002590:	f000 813b 	beq.w	800280a <bme68x_init+0x296>
 8002594:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 8002596:	2b00      	cmp	r3, #0
 8002598:	f000 8137 	beq.w	800280a <bme68x_init+0x296>
 800259c:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 800259e:	2b00      	cmp	r3, #0
 80025a0:	f000 8133 	beq.w	800280a <bme68x_init+0x296>
        if (dev->intf == BME68X_SPI_INTF)
 80025a4:	7b03      	ldrb	r3, [r0, #12]
 80025a6:	2b00      	cmp	r3, #0
 80025a8:	f000 80f5 	beq.w	8002796 <bme68x_init+0x222>
            rslt = bme68x_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
 80025ac:	f10d 0103 	add.w	r1, sp, #3
 80025b0:	4622      	mov	r2, r4
 80025b2:	f10d 0002 	add.w	r0, sp, #2
 80025b6:	f7ff ff6b 	bl	8002490 <bme68x_set_regs.constprop.0>
            dev->delay_us(BME68X_PERIOD_RESET, dev->intf_ptr);
 80025ba:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80025bc:	6861      	ldr	r1, [r4, #4]
            rslt = bme68x_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
 80025be:	4605      	mov	r5, r0
            dev->delay_us(BME68X_PERIOD_RESET, dev->intf_ptr);
 80025c0:	f242 7010 	movw	r0, #10000	@ 0x2710
 80025c4:	4798      	blx	r3
            if (rslt == BME68X_OK)
 80025c6:	2d00      	cmp	r5, #0
 80025c8:	f040 80e2 	bne.w	8002790 <bme68x_init+0x21c>
                if (dev->intf == BME68X_SPI_INTF)
 80025cc:	7b23      	ldrb	r3, [r4, #12]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80025ce:	6c25      	ldr	r5, [r4, #64]	@ 0x40
                if (dev->intf == BME68X_SPI_INTF)
 80025d0:	2b00      	cmp	r3, #0
 80025d2:	f000 80ee 	beq.w	80027b2 <bme68x_init+0x23e>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80025d6:	2d00      	cmp	r5, #0
 80025d8:	f000 8117 	beq.w	800280a <bme68x_init+0x296>
 80025dc:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80025de:	2b00      	cmp	r3, #0
 80025e0:	f000 8113 	beq.w	800280a <bme68x_init+0x296>
 80025e4:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80025e6:	2b00      	cmp	r3, #0
 80025e8:	f000 810f 	beq.w	800280a <bme68x_init+0x296>
        if (dev->intf == BME68X_SPI_INTF)
 80025ec:	7b23      	ldrb	r3, [r4, #12]
 80025ee:	2b00      	cmp	r3, #0
 80025f0:	f000 80f6 	beq.w	80027e0 <bme68x_init+0x26c>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80025f4:	6863      	ldr	r3, [r4, #4]
 80025f6:	2201      	movs	r2, #1
 80025f8:	4621      	mov	r1, r4
 80025fa:	20d0      	movs	r0, #208	@ 0xd0
 80025fc:	47a8      	blx	r5
 80025fe:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002602:	2800      	cmp	r0, #0
 8002604:	f040 80e9 	bne.w	80027da <bme68x_init+0x266>
            if (dev->chip_id == BME68X_CHIP_ID)
 8002608:	7823      	ldrb	r3, [r4, #0]
 800260a:	2b61      	cmp	r3, #97	@ 0x61
 800260c:	f040 8126 	bne.w	800285c <bme68x_init+0x2e8>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002610:	6c25      	ldr	r5, [r4, #64]	@ 0x40

/* This internal API is used to read variant ID information from the register */
static int8_t read_variant_id(struct bme68x_dev *dev)
{
    int8_t rslt;
    uint8_t reg_data = 0;
 8002612:	2300      	movs	r3, #0
 8002614:	f88d 3004 	strb.w	r3, [sp, #4]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002618:	2d00      	cmp	r5, #0
 800261a:	f000 80f6 	beq.w	800280a <bme68x_init+0x296>
 800261e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002620:	2b00      	cmp	r3, #0
 8002622:	f000 80f2 	beq.w	800280a <bme68x_init+0x296>
 8002626:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002628:	2b00      	cmp	r3, #0
 800262a:	f000 80ee 	beq.w	800280a <bme68x_init+0x296>
        if (dev->intf == BME68X_SPI_INTF)
 800262e:	7b23      	ldrb	r3, [r4, #12]
 8002630:	2b00      	cmp	r3, #0
 8002632:	f000 80ed 	beq.w	8002810 <bme68x_init+0x29c>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002636:	ae01      	add	r6, sp, #4
 8002638:	6863      	ldr	r3, [r4, #4]
 800263a:	2201      	movs	r2, #1
 800263c:	4631      	mov	r1, r6
 800263e:	20f0      	movs	r0, #240	@ 0xf0
 8002640:	47a8      	blx	r5
 8002642:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002646:	2800      	cmp	r0, #0
 8002648:	f040 80c7 	bne.w	80027da <bme68x_init+0x266>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800264c:	6c25      	ldr	r5, [r4, #64]	@ 0x40
    /* Read variant ID information register */
    rslt = bme68x_get_regs(BME68X_REG_VARIANT_ID, &reg_data, 1, dev);

    if (rslt == BME68X_OK)
    {
        dev->variant_id = reg_data;
 800264e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8002652:	60a3      	str	r3, [r4, #8]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002654:	2d00      	cmp	r5, #0
 8002656:	f000 80d8 	beq.w	800280a <bme68x_init+0x296>
 800265a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800265c:	2b00      	cmp	r3, #0
 800265e:	f000 80d4 	beq.w	800280a <bme68x_init+0x296>
 8002662:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002664:	2b00      	cmp	r3, #0
 8002666:	f000 80d0 	beq.w	800280a <bme68x_init+0x296>
        if (dev->intf == BME68X_SPI_INTF)
 800266a:	7b23      	ldrb	r3, [r4, #12]
 800266c:	2b00      	cmp	r3, #0
 800266e:	f000 80e3 	beq.w	8002838 <bme68x_init+0x2c4>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002672:	6863      	ldr	r3, [r4, #4]
 8002674:	2217      	movs	r2, #23
 8002676:	4631      	mov	r1, r6
 8002678:	208a      	movs	r0, #138	@ 0x8a
 800267a:	47a8      	blx	r5
 800267c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002680:	2800      	cmp	r0, #0
 8002682:	f040 80aa 	bne.w	80027da <bme68x_init+0x266>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002686:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 8002688:	2d00      	cmp	r5, #0
 800268a:	f000 80be 	beq.w	800280a <bme68x_init+0x296>
 800268e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002690:	2b00      	cmp	r3, #0
 8002692:	f000 80ba 	beq.w	800280a <bme68x_init+0x296>
 8002696:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002698:	2b00      	cmp	r3, #0
 800269a:	f000 80b6 	beq.w	800280a <bme68x_init+0x296>
        if (dev->intf == BME68X_SPI_INTF)
 800269e:	7b23      	ldrb	r3, [r4, #12]
 80026a0:	2b00      	cmp	r3, #0
 80026a2:	f000 80de 	beq.w	8002862 <bme68x_init+0x2ee>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80026a6:	6863      	ldr	r3, [r4, #4]
 80026a8:	220e      	movs	r2, #14
 80026aa:	f10d 011b 	add.w	r1, sp, #27
 80026ae:	20e1      	movs	r0, #225	@ 0xe1
 80026b0:	47a8      	blx	r5
 80026b2:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80026b6:	2800      	cmp	r0, #0
 80026b8:	f040 808f 	bne.w	80027da <bme68x_init+0x266>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80026bc:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 80026be:	2d00      	cmp	r5, #0
 80026c0:	f000 80a3 	beq.w	800280a <bme68x_init+0x296>
 80026c4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80026c6:	2b00      	cmp	r3, #0
 80026c8:	f000 809f 	beq.w	800280a <bme68x_init+0x296>
 80026cc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80026ce:	2b00      	cmp	r3, #0
 80026d0:	f000 809b 	beq.w	800280a <bme68x_init+0x296>
        if (dev->intf == BME68X_SPI_INTF)
 80026d4:	7b20      	ldrb	r0, [r4, #12]
 80026d6:	2800      	cmp	r0, #0
 80026d8:	f000 80d6 	beq.w	8002888 <bme68x_init+0x314>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80026dc:	6863      	ldr	r3, [r4, #4]
 80026de:	2205      	movs	r2, #5
 80026e0:	f10d 0129 	add.w	r1, sp, #41	@ 0x29
 80026e4:	2000      	movs	r0, #0
 80026e6:	47a8      	blx	r5
 80026e8:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80026ec:	2800      	cmp	r0, #0
 80026ee:	d174      	bne.n	80027da <bme68x_init+0x266>
                       (coeff_array[BME68X_IDX_H1_LSB] & BME68X_BIT_H1_DATA_MSK));
 80026f0:	f89d 301c 	ldrb.w	r3, [sp, #28]
        dev->calib.par_t1 =
 80026f4:	f8bd 0023 	ldrh.w	r0, [sp, #35]	@ 0x23
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H1_MSB] << 4) |
 80026f8:	f89d 501d 	ldrb.w	r5, [sp, #29]
        dev->calib.par_t1 =
 80026fc:	83e0      	strh	r0, [r4, #30]
        dev->calib.par_t2 =
 80026fe:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8002702:	8420      	strh	r0, [r4, #32]
                       (coeff_array[BME68X_IDX_H1_LSB] & BME68X_BIT_H1_DATA_MSK));
 8002704:	f003 020f 	and.w	r2, r3, #15
        dev->calib.par_t3 = (int8_t)(coeff_array[BME68X_IDX_T3]);
 8002708:	f89d 0006 	ldrb.w	r0, [sp, #6]
        dev->calib.par_p6 = (int8_t)(coeff_array[BME68X_IDX_P6]);
 800270c:	f8bd 1012 	ldrh.w	r1, [sp, #18]
        dev->calib.par_t3 = (int8_t)(coeff_array[BME68X_IDX_T3]);
 8002710:	f884 0022 	strb.w	r0, [r4, #34]	@ 0x22
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H1_MSB] << 4) |
 8002714:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
        dev->calib.par_p1 =
 8002718:	9802      	ldr	r0, [sp, #8]
 800271a:	6260      	str	r0, [r4, #36]	@ 0x24
        dev->calib.par_h1 =
 800271c:	8222      	strh	r2, [r4, #16]
        dev->calib.par_p3 = (int8_t)coeff_array[BME68X_IDX_P3];
 800271e:	f89d 000c 	ldrb.w	r0, [sp, #12]
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H2_MSB] << 4) | ((coeff_array[BME68X_IDX_H2_LSB]) >> 4));
 8002722:	f89d 201b 	ldrb.w	r2, [sp, #27]
        dev->calib.par_p3 = (int8_t)coeff_array[BME68X_IDX_P3];
 8002726:	f884 0028 	strb.w	r0, [r4, #40]	@ 0x28
        dev->calib.par_p6 = (int8_t)(coeff_array[BME68X_IDX_P6]);
 800272a:	ba49      	rev16	r1, r1
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P4_MSB], coeff_array[BME68X_IDX_P4_LSB]));
 800272c:	f8dd 000e 	ldr.w	r0, [sp, #14]
        dev->calib.par_p4 =
 8002730:	f8c4 002a 	str.w	r0, [r4, #42]	@ 0x2a
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H2_MSB] << 4) | ((coeff_array[BME68X_IDX_H2_LSB]) >> 4));
 8002734:	091b      	lsrs	r3, r3, #4
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P8_MSB], coeff_array[BME68X_IDX_P8_LSB]));
 8002736:	f8dd 0016 	ldr.w	r0, [sp, #22]
        dev->calib.par_p6 = (int8_t)(coeff_array[BME68X_IDX_P6]);
 800273a:	85e1      	strh	r1, [r4, #46]	@ 0x2e
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H2_MSB] << 4) | ((coeff_array[BME68X_IDX_H2_LSB]) >> 4));
 800273c:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
        dev->calib.par_p10 = (uint8_t)(coeff_array[BME68X_IDX_P10]);
 8002740:	f89d 101a 	ldrb.w	r1, [sp, #26]
        dev->calib.par_h3 = (int8_t)coeff_array[BME68X_IDX_H3];
 8002744:	f8bd 201e 	ldrh.w	r2, [sp, #30]
        dev->calib.par_p8 =
 8002748:	6320      	str	r0, [r4, #48]	@ 0x30
        dev->calib.par_p10 = (uint8_t)(coeff_array[BME68X_IDX_P10]);
 800274a:	f884 1034 	strb.w	r1, [r4, #52]	@ 0x34
        dev->calib.par_h5 = (int8_t)coeff_array[BME68X_IDX_H5];
 800274e:	f8bd 0020 	ldrh.w	r0, [sp, #32]
        dev->calib.par_h7 = (int8_t)coeff_array[BME68X_IDX_H7];
 8002752:	f89d 1022 	ldrb.w	r1, [sp, #34]	@ 0x22
        dev->calib.par_h2 =
 8002756:	8263      	strh	r3, [r4, #18]
        dev->calib.par_h3 = (int8_t)coeff_array[BME68X_IDX_H3];
 8002758:	82a2      	strh	r2, [r4, #20]
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_GH2_MSB], coeff_array[BME68X_IDX_GH2_LSB]));
 800275a:	f8bd 3025 	ldrh.w	r3, [sp, #37]	@ 0x25
        dev->calib.par_gh1 = (int8_t)coeff_array[BME68X_IDX_GH1];
 800275e:	f89d 2027 	ldrb.w	r2, [sp, #39]	@ 0x27
        dev->calib.par_h5 = (int8_t)coeff_array[BME68X_IDX_H5];
 8002762:	82e0      	strh	r0, [r4, #22]
        dev->calib.par_h7 = (int8_t)coeff_array[BME68X_IDX_H7];
 8002764:	7621      	strb	r1, [r4, #24]
        dev->calib.par_gh1 = (int8_t)coeff_array[BME68X_IDX_GH1];
 8002766:	7662      	strb	r2, [r4, #25]
        dev->calib.par_gh2 =
 8002768:	8363      	strh	r3, [r4, #26]
        dev->calib.res_heat_range = ((coeff_array[BME68X_IDX_RES_HEAT_RANGE] & BME68X_RHRANGE_MSK) / 16);
 800276a:	f89d 202b 	ldrb.w	r2, [sp, #43]	@ 0x2b
        dev->calib.range_sw_err = ((int8_t)(coeff_array[BME68X_IDX_RANGE_SW_ERR] & BME68X_RSERROR_MSK)) / 16;
 800276e:	f99d 302d 	ldrsb.w	r3, [sp, #45]	@ 0x2d
        dev->calib.par_gh3 = (int8_t)coeff_array[BME68X_IDX_GH3];
 8002772:	f89d 0028 	ldrb.w	r0, [sp, #40]	@ 0x28
        dev->calib.res_heat_val = (int8_t)coeff_array[BME68X_IDX_RES_HEAT_VAL];
 8002776:	f89d 1029 	ldrb.w	r1, [sp, #41]	@ 0x29
        dev->calib.par_gh3 = (int8_t)coeff_array[BME68X_IDX_GH3];
 800277a:	7720      	strb	r0, [r4, #28]
        dev->calib.res_heat_range = ((coeff_array[BME68X_IDX_RES_HEAT_RANGE] & BME68X_RHRANGE_MSK) / 16);
 800277c:	f3c2 1201 	ubfx	r2, r2, #4, #2
        dev->calib.range_sw_err = ((int8_t)(coeff_array[BME68X_IDX_RANGE_SW_ERR] & BME68X_RSERROR_MSK)) / 16;
 8002780:	111b      	asrs	r3, r3, #4
        dev->calib.res_heat_range = ((coeff_array[BME68X_IDX_RES_HEAT_RANGE] & BME68X_RHRANGE_MSK) / 16);
 8002782:	f884 203c 	strb.w	r2, [r4, #60]	@ 0x3c
        dev->calib.res_heat_val = (int8_t)coeff_array[BME68X_IDX_RES_HEAT_VAL];
 8002786:	f884 103d 	strb.w	r1, [r4, #61]	@ 0x3d
        dev->calib.range_sw_err = ((int8_t)(coeff_array[BME68X_IDX_RANGE_SW_ERR] & BME68X_RSERROR_MSK)) / 16;
 800278a:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 800278e:	2500      	movs	r5, #0
}
 8002790:	4628      	mov	r0, r5
 8002792:	b00c      	add	sp, #48	@ 0x30
 8002794:	bd70      	pop	{r4, r5, r6, pc}
        dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8002796:	6843      	ldr	r3, [r0, #4]
 8002798:	2201      	movs	r2, #1
 800279a:	a901      	add	r1, sp, #4
 800279c:	20f3      	movs	r0, #243	@ 0xf3
 800279e:	47a8      	blx	r5
 80027a0:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80027a4:	b9c8      	cbnz	r0, 80027da <bme68x_init+0x266>
            dev->mem_page = reg & BME68X_MEM_PAGE_MSK;
 80027a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80027aa:	f003 0310 	and.w	r3, r3, #16
 80027ae:	7363      	strb	r3, [r4, #13]
        if (rslt == BME68X_OK)
 80027b0:	e6fc      	b.n	80025ac <bme68x_init+0x38>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80027b2:	b355      	cbz	r5, 800280a <bme68x_init+0x296>
 80027b4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80027b6:	b343      	cbz	r3, 800280a <bme68x_init+0x296>
 80027b8:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80027ba:	b333      	cbz	r3, 800280a <bme68x_init+0x296>
        dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 80027bc:	6863      	ldr	r3, [r4, #4]
 80027be:	2201      	movs	r2, #1
 80027c0:	a901      	add	r1, sp, #4
 80027c2:	20f3      	movs	r0, #243	@ 0xf3
 80027c4:	47a8      	blx	r5
 80027c6:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80027ca:	b930      	cbnz	r0, 80027da <bme68x_init+0x266>
            dev->mem_page = reg & BME68X_MEM_PAGE_MSK;
 80027cc:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80027d0:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 80027d2:	f003 0310 	and.w	r3, r3, #16
 80027d6:	7363      	strb	r3, [r4, #13]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80027d8:	e6fd      	b.n	80025d6 <bme68x_init+0x62>
            rslt = BME68X_E_COM_FAIL;
 80027da:	f06f 0501 	mvn.w	r5, #1
 80027de:	e7d7      	b.n	8002790 <bme68x_init+0x21c>
            rslt = set_mem_page(reg_addr, dev);
 80027e0:	4621      	mov	r1, r4
 80027e2:	20d0      	movs	r0, #208	@ 0xd0
 80027e4:	f7ff fe16 	bl	8002414 <set_mem_page>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80027e8:	6863      	ldr	r3, [r4, #4]
 80027ea:	6c26      	ldr	r6, [r4, #64]	@ 0x40
 80027ec:	2201      	movs	r2, #1
            rslt = set_mem_page(reg_addr, dev);
 80027ee:	4605      	mov	r5, r0
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80027f0:	4621      	mov	r1, r4
 80027f2:	20d0      	movs	r0, #208	@ 0xd0
 80027f4:	47b0      	blx	r6
 80027f6:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80027fa:	2800      	cmp	r0, #0
 80027fc:	d1ed      	bne.n	80027da <bme68x_init+0x266>
        if (rslt == BME68X_OK)
 80027fe:	2d00      	cmp	r5, #0
 8002800:	f43f af02 	beq.w	8002608 <bme68x_init+0x94>
}
 8002804:	4628      	mov	r0, r5
 8002806:	b00c      	add	sp, #48	@ 0x30
 8002808:	bd70      	pop	{r4, r5, r6, pc}
        rslt = BME68X_E_NULL_PTR;
 800280a:	f04f 35ff 	mov.w	r5, #4294967295
                if (rslt == BME68X_OK)
 800280e:	e7bf      	b.n	8002790 <bme68x_init+0x21c>
            rslt = set_mem_page(reg_addr, dev);
 8002810:	4621      	mov	r1, r4
 8002812:	20f0      	movs	r0, #240	@ 0xf0
 8002814:	f7ff fdfe 	bl	8002414 <set_mem_page>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002818:	ae01      	add	r6, sp, #4
 800281a:	6863      	ldr	r3, [r4, #4]
 800281c:	f8d4 c040 	ldr.w	ip, [r4, #64]	@ 0x40
            rslt = set_mem_page(reg_addr, dev);
 8002820:	4605      	mov	r5, r0
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002822:	2201      	movs	r2, #1
 8002824:	4631      	mov	r1, r6
 8002826:	20f0      	movs	r0, #240	@ 0xf0
 8002828:	47e0      	blx	ip
 800282a:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 800282e:	2800      	cmp	r0, #0
 8002830:	d1d3      	bne.n	80027da <bme68x_init+0x266>
    if (rslt == BME68X_OK)
 8002832:	2d00      	cmp	r5, #0
 8002834:	d1ac      	bne.n	8002790 <bme68x_init+0x21c>
 8002836:	e709      	b.n	800264c <bme68x_init+0xd8>
            rslt = set_mem_page(reg_addr, dev);
 8002838:	4621      	mov	r1, r4
 800283a:	208a      	movs	r0, #138	@ 0x8a
 800283c:	f7ff fdea 	bl	8002414 <set_mem_page>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002840:	4631      	mov	r1, r6
 8002842:	6863      	ldr	r3, [r4, #4]
 8002844:	6c26      	ldr	r6, [r4, #64]	@ 0x40
            rslt = set_mem_page(reg_addr, dev);
 8002846:	4605      	mov	r5, r0
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002848:	2217      	movs	r2, #23
 800284a:	208a      	movs	r0, #138	@ 0x8a
 800284c:	47b0      	blx	r6
 800284e:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002852:	2800      	cmp	r0, #0
 8002854:	d1c1      	bne.n	80027da <bme68x_init+0x266>
    if (rslt == BME68X_OK)
 8002856:	2d00      	cmp	r5, #0
 8002858:	d19a      	bne.n	8002790 <bme68x_init+0x21c>
 800285a:	e714      	b.n	8002686 <bme68x_init+0x112>
                rslt = BME68X_E_DEV_NOT_FOUND;
 800285c:	f06f 0502 	mvn.w	r5, #2
    return rslt;
 8002860:	e796      	b.n	8002790 <bme68x_init+0x21c>
            rslt = set_mem_page(reg_addr, dev);
 8002862:	4621      	mov	r1, r4
 8002864:	20e1      	movs	r0, #225	@ 0xe1
 8002866:	f7ff fdd5 	bl	8002414 <set_mem_page>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 800286a:	6c26      	ldr	r6, [r4, #64]	@ 0x40
 800286c:	6863      	ldr	r3, [r4, #4]
 800286e:	220e      	movs	r2, #14
            rslt = set_mem_page(reg_addr, dev);
 8002870:	4605      	mov	r5, r0
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002872:	f10d 011b 	add.w	r1, sp, #27
 8002876:	20e1      	movs	r0, #225	@ 0xe1
 8002878:	47b0      	blx	r6
 800287a:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 800287e:	2800      	cmp	r0, #0
 8002880:	d1ab      	bne.n	80027da <bme68x_init+0x266>
    if (rslt == BME68X_OK)
 8002882:	2d00      	cmp	r5, #0
 8002884:	d184      	bne.n	8002790 <bme68x_init+0x21c>
 8002886:	e719      	b.n	80026bc <bme68x_init+0x148>
            rslt = set_mem_page(reg_addr, dev);
 8002888:	4621      	mov	r1, r4
 800288a:	f7ff fdc3 	bl	8002414 <set_mem_page>
 800288e:	4605      	mov	r5, r0
            if (rslt == BME68X_OK)
 8002890:	fab0 f080 	clz	r0, r0
 8002894:	0940      	lsrs	r0, r0, #5
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002896:	6c26      	ldr	r6, [r4, #64]	@ 0x40
 8002898:	6863      	ldr	r3, [r4, #4]
 800289a:	01c0      	lsls	r0, r0, #7
 800289c:	2205      	movs	r2, #5
 800289e:	f10d 0129 	add.w	r1, sp, #41	@ 0x29
 80028a2:	47b0      	blx	r6
 80028a4:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80028a8:	2800      	cmp	r0, #0
 80028aa:	d196      	bne.n	80027da <bme68x_init+0x266>
    if (rslt == BME68X_OK)
 80028ac:	2d00      	cmp	r5, #0
 80028ae:	f47f af6f 	bne.w	8002790 <bme68x_init+0x21c>
 80028b2:	e71d      	b.n	80026f0 <bme68x_init+0x17c>

080028b4 <bme68x_set_regs>:
{
 80028b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80028b8:	b089      	sub	sp, #36	@ 0x24
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 80028ba:	2500      	movs	r5, #0
 80028bc:	e9cd 5503 	strd	r5, r5, [sp, #12]
 80028c0:	e9cd 5505 	strd	r5, r5, [sp, #20]
 80028c4:	9507      	str	r5, [sp, #28]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80028c6:	2b00      	cmp	r3, #0
 80028c8:	f000 816a 	beq.w	8002ba0 <bme68x_set_regs+0x2ec>
 80028cc:	461c      	mov	r4, r3
 80028ce:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80028d0:	2b00      	cmp	r3, #0
 80028d2:	f000 8165 	beq.w	8002ba0 <bme68x_set_regs+0x2ec>
 80028d6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80028d8:	2b00      	cmp	r3, #0
 80028da:	f000 8161 	beq.w	8002ba0 <bme68x_set_regs+0x2ec>
 80028de:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80028e0:	2b00      	cmp	r3, #0
 80028e2:	f000 815d 	beq.w	8002ba0 <bme68x_set_regs+0x2ec>
    if ((rslt == BME68X_OK) && reg_addr && reg_data)
 80028e6:	4682      	mov	sl, r0
 80028e8:	2800      	cmp	r0, #0
 80028ea:	f000 8159 	beq.w	8002ba0 <bme68x_set_regs+0x2ec>
 80028ee:	468b      	mov	fp, r1
 80028f0:	2900      	cmp	r1, #0
 80028f2:	f000 8155 	beq.w	8002ba0 <bme68x_set_regs+0x2ec>
        if ((len > 0) && (len <= (BME68X_LEN_INTERLEAVE_BUFF / 2)))
 80028f6:	1e53      	subs	r3, r2, #1
 80028f8:	2b09      	cmp	r3, #9
 80028fa:	4691      	mov	r9, r2
 80028fc:	f200 815b 	bhi.w	8002bb6 <bme68x_set_regs+0x302>
    int8_t rslt = BME68X_OK;
 8002900:	4628      	mov	r0, r5
 8002902:	f10a 38ff 	add.w	r8, sl, #4294967295
 8002906:	ae03      	add	r6, sp, #12
 8002908:	1e4f      	subs	r7, r1, #1
        if ((len > 0) && (len <= (BME68X_LEN_INTERLEAVE_BUFF / 2)))
 800290a:	2501      	movs	r5, #1
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 800290c:	f8cd a004 	str.w	sl, [sp, #4]
                if (dev->intf == BME68X_SPI_INTF)
 8002910:	7b21      	ldrb	r1, [r4, #12]
                    rslt = set_mem_page(reg_addr[index], dev);
 8002912:	f818 3f01 	ldrb.w	r3, [r8, #1]!
                if (dev->intf == BME68X_SPI_INTF)
 8002916:	2900      	cmp	r1, #0
 8002918:	f000 8089 	beq.w	8002a2e <bme68x_set_regs+0x17a>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800291c:	787a      	ldrb	r2, [r7, #1]
 800291e:	f8dd a004 	ldr.w	sl, [sp, #4]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002922:	7033      	strb	r3, [r6, #0]
            for (index = 0; index < len; index++)
 8002924:	45a9      	cmp	r9, r5
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002926:	7072      	strb	r2, [r6, #1]
            for (index = 0; index < len; index++)
 8002928:	b2a9      	uxth	r1, r5
 800292a:	f000 80cb 	beq.w	8002ac4 <bme68x_set_regs+0x210>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800292e:	aa08      	add	r2, sp, #32
 8002930:	1c6b      	adds	r3, r5, #1
 8002932:	eb02 0245 	add.w	r2, r2, r5, lsl #1
 8002936:	f81b 6005 	ldrb.w	r6, [fp, r5]
 800293a:	f802 6c13 	strb.w	r6, [r2, #-19]
            for (index = 0; index < len; index++)
 800293e:	4599      	cmp	r9, r3
 8002940:	f240 80bc 	bls.w	8002abc <bme68x_set_regs+0x208>
 8002944:	1c4e      	adds	r6, r1, #1
 8002946:	b2b6      	uxth	r6, r6
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002948:	af08      	add	r7, sp, #32
 800294a:	eb07 0e46 	add.w	lr, r7, r6, lsl #1
 800294e:	f81b 8003 	ldrb.w	r8, [fp, r3]
 8002952:	f80e 8c13 	strb.w	r8, [lr, #-19]
 8002956:	0077      	lsls	r7, r6, #1
            for (index = 0; index < len; index++)
 8002958:	1c8e      	adds	r6, r1, #2
 800295a:	fa1f fe86 	uxth.w	lr, r6
 800295e:	45f1      	cmp	r9, lr
 8002960:	f240 80c6 	bls.w	8002af0 <bme68x_set_regs+0x23c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002964:	f10d 0c20 	add.w	ip, sp, #32
 8002968:	eb0c 084e 	add.w	r8, ip, lr, lsl #1
 800296c:	f81b e00e 	ldrb.w	lr, [fp, lr]
 8002970:	f808 ec13 	strb.w	lr, [r8, #-19]
            for (index = 0; index < len; index++)
 8002974:	f101 0e03 	add.w	lr, r1, #3
 8002978:	fa1f f88e 	uxth.w	r8, lr
 800297c:	45c1      	cmp	r9, r8
 800297e:	f240 80b7 	bls.w	8002af0 <bme68x_set_regs+0x23c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002982:	eb0c 0c48 	add.w	ip, ip, r8, lsl #1
 8002986:	f81b 8008 	ldrb.w	r8, [fp, r8]
 800298a:	f80c 8c13 	strb.w	r8, [ip, #-19]
            for (index = 0; index < len; index++)
 800298e:	f101 0804 	add.w	r8, r1, #4
 8002992:	fa1f f888 	uxth.w	r8, r8
 8002996:	45c1      	cmp	r9, r8
 8002998:	f240 80aa 	bls.w	8002af0 <bme68x_set_regs+0x23c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800299c:	f10d 0c20 	add.w	ip, sp, #32
 80029a0:	eb0c 0c48 	add.w	ip, ip, r8, lsl #1
 80029a4:	f81b 8008 	ldrb.w	r8, [fp, r8]
 80029a8:	f80c 8c13 	strb.w	r8, [ip, #-19]
            for (index = 0; index < len; index++)
 80029ac:	f101 0805 	add.w	r8, r1, #5
 80029b0:	fa1f f888 	uxth.w	r8, r8
 80029b4:	45c1      	cmp	r9, r8
 80029b6:	f240 809b 	bls.w	8002af0 <bme68x_set_regs+0x23c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80029ba:	f10d 0c20 	add.w	ip, sp, #32
 80029be:	eb0c 0c48 	add.w	ip, ip, r8, lsl #1
 80029c2:	f81b 8008 	ldrb.w	r8, [fp, r8]
 80029c6:	f80c 8c13 	strb.w	r8, [ip, #-19]
            for (index = 0; index < len; index++)
 80029ca:	f101 0806 	add.w	r8, r1, #6
 80029ce:	fa1f f888 	uxth.w	r8, r8
 80029d2:	45c1      	cmp	r9, r8
 80029d4:	f240 808c 	bls.w	8002af0 <bme68x_set_regs+0x23c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80029d8:	f10d 0c20 	add.w	ip, sp, #32
 80029dc:	eb0c 0c48 	add.w	ip, ip, r8, lsl #1
 80029e0:	f81b 8008 	ldrb.w	r8, [fp, r8]
 80029e4:	f80c 8c13 	strb.w	r8, [ip, #-19]
            for (index = 0; index < len; index++)
 80029e8:	f101 0807 	add.w	r8, r1, #7
 80029ec:	fa1f f888 	uxth.w	r8, r8
 80029f0:	45c1      	cmp	r9, r8
 80029f2:	d97d      	bls.n	8002af0 <bme68x_set_regs+0x23c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80029f4:	f10d 0c20 	add.w	ip, sp, #32
 80029f8:	eb0c 0c48 	add.w	ip, ip, r8, lsl #1
 80029fc:	f81b 8008 	ldrb.w	r8, [fp, r8]
 8002a00:	f80c 8c13 	strb.w	r8, [ip, #-19]
            for (index = 0; index < len; index++)
 8002a04:	f101 0808 	add.w	r8, r1, #8
 8002a08:	fa1f f888 	uxth.w	r8, r8
 8002a0c:	45c1      	cmp	r9, r8
 8002a0e:	d96f      	bls.n	8002af0 <bme68x_set_regs+0x23c>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002a10:	f89b 6009 	ldrb.w	r6, [fp, #9]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002a14:	f81a 5005 	ldrb.w	r5, [sl, r5]
 8002a18:	f81a 3003 	ldrb.w	r3, [sl, r3]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002a1c:	f88d 601f 	strb.w	r6, [sp, #31]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002a20:	f802 5c14 	strb.w	r5, [r2, #-20]
            for (index = 0; index < len; index++)
 8002a24:	2203      	movs	r2, #3
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002a26:	f88d 3010 	strb.w	r3, [sp, #16]
            for (index = 0; index < len; index++)
 8002a2a:	4613      	mov	r3, r2
 8002a2c:	e070      	b.n	8002b10 <bme68x_set_regs+0x25c>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002a2e:	f8d4 a040 	ldr.w	sl, [r4, #64]	@ 0x40
 8002a32:	f1ba 0f00 	cmp.w	sl, #0
 8002a36:	f000 80b0 	beq.w	8002b9a <bme68x_set_regs+0x2e6>
 8002a3a:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8002a3c:	2a00      	cmp	r2, #0
 8002a3e:	f000 80ac 	beq.w	8002b9a <bme68x_set_regs+0x2e6>
 8002a42:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8002a44:	2a00      	cmp	r2, #0
 8002a46:	f000 80a8 	beq.w	8002b9a <bme68x_set_regs+0x2e6>
        if (mem_page != dev->mem_page)
 8002a4a:	7b60      	ldrb	r0, [r4, #13]
        if (reg_addr > 0x7f)
 8002a4c:	43da      	mvns	r2, r3
 8002a4e:	f3c2 12c0 	ubfx	r2, r2, #7, #1
        if (mem_page != dev->mem_page)
 8002a52:	ebb0 1f02 	cmp.w	r0, r2, lsl #4
        if (reg_addr > 0x7f)
 8002a56:	ea4f 1c02 	mov.w	ip, r2, lsl #4
        if (mem_page != dev->mem_page)
 8002a5a:	d047      	beq.n	8002aec <bme68x_set_regs+0x238>
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8002a5c:	6863      	ldr	r3, [r4, #4]
            dev->mem_page = mem_page;
 8002a5e:	f884 c00d 	strb.w	ip, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8002a62:	2201      	movs	r2, #1
 8002a64:	f10d 010b 	add.w	r1, sp, #11
 8002a68:	20f3      	movs	r0, #243	@ 0xf3
 8002a6a:	47d0      	blx	sl
 8002a6c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 8002a70:	2800      	cmp	r0, #0
 8002a72:	f040 809b 	bne.w	8002bac <bme68x_set_regs+0x2f8>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8002a76:	f89d 300b 	ldrb.w	r3, [sp, #11]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002a7a:	7b62      	ldrb	r2, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8002a7c:	f8d4 c044 	ldr.w	ip, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002a80:	f002 0210 	and.w	r2, r2, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8002a84:	f023 0310 	bic.w	r3, r3, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8002a88:	4313      	orrs	r3, r2
 8002a8a:	f88d 300b 	strb.w	r3, [sp, #11]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8002a8e:	2201      	movs	r2, #1
 8002a90:	6863      	ldr	r3, [r4, #4]
 8002a92:	f10d 010b 	add.w	r1, sp, #11
 8002a96:	2073      	movs	r0, #115	@ 0x73
 8002a98:	47e0      	blx	ip
 8002a9a:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002a9e:	f898 3000 	ldrb.w	r3, [r8]
                if (dev->intf_rslt != 0)
 8002aa2:	2800      	cmp	r0, #0
 8002aa4:	d17f      	bne.n	8002ba6 <bme68x_set_regs+0x2f2>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002aa6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8002aaa:	7033      	strb	r3, [r6, #0]
            for (index = 0; index < len; index++)
 8002aac:	45a9      	cmp	r9, r5
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002aae:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 8002ab2:	7073      	strb	r3, [r6, #1]
            for (index = 0; index < len; index++)
 8002ab4:	d006      	beq.n	8002ac4 <bme68x_set_regs+0x210>
 8002ab6:	3501      	adds	r5, #1
 8002ab8:	3602      	adds	r6, #2
 8002aba:	e729      	b.n	8002910 <bme68x_set_regs+0x5c>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002abc:	f81a 3005 	ldrb.w	r3, [sl, r5]
 8002ac0:	f802 3c14 	strb.w	r3, [r2, #-20]
            if (rslt == BME68X_OK)
 8002ac4:	b978      	cbnz	r0, 8002ae6 <bme68x_set_regs+0x232>
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 8002ac6:	ea4f 0249 	mov.w	r2, r9, lsl #1
 8002aca:	6c65      	ldr	r5, [r4, #68]	@ 0x44
 8002acc:	6863      	ldr	r3, [r4, #4]
 8002ace:	f89d 000c 	ldrb.w	r0, [sp, #12]
 8002ad2:	3a01      	subs	r2, #1
 8002ad4:	f10d 010d 	add.w	r1, sp, #13
 8002ad8:	47a8      	blx	r5
                    rslt = BME68X_E_COM_FAIL;
 8002ada:	2800      	cmp	r0, #0
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 8002adc:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                    rslt = BME68X_E_COM_FAIL;
 8002ae0:	bf18      	it	ne
 8002ae2:	f06f 0001 	mvnne.w	r0, #1
}
 8002ae6:	b009      	add	sp, #36	@ 0x24
 8002ae8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    int8_t rslt = BME68X_OK;
 8002aec:	4608      	mov	r0, r1
 8002aee:	e7da      	b.n	8002aa6 <bme68x_set_regs+0x1f2>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002af0:	3720      	adds	r7, #32
 8002af2:	446f      	add	r7, sp
 8002af4:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8002af8:	f81a 5005 	ldrb.w	r5, [sl, r5]
 8002afc:	f802 5c14 	strb.w	r5, [r2, #-20]
 8002b00:	f807 3c14 	strb.w	r3, [r7, #-20]
            for (index = 0; index < len; index++)
 8002b04:	b2b3      	uxth	r3, r6
 8002b06:	4599      	cmp	r9, r3
 8002b08:	461a      	mov	r2, r3
 8002b0a:	d9db      	bls.n	8002ac4 <bme68x_set_regs+0x210>
 8002b0c:	f101 0e03 	add.w	lr, r1, #3
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b10:	ad08      	add	r5, sp, #32
 8002b12:	eb05 0343 	add.w	r3, r5, r3, lsl #1
            for (index = 0; index < len; index++)
 8002b16:	fa1f fe8e 	uxth.w	lr, lr
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b1a:	f81a 2002 	ldrb.w	r2, [sl, r2]
 8002b1e:	f803 2c14 	strb.w	r2, [r3, #-20]
            for (index = 0; index < len; index++)
 8002b22:	45f1      	cmp	r9, lr
 8002b24:	d9ce      	bls.n	8002ac4 <bme68x_set_regs+0x210>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b26:	eb05 034e 	add.w	r3, r5, lr, lsl #1
 8002b2a:	f81a 200e 	ldrb.w	r2, [sl, lr]
 8002b2e:	f803 2c14 	strb.w	r2, [r3, #-20]
            for (index = 0; index < len; index++)
 8002b32:	1d0b      	adds	r3, r1, #4
 8002b34:	b29b      	uxth	r3, r3
 8002b36:	4599      	cmp	r9, r3
 8002b38:	d9c4      	bls.n	8002ac4 <bme68x_set_regs+0x210>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b3a:	eb05 0243 	add.w	r2, r5, r3, lsl #1
 8002b3e:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8002b42:	f802 3c14 	strb.w	r3, [r2, #-20]
            for (index = 0; index < len; index++)
 8002b46:	1d4b      	adds	r3, r1, #5
 8002b48:	b29b      	uxth	r3, r3
 8002b4a:	4599      	cmp	r9, r3
 8002b4c:	d9ba      	bls.n	8002ac4 <bme68x_set_regs+0x210>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b4e:	eb05 0243 	add.w	r2, r5, r3, lsl #1
 8002b52:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8002b56:	f802 3c14 	strb.w	r3, [r2, #-20]
            for (index = 0; index < len; index++)
 8002b5a:	1d8b      	adds	r3, r1, #6
 8002b5c:	b29b      	uxth	r3, r3
 8002b5e:	4599      	cmp	r9, r3
 8002b60:	d9b0      	bls.n	8002ac4 <bme68x_set_regs+0x210>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b62:	eb05 0243 	add.w	r2, r5, r3, lsl #1
 8002b66:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8002b6a:	f802 3c14 	strb.w	r3, [r2, #-20]
            for (index = 0; index < len; index++)
 8002b6e:	1dcb      	adds	r3, r1, #7
 8002b70:	b29b      	uxth	r3, r3
 8002b72:	4599      	cmp	r9, r3
 8002b74:	d9a6      	bls.n	8002ac4 <bme68x_set_regs+0x210>
 8002b76:	f101 0208 	add.w	r2, r1, #8
 8002b7a:	b292      	uxth	r2, r2
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b7c:	eb05 0143 	add.w	r1, r5, r3, lsl #1
            for (index = 0; index < len; index++)
 8002b80:	4591      	cmp	r9, r2
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002b82:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8002b86:	f801 3c14 	strb.w	r3, [r1, #-20]
 8002b8a:	bf84      	itt	hi
 8002b8c:	f89a 3009 	ldrbhi.w	r3, [sl, #9]
 8002b90:	f88d 301e 	strbhi.w	r3, [sp, #30]
            if (rslt == BME68X_OK)
 8002b94:	2800      	cmp	r0, #0
 8002b96:	d1a6      	bne.n	8002ae6 <bme68x_set_regs+0x232>
 8002b98:	e795      	b.n	8002ac6 <bme68x_set_regs+0x212>
        rslt = BME68X_E_NULL_PTR;
 8002b9a:	f04f 30ff 	mov.w	r0, #4294967295
 8002b9e:	e782      	b.n	8002aa6 <bme68x_set_regs+0x1f2>
        rslt = BME68X_E_NULL_PTR;
 8002ba0:	f04f 30ff 	mov.w	r0, #4294967295
 8002ba4:	e79f      	b.n	8002ae6 <bme68x_set_regs+0x232>
                rslt = BME68X_E_COM_FAIL;
 8002ba6:	f06f 0001 	mvn.w	r0, #1
 8002baa:	e77c      	b.n	8002aa6 <bme68x_set_regs+0x1f2>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002bac:	f898 3000 	ldrb.w	r3, [r8]
                rslt = BME68X_E_COM_FAIL;
 8002bb0:	f06f 0001 	mvn.w	r0, #1
 8002bb4:	e777      	b.n	8002aa6 <bme68x_set_regs+0x1f2>
            rslt = BME68X_E_INVALID_LENGTH;
 8002bb6:	f06f 0003 	mvn.w	r0, #3
 8002bba:	e794      	b.n	8002ae6 <bme68x_set_regs+0x232>

08002bbc <bme68x_set_op_mode>:
{
 8002bbc:	b570      	push	{r4, r5, r6, lr}
 8002bbe:	b082      	sub	sp, #8
    uint8_t reg_addr = BME68X_REG_CTRL_MEAS;
 8002bc0:	2374      	movs	r3, #116	@ 0x74
 8002bc2:	f88d 3007 	strb.w	r3, [sp, #7]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002bc6:	2900      	cmp	r1, #0
 8002bc8:	d049      	beq.n	8002c5e <bme68x_set_op_mode+0xa2>
 8002bca:	4606      	mov	r6, r0
 8002bcc:	460c      	mov	r4, r1
 8002bce:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 8002bd0:	2074      	movs	r0, #116	@ 0x74
 8002bd2:	2d00      	cmp	r5, #0
 8002bd4:	d043      	beq.n	8002c5e <bme68x_set_op_mode+0xa2>
 8002bd6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002bd8:	2b00      	cmp	r3, #0
 8002bda:	d040      	beq.n	8002c5e <bme68x_set_op_mode+0xa2>
 8002bdc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002bde:	2b00      	cmp	r3, #0
 8002be0:	d03d      	beq.n	8002c5e <bme68x_set_op_mode+0xa2>
        if (dev->intf == BME68X_SPI_INTF)
 8002be2:	7b23      	ldrb	r3, [r4, #12]
 8002be4:	b31b      	cbz	r3, 8002c2e <bme68x_set_op_mode+0x72>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002be6:	2201      	movs	r2, #1
 8002be8:	f10d 0106 	add.w	r1, sp, #6
 8002bec:	6863      	ldr	r3, [r4, #4]
 8002bee:	47a8      	blx	r5
 8002bf0:	4605      	mov	r5, r0
                rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
 8002bf2:	f10d 0106 	add.w	r1, sp, #6
 8002bf6:	4622      	mov	r2, r4
 8002bf8:	f10d 0007 	add.w	r0, sp, #7
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002bfc:	f884 504c 	strb.w	r5, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002c00:	bb45      	cbnz	r5, 8002c54 <bme68x_set_op_mode+0x98>
            pow_mode = (tmp_pow_mode & BME68X_MODE_MSK);
 8002c02:	f89d 3006 	ldrb.w	r3, [sp, #6]
            if (pow_mode != BME68X_SLEEP_MODE)
 8002c06:	f013 0f03 	tst.w	r3, #3
                tmp_pow_mode &= ~BME68X_MODE_MSK; /* Set to sleep */
 8002c0a:	f023 0c03 	bic.w	ip, r3, #3
            if (pow_mode != BME68X_SLEEP_MODE)
 8002c0e:	d029      	beq.n	8002c64 <bme68x_set_op_mode+0xa8>
                tmp_pow_mode &= ~BME68X_MODE_MSK; /* Set to sleep */
 8002c10:	f88d c006 	strb.w	ip, [sp, #6]
                rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
 8002c14:	f7ff fc3c 	bl	8002490 <bme68x_set_regs.constprop.0>
                dev->delay_us(BME68X_PERIOD_POLL, dev->intf_ptr);
 8002c18:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002c1a:	6861      	ldr	r1, [r4, #4]
                rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
 8002c1c:	4605      	mov	r5, r0
                dev->delay_us(BME68X_PERIOD_POLL, dev->intf_ptr);
 8002c1e:	f242 7010 	movw	r0, #10000	@ 0x2710
 8002c22:	4798      	blx	r3
    } while ((pow_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK));
 8002c24:	2d00      	cmp	r5, #0
 8002c26:	d0d2      	beq.n	8002bce <bme68x_set_op_mode+0x12>
}
 8002c28:	4628      	mov	r0, r5
 8002c2a:	b002      	add	sp, #8
 8002c2c:	bd70      	pop	{r4, r5, r6, pc}
            rslt = set_mem_page(reg_addr, dev);
 8002c2e:	4621      	mov	r1, r4
 8002c30:	f7ff fbf0 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8002c34:	4605      	mov	r5, r0
 8002c36:	b910      	cbnz	r0, 8002c3e <bme68x_set_op_mode+0x82>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002c38:	6c25      	ldr	r5, [r4, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8002c3a:	20f4      	movs	r0, #244	@ 0xf4
 8002c3c:	e7d3      	b.n	8002be6 <bme68x_set_op_mode+0x2a>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002c3e:	6c26      	ldr	r6, [r4, #64]	@ 0x40
 8002c40:	6863      	ldr	r3, [r4, #4]
 8002c42:	2201      	movs	r2, #1
 8002c44:	f10d 0106 	add.w	r1, sp, #6
 8002c48:	2074      	movs	r0, #116	@ 0x74
 8002c4a:	47b0      	blx	r6
 8002c4c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002c50:	2800      	cmp	r0, #0
 8002c52:	d0e9      	beq.n	8002c28 <bme68x_set_op_mode+0x6c>
            rslt = BME68X_E_COM_FAIL;
 8002c54:	f06f 0501 	mvn.w	r5, #1
}
 8002c58:	4628      	mov	r0, r5
 8002c5a:	b002      	add	sp, #8
 8002c5c:	bd70      	pop	{r4, r5, r6, pc}
        rslt = BME68X_E_NULL_PTR;
 8002c5e:	f04f 35ff 	mov.w	r5, #4294967295
    return rslt;
 8002c62:	e7e1      	b.n	8002c28 <bme68x_set_op_mode+0x6c>
    if ((op_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK))
 8002c64:	2e00      	cmp	r6, #0
 8002c66:	d0df      	beq.n	8002c28 <bme68x_set_op_mode+0x6c>
        tmp_pow_mode = (tmp_pow_mode & ~BME68X_MODE_MSK) | (op_mode & BME68X_MODE_MSK);
 8002c68:	f023 0303 	bic.w	r3, r3, #3
 8002c6c:	f006 0603 	and.w	r6, r6, #3
 8002c70:	4333      	orrs	r3, r6
        rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
 8002c72:	4622      	mov	r2, r4
 8002c74:	f10d 0106 	add.w	r1, sp, #6
 8002c78:	f10d 0007 	add.w	r0, sp, #7
        tmp_pow_mode = (tmp_pow_mode & ~BME68X_MODE_MSK) | (op_mode & BME68X_MODE_MSK);
 8002c7c:	f88d 3006 	strb.w	r3, [sp, #6]
        rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
 8002c80:	f7ff fc06 	bl	8002490 <bme68x_set_regs.constprop.0>
 8002c84:	4605      	mov	r5, r0
 8002c86:	e7cf      	b.n	8002c28 <bme68x_set_op_mode+0x6c>

08002c88 <bme68x_set_conf>:
{
 8002c88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint8_t reg_array[BME68X_LEN_CONFIG] = { 0x71, 0x72, 0x73, 0x74, 0x75 };
 8002c8c:	4bc3      	ldr	r3, [pc, #780]	@ (8002f9c <bme68x_set_conf+0x314>)
{
 8002c8e:	4606      	mov	r6, r0
 8002c90:	460c      	mov	r4, r1
    uint8_t reg_array[BME68X_LEN_CONFIG] = { 0x71, 0x72, 0x73, 0x74, 0x75 };
 8002c92:	e893 0003 	ldmia.w	r3, {r0, r1}
{
 8002c96:	b08b      	sub	sp, #44	@ 0x2c
    uint8_t data_array[BME68X_LEN_CONFIG] = { 0 };
 8002c98:	2300      	movs	r3, #0
    uint8_t reg_array[BME68X_LEN_CONFIG] = { 0x71, 0x72, 0x73, 0x74, 0x75 };
 8002c9a:	9001      	str	r0, [sp, #4]
 8002c9c:	f88d 1008 	strb.w	r1, [sp, #8]
    uint8_t data_array[BME68X_LEN_CONFIG] = { 0 };
 8002ca0:	9303      	str	r3, [sp, #12]
 8002ca2:	f88d 3010 	strb.w	r3, [sp, #16]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002ca6:	2c00      	cmp	r4, #0
 8002ca8:	f000 8160 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002cac:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 8002cae:	2d00      	cmp	r5, #0
 8002cb0:	f000 81e6 	beq.w	8003080 <bme68x_set_conf+0x3f8>
 8002cb4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002cb6:	2b00      	cmp	r3, #0
 8002cb8:	f000 81e2 	beq.w	8003080 <bme68x_set_conf+0x3f8>
 8002cbc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002cbe:	2b00      	cmp	r3, #0
 8002cc0:	f000 81de 	beq.w	8003080 <bme68x_set_conf+0x3f8>
        if (dev->intf == BME68X_SPI_INTF)
 8002cc4:	7b23      	ldrb	r3, [r4, #12]
 8002cc6:	2b00      	cmp	r3, #0
 8002cc8:	f000 8139 	beq.w	8002f3e <bme68x_set_conf+0x2b6>
 8002ccc:	2074      	movs	r0, #116	@ 0x74
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002cce:	6863      	ldr	r3, [r4, #4]
 8002cd0:	2201      	movs	r2, #1
 8002cd2:	a905      	add	r1, sp, #20
 8002cd4:	47a8      	blx	r5
 8002cd6:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002cda:	b140      	cbz	r0, 8002cee <bme68x_set_conf+0x66>
            rslt = BME68X_E_COM_FAIL;
 8002cdc:	f06f 0501 	mvn.w	r5, #1
    if (conf == NULL)
 8002ce0:	2e00      	cmp	r6, #0
 8002ce2:	f000 8143 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
}
 8002ce6:	4628      	mov	r0, r5
 8002ce8:	b00b      	add	sp, #44	@ 0x2c
 8002cea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
 8002cee:	4621      	mov	r1, r4
        *op_mode = mode & BME68X_MODE_MSK;
 8002cf0:	f89d 8014 	ldrb.w	r8, [sp, #20]
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
 8002cf4:	f7ff ff62 	bl	8002bbc <bme68x_set_op_mode>
 8002cf8:	4605      	mov	r5, r0
    if (conf == NULL)
 8002cfa:	2e00      	cmp	r6, #0
 8002cfc:	f000 8136 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
    else if (rslt == BME68X_OK)
 8002d00:	2d00      	cmp	r5, #0
 8002d02:	d1f0      	bne.n	8002ce6 <bme68x_set_conf+0x5e>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002d04:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 8002d06:	2d00      	cmp	r5, #0
 8002d08:	f000 82d6 	beq.w	80032b8 <bme68x_set_conf+0x630>
 8002d0c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002d0e:	2b00      	cmp	r3, #0
 8002d10:	f000 82d2 	beq.w	80032b8 <bme68x_set_conf+0x630>
 8002d14:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002d16:	2b00      	cmp	r3, #0
 8002d18:	f000 82ce 	beq.w	80032b8 <bme68x_set_conf+0x630>
        if (dev->intf == BME68X_SPI_INTF)
 8002d1c:	7b23      	ldrb	r3, [r4, #12]
 8002d1e:	2b00      	cmp	r3, #0
 8002d20:	f000 8127 	beq.w	8002f72 <bme68x_set_conf+0x2ea>
 8002d24:	2071      	movs	r0, #113	@ 0x71
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002d26:	6863      	ldr	r3, [r4, #4]
 8002d28:	2205      	movs	r2, #5
 8002d2a:	a903      	add	r1, sp, #12
 8002d2c:	47a8      	blx	r5
 8002d2e:	4607      	mov	r7, r0
 8002d30:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002d34:	2800      	cmp	r0, #0
 8002d36:	f040 815c 	bne.w	8002ff2 <bme68x_set_conf+0x36a>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002d3a:	6c25      	ldr	r5, [r4, #64]	@ 0x40
        dev->info_msg = BME68X_OK;
 8002d3c:	f884 704d 	strb.w	r7, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002d40:	2d00      	cmp	r5, #0
 8002d42:	f000 8113 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002d46:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002d48:	2b00      	cmp	r3, #0
 8002d4a:	f000 810f 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002d4e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002d50:	2b00      	cmp	r3, #0
 8002d52:	f000 810b 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
        if (*value > max)
 8002d56:	78f1      	ldrb	r1, [r6, #3]
 8002d58:	2907      	cmp	r1, #7
 8002d5a:	f200 8121 	bhi.w	8002fa0 <bme68x_set_conf+0x318>
 8002d5e:	f896 c001 	ldrb.w	ip, [r6, #1]
 8002d62:	f1bc 0f05 	cmp.w	ip, #5
 8002d66:	f200 8132 	bhi.w	8002fce <bme68x_set_conf+0x346>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002d6a:	2b00      	cmp	r3, #0
 8002d6c:	f000 80fe 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
        if (*value > max)
 8002d70:	f896 e002 	ldrb.w	lr, [r6, #2]
 8002d74:	f1be 0f05 	cmp.w	lr, #5
 8002d78:	d915      	bls.n	8002da6 <bme68x_set_conf+0x11e>
            *value = max;
 8002d7a:	f04f 0e05 	mov.w	lr, #5
 8002d7e:	f886 e002 	strb.w	lr, [r6, #2]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002d82:	f894 304d 	ldrb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002d86:	6c25      	ldr	r5, [r4, #64]	@ 0x40
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002d88:	f043 0301 	orr.w	r3, r3, #1
 8002d8c:	f884 304d 	strb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002d90:	2d00      	cmp	r5, #0
 8002d92:	f000 80eb 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002d96:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002d98:	2b00      	cmp	r3, #0
 8002d9a:	f000 80e7 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002d9e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002da0:	2b00      	cmp	r3, #0
 8002da2:	f000 80e3 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
        if (*value > max)
 8002da6:	7830      	ldrb	r0, [r6, #0]
 8002da8:	2805      	cmp	r0, #5
 8002daa:	d913      	bls.n	8002dd4 <bme68x_set_conf+0x14c>
            *value = max;
 8002dac:	2005      	movs	r0, #5
 8002dae:	7030      	strb	r0, [r6, #0]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002db0:	f894 304d 	ldrb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002db4:	6c25      	ldr	r5, [r4, #64]	@ 0x40
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002db6:	f043 0301 	orr.w	r3, r3, #1
 8002dba:	f884 304d 	strb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002dbe:	2d00      	cmp	r5, #0
 8002dc0:	f000 80d4 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002dc4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002dc6:	2b00      	cmp	r3, #0
 8002dc8:	f000 80d0 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002dcc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002dce:	2b00      	cmp	r3, #0
 8002dd0:	f000 80cc 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
        if (*value > max)
 8002dd4:	7933      	ldrb	r3, [r6, #4]
 8002dd6:	2b08      	cmp	r3, #8
 8002dd8:	d908      	bls.n	8002dec <bme68x_set_conf+0x164>
            *value = max;
 8002dda:	2308      	movs	r3, #8
 8002ddc:	7133      	strb	r3, [r6, #4]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002dde:	f894 204d 	ldrb.w	r2, [r4, #77]	@ 0x4d
 8002de2:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 8002de4:	f042 0201 	orr.w	r2, r2, #1
 8002de8:	f884 204d 	strb.w	r2, [r4, #77]	@ 0x4d
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OST, conf->os_temp);
 8002dec:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8002df0:	f002 021f 	and.w	r2, r2, #31
 8002df4:	ea42 124c 	orr.w	r2, r2, ip, lsl #5
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OSP, conf->os_pres);
 8002df8:	f022 021c 	bic.w	r2, r2, #28
 8002dfc:	ea42 028e 	orr.w	r2, r2, lr, lsl #2
 8002e00:	f88d 200f 	strb.w	r2, [sp, #15]
            data_array[1] = BME68X_SET_BITS_POS_0(data_array[1], BME68X_OSH, conf->os_hum);
 8002e04:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8002e08:	f022 0207 	bic.w	r2, r2, #7
 8002e0c:	4310      	orrs	r0, r2
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_FILTER, conf->filter);
 8002e0e:	f89d 2010 	ldrb.w	r2, [sp, #16]
            data_array[1] = BME68X_SET_BITS_POS_0(data_array[1], BME68X_OSH, conf->os_hum);
 8002e12:	f88d 000d 	strb.w	r0, [sp, #13]
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_FILTER, conf->filter);
 8002e16:	f022 021c 	bic.w	r2, r2, #28
 8002e1a:	ea42 0281 	orr.w	r2, r2, r1, lsl #2
            if (conf->odr != BME68X_ODR_NONE)
 8002e1e:	2b08      	cmp	r3, #8
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_FILTER, conf->filter);
 8002e20:	b2d2      	uxtb	r2, r2
            if (conf->odr != BME68X_ODR_NONE)
 8002e22:	f000 812a 	beq.w	800307a <bme68x_set_conf+0x3f2>
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_ODR20, odr20);
 8002e26:	015b      	lsls	r3, r3, #5
 8002e28:	b2db      	uxtb	r3, r3
 8002e2a:	2100      	movs	r1, #0
 8002e2c:	f002 021f 	and.w	r2, r2, #31
 8002e30:	4313      	orrs	r3, r2
 8002e32:	f88d 3010 	strb.w	r3, [sp, #16]
            data_array[0] = BME68X_SET_BITS(data_array[0], BME68X_ODR3, odr3);
 8002e36:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8002e3a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8002e3e:	4319      	orrs	r1, r3
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 8002e40:	2300      	movs	r3, #0
 8002e42:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8002e46:	e9cd 3307 	strd	r3, r3, [sp, #28]
            data_array[0] = BME68X_SET_BITS(data_array[0], BME68X_ODR3, odr3);
 8002e4a:	f88d 100c 	strb.w	r1, [sp, #12]
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 8002e4e:	9309      	str	r3, [sp, #36]	@ 0x24
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002e50:	2d00      	cmp	r5, #0
 8002e52:	f000 808b 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002e56:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 8002e58:	2e00      	cmp	r6, #0
 8002e5a:	f000 8087 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8002e5e:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8002e60:	2a00      	cmp	r2, #0
 8002e62:	f000 8083 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
                if (dev->intf == BME68X_SPI_INTF)
 8002e66:	7b22      	ldrb	r2, [r4, #12]
 8002e68:	2a00      	cmp	r2, #0
 8002e6a:	f000 80cb 	beq.w	8003004 <bme68x_set_conf+0x37c>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002e6e:	2271      	movs	r2, #113	@ 0x71
 8002e70:	f88d 2014 	strb.w	r2, [sp, #20]
            for (index = 0; index < len; index++)
 8002e74:	2201      	movs	r2, #1
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002e76:	f88d 1015 	strb.w	r1, [sp, #21]
    int8_t rslt = BME68X_OK;
 8002e7a:	461d      	mov	r5, r3
            for (index = 0; index < len; index++)
 8002e7c:	4610      	mov	r0, r2
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002e7e:	f100 0328 	add.w	r3, r0, #40	@ 0x28
 8002e82:	f102 0129 	add.w	r1, r2, #41	@ 0x29
 8002e86:	eb0d 0003 	add.w	r0, sp, r3
 8002e8a:	eb0d 0601 	add.w	r6, sp, r1
            for (index = 0; index < len; index++)
 8002e8e:	1c53      	adds	r3, r2, #1
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002e90:	a90a      	add	r1, sp, #40	@ 0x28
 8002e92:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 8002e96:	ab0a      	add	r3, sp, #40	@ 0x28
 8002e98:	eb03 0742 	add.w	r7, r3, r2, lsl #1
 8002e9c:	f810 3c1c 	ldrb.w	r3, [r0, #-28]
 8002ea0:	f807 3c13 	strb.w	r3, [r7, #-19]
            for (index = 0; index < len; index++)
 8002ea4:	2a03      	cmp	r2, #3
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002ea6:	f816 3c1c 	ldrb.w	r3, [r6, #-28]
 8002eaa:	f801 3c13 	strb.w	r3, [r1, #-19]
            for (index = 0; index < len; index++)
 8002eae:	f102 0302 	add.w	r3, r2, #2
 8002eb2:	f000 81f8 	beq.w	80032a6 <bme68x_set_conf+0x61e>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002eb6:	f103 0c28 	add.w	ip, r3, #40	@ 0x28
 8002eba:	44ec      	add	ip, sp
 8002ebc:	f10d 0e28 	add.w	lr, sp, #40	@ 0x28
 8002ec0:	eb0e 0e43 	add.w	lr, lr, r3, lsl #1
 8002ec4:	f81c 9c1c 	ldrb.w	r9, [ip, #-28]
 8002ec8:	f80e 9c13 	strb.w	r9, [lr, #-19]
            for (index = 0; index < len; index++)
 8002ecc:	2a02      	cmp	r2, #2
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002ece:	ea4f 0343 	mov.w	r3, r3, lsl #1
            for (index = 0; index < len; index++)
 8002ed2:	f000 81f5 	beq.w	80032c0 <bme68x_set_conf+0x638>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002ed6:	f810 ec24 	ldrb.w	lr, [r0, #-36]
                    tmp_buff[(2 * index)] = reg_addr[index];
 8002eda:	f816 0c24 	ldrb.w	r0, [r6, #-36]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8002ede:	f89d 6010 	ldrb.w	r6, [sp, #16]
 8002ee2:	f88d 601d 	strb.w	r6, [sp, #29]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002ee6:	f807 ec14 	strb.w	lr, [r7, #-20]
 8002eea:	3328      	adds	r3, #40	@ 0x28
 8002eec:	446b      	add	r3, sp
 8002eee:	f801 0c14 	strb.w	r0, [r1, #-20]
            for (index = 0; index < len; index++)
 8002ef2:	2a02      	cmp	r2, #2
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8002ef4:	f81c 1c24 	ldrb.w	r1, [ip, #-36]
 8002ef8:	f803 1c14 	strb.w	r1, [r3, #-20]
 8002efc:	bf1c      	itt	ne
 8002efe:	f89d 3008 	ldrbne.w	r3, [sp, #8]
 8002f02:	f88d 301c 	strbne.w	r3, [sp, #28]
            if (rslt == BME68X_OK)
 8002f06:	2d00      	cmp	r5, #0
 8002f08:	f47f aeed 	bne.w	8002ce6 <bme68x_set_conf+0x5e>
 8002f0c:	6c66      	ldr	r6, [r4, #68]	@ 0x44
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 8002f0e:	6863      	ldr	r3, [r4, #4]
 8002f10:	f89d 0014 	ldrb.w	r0, [sp, #20]
 8002f14:	2209      	movs	r2, #9
 8002f16:	f10d 0115 	add.w	r1, sp, #21
 8002f1a:	47b0      	blx	r6
 8002f1c:	4605      	mov	r5, r0
 8002f1e:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 8002f22:	2800      	cmp	r0, #0
 8002f24:	d168      	bne.n	8002ff8 <bme68x_set_conf+0x370>
    if ((current_op_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK))
 8002f26:	f018 0003 	ands.w	r0, r8, #3
 8002f2a:	f43f aedc 	beq.w	8002ce6 <bme68x_set_conf+0x5e>
        rslt = bme68x_set_op_mode(current_op_mode, dev);
 8002f2e:	4621      	mov	r1, r4
 8002f30:	f7ff fe44 	bl	8002bbc <bme68x_set_op_mode>
 8002f34:	4605      	mov	r5, r0
}
 8002f36:	4628      	mov	r0, r5
 8002f38:	b00b      	add	sp, #44	@ 0x2c
 8002f3a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            rslt = set_mem_page(reg_addr, dev);
 8002f3e:	4621      	mov	r1, r4
 8002f40:	2074      	movs	r0, #116	@ 0x74
 8002f42:	f7ff fa67 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8002f46:	4605      	mov	r5, r0
 8002f48:	b910      	cbnz	r0, 8002f50 <bme68x_set_conf+0x2c8>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002f4a:	6c25      	ldr	r5, [r4, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8002f4c:	20f4      	movs	r0, #244	@ 0xf4
 8002f4e:	e6be      	b.n	8002cce <bme68x_set_conf+0x46>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002f50:	6c27      	ldr	r7, [r4, #64]	@ 0x40
 8002f52:	6863      	ldr	r3, [r4, #4]
 8002f54:	2201      	movs	r2, #1
 8002f56:	a905      	add	r1, sp, #20
 8002f58:	2074      	movs	r0, #116	@ 0x74
 8002f5a:	47b8      	blx	r7
 8002f5c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002f60:	2800      	cmp	r0, #0
 8002f62:	f47f aebb 	bne.w	8002cdc <bme68x_set_conf+0x54>
    if (conf == NULL)
 8002f66:	2e00      	cmp	r6, #0
 8002f68:	f47f aebd 	bne.w	8002ce6 <bme68x_set_conf+0x5e>
        rslt = BME68X_E_NULL_PTR;
 8002f6c:	f04f 35ff 	mov.w	r5, #4294967295
 8002f70:	e6b9      	b.n	8002ce6 <bme68x_set_conf+0x5e>
            rslt = set_mem_page(reg_addr, dev);
 8002f72:	4621      	mov	r1, r4
 8002f74:	2071      	movs	r0, #113	@ 0x71
 8002f76:	f7ff fa4d 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8002f7a:	4605      	mov	r5, r0
 8002f7c:	2800      	cmp	r0, #0
 8002f7e:	d03e      	beq.n	8002ffe <bme68x_set_conf+0x376>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002f80:	6c26      	ldr	r6, [r4, #64]	@ 0x40
 8002f82:	6863      	ldr	r3, [r4, #4]
 8002f84:	2205      	movs	r2, #5
 8002f86:	a903      	add	r1, sp, #12
 8002f88:	2071      	movs	r0, #113	@ 0x71
 8002f8a:	47b0      	blx	r6
 8002f8c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8002f90:	2800      	cmp	r0, #0
 8002f92:	d12e      	bne.n	8002ff2 <bme68x_set_conf+0x36a>
        dev->info_msg = BME68X_OK;
 8002f94:	f884 004d 	strb.w	r0, [r4, #77]	@ 0x4d
    return rslt;
 8002f98:	e6a5      	b.n	8002ce6 <bme68x_set_conf+0x5e>
 8002f9a:	bf00      	nop
 8002f9c:	08016afc 	.word	0x08016afc
            *value = max;
 8002fa0:	2107      	movs	r1, #7
 8002fa2:	70f1      	strb	r1, [r6, #3]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002fa4:	f894 304d 	ldrb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002fa8:	6c25      	ldr	r5, [r4, #64]	@ 0x40
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002faa:	f043 0301 	orr.w	r3, r3, #1
 8002fae:	f884 304d 	strb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002fb2:	2d00      	cmp	r5, #0
 8002fb4:	d0da      	beq.n	8002f6c <bme68x_set_conf+0x2e4>
 8002fb6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002fb8:	2b00      	cmp	r3, #0
 8002fba:	d0d7      	beq.n	8002f6c <bme68x_set_conf+0x2e4>
 8002fbc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002fbe:	2b00      	cmp	r3, #0
 8002fc0:	d0d4      	beq.n	8002f6c <bme68x_set_conf+0x2e4>
        if (*value > max)
 8002fc2:	f896 c001 	ldrb.w	ip, [r6, #1]
 8002fc6:	f1bc 0f05 	cmp.w	ip, #5
 8002fca:	f67f aed1 	bls.w	8002d70 <bme68x_set_conf+0xe8>
            *value = max;
 8002fce:	f04f 0c05 	mov.w	ip, #5
 8002fd2:	f886 c001 	strb.w	ip, [r6, #1]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002fd6:	f894 304d 	ldrb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002fda:	6c25      	ldr	r5, [r4, #64]	@ 0x40
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8002fdc:	f043 0301 	orr.w	r3, r3, #1
 8002fe0:	f884 304d 	strb.w	r3, [r4, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8002fe4:	2d00      	cmp	r5, #0
 8002fe6:	d0c1      	beq.n	8002f6c <bme68x_set_conf+0x2e4>
 8002fe8:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8002fea:	2b00      	cmp	r3, #0
 8002fec:	d0be      	beq.n	8002f6c <bme68x_set_conf+0x2e4>
 8002fee:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8002ff0:	e6bb      	b.n	8002d6a <bme68x_set_conf+0xe2>
        dev->info_msg = BME68X_OK;
 8002ff2:	2300      	movs	r3, #0
 8002ff4:	f884 304d 	strb.w	r3, [r4, #77]	@ 0x4d
                    rslt = BME68X_E_COM_FAIL;
 8002ff8:	f06f 0501 	mvn.w	r5, #1
 8002ffc:	e673      	b.n	8002ce6 <bme68x_set_conf+0x5e>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8002ffe:	6c25      	ldr	r5, [r4, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8003000:	20f1      	movs	r0, #241	@ 0xf1
 8003002:	e690      	b.n	8002d26 <bme68x_set_conf+0x9e>
        if (mem_page != dev->mem_page)
 8003004:	7b63      	ldrb	r3, [r4, #13]
 8003006:	2b10      	cmp	r3, #16
 8003008:	f000 8161 	beq.w	80032ce <bme68x_set_conf+0x646>
            dev->mem_page = mem_page;
 800300c:	2310      	movs	r3, #16
 800300e:	7363      	strb	r3, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8003010:	2201      	movs	r2, #1
 8003012:	6863      	ldr	r3, [r4, #4]
 8003014:	f10d 0103 	add.w	r1, sp, #3
 8003018:	20f3      	movs	r0, #243	@ 0xf3
 800301a:	47a8      	blx	r5
 800301c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 8003020:	2800      	cmp	r0, #0
 8003022:	f040 815a 	bne.w	80032da <bme68x_set_conf+0x652>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8003026:	f89d 3003 	ldrb.w	r3, [sp, #3]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 800302a:	7b62      	ldrb	r2, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 800302c:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 800302e:	f002 0210 	and.w	r2, r2, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8003032:	f023 0310 	bic.w	r3, r3, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8003036:	4313      	orrs	r3, r2
 8003038:	f88d 3003 	strb.w	r3, [sp, #3]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 800303c:	f10d 0103 	add.w	r1, sp, #3
 8003040:	6863      	ldr	r3, [r4, #4]
 8003042:	2201      	movs	r2, #1
 8003044:	2073      	movs	r0, #115	@ 0x73
 8003046:	47a8      	blx	r5
 8003048:	4605      	mov	r5, r0
 800304a:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 800304e:	2800      	cmp	r0, #0
 8003050:	f040 8143 	bne.w	80032da <bme68x_set_conf+0x652>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8003054:	2371      	movs	r3, #113	@ 0x71
                if (dev->intf == BME68X_SPI_INTF)
 8003056:	7b22      	ldrb	r2, [r4, #12]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8003058:	f88d 3014 	strb.w	r3, [sp, #20]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800305c:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8003060:	f88d 3015 	strb.w	r3, [sp, #21]
                if (dev->intf == BME68X_SPI_INTF)
 8003064:	b17a      	cbz	r2, 8003086 <bme68x_set_conf+0x3fe>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8003066:	2272      	movs	r2, #114	@ 0x72
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8003068:	f89d 300d 	ldrb.w	r3, [sp, #13]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 800306c:	f88d 2016 	strb.w	r2, [sp, #22]
            for (index = 0; index < len; index++)
 8003070:	2202      	movs	r2, #2
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8003072:	f88d 3017 	strb.w	r3, [sp, #23]
            for (index = 0; index < len; index++)
 8003076:	4610      	mov	r0, r2
 8003078:	e701      	b.n	8002e7e <bme68x_set_conf+0x1f6>
 800307a:	2180      	movs	r1, #128	@ 0x80
 800307c:	2300      	movs	r3, #0
 800307e:	e6d5      	b.n	8002e2c <bme68x_set_conf+0x1a4>
        rslt = BME68X_E_NULL_PTR;
 8003080:	f04f 35ff 	mov.w	r5, #4294967295
 8003084:	e62c      	b.n	8002ce0 <bme68x_set_conf+0x58>
 8003086:	6c25      	ldr	r5, [r4, #64]	@ 0x40
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003088:	2d00      	cmp	r5, #0
 800308a:	f43f af6f 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 800308e:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 8003090:	2e00      	cmp	r6, #0
 8003092:	f000 8131 	beq.w	80032f8 <bme68x_set_conf+0x670>
 8003096:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8003098:	2b00      	cmp	r3, #0
 800309a:	f000 812d 	beq.w	80032f8 <bme68x_set_conf+0x670>
        if (mem_page != dev->mem_page)
 800309e:	7b63      	ldrb	r3, [r4, #13]
 80030a0:	2b10      	cmp	r3, #16
 80030a2:	d023      	beq.n	80030ec <bme68x_set_conf+0x464>
            dev->mem_page = mem_page;
 80030a4:	2310      	movs	r3, #16
 80030a6:	7363      	strb	r3, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 80030a8:	2201      	movs	r2, #1
 80030aa:	6863      	ldr	r3, [r4, #4]
 80030ac:	f10d 0103 	add.w	r1, sp, #3
 80030b0:	20f3      	movs	r0, #243	@ 0xf3
 80030b2:	47a8      	blx	r5
 80030b4:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 80030b8:	2800      	cmp	r0, #0
 80030ba:	f040 8115 	bne.w	80032e8 <bme68x_set_conf+0x660>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 80030be:	f89d 3003 	ldrb.w	r3, [sp, #3]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80030c2:	7b62      	ldrb	r2, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 80030c4:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80030c6:	f002 0210 	and.w	r2, r2, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 80030ca:	f023 0310 	bic.w	r3, r3, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80030ce:	4313      	orrs	r3, r2
 80030d0:	f88d 3003 	strb.w	r3, [sp, #3]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 80030d4:	f10d 0103 	add.w	r1, sp, #3
 80030d8:	6863      	ldr	r3, [r4, #4]
 80030da:	2201      	movs	r2, #1
 80030dc:	2073      	movs	r0, #115	@ 0x73
 80030de:	47a8      	blx	r5
 80030e0:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 80030e4:	2800      	cmp	r0, #0
 80030e6:	f040 80ff 	bne.w	80032e8 <bme68x_set_conf+0x660>
 80030ea:	7b22      	ldrb	r2, [r4, #12]
    int8_t rslt = BME68X_OK;
 80030ec:	2500      	movs	r5, #0
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80030ee:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80030f2:	f88d 3017 	strb.w	r3, [sp, #23]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80030f6:	2372      	movs	r3, #114	@ 0x72
 80030f8:	f88d 3016 	strb.w	r3, [sp, #22]
                if (dev->intf == BME68X_SPI_INTF)
 80030fc:	b14a      	cbz	r2, 8003112 <bme68x_set_conf+0x48a>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80030fe:	2273      	movs	r2, #115	@ 0x73
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8003100:	f89d 300e 	ldrb.w	r3, [sp, #14]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8003104:	f88d 2018 	strb.w	r2, [sp, #24]
            for (index = 0; index < len; index++)
 8003108:	2203      	movs	r2, #3
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800310a:	f88d 3019 	strb.w	r3, [sp, #25]
            for (index = 0; index < len; index++)
 800310e:	4610      	mov	r0, r2
 8003110:	e6b5      	b.n	8002e7e <bme68x_set_conf+0x1f6>
 8003112:	6c25      	ldr	r5, [r4, #64]	@ 0x40
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003114:	2d00      	cmp	r5, #0
 8003116:	f43f af29 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 800311a:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 800311c:	2e00      	cmp	r6, #0
 800311e:	f000 80ee 	beq.w	80032fe <bme68x_set_conf+0x676>
 8003122:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8003124:	2b00      	cmp	r3, #0
 8003126:	f000 80ea 	beq.w	80032fe <bme68x_set_conf+0x676>
        if (mem_page != dev->mem_page)
 800312a:	7b63      	ldrb	r3, [r4, #13]
 800312c:	2b10      	cmp	r3, #16
 800312e:	d023      	beq.n	8003178 <bme68x_set_conf+0x4f0>
            dev->mem_page = mem_page;
 8003130:	2310      	movs	r3, #16
 8003132:	7363      	strb	r3, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8003134:	2201      	movs	r2, #1
 8003136:	6863      	ldr	r3, [r4, #4]
 8003138:	f10d 0103 	add.w	r1, sp, #3
 800313c:	20f3      	movs	r0, #243	@ 0xf3
 800313e:	47a8      	blx	r5
 8003140:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 8003144:	2800      	cmp	r0, #0
 8003146:	f040 80d3 	bne.w	80032f0 <bme68x_set_conf+0x668>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 800314a:	f89d 3003 	ldrb.w	r3, [sp, #3]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 800314e:	7b62      	ldrb	r2, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8003150:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8003152:	f002 0210 	and.w	r2, r2, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8003156:	f023 0310 	bic.w	r3, r3, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 800315a:	4313      	orrs	r3, r2
 800315c:	f88d 3003 	strb.w	r3, [sp, #3]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8003160:	f10d 0103 	add.w	r1, sp, #3
 8003164:	6863      	ldr	r3, [r4, #4]
 8003166:	2201      	movs	r2, #1
 8003168:	2073      	movs	r0, #115	@ 0x73
 800316a:	47a8      	blx	r5
 800316c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 8003170:	2800      	cmp	r0, #0
 8003172:	f040 80bd 	bne.w	80032f0 <bme68x_set_conf+0x668>
 8003176:	7b22      	ldrb	r2, [r4, #12]
    int8_t rslt = BME68X_OK;
 8003178:	2500      	movs	r5, #0
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800317a:	f89d 300e 	ldrb.w	r3, [sp, #14]
 800317e:	f88d 3019 	strb.w	r3, [sp, #25]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8003182:	f04f 0973 	mov.w	r9, #115	@ 0x73
 8003186:	f88d 9018 	strb.w	r9, [sp, #24]
                if (dev->intf == BME68X_SPI_INTF)
 800318a:	b17a      	cbz	r2, 80031ac <bme68x_set_conf+0x524>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800318c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8003190:	f89d 2010 	ldrb.w	r2, [sp, #16]
 8003194:	f88d 301b 	strb.w	r3, [sp, #27]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8003198:	2174      	movs	r1, #116	@ 0x74
 800319a:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800319e:	f88d 101a 	strb.w	r1, [sp, #26]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80031a2:	f88d 201d 	strb.w	r2, [sp, #29]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80031a6:	f88d 301c 	strb.w	r3, [sp, #28]
            for (index = 0; index < len; index++)
 80031aa:	e6ac      	b.n	8002f06 <bme68x_set_conf+0x27e>
 80031ac:	6c25      	ldr	r5, [r4, #64]	@ 0x40
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80031ae:	2d00      	cmp	r5, #0
 80031b0:	f43f aedc 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 80031b4:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 80031b6:	2e00      	cmp	r6, #0
 80031b8:	f000 80a4 	beq.w	8003304 <bme68x_set_conf+0x67c>
 80031bc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80031be:	2b00      	cmp	r3, #0
 80031c0:	f000 80a0 	beq.w	8003304 <bme68x_set_conf+0x67c>
        if (mem_page != dev->mem_page)
 80031c4:	7b63      	ldrb	r3, [r4, #13]
 80031c6:	2b10      	cmp	r3, #16
 80031c8:	d021      	beq.n	800320e <bme68x_set_conf+0x586>
            dev->mem_page = mem_page;
 80031ca:	2310      	movs	r3, #16
 80031cc:	7363      	strb	r3, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 80031ce:	2201      	movs	r2, #1
 80031d0:	6863      	ldr	r3, [r4, #4]
 80031d2:	f10d 0103 	add.w	r1, sp, #3
 80031d6:	20f3      	movs	r0, #243	@ 0xf3
 80031d8:	47a8      	blx	r5
 80031da:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 80031de:	2800      	cmp	r0, #0
 80031e0:	d17e      	bne.n	80032e0 <bme68x_set_conf+0x658>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 80031e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80031e6:	7b62      	ldrb	r2, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 80031e8:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80031ea:	f002 0210 	and.w	r2, r2, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 80031ee:	f023 0310 	bic.w	r3, r3, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80031f2:	4313      	orrs	r3, r2
 80031f4:	f88d 3003 	strb.w	r3, [sp, #3]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 80031f8:	f10d 0103 	add.w	r1, sp, #3
 80031fc:	6863      	ldr	r3, [r4, #4]
 80031fe:	4648      	mov	r0, r9
 8003200:	2201      	movs	r2, #1
 8003202:	47a8      	blx	r5
 8003204:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 8003208:	2800      	cmp	r0, #0
 800320a:	d169      	bne.n	80032e0 <bme68x_set_conf+0x658>
 800320c:	7b22      	ldrb	r2, [r4, #12]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 800320e:	2374      	movs	r3, #116	@ 0x74
 8003210:	f88d 301a 	strb.w	r3, [sp, #26]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8003214:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8003218:	f88d 301b 	strb.w	r3, [sp, #27]
                if (dev->intf == BME68X_SPI_INTF)
 800321c:	b142      	cbz	r2, 8003230 <bme68x_set_conf+0x5a8>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800321e:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8003222:	f88d 301d 	strb.w	r3, [sp, #29]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8003226:	2275      	movs	r2, #117	@ 0x75
 8003228:	f88d 201c 	strb.w	r2, [sp, #28]
            for (index = 0; index < len; index++)
 800322c:	463d      	mov	r5, r7
 800322e:	e66a      	b.n	8002f06 <bme68x_set_conf+0x27e>
 8003230:	6c25      	ldr	r5, [r4, #64]	@ 0x40
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003232:	2d00      	cmp	r5, #0
 8003234:	f43f ae9a 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8003238:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 800323a:	2e00      	cmp	r6, #0
 800323c:	f43f ae96 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
 8003240:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8003242:	2b00      	cmp	r3, #0
 8003244:	f43f ae92 	beq.w	8002f6c <bme68x_set_conf+0x2e4>
        if (mem_page != dev->mem_page)
 8003248:	7b63      	ldrb	r3, [r4, #13]
 800324a:	2b10      	cmp	r3, #16
 800324c:	d023      	beq.n	8003296 <bme68x_set_conf+0x60e>
            dev->mem_page = mem_page;
 800324e:	2310      	movs	r3, #16
 8003250:	7363      	strb	r3, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8003252:	2201      	movs	r2, #1
 8003254:	6863      	ldr	r3, [r4, #4]
 8003256:	f10d 0103 	add.w	r1, sp, #3
 800325a:	20f3      	movs	r0, #243	@ 0xf3
 800325c:	47a8      	blx	r5
 800325e:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 8003262:	2800      	cmp	r0, #0
 8003264:	f47f aec8 	bne.w	8002ff8 <bme68x_set_conf+0x370>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8003268:	f89d 3003 	ldrb.w	r3, [sp, #3]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 800326c:	7b62      	ldrb	r2, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 800326e:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8003270:	f002 0210 	and.w	r2, r2, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8003274:	f023 0310 	bic.w	r3, r3, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8003278:	4313      	orrs	r3, r2
 800327a:	f88d 3003 	strb.w	r3, [sp, #3]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 800327e:	f10d 0103 	add.w	r1, sp, #3
 8003282:	6863      	ldr	r3, [r4, #4]
 8003284:	2201      	movs	r2, #1
 8003286:	2073      	movs	r0, #115	@ 0x73
 8003288:	47a8      	blx	r5
 800328a:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 800328e:	2800      	cmp	r0, #0
 8003290:	f47f aeb2 	bne.w	8002ff8 <bme68x_set_conf+0x370>
 8003294:	6c66      	ldr	r6, [r4, #68]	@ 0x44
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8003296:	f89d 3010 	ldrb.w	r3, [sp, #16]
 800329a:	f88d 301d 	strb.w	r3, [sp, #29]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 800329e:	2275      	movs	r2, #117	@ 0x75
 80032a0:	f88d 201c 	strb.w	r2, [sp, #28]
            if (rslt == BME68X_OK)
 80032a4:	e633      	b.n	8002f0e <bme68x_set_conf+0x286>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80032a6:	f810 3c24 	ldrb.w	r3, [r0, #-36]
 80032aa:	f807 3c14 	strb.w	r3, [r7, #-20]
 80032ae:	f816 3c24 	ldrb.w	r3, [r6, #-36]
 80032b2:	f801 3c14 	strb.w	r3, [r1, #-20]
            for (index = 0; index < len; index++)
 80032b6:	e626      	b.n	8002f06 <bme68x_set_conf+0x27e>
        dev->info_msg = BME68X_OK;
 80032b8:	2300      	movs	r3, #0
 80032ba:	f884 304d 	strb.w	r3, [r4, #77]	@ 0x4d
        if (rslt == BME68X_OK)
 80032be:	e655      	b.n	8002f6c <bme68x_set_conf+0x2e4>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80032c0:	f810 0c24 	ldrb.w	r0, [r0, #-36]
 80032c4:	f807 0c14 	strb.w	r0, [r7, #-20]
                    tmp_buff[(2 * index)] = reg_addr[index];
 80032c8:	f816 0c24 	ldrb.w	r0, [r6, #-36]
            for (index = 0; index < len; index++)
 80032cc:	e60d      	b.n	8002eea <bme68x_set_conf+0x262>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80032ce:	2371      	movs	r3, #113	@ 0x71
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80032d0:	f88d 1015 	strb.w	r1, [sp, #21]
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80032d4:	f88d 3014 	strb.w	r3, [sp, #20]
                if (dev->intf == BME68X_SPI_INTF)
 80032d8:	e6d6      	b.n	8003088 <bme68x_set_conf+0x400>
                rslt = BME68X_E_COM_FAIL;
 80032da:	f06f 0501 	mvn.w	r5, #1
 80032de:	e6b9      	b.n	8003054 <bme68x_set_conf+0x3cc>
 80032e0:	7b22      	ldrb	r2, [r4, #12]
 80032e2:	f06f 0701 	mvn.w	r7, #1
 80032e6:	e792      	b.n	800320e <bme68x_set_conf+0x586>
 80032e8:	7b22      	ldrb	r2, [r4, #12]
 80032ea:	f06f 0501 	mvn.w	r5, #1
 80032ee:	e6fe      	b.n	80030ee <bme68x_set_conf+0x466>
 80032f0:	7b22      	ldrb	r2, [r4, #12]
 80032f2:	f06f 0501 	mvn.w	r5, #1
 80032f6:	e740      	b.n	800317a <bme68x_set_conf+0x4f2>
        rslt = BME68X_E_NULL_PTR;
 80032f8:	f04f 35ff 	mov.w	r5, #4294967295
 80032fc:	e6f7      	b.n	80030ee <bme68x_set_conf+0x466>
 80032fe:	f04f 35ff 	mov.w	r5, #4294967295
 8003302:	e73a      	b.n	800317a <bme68x_set_conf+0x4f2>
 8003304:	f04f 37ff 	mov.w	r7, #4294967295
 8003308:	e781      	b.n	800320e <bme68x_set_conf+0x586>
 800330a:	bf00      	nop

0800330c <bme68x_get_meas_dur>:
{
 800330c:	b510      	push	{r4, lr}
    uint8_t os_to_meas_cycles[6] = { 0, 1, 2, 4, 8, 16 };
 800330e:	4b3a      	ldr	r3, [pc, #232]	@ (80033f8 <bme68x_get_meas_dur+0xec>)
{
 8003310:	4684      	mov	ip, r0
 8003312:	460c      	mov	r4, r1
    uint8_t os_to_meas_cycles[6] = { 0, 1, 2, 4, 8, 16 };
 8003314:	e893 0003 	ldmia.w	r3, {r0, r1}
{
 8003318:	b082      	sub	sp, #8
    uint8_t os_to_meas_cycles[6] = { 0, 1, 2, 4, 8, 16 };
 800331a:	9000      	str	r0, [sp, #0]
 800331c:	f8ad 1004 	strh.w	r1, [sp, #4]
    if (conf != NULL)
 8003320:	2c00      	cmp	r4, #0
 8003322:	d05c      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003324:	2a00      	cmp	r2, #0
 8003326:	d05a      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
 8003328:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800332a:	2b00      	cmp	r3, #0
 800332c:	d057      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
 800332e:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 8003330:	2b00      	cmp	r3, #0
 8003332:	d054      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
 8003334:	4621      	mov	r1, r4
 8003336:	6c94      	ldr	r4, [r2, #72]	@ 0x48
 8003338:	2c00      	cmp	r4, #0
 800333a:	d050      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
        if (*value > max)
 800333c:	7848      	ldrb	r0, [r1, #1]
 800333e:	2805      	cmp	r0, #5
 8003340:	d949      	bls.n	80033d6 <bme68x_get_meas_dur+0xca>
            *value = max;
 8003342:	2305      	movs	r3, #5
 8003344:	704b      	strb	r3, [r1, #1]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8003346:	f892 304d 	ldrb.w	r3, [r2, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800334a:	6c10      	ldr	r0, [r2, #64]	@ 0x40
            dev->info_msg |= BME68X_I_PARAM_CORR;
 800334c:	f043 0301 	orr.w	r3, r3, #1
 8003350:	f882 304d 	strb.w	r3, [r2, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003354:	2800      	cmp	r0, #0
 8003356:	d042      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
 8003358:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800335a:	2b00      	cmp	r3, #0
 800335c:	d03f      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
 800335e:	6c93      	ldr	r3, [r2, #72]	@ 0x48
 8003360:	2b00      	cmp	r3, #0
 8003362:	d03c      	beq.n	80033de <bme68x_get_meas_dur+0xd2>
        if (*value > max)
 8003364:	788b      	ldrb	r3, [r1, #2]
 8003366:	2b05      	cmp	r3, #5
 8003368:	f04f 0005 	mov.w	r0, #5
 800336c:	d90d      	bls.n	800338a <bme68x_get_meas_dur+0x7e>
            *value = max;
 800336e:	2305      	movs	r3, #5
 8003370:	708b      	strb	r3, [r1, #2]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 8003372:	f892 404d 	ldrb.w	r4, [r2, #77]	@ 0x4d
 8003376:	f044 0401 	orr.w	r4, r4, #1
 800337a:	f882 404d 	strb.w	r4, [r2, #77]	@ 0x4d
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800337e:	6c14      	ldr	r4, [r2, #64]	@ 0x40
 8003380:	b36c      	cbz	r4, 80033de <bme68x_get_meas_dur+0xd2>
 8003382:	6c54      	ldr	r4, [r2, #68]	@ 0x44
 8003384:	b35c      	cbz	r4, 80033de <bme68x_get_meas_dur+0xd2>
 8003386:	6c94      	ldr	r4, [r2, #72]	@ 0x48
 8003388:	b34c      	cbz	r4, 80033de <bme68x_get_meas_dur+0xd2>
        if (*value > max)
 800338a:	f891 e000 	ldrb.w	lr, [r1]
 800338e:	f1be 0f05 	cmp.w	lr, #5
 8003392:	d827      	bhi.n	80033e4 <bme68x_get_meas_dur+0xd8>
            meas_cycles += os_to_meas_cycles[conf->os_hum];
 8003394:	f10e 0208 	add.w	r2, lr, #8
 8003398:	eb0d 0e02 	add.w	lr, sp, r2
 800339c:	f81e 1c08 	ldrb.w	r1, [lr, #-8]
            meas_cycles = os_to_meas_cycles[conf->os_temp];
 80033a0:	f100 0208 	add.w	r2, r0, #8
            meas_cycles += os_to_meas_cycles[conf->os_pres];
 80033a4:	3308      	adds	r3, #8
            meas_cycles = os_to_meas_cycles[conf->os_temp];
 80033a6:	eb0d 0002 	add.w	r0, sp, r2
            meas_cycles += os_to_meas_cycles[conf->os_pres];
 80033aa:	446b      	add	r3, sp
            meas_cycles = os_to_meas_cycles[conf->os_temp];
 80033ac:	f810 0c08 	ldrb.w	r0, [r0, #-8]
            meas_cycles += os_to_meas_cycles[conf->os_pres];
 80033b0:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 80033b4:	4403      	add	r3, r0
            meas_dur = meas_cycles * UINT32_C(1963);
 80033b6:	f240 72ab 	movw	r2, #1963	@ 0x7ab
            meas_cycles += os_to_meas_cycles[conf->os_hum];
 80033ba:	440b      	add	r3, r1
            if (op_mode != BME68X_PARALLEL_MODE)
 80033bc:	f1bc 0f02 	cmp.w	ip, #2
            meas_dur = meas_cycles * UINT32_C(1963);
 80033c0:	fb02 f303 	mul.w	r3, r2, r3
            meas_dur += UINT32_C(477 * 5); /* Gas measurement duration */
 80033c4:	bf0b      	itete	eq
 80033c6:	f503 5086 	addeq.w	r0, r3, #4288	@ 0x10c0
                meas_dur += UINT32_C(1000); /* Wake up duration of 1ms */
 80033ca:	f503 50a5 	addne.w	r0, r3, #5280	@ 0x14a0
            meas_dur += UINT32_C(477 * 5); /* Gas measurement duration */
 80033ce:	3005      	addeq	r0, #5
                meas_dur += UINT32_C(1000); /* Wake up duration of 1ms */
 80033d0:	300d      	addne	r0, #13
}
 80033d2:	b002      	add	sp, #8
 80033d4:	bd10      	pop	{r4, pc}
        if (*value > max)
 80033d6:	788b      	ldrb	r3, [r1, #2]
 80033d8:	2b05      	cmp	r3, #5
 80033da:	d8c8      	bhi.n	800336e <bme68x_get_meas_dur+0x62>
 80033dc:	e7d4      	b.n	8003388 <bme68x_get_meas_dur+0x7c>
    uint32_t meas_dur = 0; /* Calculate in us */
 80033de:	2000      	movs	r0, #0
}
 80033e0:	b002      	add	sp, #8
 80033e2:	bd10      	pop	{r4, pc}
            *value = max;
 80033e4:	2405      	movs	r4, #5
 80033e6:	700c      	strb	r4, [r1, #0]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 80033e8:	f892 104d 	ldrb.w	r1, [r2, #77]	@ 0x4d
 80033ec:	f041 0101 	orr.w	r1, r1, #1
 80033f0:	f882 104d 	strb.w	r1, [r2, #77]	@ 0x4d
 80033f4:	2110      	movs	r1, #16
 80033f6:	e7d3      	b.n	80033a0 <bme68x_get_meas_dur+0x94>
 80033f8:	08016740 	.word	0x08016740

080033fc <bme68x_get_data>:
{
 80033fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003400:	b0d5      	sub	sp, #340	@ 0x154
 8003402:	4606      	mov	r6, r0
 8003404:	460d      	mov	r5, r1
 8003406:	4614      	mov	r4, r2
    struct bme68x_data field_data[3] = { { 0 } };
 8003408:	2100      	movs	r1, #0
 800340a:	223c      	movs	r2, #60	@ 0x3c
 800340c:	a825      	add	r0, sp, #148	@ 0x94
{
 800340e:	469b      	mov	fp, r3
    struct bme68x_data field_data[3] = { { 0 } };
 8003410:	f012 fe5a 	bl	80160c8 <memset>
    field_ptr[0] = &field_data[0];
 8003414:	ab25      	add	r3, sp, #148	@ 0x94
 8003416:	930c      	str	r3, [sp, #48]	@ 0x30
    field_ptr[1] = &field_data[1];
 8003418:	ab2a      	add	r3, sp, #168	@ 0xa8
 800341a:	930d      	str	r3, [sp, #52]	@ 0x34
    field_ptr[2] = &field_data[2];
 800341c:	ab2f      	add	r3, sp, #188	@ 0xbc
 800341e:	930e      	str	r3, [sp, #56]	@ 0x38
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003420:	f1bb 0f00 	cmp.w	fp, #0
 8003424:	f000 8380 	beq.w	8003b28 <bme68x_get_data+0x72c>
 8003428:	f8db 9040 	ldr.w	r9, [fp, #64]	@ 0x40
 800342c:	f1b9 0f00 	cmp.w	r9, #0
 8003430:	f000 837a 	beq.w	8003b28 <bme68x_get_data+0x72c>
 8003434:	f8db 3044 	ldr.w	r3, [fp, #68]	@ 0x44
 8003438:	2b00      	cmp	r3, #0
 800343a:	f000 8375 	beq.w	8003b28 <bme68x_get_data+0x72c>
 800343e:	f8db 3048 	ldr.w	r3, [fp, #72]	@ 0x48
 8003442:	2b00      	cmp	r3, #0
 8003444:	f000 8370 	beq.w	8003b28 <bme68x_get_data+0x72c>
    if ((rslt == BME68X_OK) && (data != NULL))
 8003448:	2d00      	cmp	r5, #0
 800344a:	f000 836d 	beq.w	8003b28 <bme68x_get_data+0x72c>
        if (op_mode == BME68X_FORCED_MODE)
 800344e:	2e01      	cmp	r6, #1
 8003450:	d02f      	beq.n	80034b2 <bme68x_get_data+0xb6>
        else if ((op_mode == BME68X_PARALLEL_MODE) || (op_mode == BME68X_SEQUENTIAL_MODE))
 8003452:	3e02      	subs	r6, #2
 8003454:	2e01      	cmp	r6, #1
    uint8_t buff[BME68X_LEN_FIELD * 3] = { 0 };
 8003456:	f04f 0600 	mov.w	r6, #0
        else if ((op_mode == BME68X_PARALLEL_MODE) || (op_mode == BME68X_SEQUENTIAL_MODE))
 800345a:	d908      	bls.n	800346e <bme68x_get_data+0x72>
            rslt = BME68X_W_DEFINE_OP_MODE;
 800345c:	2701      	movs	r7, #1
        if (n_data == NULL)
 800345e:	2c00      	cmp	r4, #0
 8003460:	f000 8362 	beq.w	8003b28 <bme68x_get_data+0x72c>
            *n_data = new_fields;
 8003464:	7026      	strb	r6, [r4, #0]
}
 8003466:	4638      	mov	r0, r7
 8003468:	b055      	add	sp, #340	@ 0x154
 800346a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint8_t buff[BME68X_LEN_FIELD * 3] = { 0 };
 800346e:	222f      	movs	r2, #47	@ 0x2f
 8003470:	4631      	mov	r1, r6
 8003472:	a819      	add	r0, sp, #100	@ 0x64
 8003474:	9618      	str	r6, [sp, #96]	@ 0x60
 8003476:	f012 fe27 	bl	80160c8 <memset>
        if (dev->intf == BME68X_SPI_INTF)
 800347a:	f89b 300c 	ldrb.w	r3, [fp, #12]
    uint8_t set_val[30] = { 0 }; /* idac, res_heat, gas_wait */
 800347e:	f8ad 605c 	strh.w	r6, [sp, #92]	@ 0x5c
 8003482:	e9cd 6615 	strd	r6, r6, [sp, #84]	@ 0x54
 8003486:	e9cd 6611 	strd	r6, r6, [sp, #68]	@ 0x44
 800348a:	e9cd 6613 	strd	r6, r6, [sp, #76]	@ 0x4c
 800348e:	9610      	str	r6, [sp, #64]	@ 0x40
        if (dev->intf == BME68X_SPI_INTF)
 8003490:	2b00      	cmp	r3, #0
 8003492:	f000 8340 	beq.w	8003b16 <bme68x_get_data+0x71a>
 8003496:	201d      	movs	r0, #29
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003498:	f8db 3004 	ldr.w	r3, [fp, #4]
 800349c:	2233      	movs	r2, #51	@ 0x33
 800349e:	a918      	add	r1, sp, #96	@ 0x60
 80034a0:	47c8      	blx	r9
 80034a2:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80034a6:	2800      	cmp	r0, #0
 80034a8:	f000 81b8 	beq.w	800381c <bme68x_get_data+0x420>
            rslt = read_field_data(0, data, dev);
 80034ac:	2600      	movs	r6, #0
                rslt = BME68X_W_NO_NEW_DATA;
 80034ae:	2702      	movs	r7, #2
 80034b0:	e7d5      	b.n	800345e <bme68x_get_data+0x62>
    uint8_t buff[BME68X_LEN_FIELD] = { 0 };
 80034b2:	2300      	movs	r3, #0
 80034b4:	e9cd 3318 	strd	r3, r3, [sp, #96]	@ 0x60
 80034b8:	e9cd 331a 	strd	r3, r3, [sp, #104]	@ 0x68
 80034bc:	f88d 3070 	strb.w	r3, [sp, #112]	@ 0x70
 80034c0:	f04f 0805 	mov.w	r8, #5
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80034c4:	f1b9 0f00 	cmp.w	r9, #0
 80034c8:	f000 83c5 	beq.w	8003c56 <bme68x_get_data+0x85a>
 80034cc:	f8db 3044 	ldr.w	r3, [fp, #68]	@ 0x44
 80034d0:	2b00      	cmp	r3, #0
 80034d2:	f000 83c0 	beq.w	8003c56 <bme68x_get_data+0x85a>
 80034d6:	f8db 3048 	ldr.w	r3, [fp, #72]	@ 0x48
 80034da:	2b00      	cmp	r3, #0
 80034dc:	f000 83bb 	beq.w	8003c56 <bme68x_get_data+0x85a>
        if (dev->intf == BME68X_SPI_INTF)
 80034e0:	f89b 300c 	ldrb.w	r3, [fp, #12]
 80034e4:	2b00      	cmp	r3, #0
 80034e6:	d06e      	beq.n	80035c6 <bme68x_get_data+0x1ca>
    int8_t rslt = BME68X_OK;
 80034e8:	2700      	movs	r7, #0
 80034ea:	201d      	movs	r0, #29
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80034ec:	f8db 3004 	ldr.w	r3, [fp, #4]
 80034f0:	2211      	movs	r2, #17
 80034f2:	a918      	add	r1, sp, #96	@ 0x60
 80034f4:	47c8      	blx	r9
            rslt = BME68X_E_COM_FAIL;
 80034f6:	2800      	cmp	r0, #0
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80034f8:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
            rslt = BME68X_E_COM_FAIL;
 80034fc:	bf18      	it	ne
 80034fe:	f06f 0701 	mvnne.w	r7, #1
        data->status = buff[0] & BME68X_NEW_DATA_MSK;
 8003502:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
        data->meas_index = buff[1];
 8003506:	f89d 2061 	ldrb.w	r2, [sp, #97]	@ 0x61
        adc_pres = (uint32_t)(((uint32_t)buff[2] * 4096) | ((uint32_t)buff[3] * 16) | ((uint32_t)buff[4] / 16));
 800350a:	f89d 1062 	ldrb.w	r1, [sp, #98]	@ 0x62
        data->meas_index = buff[1];
 800350e:	70aa      	strb	r2, [r5, #2]
        data->gas_index = buff[0] & BME68X_GAS_INDEX_MSK;
 8003510:	f003 000f 	and.w	r0, r3, #15
 8003514:	7068      	strb	r0, [r5, #1]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 8003516:	f8db 2008 	ldr.w	r2, [fp, #8]
        adc_pres = (uint32_t)(((uint32_t)buff[2] * 4096) | ((uint32_t)buff[3] * 16) | ((uint32_t)buff[4] / 16));
 800351a:	9101      	str	r1, [sp, #4]
 800351c:	f89d 1063 	ldrb.w	r1, [sp, #99]	@ 0x63
        adc_gas_res_low = (uint16_t)((uint32_t)buff[13] * 4 | (((uint32_t)buff[14]) / 64));
 8003520:	f89d 906e 	ldrb.w	r9, [sp, #110]	@ 0x6e
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
 8003524:	f89d a070 	ldrb.w	sl, [sp, #112]	@ 0x70
        adc_pres = (uint32_t)(((uint32_t)buff[2] * 4096) | ((uint32_t)buff[3] * 16) | ((uint32_t)buff[4] / 16));
 8003528:	9102      	str	r1, [sp, #8]
 800352a:	f89d 1064 	ldrb.w	r1, [sp, #100]	@ 0x64
 800352e:	9103      	str	r1, [sp, #12]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 8003530:	2a01      	cmp	r2, #1
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
 8003532:	f89d 1065 	ldrb.w	r1, [sp, #101]	@ 0x65
 8003536:	9104      	str	r1, [sp, #16]
 8003538:	bf08      	it	eq
 800353a:	f00a 0230 	andeq.w	r2, sl, #48	@ 0x30
 800353e:	f89d 1066 	ldrb.w	r1, [sp, #102]	@ 0x66
 8003542:	9105      	str	r1, [sp, #20]
 8003544:	bf18      	it	ne
 8003546:	f009 0230 	andne.w	r2, r9, #48	@ 0x30
        data->status = buff[0] & BME68X_NEW_DATA_MSK;
 800354a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
 800354e:	f89d 1067 	ldrb.w	r1, [sp, #103]	@ 0x67
 8003552:	9106      	str	r1, [sp, #24]
        adc_hum = (uint16_t)(((uint32_t)buff[8] * 256) | (uint32_t)buff[9]);
 8003554:	4313      	orrs	r3, r2
 8003556:	f89d 1068 	ldrb.w	r1, [sp, #104]	@ 0x68
 800355a:	702b      	strb	r3, [r5, #0]
        if ((data->status & BME68X_NEW_DATA_MSK) && (rslt == BME68X_OK))
 800355c:	061b      	lsls	r3, r3, #24
        adc_hum = (uint16_t)(((uint32_t)buff[8] * 256) | (uint32_t)buff[9]);
 800355e:	9107      	str	r1, [sp, #28]
        adc_gas_res_low = (uint16_t)((uint32_t)buff[13] * 4 | (((uint32_t)buff[14]) / 64));
 8003560:	f89d c06d 	ldrb.w	ip, [sp, #109]	@ 0x6d
        adc_hum = (uint16_t)(((uint32_t)buff[8] * 256) | (uint32_t)buff[9]);
 8003564:	f89d 1069 	ldrb.w	r1, [sp, #105]	@ 0x69
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
 8003568:	f89d e06f 	ldrb.w	lr, [sp, #111]	@ 0x6f
        if ((data->status & BME68X_NEW_DATA_MSK) && (rslt == BME68X_OK))
 800356c:	d402      	bmi.n	8003574 <bme68x_get_data+0x178>
        if (rslt == BME68X_OK)
 800356e:	b3af      	cbz	r7, 80035dc <bme68x_get_data+0x1e0>
    uint8_t i = 0, j = 0, new_fields = 0;
 8003570:	2600      	movs	r6, #0
 8003572:	e774      	b.n	800345e <bme68x_get_data+0x62>
        if ((data->status & BME68X_NEW_DATA_MSK) && (rslt == BME68X_OK))
 8003574:	e9cd 1c08 	strd	r1, ip, [sp, #32]
 8003578:	f8cd e028 	str.w	lr, [sp, #40]	@ 0x28
 800357c:	2f00      	cmp	r7, #0
 800357e:	d1f7      	bne.n	8003570 <bme68x_get_data+0x174>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003580:	f8db 7040 	ldr.w	r7, [fp, #64]	@ 0x40
            rslt = bme68x_get_regs(BME68X_REG_RES_HEAT0 + data->gas_index, &data->res_heat, 1, dev);
 8003584:	f100 085a 	add.w	r8, r0, #90	@ 0x5a
 8003588:	1ceb      	adds	r3, r5, #3
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800358a:	2f00      	cmp	r7, #0
 800358c:	f000 837f 	beq.w	8003c8e <bme68x_get_data+0x892>
 8003590:	f8db 2044 	ldr.w	r2, [fp, #68]	@ 0x44
 8003594:	2a00      	cmp	r2, #0
 8003596:	f000 837a 	beq.w	8003c8e <bme68x_get_data+0x892>
 800359a:	f8db 2048 	ldr.w	r2, [fp, #72]	@ 0x48
 800359e:	2a00      	cmp	r2, #0
 80035a0:	f000 8375 	beq.w	8003c8e <bme68x_get_data+0x892>
        if (dev->intf == BME68X_SPI_INTF)
 80035a4:	f89b 200c 	ldrb.w	r2, [fp, #12]
 80035a8:	2a00      	cmp	r2, #0
 80035aa:	f000 8339 	beq.w	8003c20 <bme68x_get_data+0x824>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80035ae:	4619      	mov	r1, r3
 80035b0:	4640      	mov	r0, r8
 80035b2:	f8db 3004 	ldr.w	r3, [fp, #4]
 80035b6:	2201      	movs	r2, #1
 80035b8:	47b8      	blx	r7
 80035ba:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 80035be:	b1e8      	cbz	r0, 80035fc <bme68x_get_data+0x200>
            rslt = BME68X_E_COM_FAIL;
 80035c0:	f06f 0701 	mvn.w	r7, #1
 80035c4:	e7d4      	b.n	8003570 <bme68x_get_data+0x174>
            rslt = set_mem_page(reg_addr, dev);
 80035c6:	4659      	mov	r1, fp
 80035c8:	201d      	movs	r0, #29
 80035ca:	f7fe ff23 	bl	8002414 <set_mem_page>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 80035ce:	f8db 9040 	ldr.w	r9, [fp, #64]	@ 0x40
            if (rslt == BME68X_OK)
 80035d2:	4607      	mov	r7, r0
 80035d4:	2800      	cmp	r0, #0
 80035d6:	d188      	bne.n	80034ea <bme68x_get_data+0xee>
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 80035d8:	209d      	movs	r0, #157	@ 0x9d
 80035da:	e787      	b.n	80034ec <bme68x_get_data+0xf0>
            dev->delay_us(BME68X_PERIOD_POLL, dev->intf_ptr);
 80035dc:	f8db 3048 	ldr.w	r3, [fp, #72]	@ 0x48
 80035e0:	f8db 1004 	ldr.w	r1, [fp, #4]
 80035e4:	f242 7010 	movw	r0, #10000	@ 0x2710
    while ((tries) && (rslt == BME68X_OK))
 80035e8:	f108 38ff 	add.w	r8, r8, #4294967295
            dev->delay_us(BME68X_PERIOD_POLL, dev->intf_ptr);
 80035ec:	4798      	blx	r3
    while ((tries) && (rslt == BME68X_OK))
 80035ee:	f018 08ff 	ands.w	r8, r8, #255	@ 0xff
 80035f2:	f000 810a 	beq.w	800380a <bme68x_get_data+0x40e>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80035f6:	f8db 9040 	ldr.w	r9, [fp, #64]	@ 0x40
 80035fa:	e763      	b.n	80034c4 <bme68x_get_data+0xc8>
                rslt = bme68x_get_regs(BME68X_REG_IDAC_HEAT0 + data->gas_index, &data->idac, 1, dev);
 80035fc:	f895 8001 	ldrb.w	r8, [r5, #1]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003600:	f8db 7040 	ldr.w	r7, [fp, #64]	@ 0x40
                rslt = bme68x_get_regs(BME68X_REG_IDAC_HEAT0 + data->gas_index, &data->idac, 1, dev);
 8003604:	f108 0850 	add.w	r8, r8, #80	@ 0x50
 8003608:	fa5f f888 	uxtb.w	r8, r8
 800360c:	1d2b      	adds	r3, r5, #4
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800360e:	2f00      	cmp	r7, #0
 8003610:	f000 833d 	beq.w	8003c8e <bme68x_get_data+0x892>
 8003614:	f8db 2044 	ldr.w	r2, [fp, #68]	@ 0x44
 8003618:	2a00      	cmp	r2, #0
 800361a:	f000 8338 	beq.w	8003c8e <bme68x_get_data+0x892>
 800361e:	f8db 2048 	ldr.w	r2, [fp, #72]	@ 0x48
 8003622:	2a00      	cmp	r2, #0
 8003624:	f000 8333 	beq.w	8003c8e <bme68x_get_data+0x892>
        if (dev->intf == BME68X_SPI_INTF)
 8003628:	f89b 200c 	ldrb.w	r2, [fp, #12]
 800362c:	2a00      	cmp	r2, #0
 800362e:	f000 8320 	beq.w	8003c72 <bme68x_get_data+0x876>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003632:	4619      	mov	r1, r3
 8003634:	4640      	mov	r0, r8
 8003636:	f8db 3004 	ldr.w	r3, [fp, #4]
 800363a:	2201      	movs	r2, #1
 800363c:	47b8      	blx	r7
 800363e:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8003642:	2800      	cmp	r0, #0
 8003644:	d1bc      	bne.n	80035c0 <bme68x_get_data+0x1c4>
                rslt = bme68x_get_regs(BME68X_REG_GAS_WAIT0 + data->gas_index, &data->gas_wait, 1, dev);
 8003646:	f895 8001 	ldrb.w	r8, [r5, #1]
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800364a:	f8db 7040 	ldr.w	r7, [fp, #64]	@ 0x40
                rslt = bme68x_get_regs(BME68X_REG_GAS_WAIT0 + data->gas_index, &data->gas_wait, 1, dev);
 800364e:	f108 0864 	add.w	r8, r8, #100	@ 0x64
 8003652:	fa5f f888 	uxtb.w	r8, r8
 8003656:	1d6b      	adds	r3, r5, #5
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8003658:	2f00      	cmp	r7, #0
 800365a:	f000 8318 	beq.w	8003c8e <bme68x_get_data+0x892>
 800365e:	f8db 2044 	ldr.w	r2, [fp, #68]	@ 0x44
 8003662:	2a00      	cmp	r2, #0
 8003664:	f000 8313 	beq.w	8003c8e <bme68x_get_data+0x892>
 8003668:	f8db 2048 	ldr.w	r2, [fp, #72]	@ 0x48
 800366c:	2a00      	cmp	r2, #0
 800366e:	f000 830e 	beq.w	8003c8e <bme68x_get_data+0x892>
        if (dev->intf == BME68X_SPI_INTF)
 8003672:	f89b 200c 	ldrb.w	r2, [fp, #12]
 8003676:	2a00      	cmp	r2, #0
 8003678:	f000 830c 	beq.w	8003c94 <bme68x_get_data+0x898>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 800367c:	4619      	mov	r1, r3
 800367e:	4640      	mov	r0, r8
 8003680:	f8db 3004 	ldr.w	r3, [fp, #4]
 8003684:	2201      	movs	r2, #1
 8003686:	47b8      	blx	r7
 8003688:	4607      	mov	r7, r0
 800368a:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 800368e:	2800      	cmp	r0, #0
 8003690:	d196      	bne.n	80035c0 <bme68x_get_data+0x1c4>
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
 8003692:	9b06      	ldr	r3, [sp, #24]
 8003694:	9a05      	ldr	r2, [sp, #20]
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 8003696:	f99b e022 	ldrsb.w	lr, [fp, #34]	@ 0x22
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
 800369a:	091b      	lsrs	r3, r3, #4
 800369c:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 80036a0:	9a04      	ldr	r2, [sp, #16]
 80036a2:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
        adc_pres = (uint32_t)(((uint32_t)buff[2] * 4096) | ((uint32_t)buff[3] * 16) | ((uint32_t)buff[4] / 16));
 80036a6:	9a03      	ldr	r2, [sp, #12]
 80036a8:	0910      	lsrs	r0, r2, #4
 80036aa:	9a02      	ldr	r2, [sp, #8]
 80036ac:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
                data->pressure = calc_pressure(adc_pres, dev);
 80036b0:	9a01      	ldr	r2, [sp, #4]
 80036b2:	ea40 3002 	orr.w	r0, r0, r2, lsl #12
    var1 = ((int32_t)temp_adc >> 3) - ((int32_t)dev->calib.par_t1 << 1);
 80036b6:	f8bb 201e 	ldrh.w	r2, [fp, #30]
 80036ba:	0052      	lsls	r2, r2, #1
 80036bc:	ebc2 02d3 	rsb	r2, r2, r3, lsr #3
 80036c0:	ea4f 7ce2 	mov.w	ip, r2, asr #31
    var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
 80036c4:	0853      	lsrs	r3, r2, #1
 80036c6:	ea43 73cc 	orr.w	r3, r3, ip, lsl #31
 80036ca:	fb03 fc0c 	mul.w	ip, r3, ip
 80036ce:	fba3 3103 	umull	r3, r1, r3, r3
 80036d2:	eb01 014c 	add.w	r1, r1, ip, lsl #1
 80036d6:	0b1b      	lsrs	r3, r3, #12
 80036d8:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
 80036dc:	ea4f 3821 	mov.w	r8, r1, asr #12
    var2 = (var1 * (int32_t)dev->calib.par_t2) >> 11;
 80036e0:	f9bb 1020 	ldrsh.w	r1, [fp, #32]
 80036e4:	fb81 1202 	smull	r1, r2, r1, r2
 80036e8:	0ac9      	lsrs	r1, r1, #11
 80036ea:	ea41 5142 	orr.w	r1, r1, r2, lsl #21
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 80036ee:	ea4f 72ee 	mov.w	r2, lr, asr #31
 80036f2:	ea4f 1c0e 	mov.w	ip, lr, lsl #4
 80036f6:	fb03 f202 	mul.w	r2, r3, r2
 80036fa:	fb0c 2208 	mla	r2, ip, r8, r2
 80036fe:	fba3 c30c 	umull	ip, r3, r3, ip
 8003702:	441a      	add	r2, r3
 8003704:	ea4f 339c 	mov.w	r3, ip, lsr #14
 8003708:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
    dev->calib.t_fine = (int32_t)(var2 + var3);
 800370c:	4419      	add	r1, r3
 800370e:	f8cb 1038 	str.w	r1, [fp, #56]	@ 0x38
    calc_temp = (int16_t)(((dev->calib.t_fine * 5) + 128) >> 8);
 8003712:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8003716:	f101 0380 	add.w	r3, r1, #128	@ 0x80
 800371a:	121b      	asrs	r3, r3, #8
 800371c:	80eb      	strh	r3, [r5, #6]
                data->pressure = calc_pressure(adc_pres, dev);
 800371e:	4659      	mov	r1, fp
 8003720:	f7fe fdae 	bl	8002280 <calc_pressure>
                data->humidity = calc_humidity(adc_hum, dev);
 8003724:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
                data->pressure = calc_pressure(adc_pres, dev);
 8003728:	60a8      	str	r0, [r5, #8]
                data->humidity = calc_humidity(adc_hum, dev);
 800372a:	4659      	mov	r1, fp
 800372c:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
 8003730:	f7fe fe0c 	bl	800234c <calc_humidity>
                if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 8003734:	f8db 3008 	ldr.w	r3, [fp, #8]
                data->humidity = calc_humidity(adc_hum, dev);
 8003738:	60e8      	str	r0, [r5, #12]
                if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 800373a:	2b01      	cmp	r3, #1
 800373c:	f000 82ba 	beq.w	8003cb4 <bme68x_get_data+0x8b8>
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 8003740:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8003742:	f99b 203e 	ldrsb.w	r2, [fp, #62]	@ 0x3e
    uint32_t lookup_table1[16] = {
 8003746:	f8df c0d0 	ldr.w	ip, [pc, #208]	@ 8003818 <bme68x_get_data+0x41c>
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 800374a:	f009 0a0f 	and.w	sl, r9, #15
 800374e:	ab54      	add	r3, sp, #336	@ 0x150
 8003750:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
        adc_gas_res_low = (uint16_t)((uint32_t)buff[13] * 4 | (((uint32_t)buff[14]) / 64));
 8003754:	ea4f 1399 	mov.w	r3, r9, lsr #6
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 8003758:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
 800375c:	03db      	lsls	r3, r3, #15
 800375e:	f113 437f 	adds.w	r3, r3, #4278190080	@ 0xff000000
 8003762:	9301      	str	r3, [sp, #4]
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 8003764:	f240 593c 	movw	r9, #1340	@ 0x53c
 8003768:	f04f 0305 	mov.w	r3, #5
 800376c:	fbc3 9702 	smlal	r9, r7, r3, r2
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 8003770:	eb62 0202 	sbc.w	r2, r2, r2
 8003774:	9202      	str	r2, [sp, #8]
    uint32_t lookup_table1[16] = {
 8003776:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800377a:	f10d 08d0 	add.w	r8, sp, #208	@ 0xd0
 800377e:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 8003782:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003786:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 800378a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800378e:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 8003792:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    uint32_t lookup_table2[16] = {
 8003796:	f10c 0b10 	add.w	fp, ip, #16
    uint32_t lookup_table1[16] = {
 800379a:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
    uint32_t lookup_table2[16] = {
 800379e:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
 80037a2:	f50d 7e88 	add.w	lr, sp, #272	@ 0x110
 80037a6:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80037aa:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
 80037ae:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80037b2:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
 80037b6:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80037ba:	e89b 000f 	ldmia.w	fp, {r0, r1, r2, r3}
 80037be:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80037c2:	f85a 3c80 	ldr.w	r3, [sl, #-128]
    var3 = (((int64_t)lookup_table2[gas_range] * (int64_t)var1) >> 9);
 80037c6:	f85a cc40 	ldr.w	ip, [sl, #-64]
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80037ca:	fba9 1003 	umull	r1, r0, r9, r3
 80037ce:	fb03 0007 	mla	r0, r3, r7, r0
 80037d2:	0c09      	lsrs	r1, r1, #16
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80037d4:	9b01      	ldr	r3, [sp, #4]
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80037d6:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80037da:	185a      	adds	r2, r3, r1
 80037dc:	9b02      	ldr	r3, [sp, #8]
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80037de:	ea4f 4720 	mov.w	r7, r0, asr #16
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80037e2:	eb43 4320 	adc.w	r3, r3, r0, asr #16
    var3 = (((int64_t)lookup_table2[gas_range] * (int64_t)var1) >> 9);
 80037e6:	fbac 0101 	umull	r0, r1, ip, r1
 80037ea:	fb0c 1107 	mla	r1, ip, r7, r1
 80037ee:	0a40      	lsrs	r0, r0, #9
    calc_gas_res = (uint32_t)((var3 + ((int64_t)var2 >> 1)) / (int64_t)var2);
 80037f0:	0857      	lsrs	r7, r2, #1
 80037f2:	ea47 77c3 	orr.w	r7, r7, r3, lsl #31
    var3 = (((int64_t)lookup_table2[gas_range] * (int64_t)var1) >> 9);
 80037f6:	ea40 50c1 	orr.w	r0, r0, r1, lsl #23
    calc_gas_res = (uint32_t)((var3 + ((int64_t)var2 >> 1)) / (int64_t)var2);
 80037fa:	19c0      	adds	r0, r0, r7
 80037fc:	ea4f 0763 	mov.w	r7, r3, asr #1
 8003800:	eb47 2161 	adc.w	r1, r7, r1, asr #9
 8003804:	f7fd f860 	bl	80008c8 <__aeabi_ldivmod>
                    data->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
 8003808:	6128      	str	r0, [r5, #16]
                if (data->status & BME68X_NEW_DATA_MSK)
 800380a:	f995 3000 	ldrsb.w	r3, [r5]
 800380e:	2b00      	cmp	r3, #0
 8003810:	f6bf ae4c 	bge.w	80034ac <bme68x_get_data+0xb0>
            rslt = read_field_data(0, data, dev);
 8003814:	2700      	movs	r7, #0
 8003816:	e622      	b.n	800345e <bme68x_get_data+0x62>
 8003818:	08016748 	.word	0x08016748
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800381c:	f8db 6040 	ldr.w	r6, [fp, #64]	@ 0x40
 8003820:	2e00      	cmp	r6, #0
 8003822:	f43f ae43 	beq.w	80034ac <bme68x_get_data+0xb0>
 8003826:	f8db 3044 	ldr.w	r3, [fp, #68]	@ 0x44
 800382a:	2b00      	cmp	r3, #0
 800382c:	f43f ae3e 	beq.w	80034ac <bme68x_get_data+0xb0>
 8003830:	f8db 3048 	ldr.w	r3, [fp, #72]	@ 0x48
 8003834:	2b00      	cmp	r3, #0
 8003836:	f43f ae39 	beq.w	80034ac <bme68x_get_data+0xb0>
        if (dev->intf == BME68X_SPI_INTF)
 800383a:	f89b 300c 	ldrb.w	r3, [fp, #12]
 800383e:	2b00      	cmp	r3, #0
 8003840:	f000 8180 	beq.w	8003b44 <bme68x_get_data+0x748>
 8003844:	2050      	movs	r0, #80	@ 0x50
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003846:	f8db 3004 	ldr.w	r3, [fp, #4]
 800384a:	221e      	movs	r2, #30
 800384c:	a910      	add	r1, sp, #64	@ 0x40
 800384e:	47b0      	blx	r6
 8003850:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8003854:	2800      	cmp	r0, #0
 8003856:	f47f ae29 	bne.w	80034ac <bme68x_get_data+0xb0>
    var1 = ((int32_t)temp_adc >> 3) - ((int32_t)dev->calib.par_t1 << 1);
 800385a:	f8bb 201e 	ldrh.w	r2, [fp, #30]
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 800385e:	f99b 3022 	ldrsb.w	r3, [fp, #34]	@ 0x22
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 8003862:	9009      	str	r0, [sp, #36]	@ 0x24
    var1 = ((int32_t)temp_adc >> 3) - ((int32_t)dev->calib.par_t1 << 1);
 8003864:	0052      	lsls	r2, r2, #1
 8003866:	9205      	str	r2, [sp, #20]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 8003868:	f8db 2008 	ldr.w	r2, [fp, #8]
 800386c:	9201      	str	r2, [sp, #4]
    var2 = (var1 * (int32_t)dev->calib.par_t2) >> 11;
 800386e:	f9bb 2020 	ldrsh.w	r2, [fp, #32]
 8003872:	9206      	str	r2, [sp, #24]
    calc_gas_res = calc_gas_res * 100;
 8003874:	e9cd 540a 	strd	r5, r4, [sp, #40]	@ 0x28
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 8003878:	011a      	lsls	r2, r3, #4
 800387a:	17db      	asrs	r3, r3, #31
 800387c:	9308      	str	r3, [sp, #32]
 800387e:	ab0c      	add	r3, sp, #48	@ 0x30
 8003880:	f10d 0a60 	add.w	sl, sp, #96	@ 0x60
 8003884:	9207      	str	r2, [sp, #28]
 8003886:	9302      	str	r3, [sp, #8]
    calc_gas_res = calc_gas_res * 100;
 8003888:	46d9      	mov	r9, fp
            (uint32_t) (((uint32_t) buff[off + 2] * 4096) | ((uint32_t) buff[off + 3] * 16) |
 800388a:	f89a 0003 	ldrb.w	r0, [sl, #3]
 800388e:	f89a 1002 	ldrb.w	r1, [sl, #2]
            (uint32_t) (((uint32_t) buff[off + 5] * 4096) | ((uint32_t) buff[off + 6] * 16) |
 8003892:	f89a 3006 	ldrb.w	r3, [sl, #6]
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
 8003896:	f89a 500f 	ldrb.w	r5, [sl, #15]
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
 800389a:	f89a 4009 	ldrb.w	r4, [sl, #9]
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
 800389e:	9503      	str	r5, [sp, #12]
            (uint32_t) (((uint32_t) buff[off + 2] * 4096) | ((uint32_t) buff[off + 3] * 16) |
 80038a0:	0100      	lsls	r0, r0, #4
 80038a2:	ea40 3001 	orr.w	r0, r0, r1, lsl #12
            (uint32_t) (((uint32_t) buff[off + 5] * 4096) | ((uint32_t) buff[off + 6] * 16) |
 80038a6:	f89a 1005 	ldrb.w	r1, [sl, #5]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 80038aa:	9d01      	ldr	r5, [sp, #4]
        data[i]->status = buff[off] & BME68X_NEW_DATA_MSK;
 80038ac:	f89a 2000 	ldrb.w	r2, [sl]
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
 80038b0:	f89a b00e 	ldrb.w	fp, [sl, #14]
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
 80038b4:	f89a 7010 	ldrb.w	r7, [sl, #16]
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
 80038b8:	f89a 600d 	ldrb.w	r6, [sl, #13]
            (uint32_t) (((uint32_t) buff[off + 5] * 4096) | ((uint32_t) buff[off + 6] * 16) |
 80038bc:	011b      	lsls	r3, r3, #4
 80038be:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
        data[i]->status = buff[off] & BME68X_NEW_DATA_MSK;
 80038c2:	9902      	ldr	r1, [sp, #8]
 80038c4:	f851 8b04 	ldr.w	r8, [r1], #4
 80038c8:	9102      	str	r1, [sp, #8]
                        ((uint32_t) buff[off + 4] / 16));
 80038ca:	f89a 1004 	ldrb.w	r1, [sl, #4]
        adc_pres =
 80038ce:	ea40 1011 	orr.w	r0, r0, r1, lsr #4
                        ((uint32_t) buff[off + 7] / 16));
 80038d2:	f89a 1007 	ldrb.w	r1, [sl, #7]
        adc_temp =
 80038d6:	ea43 1311 	orr.w	r3, r3, r1, lsr #4
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
 80038da:	f89a 1008 	ldrb.w	r1, [sl, #8]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 80038de:	2d01      	cmp	r5, #1
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
 80038e0:	ea44 2401 	orr.w	r4, r4, r1, lsl #8
        data[i]->meas_index = buff[off + 1];
 80038e4:	f89a 1001 	ldrb.w	r1, [sl, #1]
 80038e8:	f888 1002 	strb.w	r1, [r8, #2]
 80038ec:	bf08      	it	eq
 80038ee:	f007 0c30 	andeq.w	ip, r7, #48	@ 0x30
        data[i]->gas_index = buff[off] & BME68X_GAS_INDEX_MSK;
 80038f2:	f002 010f 	and.w	r1, r2, #15
 80038f6:	bf18      	it	ne
 80038f8:	f00b 0c30 	andne.w	ip, fp, #48	@ 0x30
        data[i]->status = buff[off] & BME68X_NEW_DATA_MSK;
 80038fc:	f002 0280 	and.w	r2, r2, #128	@ 0x80
            data[i]->status |= buff[off + 14] & BME68X_HEAT_STAB_MSK;
 8003900:	ea42 020c 	orr.w	r2, r2, ip
 8003904:	f888 2000 	strb.w	r2, [r8]
    var1 = ((int32_t)temp_adc >> 3) - ((int32_t)dev->calib.par_t1 << 1);
 8003908:	9a05      	ldr	r2, [sp, #20]
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 800390a:	9d08      	ldr	r5, [sp, #32]
        data[i]->gas_index = buff[off] & BME68X_GAS_INDEX_MSK;
 800390c:	f888 1001 	strb.w	r1, [r8, #1]
    var1 = ((int32_t)temp_adc >> 3) - ((int32_t)dev->calib.par_t1 << 1);
 8003910:	ebc2 03d3 	rsb	r3, r2, r3, lsr #3
 8003914:	ea4f 7ee3 	mov.w	lr, r3, asr #31
    var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
 8003918:	085a      	lsrs	r2, r3, #1
 800391a:	ea42 72ce 	orr.w	r2, r2, lr, lsl #31
 800391e:	fb02 fe0e 	mul.w	lr, r2, lr
 8003922:	fba2 c202 	umull	ip, r2, r2, r2
 8003926:	eb02 024e 	add.w	r2, r2, lr, lsl #1
 800392a:	ea4f 3c1c 	mov.w	ip, ip, lsr #12
 800392e:	ea4c 5c02 	orr.w	ip, ip, r2, lsl #20
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 8003932:	fb0c fe05 	mul.w	lr, ip, r5
 8003936:	9d07      	ldr	r5, [sp, #28]
    var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
 8003938:	1312      	asrs	r2, r2, #12
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 800393a:	fb05 e202 	mla	r2, r5, r2, lr
 800393e:	fbac ce05 	umull	ip, lr, ip, r5
 8003942:	4496      	add	lr, r2
    var2 = (var1 * (int32_t)dev->calib.par_t2) >> 11;
 8003944:	9a06      	ldr	r2, [sp, #24]
 8003946:	fb82 3203 	smull	r3, r2, r2, r3
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 800394a:	ea4f 3c9c 	mov.w	ip, ip, lsr #14
    var2 = (var1 * (int32_t)dev->calib.par_t2) >> 11;
 800394e:	0adb      	lsrs	r3, r3, #11
    var3 = ((var3) * ((int32_t)dev->calib.par_t3 << 4)) >> 14;
 8003950:	ea4c 4c8e 	orr.w	ip, ip, lr, lsl #18
    var2 = (var1 * (int32_t)dev->calib.par_t2) >> 11;
 8003954:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
    dev->calib.t_fine = (int32_t)(var2 + var3);
 8003958:	4463      	add	r3, ip
 800395a:	f8c9 3038 	str.w	r3, [r9, #56]	@ 0x38
    calc_temp = (int16_t)(((dev->calib.t_fine * 5) + 128) >> 8);
 800395e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003962:	3380      	adds	r3, #128	@ 0x80
 8003964:	121b      	asrs	r3, r3, #8
 8003966:	f8a8 3006 	strh.w	r3, [r8, #6]
        data[i]->idac = set_val[data[i]->gas_index];
 800396a:	aa10      	add	r2, sp, #64	@ 0x40
        data[i]->res_heat = set_val[10 + data[i]->gas_index];
 800396c:	ab10      	add	r3, sp, #64	@ 0x40
 800396e:	440b      	add	r3, r1
        data[i]->idac = set_val[data[i]->gas_index];
 8003970:	5c52      	ldrb	r2, [r2, r1]
 8003972:	f888 2004 	strb.w	r2, [r8, #4]
        data[i]->res_heat = set_val[10 + data[i]->gas_index];
 8003976:	7a9a      	ldrb	r2, [r3, #10]
 8003978:	f888 2003 	strb.w	r2, [r8, #3]
        data[i]->gas_wait = set_val[20 + data[i]->gas_index];
 800397c:	7d1b      	ldrb	r3, [r3, #20]
 800397e:	f888 3005 	strb.w	r3, [r8, #5]
        data[i]->pressure = calc_pressure(adc_pres, dev);
 8003982:	4649      	mov	r1, r9
 8003984:	f7fe fc7c 	bl	8002280 <calc_pressure>
        data[i]->humidity = calc_humidity(adc_hum, dev);
 8003988:	4649      	mov	r1, r9
        data[i]->pressure = calc_pressure(adc_pres, dev);
 800398a:	f8c8 0008 	str.w	r0, [r8, #8]
        data[i]->humidity = calc_humidity(adc_hum, dev);
 800398e:	4620      	mov	r0, r4
 8003990:	f7fe fcdc 	bl	800234c <calc_humidity>
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 8003994:	9b01      	ldr	r3, [sp, #4]
        data[i]->humidity = calc_humidity(adc_hum, dev);
 8003996:	f8c8 000c 	str.w	r0, [r8, #12]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 800399a:	2b01      	cmp	r3, #1
    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 800399c:	f10a 0a11 	add.w	sl, sl, #17
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 80039a0:	f000 80db 	beq.w	8003b5a <bme68x_get_data+0x75e>
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
 80039a4:	ea4f 1c9b 	mov.w	ip, fp, lsr #6
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80039a8:	ea4c 0c86 	orr.w	ip, ip, r6, lsl #2
 80039ac:	f999 303e 	ldrsb.w	r3, [r9, #62]	@ 0x3e
    uint32_t lookup_table1[16] = {
 80039b0:	4cbf      	ldr	r4, [pc, #764]	@ (8003cb0 <bme68x_get_data+0x8b4>)
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80039b2:	f00b 020f 	and.w	r2, fp, #15
 80039b6:	a954      	add	r1, sp, #336	@ 0x150
 80039b8:	f8dd b024 	ldr.w	fp, [sp, #36]	@ 0x24
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80039bc:	ea4f 3ccc 	mov.w	ip, ip, lsl #15
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80039c0:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80039c4:	f11c 4c7f 	adds.w	ip, ip, #4278190080	@ 0xff000000
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80039c8:	f04f 0105 	mov.w	r1, #5
 80039cc:	f240 523c 	movw	r2, #1340	@ 0x53c
 80039d0:	fbc1 2b03 	smlal	r2, fp, r1, r3
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80039d4:	eb63 0303 	sbc.w	r3, r3, r3
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 80039d8:	9203      	str	r2, [sp, #12]
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 80039da:	9304      	str	r3, [sp, #16]
    uint32_t lookup_table1[16] = {
 80039dc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80039de:	af34      	add	r7, sp, #208	@ 0xd0
 80039e0:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80039e2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80039e4:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80039e6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80039e8:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80039ea:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    uint32_t lookup_table2[16] = {
 80039ee:	f104 0610 	add.w	r6, r4, #16
    uint32_t lookup_table1[16] = {
 80039f2:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    uint32_t lookup_table2[16] = {
 80039f6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80039f8:	ad44      	add	r5, sp, #272	@ 0x110
 80039fa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80039fc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80039fe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003a00:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8003a02:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003a04:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8003a08:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 8003a0c:	f85e 3c80 	ldr.w	r3, [lr, #-128]
 8003a10:	9a03      	ldr	r2, [sp, #12]
    var3 = (((int64_t)lookup_table2[gas_range] * (int64_t)var1) >> 9);
 8003a12:	f85e 4c40 	ldr.w	r4, [lr, #-64]
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 8003a16:	fba2 1003 	umull	r1, r0, r2, r3
 8003a1a:	fb03 000b 	mla	r0, r3, fp, r0
 8003a1e:	0c09      	lsrs	r1, r1, #16
 8003a20:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    var2 = (((int64_t)((int64_t)gas_res_adc << 15) - (int64_t)(16777216)) + var1);
 8003a24:	9b04      	ldr	r3, [sp, #16]
 8003a26:	eb1c 0201 	adds.w	r2, ip, r1
 8003a2a:	eb43 4320 	adc.w	r3, r3, r0, asr #16
    var1 = (int64_t)((1340 + (5 * (int64_t)dev->calib.range_sw_err)) * ((int64_t)lookup_table1[gas_range])) >> 16;
 8003a2e:	1405      	asrs	r5, r0, #16
    var3 = (((int64_t)lookup_table2[gas_range] * (int64_t)var1) >> 9);
 8003a30:	fba4 0101 	umull	r0, r1, r4, r1
 8003a34:	fb04 1105 	mla	r1, r4, r5, r1
 8003a38:	0a40      	lsrs	r0, r0, #9
    calc_gas_res = (uint32_t)((var3 + ((int64_t)var2 >> 1)) / (int64_t)var2);
 8003a3a:	0854      	lsrs	r4, r2, #1
 8003a3c:	ea44 74c3 	orr.w	r4, r4, r3, lsl #31
    var3 = (((int64_t)lookup_table2[gas_range] * (int64_t)var1) >> 9);
 8003a40:	ea40 50c1 	orr.w	r0, r0, r1, lsl #23
    calc_gas_res = (uint32_t)((var3 + ((int64_t)var2 >> 1)) / (int64_t)var2);
 8003a44:	1900      	adds	r0, r0, r4
 8003a46:	ea4f 0463 	mov.w	r4, r3, asr #1
 8003a4a:	eb44 2161 	adc.w	r1, r4, r1, asr #9
 8003a4e:	f7fc ff3b 	bl	80008c8 <__aeabi_ldivmod>
    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 8003a52:	f10d 0393 	add.w	r3, sp, #147	@ 0x93
 8003a56:	459a      	cmp	sl, r3
            data[i]->gas_resistance = calc_gas_resistance_high(adc_gas_res_high, gas_range_h);
 8003a58:	f8c8 0010 	str.w	r0, [r8, #16]
    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 8003a5c:	f47f af15 	bne.w	800388a <bme68x_get_data+0x48e>
                if (field_ptr[i]->status & BME68X_NEW_DATA_MSK)
 8003a60:	f99d 3094 	ldrsb.w	r3, [sp, #148]	@ 0x94
 8003a64:	f99d 20a8 	ldrsb.w	r2, [sp, #168]	@ 0xa8
 8003a68:	f99d 10bc 	ldrsb.w	r1, [sp, #188]	@ 0xbc
    meas_index1 = (int16_t)field[low_index]->meas_index;
 8003a6c:	f89d 7096 	ldrb.w	r7, [sp, #150]	@ 0x96
    meas_index2 = (int16_t)field[high_index]->meas_index;
 8003a70:	f89d 00aa 	ldrb.w	r0, [sp, #170]	@ 0xaa
                if (field_ptr[i]->status & BME68X_NEW_DATA_MSK)
 8003a74:	0fde      	lsrs	r6, r3, #31
 8003a76:	2a00      	cmp	r2, #0
                    new_fields++;
 8003a78:	bfb8      	it	lt
 8003a7a:	3601      	addlt	r6, #1
                if (field_ptr[i]->status & BME68X_NEW_DATA_MSK)
 8003a7c:	2900      	cmp	r1, #0
                    new_fields++;
 8003a7e:	bfbc      	itt	lt
 8003a80:	3601      	addlt	r6, #1
 8003a82:	b2f6      	uxtblt	r6, r6
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003a84:	2b00      	cmp	r3, #0
 8003a86:	e9dd 540a 	ldrd	r5, r4, [sp, #40]	@ 0x28
 8003a8a:	f2c0 8085 	blt.w	8003b98 <bme68x_get_data+0x79c>
    else if (field[high_index]->status & BME68X_NEW_DATA_MSK)
 8003a8e:	2a00      	cmp	r2, #0
 8003a90:	da03      	bge.n	8003a9a <bme68x_get_data+0x69e>
    field[index1] = field[index2];
 8003a92:	ab2a      	add	r3, sp, #168	@ 0xa8
 8003a94:	930c      	str	r3, [sp, #48]	@ 0x30
    field[index2] = temp;
 8003a96:	ab25      	add	r3, sp, #148	@ 0x94
 8003a98:	930d      	str	r3, [sp, #52]	@ 0x34
    meas_index1 = (int16_t)field[low_index]->meas_index;
 8003a9a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    meas_index2 = (int16_t)field[high_index]->meas_index;
 8003a9c:	f89d 00be 	ldrb.w	r0, [sp, #190]	@ 0xbe
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003aa0:	f993 2000 	ldrsb.w	r2, [r3]
    meas_index1 = (int16_t)field[low_index]->meas_index;
 8003aa4:	789f      	ldrb	r7, [r3, #2]
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003aa6:	2a00      	cmp	r2, #0
 8003aa8:	f2c0 80a1 	blt.w	8003bee <bme68x_get_data+0x7f2>
    else if (field[high_index]->status & BME68X_NEW_DATA_MSK)
 8003aac:	2900      	cmp	r1, #0
 8003aae:	f280 8082 	bge.w	8003bb6 <bme68x_get_data+0x7ba>
    field[index1] = field[index2];
 8003ab2:	aa2f      	add	r2, sp, #188	@ 0xbc
 8003ab4:	920c      	str	r2, [sp, #48]	@ 0x30
    meas_index1 = (int16_t)field[low_index]->meas_index;
 8003ab6:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
    field[index2] = temp;
 8003ab8:	930e      	str	r3, [sp, #56]	@ 0x38
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003aba:	f992 1000 	ldrsb.w	r1, [r2]
 8003abe:	2900      	cmp	r1, #0
 8003ac0:	db06      	blt.n	8003ad0 <bme68x_get_data+0x6d4>
    meas_index2 = (int16_t)field[high_index]->meas_index;
 8003ac2:	4619      	mov	r1, r3
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003ac4:	f991 3000 	ldrsb.w	r3, [r1]
    else if (field[high_index]->status & BME68X_NEW_DATA_MSK)
 8003ac8:	2b00      	cmp	r3, #0
 8003aca:	da01      	bge.n	8003ad0 <bme68x_get_data+0x6d4>
    field[index1] = field[index2];
 8003acc:	e9cd 120d 	strd	r1, r2, [sp, #52]	@ 0x34
                data[i] = *field_ptr[i];
 8003ad0:	e9dd a90c 	ldrd	sl, r9, [sp, #48]	@ 0x30
 8003ad4:	e8ba 000f 	ldmia.w	sl!, {r0, r1, r2, r3}
 8003ad8:	f105 0814 	add.w	r8, r5, #20
 8003adc:	f105 0c28 	add.w	ip, r5, #40	@ 0x28
 8003ae0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003ae2:	f8da 3000 	ldr.w	r3, [sl]
 8003ae6:	602b      	str	r3, [r5, #0]
 8003ae8:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
 8003aec:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 8003af0:	f8dd e038 	ldr.w	lr, [sp, #56]	@ 0x38
 8003af4:	f8d9 3000 	ldr.w	r3, [r9]
 8003af8:	f8c8 3000 	str.w	r3, [r8]
 8003afc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8003b00:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
            if (new_fields == 0)
 8003b04:	fab6 f786 	clz	r7, r6
                data[i] = *field_ptr[i];
 8003b08:	f8de 3000 	ldr.w	r3, [lr]
 8003b0c:	f8cc 3000 	str.w	r3, [ip]
            if (new_fields == 0)
 8003b10:	097f      	lsrs	r7, r7, #5
 8003b12:	007f      	lsls	r7, r7, #1
 8003b14:	e4a3      	b.n	800345e <bme68x_get_data+0x62>
            rslt = set_mem_page(reg_addr, dev);
 8003b16:	4659      	mov	r1, fp
 8003b18:	201d      	movs	r0, #29
 8003b1a:	f7fe fc7b 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8003b1e:	b930      	cbnz	r0, 8003b2e <bme68x_get_data+0x732>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003b20:	f8db 9040 	ldr.w	r9, [fp, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8003b24:	209d      	movs	r0, #157	@ 0x9d
 8003b26:	e4b7      	b.n	8003498 <bme68x_get_data+0x9c>
        rslt = BME68X_E_NULL_PTR;
 8003b28:	f04f 37ff 	mov.w	r7, #4294967295
 8003b2c:	e49b      	b.n	8003466 <bme68x_get_data+0x6a>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003b2e:	f8db 5040 	ldr.w	r5, [fp, #64]	@ 0x40
 8003b32:	f8db 3004 	ldr.w	r3, [fp, #4]
 8003b36:	2233      	movs	r2, #51	@ 0x33
 8003b38:	a918      	add	r1, sp, #96	@ 0x60
 8003b3a:	201d      	movs	r0, #29
 8003b3c:	47a8      	blx	r5
 8003b3e:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8003b42:	e4b3      	b.n	80034ac <bme68x_get_data+0xb0>
            rslt = set_mem_page(reg_addr, dev);
 8003b44:	4659      	mov	r1, fp
 8003b46:	2050      	movs	r0, #80	@ 0x50
 8003b48:	f7fe fc64 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8003b4c:	2800      	cmp	r0, #0
 8003b4e:	f040 8085 	bne.w	8003c5c <bme68x_get_data+0x860>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003b52:	f8db 6040 	ldr.w	r6, [fp, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8003b56:	20d0      	movs	r0, #208	@ 0xd0
 8003b58:	e675      	b.n	8003846 <bme68x_get_data+0x44a>
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
 8003b5a:	9b03      	ldr	r3, [sp, #12]
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
 8003b5c:	09ba      	lsrs	r2, r7, #6
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
 8003b5e:	ea42 0283 	orr.w	r2, r2, r3, lsl #2
    uint32_t var1 = UINT32_C(262144) >> gas_range;
 8003b62:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 8003b66:	f007 030f 	and.w	r3, r7, #15
 8003b6a:	fa21 f303 	lsr.w	r3, r1, r3
    var2 *= INT32_C(3);
 8003b6e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    calc_gas_res = (UINT32_C(10000) * var1) / (uint32_t)var2;
 8003b72:	f242 7110 	movw	r1, #10000	@ 0x2710
    var2 = INT32_C(4096) + var2;
 8003b76:	f502 6220 	add.w	r2, r2, #2560	@ 0xa00
    calc_gas_res = (UINT32_C(10000) * var1) / (uint32_t)var2;
 8003b7a:	fb01 f303 	mul.w	r3, r1, r3
 8003b7e:	fbb3 f3f2 	udiv	r3, r3, r2
    calc_gas_res = calc_gas_res * 100;
 8003b82:	2264      	movs	r2, #100	@ 0x64
 8003b84:	fb02 f303 	mul.w	r3, r2, r3
            data[i]->gas_resistance = calc_gas_resistance_high(adc_gas_res_high, gas_range_h);
 8003b88:	f8c8 3010 	str.w	r3, [r8, #16]
    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 8003b8c:	f10d 0393 	add.w	r3, sp, #147	@ 0x93
 8003b90:	4553      	cmp	r3, sl
 8003b92:	f47f ae7a 	bne.w	800388a <bme68x_get_data+0x48e>
 8003b96:	e763      	b.n	8003a60 <bme68x_get_data+0x664>
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003b98:	2a00      	cmp	r2, #0
 8003b9a:	f6bf af7e 	bge.w	8003a9a <bme68x_get_data+0x69e>
        int16_t diff = meas_index2 - meas_index1;
 8003b9e:	1bc0      	subs	r0, r0, r7
 8003ba0:	b280      	uxth	r0, r0
        if (((diff > -3) && (diff < 0)) || (diff > 2))
 8003ba2:	1c83      	adds	r3, r0, #2
 8003ba4:	b29b      	uxth	r3, r3
 8003ba6:	2b01      	cmp	r3, #1
 8003ba8:	f67f af73 	bls.w	8003a92 <bme68x_get_data+0x696>
 8003bac:	b200      	sxth	r0, r0
 8003bae:	2802      	cmp	r0, #2
 8003bb0:	f77f af73 	ble.w	8003a9a <bme68x_get_data+0x69e>
 8003bb4:	e76d      	b.n	8003a92 <bme68x_get_data+0x696>
    meas_index2 = (int16_t)field[high_index]->meas_index;
 8003bb6:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	@ 0x34
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003bba:	f992 7000 	ldrsb.w	r7, [r2]
    meas_index1 = (int16_t)field[low_index]->meas_index;
 8003bbe:	f892 c002 	ldrb.w	ip, [r2, #2]
    meas_index2 = (int16_t)field[high_index]->meas_index;
 8003bc2:	7888      	ldrb	r0, [r1, #2]
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003bc4:	f991 3000 	ldrsb.w	r3, [r1]
 8003bc8:	2f00      	cmp	r7, #0
 8003bca:	f6bf af7d 	bge.w	8003ac8 <bme68x_get_data+0x6cc>
 8003bce:	2b00      	cmp	r3, #0
 8003bd0:	f6bf af7e 	bge.w	8003ad0 <bme68x_get_data+0x6d4>
        int16_t diff = meas_index2 - meas_index1;
 8003bd4:	eba0 000c 	sub.w	r0, r0, ip
 8003bd8:	b280      	uxth	r0, r0
        if (((diff > -3) && (diff < 0)) || (diff > 2))
 8003bda:	1c83      	adds	r3, r0, #2
 8003bdc:	b29b      	uxth	r3, r3
 8003bde:	2b01      	cmp	r3, #1
 8003be0:	f67f af74 	bls.w	8003acc <bme68x_get_data+0x6d0>
 8003be4:	b200      	sxth	r0, r0
 8003be6:	2802      	cmp	r0, #2
 8003be8:	f73f af70 	bgt.w	8003acc <bme68x_get_data+0x6d0>
 8003bec:	e770      	b.n	8003ad0 <bme68x_get_data+0x6d4>
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003bee:	2900      	cmp	r1, #0
 8003bf0:	dae1      	bge.n	8003bb6 <bme68x_get_data+0x7ba>
        int16_t diff = meas_index2 - meas_index1;
 8003bf2:	1bc0      	subs	r0, r0, r7
 8003bf4:	b280      	uxth	r0, r0
        if (((diff > -3) && (diff < 0)) || (diff > 2))
 8003bf6:	1c82      	adds	r2, r0, #2
 8003bf8:	b292      	uxth	r2, r2
 8003bfa:	2a01      	cmp	r2, #1
 8003bfc:	d902      	bls.n	8003c04 <bme68x_get_data+0x808>
 8003bfe:	b200      	sxth	r0, r0
 8003c00:	2802      	cmp	r0, #2
 8003c02:	ddd8      	ble.n	8003bb6 <bme68x_get_data+0x7ba>
    field[index1] = field[index2];
 8003c04:	aa2f      	add	r2, sp, #188	@ 0xbc
 8003c06:	920c      	str	r2, [sp, #48]	@ 0x30
    meas_index1 = (int16_t)field[low_index]->meas_index;
 8003c08:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
    field[index2] = temp;
 8003c0a:	930e      	str	r3, [sp, #56]	@ 0x38
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003c0c:	f992 7000 	ldrsb.w	r7, [r2]
    meas_index1 = (int16_t)field[low_index]->meas_index;
 8003c10:	f892 c002 	ldrb.w	ip, [r2, #2]
    meas_index2 = (int16_t)field[high_index]->meas_index;
 8003c14:	7898      	ldrb	r0, [r3, #2]
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003c16:	2f00      	cmp	r7, #0
    meas_index2 = (int16_t)field[high_index]->meas_index;
 8003c18:	4619      	mov	r1, r3
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 8003c1a:	f6bf af53 	bge.w	8003ac4 <bme68x_get_data+0x6c8>
 8003c1e:	e7d9      	b.n	8003bd4 <bme68x_get_data+0x7d8>
            rslt = set_mem_page(reg_addr, dev);
 8003c20:	4659      	mov	r1, fp
 8003c22:	4640      	mov	r0, r8
 8003c24:	930b      	str	r3, [sp, #44]	@ 0x2c
 8003c26:	f7fe fbf5 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8003c2a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8003c2c:	4607      	mov	r7, r0
 8003c2e:	b920      	cbnz	r0, 8003c3a <bme68x_get_data+0x83e>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003c30:	f8db 7040 	ldr.w	r7, [fp, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8003c34:	f048 0880 	orr.w	r8, r8, #128	@ 0x80
 8003c38:	e4b9      	b.n	80035ae <bme68x_get_data+0x1b2>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003c3a:	4619      	mov	r1, r3
 8003c3c:	f8db 5040 	ldr.w	r5, [fp, #64]	@ 0x40
 8003c40:	f8db 3004 	ldr.w	r3, [fp, #4]
 8003c44:	4640      	mov	r0, r8
 8003c46:	2201      	movs	r2, #1
 8003c48:	47a8      	blx	r5
 8003c4a:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8003c4e:	2800      	cmp	r0, #0
 8003c50:	f43f ac8e 	beq.w	8003570 <bme68x_get_data+0x174>
 8003c54:	e4b4      	b.n	80035c0 <bme68x_get_data+0x1c4>
        rslt = BME68X_E_NULL_PTR;
 8003c56:	f04f 37ff 	mov.w	r7, #4294967295
 8003c5a:	e452      	b.n	8003502 <bme68x_get_data+0x106>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003c5c:	f8db 5040 	ldr.w	r5, [fp, #64]	@ 0x40
 8003c60:	f8db 3004 	ldr.w	r3, [fp, #4]
 8003c64:	a910      	add	r1, sp, #64	@ 0x40
 8003c66:	221e      	movs	r2, #30
 8003c68:	2050      	movs	r0, #80	@ 0x50
 8003c6a:	47a8      	blx	r5
 8003c6c:	f88b 004c 	strb.w	r0, [fp, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8003c70:	e41c      	b.n	80034ac <bme68x_get_data+0xb0>
            rslt = set_mem_page(reg_addr, dev);
 8003c72:	4659      	mov	r1, fp
 8003c74:	4640      	mov	r0, r8
 8003c76:	930b      	str	r3, [sp, #44]	@ 0x2c
 8003c78:	f7fe fbcc 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8003c7c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8003c7e:	4607      	mov	r7, r0
 8003c80:	2800      	cmp	r0, #0
 8003c82:	d1da      	bne.n	8003c3a <bme68x_get_data+0x83e>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003c84:	f8db 7040 	ldr.w	r7, [fp, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8003c88:	f048 0880 	orr.w	r8, r8, #128	@ 0x80
 8003c8c:	e4d1      	b.n	8003632 <bme68x_get_data+0x236>
        rslt = BME68X_E_NULL_PTR;
 8003c8e:	f04f 37ff 	mov.w	r7, #4294967295
 8003c92:	e46d      	b.n	8003570 <bme68x_get_data+0x174>
            rslt = set_mem_page(reg_addr, dev);
 8003c94:	4659      	mov	r1, fp
 8003c96:	4640      	mov	r0, r8
 8003c98:	930b      	str	r3, [sp, #44]	@ 0x2c
 8003c9a:	f7fe fbbb 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8003c9e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8003ca0:	4607      	mov	r7, r0
 8003ca2:	2800      	cmp	r0, #0
 8003ca4:	d1c9      	bne.n	8003c3a <bme68x_get_data+0x83e>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8003ca6:	f8db 7040 	ldr.w	r7, [fp, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8003caa:	f048 0880 	orr.w	r8, r8, #128	@ 0x80
 8003cae:	e4e5      	b.n	800367c <bme68x_get_data+0x280>
 8003cb0:	08016748 	.word	0x08016748
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
 8003cb4:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
 8003cb6:	ea4f 139a 	mov.w	r3, sl, lsr #6
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
 8003cba:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
    var2 *= INT32_C(3);
 8003cbe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    var2 = INT32_C(4096) + var2;
 8003cc2:	f503 6220 	add.w	r2, r3, #2560	@ 0xa00
    uint32_t var1 = UINT32_C(262144) >> gas_range;
 8003cc6:	f00a 0a0f 	and.w	sl, sl, #15
 8003cca:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003cce:	fa23 f30a 	lsr.w	r3, r3, sl
    calc_gas_res = (UINT32_C(10000) * var1) / (uint32_t)var2;
 8003cd2:	f242 7110 	movw	r1, #10000	@ 0x2710
 8003cd6:	fb01 f303 	mul.w	r3, r1, r3
 8003cda:	fbb3 f3f2 	udiv	r3, r3, r2
    calc_gas_res = calc_gas_res * 100;
 8003cde:	2264      	movs	r2, #100	@ 0x64
 8003ce0:	fb02 f303 	mul.w	r3, r2, r3
                    data->gas_resistance = calc_gas_resistance_high(adc_gas_res_high, gas_range_h);
 8003ce4:	612b      	str	r3, [r5, #16]
            if (rslt == BME68X_OK)
 8003ce6:	e590      	b.n	800380a <bme68x_get_data+0x40e>

08003ce8 <bme68x_set_heatr_conf>:
{
 8003ce8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003cec:	b095      	sub	sp, #84	@ 0x54
    if (conf != NULL)
 8003cee:	2900      	cmp	r1, #0
 8003cf0:	f000 8447 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
 8003cf4:	4606      	mov	r6, r0
 8003cf6:	468b      	mov	fp, r1
 8003cf8:	2000      	movs	r0, #0
 8003cfa:	4611      	mov	r1, r2
 8003cfc:	4614      	mov	r4, r2
 8003cfe:	f7fe ff5d 	bl	8002bbc <bme68x_set_op_mode>
        if (rslt == BME68X_OK)
 8003d02:	4605      	mov	r5, r0
 8003d04:	b118      	cbz	r0, 8003d0e <bme68x_set_heatr_conf+0x26>
}
 8003d06:	4628      	mov	r0, r5
 8003d08:	b015      	add	sp, #84	@ 0x54
 8003d0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint8_t heater_dur_shared_addr = BME68X_REG_SHD_HEATR_DUR;
 8003d0e:	236e      	movs	r3, #110	@ 0x6e
 8003d10:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d14:	4b10      	ldr	r3, [pc, #64]	@ (8003d58 <bme68x_set_heatr_conf+0x70>)
 8003d16:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8003d1a:	f10d 0818 	add.w	r8, sp, #24
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d1e:	f10d 0e24 	add.w	lr, sp, #36	@ 0x24
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d22:	f10d 0c30 	add.w	ip, sp, #48	@ 0x30
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d26:	af0f      	add	r7, sp, #60	@ 0x3c
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d28:	e8a8 0003 	stmia.w	r8!, {r0, r1}
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d2c:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d30:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d34:	c703      	stmia	r7!, {r0, r1}
    switch (op_mode)
 8003d36:	2e02      	cmp	r6, #2
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d38:	f8a8 2000 	strh.w	r2, [r8]
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d3c:	f8ae 2000 	strh.w	r2, [lr]
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d40:	f8ac 2000 	strh.w	r2, [ip]
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8003d44:	803a      	strh	r2, [r7, #0]
    switch (op_mode)
 8003d46:	d009      	beq.n	8003d5c <bme68x_set_heatr_conf+0x74>
 8003d48:	2e03      	cmp	r6, #3
 8003d4a:	f000 82e3 	beq.w	8004314 <bme68x_set_heatr_conf+0x62c>
 8003d4e:	2e01      	cmp	r6, #1
 8003d50:	f000 8277 	beq.w	8004242 <bme68x_set_heatr_conf+0x55a>
            rslt = BME68X_W_DEFINE_OP_MODE;
 8003d54:	2501      	movs	r5, #1
 8003d56:	e7d6      	b.n	8003d06 <bme68x_set_heatr_conf+0x1e>
 8003d58:	080167c8 	.word	0x080167c8
            if ((!conf->heatr_dur_prof) || (!conf->heatr_temp_prof))
 8003d5c:	f8db 000c 	ldr.w	r0, [fp, #12]
 8003d60:	2800      	cmp	r0, #0
 8003d62:	f000 840e 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
 8003d66:	f8db 8008 	ldr.w	r8, [fp, #8]
 8003d6a:	f1b8 0f00 	cmp.w	r8, #0
 8003d6e:	f000 8408 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
            if (conf->shared_heatr_dur == 0)
 8003d72:	f8bb 3012 	ldrh.w	r3, [fp, #18]
            for (i = 0; i < conf->profile_len; i++)
 8003d76:	f89b a010 	ldrb.w	sl, [fp, #16]
            if (conf->shared_heatr_dur == 0)
 8003d7a:	9302      	str	r3, [sp, #8]
 8003d7c:	2b00      	cmp	r3, #0
 8003d7e:	f000 83c6 	beq.w	800450e <bme68x_set_heatr_conf+0x826>
            for (i = 0; i < conf->profile_len; i++)
 8003d82:	f1ba 0f00 	cmp.w	sl, #0
 8003d86:	f000 83d9 	beq.w	800453c <bme68x_set_heatr_conf+0x854>
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003d8a:	f9b4 301a 	ldrsh.w	r3, [r4, #26]
 8003d8e:	4ae5      	ldr	r2, [pc, #916]	@ (8004124 <bme68x_set_heatr_conf+0x43c>)
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8003d90:	f994 601c 	ldrsb.w	r6, [r4, #28]
 8003d94:	4fe4      	ldr	r7, [pc, #912]	@ (8004128 <bme68x_set_heatr_conf+0x440>)
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003d96:	f503 3e16 	add.w	lr, r3, #153600	@ 0x25800
    if (temp > 400) /* Cap temperature */
 8003d9a:	f8b8 3000 	ldrh.w	r3, [r8]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003d9e:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 8003da2:	bf28      	it	cs
 8003da4:	f44f 73c8 	movcs.w	r3, #400	@ 0x190
 8003da8:	f20e 1e99 	addw	lr, lr, #409	@ 0x199
 8003dac:	fb0e f303 	mul.w	r3, lr, r3
 8003db0:	fba2 1303 	umull	r1, r3, r2, r3
 8003db4:	091b      	lsrs	r3, r3, #4
 8003db6:	f503 1348 	add.w	r3, r3, #3276800	@ 0x320000
 8003dba:	fba2 1303 	umull	r1, r3, r2, r3
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8003dbe:	f994 100e 	ldrsb.w	r1, [r4, #14]
 8003dc2:	fb11 f106 	smulbb	r1, r1, r6
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003dc6:	f994 6019 	ldrsb.w	r6, [r4, #25]
 8003dca:	08db      	lsrs	r3, r3, #3
 8003dcc:	f506 7944 	add.w	r9, r6, #784	@ 0x310
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8003dd0:	fb87 7c01 	smull	r7, ip, r7, r1
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003dd4:	fb09 f303 	mul.w	r3, r9, r3
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8003dd8:	17c9      	asrs	r1, r1, #31
 8003dda:	ebc1 11ac 	rsb	r1, r1, ip, asr #6
    var3 = var1 + (var2 / 2);
 8003dde:	105b      	asrs	r3, r3, #1
 8003de0:	eb03 2301 	add.w	r3, r3, r1, lsl #8
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8003de4:	0209      	lsls	r1, r1, #8
 8003de6:	9100      	str	r1, [sp, #0]
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 8003de8:	f894 103c 	ldrb.w	r1, [r4, #60]	@ 0x3c
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 8003dec:	f994 603d 	ldrsb.w	r6, [r4, #61]	@ 0x3d
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 8003df0:	3104      	adds	r1, #4
 8003df2:	9101      	str	r1, [sp, #4]
 8003df4:	fbb3 f3f1 	udiv	r3, r3, r1
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 8003df8:	eb06 1186 	add.w	r1, r6, r6, lsl #6
 8003dfc:	eb06 0641 	add.w	r6, r6, r1, lsl #1
 8003e00:	f506 3c80 	add.w	ip, r6, #65536	@ 0x10000
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8003e04:	fbb3 f3fc 	udiv	r3, r3, ip
 8003e08:	3bfa      	subs	r3, #250	@ 0xfa
 8003e0a:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8003e0e:	4ec7      	ldr	r6, [pc, #796]	@ (800412c <bme68x_set_heatr_conf+0x444>)
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8003e10:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8003e12:	3332      	adds	r3, #50	@ 0x32
 8003e14:	17d9      	asrs	r1, r3, #31
 8003e16:	fb86 7303 	smull	r7, r3, r6, r3
 8003e1a:	ebc1 1163 	rsb	r1, r1, r3, asr #5
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8003e1e:	2364      	movs	r3, #100	@ 0x64
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8003e20:	f88d 1024 	strb.w	r1, [sp, #36]	@ 0x24
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8003e24:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 8003e28:	8803      	ldrh	r3, [r0, #0]
 8003e2a:	f88d 303c 	strb.w	r3, [sp, #60]	@ 0x3c
            for (i = 0; i < conf->profile_len; i++)
 8003e2e:	f1ba 0f01 	cmp.w	sl, #1
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 8003e32:	f04f 035a 	mov.w	r3, #90	@ 0x5a
 8003e36:	f88d 3018 	strb.w	r3, [sp, #24]
            for (i = 0; i < conf->profile_len; i++)
 8003e3a:	f240 81dd 	bls.w	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 8003e3e:	f8b8 1002 	ldrh.w	r1, [r8, #2]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003e42:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 8003e46:	bf28      	it	cs
 8003e48:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 8003e4c:	fb0e f101 	mul.w	r1, lr, r1
 8003e50:	fba2 1301 	umull	r1, r3, r2, r1
 8003e54:	0919      	lsrs	r1, r3, #4
 8003e56:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 8003e5a:	fba2 1301 	umull	r1, r3, r2, r1
 8003e5e:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 8003e60:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003e62:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 8003e66:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 8003e6a:	9901      	ldr	r1, [sp, #4]
 8003e6c:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8003e70:	fbb3 f3fc 	udiv	r3, r3, ip
 8003e74:	3bfa      	subs	r3, #250	@ 0xfa
 8003e76:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 8003e7a:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8003e7c:	3332      	adds	r3, #50	@ 0x32
 8003e7e:	fb86 7103 	smull	r7, r1, r6, r3
 8003e82:	17db      	asrs	r3, r3, #31
 8003e84:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8003e88:	f88d 3025 	strb.w	r3, [sp, #37]	@ 0x25
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8003e8c:	2365      	movs	r3, #101	@ 0x65
 8003e8e:	f88d 3031 	strb.w	r3, [sp, #49]	@ 0x31
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 8003e92:	8843      	ldrh	r3, [r0, #2]
 8003e94:	f88d 303d 	strb.w	r3, [sp, #61]	@ 0x3d
            for (i = 0; i < conf->profile_len; i++)
 8003e98:	f1ba 0f02 	cmp.w	sl, #2
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 8003e9c:	f04f 035b 	mov.w	r3, #91	@ 0x5b
 8003ea0:	f88d 3019 	strb.w	r3, [sp, #25]
            for (i = 0; i < conf->profile_len; i++)
 8003ea4:	f000 81a8 	beq.w	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 8003ea8:	f8b8 1004 	ldrh.w	r1, [r8, #4]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003eac:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 8003eb0:	bf28      	it	cs
 8003eb2:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 8003eb6:	fb0e f101 	mul.w	r1, lr, r1
 8003eba:	fba2 1301 	umull	r1, r3, r2, r1
 8003ebe:	0919      	lsrs	r1, r3, #4
 8003ec0:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 8003ec4:	fba2 1301 	umull	r1, r3, r2, r1
 8003ec8:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 8003eca:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003ecc:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 8003ed0:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 8003ed4:	9901      	ldr	r1, [sp, #4]
 8003ed6:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8003eda:	fbb3 f3fc 	udiv	r3, r3, ip
 8003ede:	3bfa      	subs	r3, #250	@ 0xfa
 8003ee0:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 8003ee4:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8003ee6:	3332      	adds	r3, #50	@ 0x32
 8003ee8:	fb86 7103 	smull	r7, r1, r6, r3
 8003eec:	17db      	asrs	r3, r3, #31
 8003eee:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8003ef2:	f88d 3026 	strb.w	r3, [sp, #38]	@ 0x26
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8003ef6:	2366      	movs	r3, #102	@ 0x66
 8003ef8:	f88d 3032 	strb.w	r3, [sp, #50]	@ 0x32
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 8003efc:	8883      	ldrh	r3, [r0, #4]
 8003efe:	f88d 303e 	strb.w	r3, [sp, #62]	@ 0x3e
            for (i = 0; i < conf->profile_len; i++)
 8003f02:	f1ba 0f03 	cmp.w	sl, #3
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 8003f06:	f04f 035c 	mov.w	r3, #92	@ 0x5c
 8003f0a:	f88d 301a 	strb.w	r3, [sp, #26]
            for (i = 0; i < conf->profile_len; i++)
 8003f0e:	f000 8173 	beq.w	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 8003f12:	f8b8 1006 	ldrh.w	r1, [r8, #6]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003f16:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 8003f1a:	bf28      	it	cs
 8003f1c:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 8003f20:	fb0e f101 	mul.w	r1, lr, r1
 8003f24:	fba2 1301 	umull	r1, r3, r2, r1
 8003f28:	0919      	lsrs	r1, r3, #4
 8003f2a:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 8003f2e:	fba2 1301 	umull	r1, r3, r2, r1
 8003f32:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 8003f34:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003f36:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 8003f3a:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 8003f3e:	9901      	ldr	r1, [sp, #4]
 8003f40:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8003f44:	fbb3 f3fc 	udiv	r3, r3, ip
 8003f48:	3bfa      	subs	r3, #250	@ 0xfa
 8003f4a:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 8003f4e:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8003f50:	3332      	adds	r3, #50	@ 0x32
 8003f52:	fb86 7103 	smull	r7, r1, r6, r3
 8003f56:	17db      	asrs	r3, r3, #31
 8003f58:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8003f5c:	f88d 3027 	strb.w	r3, [sp, #39]	@ 0x27
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8003f60:	2367      	movs	r3, #103	@ 0x67
 8003f62:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 8003f66:	88c3      	ldrh	r3, [r0, #6]
 8003f68:	f88d 303f 	strb.w	r3, [sp, #63]	@ 0x3f
            for (i = 0; i < conf->profile_len; i++)
 8003f6c:	f1ba 0f04 	cmp.w	sl, #4
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 8003f70:	f04f 035d 	mov.w	r3, #93	@ 0x5d
 8003f74:	f88d 301b 	strb.w	r3, [sp, #27]
            for (i = 0; i < conf->profile_len; i++)
 8003f78:	f000 813e 	beq.w	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 8003f7c:	f8b8 1008 	ldrh.w	r1, [r8, #8]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003f80:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 8003f84:	bf28      	it	cs
 8003f86:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 8003f8a:	fb0e f101 	mul.w	r1, lr, r1
 8003f8e:	fba2 1301 	umull	r1, r3, r2, r1
 8003f92:	0919      	lsrs	r1, r3, #4
 8003f94:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 8003f98:	fba2 1301 	umull	r1, r3, r2, r1
 8003f9c:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 8003f9e:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003fa0:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 8003fa4:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 8003fa8:	9901      	ldr	r1, [sp, #4]
 8003faa:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8003fae:	fbb3 f3fc 	udiv	r3, r3, ip
 8003fb2:	3bfa      	subs	r3, #250	@ 0xfa
 8003fb4:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 8003fb8:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8003fba:	3332      	adds	r3, #50	@ 0x32
 8003fbc:	fb86 7103 	smull	r7, r1, r6, r3
 8003fc0:	17db      	asrs	r3, r3, #31
 8003fc2:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8003fc6:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8003fca:	2368      	movs	r3, #104	@ 0x68
 8003fcc:	f88d 3034 	strb.w	r3, [sp, #52]	@ 0x34
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 8003fd0:	8903      	ldrh	r3, [r0, #8]
 8003fd2:	f88d 3040 	strb.w	r3, [sp, #64]	@ 0x40
            for (i = 0; i < conf->profile_len; i++)
 8003fd6:	f1ba 0f05 	cmp.w	sl, #5
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 8003fda:	f04f 035e 	mov.w	r3, #94	@ 0x5e
 8003fde:	f88d 301c 	strb.w	r3, [sp, #28]
            for (i = 0; i < conf->profile_len; i++)
 8003fe2:	f000 8109 	beq.w	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 8003fe6:	f8b8 100a 	ldrh.w	r1, [r8, #10]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8003fea:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 8003fee:	bf28      	it	cs
 8003ff0:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 8003ff4:	fb0e f101 	mul.w	r1, lr, r1
 8003ff8:	fba2 1301 	umull	r1, r3, r2, r1
 8003ffc:	0919      	lsrs	r1, r3, #4
 8003ffe:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 8004002:	fba2 1301 	umull	r1, r3, r2, r1
 8004006:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 8004008:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 800400a:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 800400e:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 8004012:	9901      	ldr	r1, [sp, #4]
 8004014:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8004018:	fbb3 f3fc 	udiv	r3, r3, ip
 800401c:	3bfa      	subs	r3, #250	@ 0xfa
 800401e:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 8004022:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8004024:	3332      	adds	r3, #50	@ 0x32
 8004026:	fb86 7103 	smull	r7, r1, r6, r3
 800402a:	17db      	asrs	r3, r3, #31
 800402c:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8004030:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8004034:	2369      	movs	r3, #105	@ 0x69
 8004036:	f88d 3035 	strb.w	r3, [sp, #53]	@ 0x35
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 800403a:	8943      	ldrh	r3, [r0, #10]
 800403c:	f88d 3041 	strb.w	r3, [sp, #65]	@ 0x41
            for (i = 0; i < conf->profile_len; i++)
 8004040:	f1ba 0f06 	cmp.w	sl, #6
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 8004044:	f04f 035f 	mov.w	r3, #95	@ 0x5f
 8004048:	f88d 301d 	strb.w	r3, [sp, #29]
            for (i = 0; i < conf->profile_len; i++)
 800404c:	f000 80d4 	beq.w	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 8004050:	f8b8 100c 	ldrh.w	r1, [r8, #12]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004054:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 8004058:	bf28      	it	cs
 800405a:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 800405e:	fb0e f101 	mul.w	r1, lr, r1
 8004062:	fba2 1301 	umull	r1, r3, r2, r1
 8004066:	0919      	lsrs	r1, r3, #4
 8004068:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 800406c:	fba2 1301 	umull	r1, r3, r2, r1
 8004070:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 8004072:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004074:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 8004078:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 800407c:	9901      	ldr	r1, [sp, #4]
 800407e:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8004082:	fbb3 f3fc 	udiv	r3, r3, ip
 8004086:	3bfa      	subs	r3, #250	@ 0xfa
 8004088:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 800408c:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 800408e:	3332      	adds	r3, #50	@ 0x32
 8004090:	fb86 7103 	smull	r7, r1, r6, r3
 8004094:	17db      	asrs	r3, r3, #31
 8004096:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 800409a:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 800409e:	236a      	movs	r3, #106	@ 0x6a
 80040a0:	f88d 3036 	strb.w	r3, [sp, #54]	@ 0x36
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 80040a4:	8983      	ldrh	r3, [r0, #12]
 80040a6:	f88d 3042 	strb.w	r3, [sp, #66]	@ 0x42
            for (i = 0; i < conf->profile_len; i++)
 80040aa:	f1ba 0f07 	cmp.w	sl, #7
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 80040ae:	f04f 0360 	mov.w	r3, #96	@ 0x60
 80040b2:	f88d 301e 	strb.w	r3, [sp, #30]
            for (i = 0; i < conf->profile_len; i++)
 80040b6:	f000 809f 	beq.w	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 80040ba:	f8b8 100e 	ldrh.w	r1, [r8, #14]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 80040be:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 80040c2:	bf28      	it	cs
 80040c4:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 80040c8:	fb0e f101 	mul.w	r1, lr, r1
 80040cc:	fba2 1301 	umull	r1, r3, r2, r1
 80040d0:	0919      	lsrs	r1, r3, #4
 80040d2:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 80040d6:	fba2 1301 	umull	r1, r3, r2, r1
 80040da:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 80040dc:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 80040de:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 80040e2:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 80040e6:	9901      	ldr	r1, [sp, #4]
 80040e8:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 80040ec:	fbb3 f3fc 	udiv	r3, r3, ip
 80040f0:	3bfa      	subs	r3, #250	@ 0xfa
 80040f2:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 80040f6:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80040f8:	3332      	adds	r3, #50	@ 0x32
 80040fa:	fb86 7103 	smull	r7, r1, r6, r3
 80040fe:	17db      	asrs	r3, r3, #31
 8004100:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8004104:	f88d 302b 	strb.w	r3, [sp, #43]	@ 0x2b
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 8004108:	236b      	movs	r3, #107	@ 0x6b
 800410a:	f88d 3037 	strb.w	r3, [sp, #55]	@ 0x37
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 800410e:	89c3      	ldrh	r3, [r0, #14]
 8004110:	f88d 3043 	strb.w	r3, [sp, #67]	@ 0x43
            for (i = 0; i < conf->profile_len; i++)
 8004114:	f1ba 0f08 	cmp.w	sl, #8
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 8004118:	f04f 0361 	mov.w	r3, #97	@ 0x61
 800411c:	f88d 301f 	strb.w	r3, [sp, #31]
            for (i = 0; i < conf->profile_len; i++)
 8004120:	d06a      	beq.n	80041f8 <bme68x_set_heatr_conf+0x510>
 8004122:	e005      	b.n	8004130 <bme68x_set_heatr_conf+0x448>
 8004124:	cccccccd 	.word	0xcccccccd
 8004128:	10624dd3 	.word	0x10624dd3
 800412c:	51eb851f 	.word	0x51eb851f
    if (temp > 400) /* Cap temperature */
 8004130:	f8b8 1010 	ldrh.w	r1, [r8, #16]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004134:	f5b1 7fc8 	cmp.w	r1, #400	@ 0x190
 8004138:	bf28      	it	cs
 800413a:	f44f 71c8 	movcs.w	r1, #400	@ 0x190
 800413e:	fb0e f101 	mul.w	r1, lr, r1
 8004142:	fba2 1301 	umull	r1, r3, r2, r1
 8004146:	0919      	lsrs	r1, r3, #4
 8004148:	f501 1148 	add.w	r1, r1, #3276800	@ 0x320000
 800414c:	fba2 1301 	umull	r1, r3, r2, r1
 8004150:	08db      	lsrs	r3, r3, #3
    var3 = var1 + (var2 / 2);
 8004152:	9900      	ldr	r1, [sp, #0]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004154:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 8004158:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 800415c:	9901      	ldr	r1, [sp, #4]
 800415e:	fbb3 f3f1 	udiv	r3, r3, r1
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 8004162:	fbb3 f3fc 	udiv	r3, r3, ip
 8004166:	3bfa      	subs	r3, #250	@ 0xfa
 8004168:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 800416c:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 800416e:	3332      	adds	r3, #50	@ 0x32
 8004170:	fb86 7103 	smull	r7, r1, r6, r3
 8004174:	17db      	asrs	r3, r3, #31
 8004176:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 800417a:	f88d 302c 	strb.w	r3, [sp, #44]	@ 0x2c
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 800417e:	236c      	movs	r3, #108	@ 0x6c
 8004180:	f88d 3038 	strb.w	r3, [sp, #56]	@ 0x38
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 8004184:	8a03      	ldrh	r3, [r0, #16]
 8004186:	f88d 3044 	strb.w	r3, [sp, #68]	@ 0x44
            for (i = 0; i < conf->profile_len; i++)
 800418a:	f1ba 0f09 	cmp.w	sl, #9
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 800418e:	f04f 0362 	mov.w	r3, #98	@ 0x62
 8004192:	f88d 3020 	strb.w	r3, [sp, #32]
            for (i = 0; i < conf->profile_len; i++)
 8004196:	d02f      	beq.n	80041f8 <bme68x_set_heatr_conf+0x510>
    if (temp > 400) /* Cap temperature */
 8004198:	f8b8 3012 	ldrh.w	r3, [r8, #18]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 800419c:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 80041a0:	bf28      	it	cs
 80041a2:	f44f 73c8 	movcs.w	r3, #400	@ 0x190
 80041a6:	fb0e f303 	mul.w	r3, lr, r3
 80041aa:	fba2 1303 	umull	r1, r3, r2, r3
 80041ae:	091b      	lsrs	r3, r3, #4
 80041b0:	f503 1348 	add.w	r3, r3, #3276800	@ 0x320000
 80041b4:	fba2 2303 	umull	r2, r3, r2, r3
    var3 = var1 + (var2 / 2);
 80041b8:	9900      	ldr	r1, [sp, #0]
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 80041ba:	9a01      	ldr	r2, [sp, #4]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 80041bc:	08db      	lsrs	r3, r3, #3
 80041be:	fb09 f303 	mul.w	r3, r9, r3
    var3 = var1 + (var2 / 2);
 80041c2:	eb01 0363 	add.w	r3, r1, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 80041c6:	fbb3 f3f2 	udiv	r3, r3, r2
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 80041ca:	fbb3 f3fc 	udiv	r3, r3, ip
 80041ce:	3bfa      	subs	r3, #250	@ 0xfa
 80041d0:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 80041d4:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80041d6:	3332      	adds	r3, #50	@ 0x32
 80041d8:	fb86 2103 	smull	r2, r1, r6, r3
 80041dc:	17db      	asrs	r3, r3, #31
 80041de:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 80041e2:	f88d 302d 	strb.w	r3, [sp, #45]	@ 0x2d
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 80041e6:	236d      	movs	r3, #109	@ 0x6d
 80041e8:	f88d 3039 	strb.w	r3, [sp, #57]	@ 0x39
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 80041ec:	8a43      	ldrh	r3, [r0, #18]
 80041ee:	f88d 3045 	strb.w	r3, [sp, #69]	@ 0x45
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 80041f2:	2363      	movs	r3, #99	@ 0x63
 80041f4:	f88d 3021 	strb.w	r3, [sp, #33]	@ 0x21
    if (dur >= 0x783)
 80041f8:	9a02      	ldr	r2, [sp, #8]
 80041fa:	f240 7382 	movw	r3, #1922	@ 0x782
 80041fe:	429a      	cmp	r2, r3
 8004200:	f200 81bd 	bhi.w	800457e <bme68x_set_heatr_conf+0x896>
        dur = (uint16_t)(((uint32_t)dur * 1000) / 477);
 8004204:	9902      	ldr	r1, [sp, #8]
 8004206:	4ac9      	ldr	r2, [pc, #804]	@ (800452c <bme68x_set_heatr_conf+0x844>)
 8004208:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800420c:	fb03 f101 	mul.w	r1, r3, r1
 8004210:	460b      	mov	r3, r1
 8004212:	fb82 1203 	smull	r1, r2, r2, r3
        while (dur > 0x3F)
 8004216:	f247 713f 	movw	r1, #30527	@ 0x773f
 800421a:	428b      	cmp	r3, r1
        dur = (uint16_t)(((uint32_t)dur * 1000) / 477);
 800421c:	f3c2 120f 	ubfx	r2, r2, #4, #16
    uint8_t factor = 0;
 8004220:	f04f 0300 	mov.w	r3, #0
        while (dur > 0x3F)
 8004224:	d906      	bls.n	8004234 <bme68x_set_heatr_conf+0x54c>
            dur = dur >> 2;
 8004226:	0892      	lsrs	r2, r2, #2
            factor += 1;
 8004228:	3301      	adds	r3, #1
        while (dur > 0x3F)
 800422a:	2a3f      	cmp	r2, #63	@ 0x3f
            factor += 1;
 800422c:	b2db      	uxtb	r3, r3
        while (dur > 0x3F)
 800422e:	d8fa      	bhi.n	8004226 <bme68x_set_heatr_conf+0x53e>
        heatdurval = (uint8_t)(dur + (factor * 64));
 8004230:	019b      	lsls	r3, r3, #6
 8004232:	b2db      	uxtb	r3, r3
 8004234:	4413      	add	r3, r2
 8004236:	b2db      	uxtb	r3, r3
            if (rslt == BME68X_OK)
 8004238:	2d00      	cmp	r5, #0
 800423a:	f000 8186 	beq.w	800454a <bme68x_set_heatr_conf+0x862>
        if (rslt == BME68X_OK)
 800423e:	2503      	movs	r5, #3
 8004240:	e561      	b.n	8003d06 <bme68x_set_heatr_conf+0x1e>
    if (temp > 400) /* Cap temperature */
 8004242:	f8bb 2002 	ldrh.w	r2, [fp, #2]
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004246:	f9b4 301a 	ldrsh.w	r3, [r4, #26]
 800424a:	f5b2 7fc8 	cmp.w	r2, #400	@ 0x190
 800424e:	f503 3316 	add.w	r3, r3, #153600	@ 0x25800
 8004252:	bf28      	it	cs
 8004254:	f44f 72c8 	movcs.w	r2, #400	@ 0x190
 8004258:	f203 1399 	addw	r3, r3, #409	@ 0x199
 800425c:	fb02 f303 	mul.w	r3, r2, r3
 8004260:	4ab3      	ldr	r2, [pc, #716]	@ (8004530 <bme68x_set_heatr_conf+0x848>)
 8004262:	fba2 1303 	umull	r1, r3, r2, r3
 8004266:	091b      	lsrs	r3, r3, #4
 8004268:	f503 1348 	add.w	r3, r3, #3276800	@ 0x320000
 800426c:	fba2 2303 	umull	r2, r3, r2, r3
 8004270:	08d9      	lsrs	r1, r3, #3
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8004272:	f994 201c 	ldrsb.w	r2, [r4, #28]
 8004276:	f994 300e 	ldrsb.w	r3, [r4, #14]
 800427a:	fb13 f302 	smulbb	r3, r3, r2
 800427e:	4aad      	ldr	r2, [pc, #692]	@ (8004534 <bme68x_set_heatr_conf+0x84c>)
 8004280:	fb82 0203 	smull	r0, r2, r2, r3
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004284:	f994 0019 	ldrsb.w	r0, [r4, #25]
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8004288:	17db      	asrs	r3, r3, #31
 800428a:	ebc3 13a2 	rsb	r3, r3, r2, asr #6
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 800428e:	f500 7044 	add.w	r0, r0, #784	@ 0x310
 8004292:	fb00 f101 	mul.w	r1, r0, r1
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8004296:	021b      	lsls	r3, r3, #8
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 8004298:	f994 203d 	ldrsb.w	r2, [r4, #61]	@ 0x3d
    var3 = var1 + (var2 / 2);
 800429c:	eb03 0361 	add.w	r3, r3, r1, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 80042a0:	f894 103c 	ldrb.w	r1, [r4, #60]	@ 0x3c
 80042a4:	3104      	adds	r1, #4
 80042a6:	fbb3 f3f1 	udiv	r3, r3, r1
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 80042aa:	eb02 1182 	add.w	r1, r2, r2, lsl #6
 80042ae:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 80042b2:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 80042b6:	fbb3 f3f2 	udiv	r3, r3, r2
 80042ba:	3bfa      	subs	r3, #250	@ 0xfa
 80042bc:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80042c0:	4a9d      	ldr	r2, [pc, #628]	@ (8004538 <bme68x_set_heatr_conf+0x850>)
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 80042c2:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80042c4:	3332      	adds	r3, #50	@ 0x32
 80042c6:	fb82 1203 	smull	r1, r2, r2, r3
 80042ca:	17db      	asrs	r3, r3, #31
 80042cc:	ebc3 1362 	rsb	r3, r3, r2, asr #5
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
 80042d0:	f8bb 2004 	ldrh.w	r2, [fp, #4]
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80042d4:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
            rh_reg_addr[0] = BME68X_REG_RES_HEAT0;
 80042d8:	235a      	movs	r3, #90	@ 0x5a
 80042da:	f88d 3018 	strb.w	r3, [sp, #24]
    if (dur >= 0xfc0)
 80042de:	f5b2 6f7c 	cmp.w	r2, #4032	@ 0xfc0
            gw_reg_addr[0] = BME68X_REG_GAS_WAIT0;
 80042e2:	f04f 0364 	mov.w	r3, #100	@ 0x64
 80042e6:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
    if (dur >= 0xfc0)
 80042ea:	f080 8146 	bcs.w	800457a <bme68x_set_heatr_conf+0x892>
        while (dur > 0x3F)
 80042ee:	2a3f      	cmp	r2, #63	@ 0x3f
 80042f0:	f240 811a 	bls.w	8004528 <bme68x_set_heatr_conf+0x840>
    uint8_t factor = 0;
 80042f4:	4628      	mov	r0, r5
            dur = dur / 4;
 80042f6:	0892      	lsrs	r2, r2, #2
            factor += 1;
 80042f8:	3001      	adds	r0, #1
        while (dur > 0x3F)
 80042fa:	2a3f      	cmp	r2, #63	@ 0x3f
            factor += 1;
 80042fc:	b2c0      	uxtb	r0, r0
        while (dur > 0x3F)
 80042fe:	d8fa      	bhi.n	80042f6 <bme68x_set_heatr_conf+0x60e>
        durval = (uint8_t)(dur + (factor * 64));
 8004300:	0183      	lsls	r3, r0, #6
 8004302:	b2db      	uxtb	r3, r3
 8004304:	4413      	add	r3, r2
 8004306:	b2db      	uxtb	r3, r3
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
 8004308:	f88d 303c 	strb.w	r3, [sp, #60]	@ 0x3c
 800430c:	2701      	movs	r7, #1
            (*nb_conv) = 0;
 800430e:	f04f 0a00 	mov.w	sl, #0
 8004312:	e088      	b.n	8004426 <bme68x_set_heatr_conf+0x73e>
            if ((!conf->heatr_dur_prof) || (!conf->heatr_temp_prof))
 8004314:	f8db 200c 	ldr.w	r2, [fp, #12]
 8004318:	2a00      	cmp	r2, #0
 800431a:	f000 8132 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
 800431e:	f8db 1008 	ldr.w	r1, [fp, #8]
 8004322:	2900      	cmp	r1, #0
 8004324:	f000 812d 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
            for (i = 0; i < conf->profile_len; i++)
 8004328:	f89b a010 	ldrb.w	sl, [fp, #16]
 800432c:	f1ba 0f00 	cmp.w	sl, #0
 8004330:	f000 8118 	beq.w	8004564 <bme68x_set_heatr_conf+0x87c>
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8004334:	f994 300e 	ldrsb.w	r3, [r4, #14]
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 8004338:	f994 803d 	ldrsb.w	r8, [r4, #61]	@ 0x3d
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 800433c:	f9b4 901a 	ldrsh.w	r9, [r4, #26]
 8004340:	9403      	str	r4, [sp, #12]
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 8004342:	4628      	mov	r0, r5
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8004344:	f994 501c 	ldrsb.w	r5, [r4, #28]
 8004348:	fb13 f305 	smulbb	r3, r3, r5
 800434c:	4d79      	ldr	r5, [pc, #484]	@ (8004534 <bme68x_set_heatr_conf+0x84c>)
 800434e:	fb85 6503 	smull	r6, r5, r5, r3
 8004352:	17de      	asrs	r6, r3, #31
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004354:	f994 3019 	ldrsb.w	r3, [r4, #25]
 8004358:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 800435c:	9300      	str	r3, [sp, #0]
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 800435e:	f894 303c 	ldrb.w	r3, [r4, #60]	@ 0x3c
 8004362:	3304      	adds	r3, #4
 8004364:	9301      	str	r3, [sp, #4]
 8004366:	f8dd c004 	ldr.w	ip, [sp, #4]
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 800436a:	eb08 1388 	add.w	r3, r8, r8, lsl #6
 800436e:	e9cd ab01 	strd	sl, fp, [sp, #4]
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8004372:	ebc6 16a5 	rsb	r6, r6, r5, asr #6
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004376:	f509 3916 	add.w	r9, r9, #153600	@ 0x25800
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 800437a:	eb08 0843 	add.w	r8, r8, r3, lsl #1
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 800437e:	4d6c      	ldr	r5, [pc, #432]	@ (8004530 <bme68x_set_heatr_conf+0x848>)
 8004380:	3902      	subs	r1, #2
 8004382:	3a02      	subs	r2, #2
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 8004384:	0236      	lsls	r6, r6, #8
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004386:	f209 1999 	addw	r9, r9, #409	@ 0x199
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 800438a:	f508 3880 	add.w	r8, r8, #65536	@ 0x10000
 800438e:	f10d 0e18 	add.w	lr, sp, #24
    if (temp > 400) /* Cap temperature */
 8004392:	f831 4f02 	ldrh.w	r4, [r1, #2]!
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8004396:	4f68      	ldr	r7, [pc, #416]	@ (8004538 <bme68x_set_heatr_conf+0x850>)
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004398:	f5b4 7fc8 	cmp.w	r4, #400	@ 0x190
 800439c:	bf28      	it	cs
 800439e:	f44f 74c8 	movcs.w	r4, #400	@ 0x190
 80043a2:	fb09 f404 	mul.w	r4, r9, r4
 80043a6:	fba5 4304 	umull	r4, r3, r5, r4
 80043aa:	091c      	lsrs	r4, r3, #4
 80043ac:	f504 1448 	add.w	r4, r4, #3276800	@ 0x320000
 80043b0:	fba5 4304 	umull	r4, r3, r5, r4
 80043b4:	9c00      	ldr	r4, [sp, #0]
 80043b6:	08db      	lsrs	r3, r3, #3
 80043b8:	fb04 f303 	mul.w	r3, r4, r3
    var3 = var1 + (var2 / 2);
 80043bc:	eb06 0363 	add.w	r3, r6, r3, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 80043c0:	fbb3 f3fc 	udiv	r3, r3, ip
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 80043c4:	fbb3 f3f8 	udiv	r3, r3, r8
 80043c8:	3bfa      	subs	r3, #250	@ 0xfa
 80043ca:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 80043ce:	005b      	lsls	r3, r3, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80043d0:	3332      	adds	r3, #50	@ 0x32
 80043d2:	fb87 b703 	smull	fp, r7, r7, r3
 80043d6:	17db      	asrs	r3, r3, #31
 80043d8:	ebc3 1367 	rsb	r3, r3, r7, asr #5
 80043dc:	af09      	add	r7, sp, #36	@ 0x24
 80043de:	b2c4      	uxtb	r4, r0
 80043e0:	543b      	strb	r3, [r7, r0]
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 80043e2:	af0c      	add	r7, sp, #48	@ 0x30
 80043e4:	f104 0364 	add.w	r3, r4, #100	@ 0x64
 80043e8:	543b      	strb	r3, [r7, r0]
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 80043ea:	345a      	adds	r4, #90	@ 0x5a
 80043ec:	f80e 4b01 	strb.w	r4, [lr], #1
                gw_reg_data[i] = calc_gas_wait(conf->heatr_dur_prof[i]);
 80043f0:	f832 4f02 	ldrh.w	r4, [r2, #2]!
    if (dur >= 0xfc0)
 80043f4:	f5b4 6f7c 	cmp.w	r4, #4032	@ 0xfc0
 80043f8:	f080 8087 	bcs.w	800450a <bme68x_set_heatr_conf+0x822>
        while (dur > 0x3F)
 80043fc:	2c3f      	cmp	r4, #63	@ 0x3f
    uint8_t factor = 0;
 80043fe:	f04f 0300 	mov.w	r3, #0
        while (dur > 0x3F)
 8004402:	d906      	bls.n	8004412 <bme68x_set_heatr_conf+0x72a>
            dur = dur / 4;
 8004404:	08a4      	lsrs	r4, r4, #2
            factor += 1;
 8004406:	3301      	adds	r3, #1
        while (dur > 0x3F)
 8004408:	2c3f      	cmp	r4, #63	@ 0x3f
            factor += 1;
 800440a:	b2db      	uxtb	r3, r3
        while (dur > 0x3F)
 800440c:	d8fa      	bhi.n	8004404 <bme68x_set_heatr_conf+0x71c>
        durval = (uint8_t)(dur + (factor * 64));
 800440e:	019b      	lsls	r3, r3, #6
 8004410:	b2db      	uxtb	r3, r3
 8004412:	4423      	add	r3, r4
 8004414:	b2db      	uxtb	r3, r3
                gw_reg_data[i] = calc_gas_wait(conf->heatr_dur_prof[i]);
 8004416:	ac0f      	add	r4, sp, #60	@ 0x3c
 8004418:	5423      	strb	r3, [r4, r0]
            for (i = 0; i < conf->profile_len; i++)
 800441a:	3001      	adds	r0, #1
 800441c:	4582      	cmp	sl, r0
 800441e:	d1b8      	bne.n	8004392 <bme68x_set_heatr_conf+0x6aa>
 8004420:	e9dd 7b01 	ldrd	r7, fp, [sp, #4]
 8004424:	9c03      	ldr	r4, [sp, #12]
        rslt = bme68x_set_regs(rh_reg_addr, rh_reg_data, write_len, dev);
 8004426:	a806      	add	r0, sp, #24
 8004428:	4623      	mov	r3, r4
 800442a:	463a      	mov	r2, r7
 800442c:	a909      	add	r1, sp, #36	@ 0x24
 800442e:	f7fe fa41 	bl	80028b4 <bme68x_set_regs>
    if (rslt == BME68X_OK)
 8004432:	4605      	mov	r5, r0
 8004434:	2800      	cmp	r0, #0
 8004436:	f47f ac66 	bne.w	8003d06 <bme68x_set_heatr_conf+0x1e>
        rslt = bme68x_set_regs(gw_reg_addr, gw_reg_data, write_len, dev);
 800443a:	463a      	mov	r2, r7
 800443c:	a90f      	add	r1, sp, #60	@ 0x3c
 800443e:	4623      	mov	r3, r4
 8004440:	a80c      	add	r0, sp, #48	@ 0x30
 8004442:	f7fe fa37 	bl	80028b4 <bme68x_set_regs>
        if (rslt == BME68X_OK)
 8004446:	4605      	mov	r5, r0
 8004448:	2800      	cmp	r0, #0
 800444a:	f47f ac5c 	bne.w	8003d06 <bme68x_set_heatr_conf+0x1e>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 800444e:	2c00      	cmp	r4, #0
 8004450:	f000 8097 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
 8004454:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 8004456:	2d00      	cmp	r5, #0
 8004458:	f000 8093 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
 800445c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800445e:	2b00      	cmp	r3, #0
 8004460:	f000 808f 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
 8004464:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8004466:	2b00      	cmp	r3, #0
 8004468:	f000 808b 	beq.w	8004582 <bme68x_set_heatr_conf+0x89a>
        if (dev->intf == BME68X_SPI_INTF)
 800446c:	7b23      	ldrb	r3, [r4, #12]
 800446e:	2b00      	cmp	r3, #0
 8004470:	d07a      	beq.n	8004568 <bme68x_set_heatr_conf+0x880>
 8004472:	2070      	movs	r0, #112	@ 0x70
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8004474:	6863      	ldr	r3, [r4, #4]
 8004476:	a90c      	add	r1, sp, #48	@ 0x30
 8004478:	2202      	movs	r2, #2
 800447a:	47a8      	blx	r5
 800447c:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 8004480:	2800      	cmp	r0, #0
 8004482:	d13e      	bne.n	8004502 <bme68x_set_heatr_conf+0x81a>
                if (conf->enable == BME68X_ENABLE)
 8004484:	f89b 3000 	ldrb.w	r3, [fp]
 8004488:	2b01      	cmp	r3, #1
 800448a:	d046      	beq.n	800451a <bme68x_set_heatr_conf+0x832>
 800448c:	2108      	movs	r1, #8
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 800448e:	f89d 3031 	ldrb.w	r3, [sp, #49]	@ 0x31
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8004492:	6c25      	ldr	r5, [r4, #64]	@ 0x40
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 8004494:	f00a 020f 	and.w	r2, sl, #15
 8004498:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 800449c:	4313      	orrs	r3, r2
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 800449e:	2200      	movs	r2, #0
 80044a0:	e9cd 220f 	strd	r2, r2, [sp, #60]	@ 0x3c
 80044a4:	e9cd 2211 	strd	r2, r2, [sp, #68]	@ 0x44
 80044a8:	9213      	str	r2, [sp, #76]	@ 0x4c
                ctrl_gas_data[0] = BME68X_SET_BITS(ctrl_gas_data[0], BME68X_HCTRL, hctrl);
 80044aa:	f89d 2030 	ldrb.w	r2, [sp, #48]	@ 0x30
 80044ae:	f022 0208 	bic.w	r2, r2, #8
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 80044b2:	4303      	orrs	r3, r0
                ctrl_gas_data[0] = BME68X_SET_BITS(ctrl_gas_data[0], BME68X_HCTRL, hctrl);
 80044b4:	430a      	orrs	r2, r1
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 80044b6:	f88d 3031 	strb.w	r3, [sp, #49]	@ 0x31
                ctrl_gas_data[0] = BME68X_SET_BITS(ctrl_gas_data[0], BME68X_HCTRL, hctrl);
 80044ba:	f88d 2030 	strb.w	r2, [sp, #48]	@ 0x30
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80044be:	2d00      	cmp	r5, #0
 80044c0:	d05f      	beq.n	8004582 <bme68x_set_heatr_conf+0x89a>
 80044c2:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 80044c4:	2e00      	cmp	r6, #0
 80044c6:	d05c      	beq.n	8004582 <bme68x_set_heatr_conf+0x89a>
 80044c8:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 80044ca:	2900      	cmp	r1, #0
 80044cc:	d059      	beq.n	8004582 <bme68x_set_heatr_conf+0x89a>
                if (dev->intf == BME68X_SPI_INTF)
 80044ce:	7b21      	ldrb	r1, [r4, #12]
 80044d0:	2900      	cmp	r1, #0
 80044d2:	d066      	beq.n	80045a2 <bme68x_set_heatr_conf+0x8ba>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80044d4:	2170      	movs	r1, #112	@ 0x70
 80044d6:	f88d 103c 	strb.w	r1, [sp, #60]	@ 0x3c
 80044da:	2171      	movs	r1, #113	@ 0x71
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80044dc:	f88d 203d 	strb.w	r2, [sp, #61]	@ 0x3d
 80044e0:	f88d 303f 	strb.w	r3, [sp, #63]	@ 0x3f
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80044e4:	f88d 103e 	strb.w	r1, [sp, #62]	@ 0x3e
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 80044e8:	6863      	ldr	r3, [r4, #4]
 80044ea:	f89d 003c 	ldrb.w	r0, [sp, #60]	@ 0x3c
 80044ee:	2203      	movs	r2, #3
 80044f0:	f10d 013d 	add.w	r1, sp, #61	@ 0x3d
 80044f4:	47b0      	blx	r6
 80044f6:	4605      	mov	r5, r0
 80044f8:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 80044fc:	2800      	cmp	r0, #0
 80044fe:	f43f ac02 	beq.w	8003d06 <bme68x_set_heatr_conf+0x1e>
                rslt = BME68X_E_COM_FAIL;
 8004502:	f06f 0501 	mvn.w	r5, #1
 8004506:	f7ff bbfe 	b.w	8003d06 <bme68x_set_heatr_conf+0x1e>
        durval = 0xff; /* Max duration*/
 800450a:	23ff      	movs	r3, #255	@ 0xff
 800450c:	e783      	b.n	8004416 <bme68x_set_heatr_conf+0x72e>
                rslt = BME68X_W_DEFINE_SHD_HEATR_DUR;
 800450e:	2503      	movs	r5, #3
            for (i = 0; i < conf->profile_len; i++)
 8004510:	f1ba 0f00 	cmp.w	sl, #0
 8004514:	f47f ac39 	bne.w	8003d8a <bme68x_set_heatr_conf+0xa2>
 8004518:	e691      	b.n	800423e <bme68x_set_heatr_conf+0x556>
                    if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 800451a:	68a3      	ldr	r3, [r4, #8]
 800451c:	2b01      	cmp	r3, #1
 800451e:	4601      	mov	r1, r0
 8004520:	bf14      	ite	ne
 8004522:	2010      	movne	r0, #16
 8004524:	2020      	moveq	r0, #32
 8004526:	e7b2      	b.n	800448e <bme68x_set_heatr_conf+0x7a6>
        while (dur > 0x3F)
 8004528:	462b      	mov	r3, r5
 800452a:	e6eb      	b.n	8004304 <bme68x_set_heatr_conf+0x61c>
 800452c:	089645c5 	.word	0x089645c5
 8004530:	cccccccd 	.word	0xcccccccd
 8004534:	10624dd3 	.word	0x10624dd3
 8004538:	51eb851f 	.word	0x51eb851f
 800453c:	461a      	mov	r2, r3
    if (dur >= 0x783)
 800453e:	f240 7382 	movw	r3, #1922	@ 0x782
 8004542:	429a      	cmp	r2, r3
 8004544:	f67f ae5e 	bls.w	8004204 <bme68x_set_heatr_conf+0x51c>
 8004548:	23ff      	movs	r3, #255	@ 0xff
                rslt = bme68x_set_regs(&heater_dur_shared_addr, &shared_dur, 1, dev);
 800454a:	4622      	mov	r2, r4
 800454c:	f10d 0116 	add.w	r1, sp, #22
 8004550:	f10d 0017 	add.w	r0, sp, #23
            shared_dur = calc_heatr_dur_shared(conf->shared_heatr_dur);
 8004554:	f88d 3016 	strb.w	r3, [sp, #22]
                rslt = bme68x_set_regs(&heater_dur_shared_addr, &shared_dur, 1, dev);
 8004558:	f7fd ff9a 	bl	8002490 <bme68x_set_regs.constprop.0>
    if (rslt == BME68X_OK)
 800455c:	4605      	mov	r5, r0
 800455e:	2800      	cmp	r0, #0
 8004560:	f47f abd1 	bne.w	8003d06 <bme68x_set_heatr_conf+0x1e>
            for (i = 0; i < conf->profile_len; i++)
 8004564:	4657      	mov	r7, sl
 8004566:	e75e      	b.n	8004426 <bme68x_set_heatr_conf+0x73e>
            rslt = set_mem_page(reg_addr, dev);
 8004568:	4621      	mov	r1, r4
 800456a:	2070      	movs	r0, #112	@ 0x70
 800456c:	f7fd ff52 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8004570:	4605      	mov	r5, r0
 8004572:	b950      	cbnz	r0, 800458a <bme68x_set_heatr_conf+0x8a2>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8004574:	6c25      	ldr	r5, [r4, #64]	@ 0x40
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8004576:	20f0      	movs	r0, #240	@ 0xf0
 8004578:	e77c      	b.n	8004474 <bme68x_set_heatr_conf+0x78c>
        durval = 0xff; /* Max duration*/
 800457a:	23ff      	movs	r3, #255	@ 0xff
 800457c:	e6c4      	b.n	8004308 <bme68x_set_heatr_conf+0x620>
        heatdurval = 0xff; /* Max duration */
 800457e:	23ff      	movs	r3, #255	@ 0xff
 8004580:	e65a      	b.n	8004238 <bme68x_set_heatr_conf+0x550>
        rslt = BME68X_E_NULL_PTR;
 8004582:	f04f 35ff 	mov.w	r5, #4294967295
 8004586:	f7ff bbbe 	b.w	8003d06 <bme68x_set_heatr_conf+0x1e>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 800458a:	6c26      	ldr	r6, [r4, #64]	@ 0x40
 800458c:	6863      	ldr	r3, [r4, #4]
 800458e:	a90c      	add	r1, sp, #48	@ 0x30
 8004590:	2202      	movs	r2, #2
 8004592:	2070      	movs	r0, #112	@ 0x70
 8004594:	47b0      	blx	r6
 8004596:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
        if (dev->intf_rslt != 0)
 800459a:	2800      	cmp	r0, #0
 800459c:	f43f abb3 	beq.w	8003d06 <bme68x_set_heatr_conf+0x1e>
 80045a0:	e7af      	b.n	8004502 <bme68x_set_heatr_conf+0x81a>
        if (mem_page != dev->mem_page)
 80045a2:	7b63      	ldrb	r3, [r4, #13]
 80045a4:	2b10      	cmp	r3, #16
 80045a6:	d069      	beq.n	800467c <bme68x_set_heatr_conf+0x994>
            dev->mem_page = mem_page;
 80045a8:	2210      	movs	r2, #16
 80045aa:	7362      	strb	r2, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 80045ac:	6863      	ldr	r3, [r4, #4]
 80045ae:	2201      	movs	r2, #1
 80045b0:	a909      	add	r1, sp, #36	@ 0x24
 80045b2:	20f3      	movs	r0, #243	@ 0xf3
 80045b4:	47a8      	blx	r5
 80045b6:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 80045ba:	2800      	cmp	r0, #0
 80045bc:	d164      	bne.n	8004688 <bme68x_set_heatr_conf+0x9a0>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 80045be:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80045c2:	7b62      	ldrb	r2, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 80045c4:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 80045c6:	f023 0310 	bic.w	r3, r3, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 80045ca:	f002 0210 	and.w	r2, r2, #16
 80045ce:	431a      	orrs	r2, r3
 80045d0:	f88d 2024 	strb.w	r2, [sp, #36]	@ 0x24
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 80045d4:	6863      	ldr	r3, [r4, #4]
 80045d6:	2201      	movs	r2, #1
 80045d8:	a909      	add	r1, sp, #36	@ 0x24
 80045da:	2073      	movs	r0, #115	@ 0x73
 80045dc:	47a8      	blx	r5
 80045de:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 80045e2:	2800      	cmp	r0, #0
 80045e4:	d150      	bne.n	8004688 <bme68x_set_heatr_conf+0x9a0>
                if (dev->intf == BME68X_SPI_INTF)
 80045e6:	7b23      	ldrb	r3, [r4, #12]
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80045e8:	f89d 2030 	ldrb.w	r2, [sp, #48]	@ 0x30
 80045ec:	f88d 203d 	strb.w	r2, [sp, #61]	@ 0x3d
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 80045f0:	2170      	movs	r1, #112	@ 0x70
 80045f2:	f88d 103c 	strb.w	r1, [sp, #60]	@ 0x3c
                if (dev->intf == BME68X_SPI_INTF)
 80045f6:	b15b      	cbz	r3, 8004610 <bme68x_set_heatr_conf+0x928>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80045f8:	f89d 3031 	ldrb.w	r3, [sp, #49]	@ 0x31
 80045fc:	f88d 303f 	strb.w	r3, [sp, #63]	@ 0x3f
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8004600:	2271      	movs	r2, #113	@ 0x71
 8004602:	f88d 203e 	strb.w	r2, [sp, #62]	@ 0x3e
            if (rslt == BME68X_OK)
 8004606:	2800      	cmp	r0, #0
 8004608:	f47f af7b 	bne.w	8004502 <bme68x_set_heatr_conf+0x81a>
 800460c:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 800460e:	e76b      	b.n	80044e8 <bme68x_set_heatr_conf+0x800>
 8004610:	6c25      	ldr	r5, [r4, #64]	@ 0x40
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8004612:	2d00      	cmp	r5, #0
 8004614:	d0b5      	beq.n	8004582 <bme68x_set_heatr_conf+0x89a>
 8004616:	6c66      	ldr	r6, [r4, #68]	@ 0x44
 8004618:	2e00      	cmp	r6, #0
 800461a:	d0b2      	beq.n	8004582 <bme68x_set_heatr_conf+0x89a>
 800461c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 800461e:	2b00      	cmp	r3, #0
 8004620:	d0af      	beq.n	8004582 <bme68x_set_heatr_conf+0x89a>
        if (mem_page != dev->mem_page)
 8004622:	7b63      	ldrb	r3, [r4, #13]
 8004624:	2b10      	cmp	r3, #16
 8004626:	d021      	beq.n	800466c <bme68x_set_heatr_conf+0x984>
            dev->mem_page = mem_page;
 8004628:	2210      	movs	r2, #16
 800462a:	7362      	strb	r2, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 800462c:	6863      	ldr	r3, [r4, #4]
 800462e:	2201      	movs	r2, #1
 8004630:	a909      	add	r1, sp, #36	@ 0x24
 8004632:	20f3      	movs	r0, #243	@ 0xf3
 8004634:	47a8      	blx	r5
 8004636:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
            if (dev->intf_rslt != 0)
 800463a:	2800      	cmp	r0, #0
 800463c:	f47f af61 	bne.w	8004502 <bme68x_set_heatr_conf+0x81a>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8004640:	f89d 2024 	ldrb.w	r2, [sp, #36]	@ 0x24
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8004644:	7b63      	ldrb	r3, [r4, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8004646:	6c65      	ldr	r5, [r4, #68]	@ 0x44
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8004648:	f003 0310 	and.w	r3, r3, #16
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 800464c:	f022 0210 	bic.w	r2, r2, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8004650:	431a      	orrs	r2, r3
 8004652:	f88d 2024 	strb.w	r2, [sp, #36]	@ 0x24
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8004656:	6863      	ldr	r3, [r4, #4]
 8004658:	a909      	add	r1, sp, #36	@ 0x24
 800465a:	2201      	movs	r2, #1
 800465c:	2073      	movs	r0, #115	@ 0x73
 800465e:	47a8      	blx	r5
 8004660:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
                if (dev->intf_rslt != 0)
 8004664:	2800      	cmp	r0, #0
 8004666:	f47f af4c 	bne.w	8004502 <bme68x_set_heatr_conf+0x81a>
 800466a:	6c66      	ldr	r6, [r4, #68]	@ 0x44
                tmp_buff[(2 * index) + 1] = reg_data[index];
 800466c:	f89d 3031 	ldrb.w	r3, [sp, #49]	@ 0x31
 8004670:	f88d 303f 	strb.w	r3, [sp, #63]	@ 0x3f
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8004674:	2271      	movs	r2, #113	@ 0x71
 8004676:	f88d 203e 	strb.w	r2, [sp, #62]	@ 0x3e
            if (rslt == BME68X_OK)
 800467a:	e735      	b.n	80044e8 <bme68x_set_heatr_conf+0x800>
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 800467c:	2370      	movs	r3, #112	@ 0x70
 800467e:	f88d 303c 	strb.w	r3, [sp, #60]	@ 0x3c
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004682:	f88d 203d 	strb.w	r2, [sp, #61]	@ 0x3d
                if (dev->intf == BME68X_SPI_INTF)
 8004686:	e7c4      	b.n	8004612 <bme68x_set_heatr_conf+0x92a>
                rslt = BME68X_E_COM_FAIL;
 8004688:	f06f 0001 	mvn.w	r0, #1
 800468c:	e7ab      	b.n	80045e6 <bme68x_set_heatr_conf+0x8fe>
 800468e:	bf00      	nop

08004690 <bme68x_selftest_check>:
{
 8004690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004694:	4604      	mov	r4, r0
 8004696:	b0c9      	sub	sp, #292	@ 0x124
    struct bme68x_data data[BME68X_N_MEAS] = { { 0 } };
 8004698:	2278      	movs	r2, #120	@ 0x78
 800469a:	2100      	movs	r1, #0
 800469c:	a82a      	add	r0, sp, #168	@ 0xa8
 800469e:	f011 fd13 	bl	80160c8 <memset>
    t_dev.read = dev->read;
 80046a2:	6c23      	ldr	r3, [r4, #64]	@ 0x40
    t_dev.intf_ptr = dev->intf_ptr;
 80046a4:	6861      	ldr	r1, [r4, #4]
    t_dev.read = dev->read;
 80046a6:	9326      	str	r3, [sp, #152]	@ 0x98
 80046a8:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	@ 0x44
    t_dev.intf_ptr = dev->intf_ptr;
 80046ac:	9117      	str	r1, [sp, #92]	@ 0x5c
    t_dev.intf = dev->intf;
 80046ae:	7b21      	ldrb	r1, [r4, #12]
 80046b0:	f88d 1064 	strb.w	r1, [sp, #100]	@ 0x64
    rslt = bme68x_init(&t_dev);
 80046b4:	a816      	add	r0, sp, #88	@ 0x58
    t_dev.amb_temp = 25;
 80046b6:	2119      	movs	r1, #25
    t_dev.read = dev->read;
 80046b8:	e9cd 2327 	strd	r2, r3, [sp, #156]	@ 0x9c
    t_dev.amb_temp = 25;
 80046bc:	f88d 1066 	strb.w	r1, [sp, #102]	@ 0x66
    rslt = bme68x_init(&t_dev);
 80046c0:	f7fd ff58 	bl	8002574 <bme68x_init>
    if (rslt == BME68X_OK)
 80046c4:	4606      	mov	r6, r0
 80046c6:	b118      	cbz	r0, 80046d0 <bme68x_selftest_check+0x40>
}
 80046c8:	4630      	mov	r0, r6
 80046ca:	b049      	add	sp, #292	@ 0x124
 80046cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        heatr_conf.heatr_temp = BME68X_HIGH_TEMP;
 80046d0:	4bae      	ldr	r3, [pc, #696]	@ (800498c <bme68x_selftest_check+0x2fc>)
 80046d2:	f8cd 3032 	str.w	r3, [sp, #50]	@ 0x32
        heatr_conf.enable = BME68X_ENABLE;
 80046d6:	2401      	movs	r4, #1
        conf.os_pres = BME68X_OS_16X;
 80046d8:	2205      	movs	r2, #5
 80046da:	f88d 2006 	strb.w	r2, [sp, #6]
        conf.os_hum = BME68X_OS_1X;
 80046de:	f240 2301 	movw	r3, #513	@ 0x201
        rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, &t_dev);
 80046e2:	aa16      	add	r2, sp, #88	@ 0x58
 80046e4:	a90c      	add	r1, sp, #48	@ 0x30
 80046e6:	4620      	mov	r0, r4
        heatr_conf.enable = BME68X_ENABLE;
 80046e8:	f88d 4030 	strb.w	r4, [sp, #48]	@ 0x30
        conf.os_hum = BME68X_OS_1X;
 80046ec:	f8ad 3004 	strh.w	r3, [sp, #4]
        rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, &t_dev);
 80046f0:	f7ff fafa 	bl	8003ce8 <bme68x_set_heatr_conf>
        if (rslt == BME68X_OK)
 80046f4:	4606      	mov	r6, r0
 80046f6:	2800      	cmp	r0, #0
 80046f8:	d1e6      	bne.n	80046c8 <bme68x_selftest_check+0x38>
            rslt = bme68x_set_conf(&conf, &t_dev);
 80046fa:	a916      	add	r1, sp, #88	@ 0x58
 80046fc:	a801      	add	r0, sp, #4
 80046fe:	f7fe fac3 	bl	8002c88 <bme68x_set_conf>
            if (rslt == BME68X_OK)
 8004702:	4606      	mov	r6, r0
 8004704:	2800      	cmp	r0, #0
 8004706:	d1df      	bne.n	80046c8 <bme68x_selftest_check+0x38>
                rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &t_dev); /* Trigger a measurement */
 8004708:	a916      	add	r1, sp, #88	@ 0x58
 800470a:	4620      	mov	r0, r4
 800470c:	f7fe fa56 	bl	8002bbc <bme68x_set_op_mode>
                if (rslt == BME68X_OK)
 8004710:	4606      	mov	r6, r0
 8004712:	2800      	cmp	r0, #0
 8004714:	d1d8      	bne.n	80046c8 <bme68x_selftest_check+0x38>
                    t_dev.delay_us(BME68X_HEATR_DUR1_DELAY, t_dev.intf_ptr);
 8004716:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 8004718:	9917      	ldr	r1, [sp, #92]	@ 0x5c
 800471a:	489d      	ldr	r0, [pc, #628]	@ (8004990 <bme68x_selftest_check+0x300>)
 800471c:	4798      	blx	r3
                    rslt = bme68x_get_data(BME68X_FORCED_MODE, &data[0], &n_fields, &t_dev);
 800471e:	4620      	mov	r0, r4
 8004720:	ab16      	add	r3, sp, #88	@ 0x58
 8004722:	f10d 0203 	add.w	r2, sp, #3
 8004726:	a92a      	add	r1, sp, #168	@ 0xa8
 8004728:	f7fe fe68 	bl	80033fc <bme68x_get_data>
                    if (rslt == BME68X_OK)
 800472c:	4606      	mov	r6, r0
 800472e:	2800      	cmp	r0, #0
 8004730:	d1ca      	bne.n	80046c8 <bme68x_selftest_check+0x38>
                        if ((data[0].idac != 0x00) && (data[0].idac != 0xFF) &&
 8004732:	f89d 30ac 	ldrb.w	r3, [sp, #172]	@ 0xac
 8004736:	3b01      	subs	r3, #1
 8004738:	b2db      	uxtb	r3, r3
 800473a:	2bfd      	cmp	r3, #253	@ 0xfd
 800473c:	f200 8173 	bhi.w	8004a26 <bme68x_selftest_check+0x396>
 8004740:	f89d 30a8 	ldrb.w	r3, [sp, #168]	@ 0xa8
 8004744:	069a      	lsls	r2, r3, #26
 8004746:	f140 816e 	bpl.w	8004a26 <bme68x_selftest_check+0x396>
        heatr_conf.heatr_dur = BME68X_HEATR_DUR2;
 800474a:	f44f 63fa 	mov.w	r3, #2000	@ 0x7d0
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 800474e:	f8df a244 	ldr.w	sl, [pc, #580]	@ 8004994 <bme68x_selftest_check+0x304>
        heatr_conf.heatr_dur = BME68X_HEATR_DUR2;
 8004752:	f8ad 3034 	strh.w	r3, [sp, #52]	@ 0x34
        while ((rslt == BME68X_OK) && (i < BME68X_N_MEAS))
 8004756:	ad2a      	add	r5, sp, #168	@ 0xa8
        heatr_conf.heatr_dur = BME68X_HEATR_DUR2;
 8004758:	4604      	mov	r4, r0
            if (i % 2 == 0)
 800475a:	07e3      	lsls	r3, r4, #31
 800475c:	bf54      	ite	pl
 800475e:	f44f 77af 	movpl.w	r7, #350	@ 0x15e
 8004762:	2796      	movmi	r7, #150	@ 0x96
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
 8004764:	a916      	add	r1, sp, #88	@ 0x58
 8004766:	2000      	movs	r0, #0
 8004768:	f8ad 7032 	strh.w	r7, [sp, #50]	@ 0x32
 800476c:	f7fe fa26 	bl	8002bbc <bme68x_set_op_mode>
        if (rslt == BME68X_OK)
 8004770:	4606      	mov	r6, r0
 8004772:	2800      	cmp	r0, #0
 8004774:	d1a8      	bne.n	80046c8 <bme68x_selftest_check+0x38>
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 8004776:	f9bd 3072 	ldrsh.w	r3, [sp, #114]	@ 0x72
 800477a:	f99d 0071 	ldrsb.w	r0, [sp, #113]	@ 0x71
 800477e:	f503 3316 	add.w	r3, r3, #153600	@ 0x25800
 8004782:	f203 1399 	addw	r3, r3, #409	@ 0x199
 8004786:	fb07 f203 	mul.w	r2, r7, r3
 800478a:	4b83      	ldr	r3, [pc, #524]	@ (8004998 <bme68x_selftest_check+0x308>)
 800478c:	fba3 1202 	umull	r1, r2, r3, r2
 8004790:	0912      	lsrs	r2, r2, #4
 8004792:	f502 1248 	add.w	r2, r2, #3276800	@ 0x320000
 8004796:	fba3 3202 	umull	r3, r2, r3, r2
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 800479a:	f99d 1074 	ldrsb.w	r1, [sp, #116]	@ 0x74
 800479e:	f99d 3066 	ldrsb.w	r3, [sp, #102]	@ 0x66
    var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
 80047a2:	f500 7044 	add.w	r0, r0, #784	@ 0x310
 80047a6:	08d2      	lsrs	r2, r2, #3
 80047a8:	fb00 f202 	mul.w	r2, r0, r2
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 80047ac:	487b      	ldr	r0, [pc, #492]	@ (800499c <bme68x_selftest_check+0x30c>)
 80047ae:	fb13 f301 	smulbb	r3, r3, r1
 80047b2:	fb80 6003 	smull	r6, r0, r0, r3
 80047b6:	17de      	asrs	r6, r3, #31
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 80047b8:	f99d 1095 	ldrsb.w	r1, [sp, #149]	@ 0x95
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 80047bc:	f89d 3094 	ldrb.w	r3, [sp, #148]	@ 0x94
    var1 = (((int32_t)dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
 80047c0:	ebc6 16a0 	rsb	r6, r6, r0, asr #6
 80047c4:	0236      	lsls	r6, r6, #8
    var3 = var1 + (var2 / 2);
 80047c6:	eb06 0662 	add.w	r6, r6, r2, asr #1
    var4 = (var3 / (dev->calib.res_heat_range + 4));
 80047ca:	3304      	adds	r3, #4
 80047cc:	fbb6 f6f3 	udiv	r6, r6, r3
    var5 = (131 * dev->calib.res_heat_val) + 65536;
 80047d0:	eb01 1381 	add.w	r3, r1, r1, lsl #6
 80047d4:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 80047d8:	f501 3180 	add.w	r1, r1, #65536	@ 0x10000
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 80047dc:	fbb6 f6f1 	udiv	r6, r6, r1
 80047e0:	3efa      	subs	r6, #250	@ 0xfa
 80047e2:	eb06 1606 	add.w	r6, r6, r6, lsl #4
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80047e6:	4b6e      	ldr	r3, [pc, #440]	@ (80049a0 <bme68x_selftest_check+0x310>)
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
 80047e8:	0076      	lsls	r6, r6, #1
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 80047ea:	3632      	adds	r6, #50	@ 0x32
 80047ec:	fb83 2306 	smull	r2, r3, r3, r6
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 80047f0:	e89a 0007 	ldmia.w	sl, {r0, r1, r2}
 80047f4:	f10d 080c 	add.w	r8, sp, #12
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 80047f8:	f10d 0e18 	add.w	lr, sp, #24
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 80047fc:	f10d 0c24 	add.w	ip, sp, #36	@ 0x24
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8004800:	af11      	add	r7, sp, #68	@ 0x44
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8004802:	e8a8 0003 	stmia.w	r8!, {r0, r1}
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8004806:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 800480a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 800480e:	c703      	stmia	r7!, {r0, r1}
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8004810:	f8ae 2000 	strh.w	r2, [lr]
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8004814:	f8ac 2000 	strh.w	r2, [ip]
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 8004818:	803a      	strh	r2, [r7, #0]
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 800481a:	f8a8 2000 	strh.w	r2, [r8]
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 800481e:	17f6      	asrs	r6, r6, #31
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
 8004820:	f06f 0220 	mvn.w	r2, #32
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 8004824:	ebc6 1663 	rsb	r6, r6, r3, asr #5
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
 8004828:	f88d 2044 	strb.w	r2, [sp, #68]	@ 0x44
            rh_reg_addr[0] = BME68X_REG_RES_HEAT0;
 800482c:	f04f 0b5a 	mov.w	fp, #90	@ 0x5a
            gw_reg_addr[0] = BME68X_REG_GAS_WAIT0;
 8004830:	f04f 0964 	mov.w	r9, #100	@ 0x64
        rslt = bme68x_set_regs(rh_reg_addr, rh_reg_data, write_len, dev);
 8004834:	ab16      	add	r3, sp, #88	@ 0x58
 8004836:	a803      	add	r0, sp, #12
 8004838:	2201      	movs	r2, #1
 800483a:	a906      	add	r1, sp, #24
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);
 800483c:	f88d 6018 	strb.w	r6, [sp, #24]
            rh_reg_addr[0] = BME68X_REG_RES_HEAT0;
 8004840:	f88d b00c 	strb.w	fp, [sp, #12]
            gw_reg_addr[0] = BME68X_REG_GAS_WAIT0;
 8004844:	f88d 9024 	strb.w	r9, [sp, #36]	@ 0x24
        rslt = bme68x_set_regs(rh_reg_addr, rh_reg_data, write_len, dev);
 8004848:	f7fe f834 	bl	80028b4 <bme68x_set_regs>
    if (rslt == BME68X_OK)
 800484c:	4606      	mov	r6, r0
 800484e:	2800      	cmp	r0, #0
 8004850:	f47f af3a 	bne.w	80046c8 <bme68x_selftest_check+0x38>
        rslt = bme68x_set_regs(gw_reg_addr, gw_reg_data, write_len, dev);
 8004854:	a911      	add	r1, sp, #68	@ 0x44
 8004856:	ab16      	add	r3, sp, #88	@ 0x58
 8004858:	2201      	movs	r2, #1
 800485a:	a809      	add	r0, sp, #36	@ 0x24
 800485c:	f7fe f82a 	bl	80028b4 <bme68x_set_regs>
        if (rslt == BME68X_OK)
 8004860:	4606      	mov	r6, r0
 8004862:	2800      	cmp	r0, #0
 8004864:	f47f af30 	bne.w	80046c8 <bme68x_selftest_check+0x38>
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8004868:	9e26      	ldr	r6, [sp, #152]	@ 0x98
 800486a:	2e00      	cmp	r6, #0
 800486c:	f000 817f 	beq.w	8004b6e <bme68x_selftest_check+0x4de>
 8004870:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8004872:	2b00      	cmp	r3, #0
 8004874:	f000 817b 	beq.w	8004b6e <bme68x_selftest_check+0x4de>
 8004878:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 800487a:	2b00      	cmp	r3, #0
 800487c:	f000 8177 	beq.w	8004b6e <bme68x_selftest_check+0x4de>
        if (dev->intf == BME68X_SPI_INTF)
 8004880:	f89d 3064 	ldrb.w	r3, [sp, #100]	@ 0x64
 8004884:	2b00      	cmp	r3, #0
 8004886:	f000 80d1 	beq.w	8004a2c <bme68x_selftest_check+0x39c>
 800488a:	2070      	movs	r0, #112	@ 0x70
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 800488c:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 800488e:	a909      	add	r1, sp, #36	@ 0x24
 8004890:	2202      	movs	r2, #2
 8004892:	47b0      	blx	r6
 8004894:	f88d 00a4 	strb.w	r0, [sp, #164]	@ 0xa4
        if (dev->intf_rslt != 0)
 8004898:	2800      	cmp	r0, #0
 800489a:	f040 80d9 	bne.w	8004a50 <bme68x_selftest_check+0x3c0>
                    if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 800489e:	9b18      	ldr	r3, [sp, #96]	@ 0x60
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 80048a0:	f89d 1025 	ldrb.w	r1, [sp, #37]	@ 0x25
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80048a4:	9f26      	ldr	r7, [sp, #152]	@ 0x98
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 80048a6:	9015      	str	r0, [sp, #84]	@ 0x54
                    if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 80048a8:	2b01      	cmp	r3, #1
 80048aa:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 80048ae:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
                    if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 80048b2:	bf14      	ite	ne
 80048b4:	2210      	movne	r2, #16
 80048b6:	2220      	moveq	r2, #32
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 80048b8:	f003 03f7 	and.w	r3, r3, #247	@ 0xf7
 80048bc:	430a      	orrs	r2, r1
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 80048be:	e9cd 0011 	strd	r0, r0, [sp, #68]	@ 0x44
 80048c2:	e9cd 0013 	strd	r0, r0, [sp, #76]	@ 0x4c
                ctrl_gas_data[0] = BME68X_SET_BITS(ctrl_gas_data[0], BME68X_HCTRL, hctrl);
 80048c6:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 80048ca:	f88d 2025 	strb.w	r2, [sp, #37]	@ 0x25
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 80048ce:	2f00      	cmp	r7, #0
 80048d0:	f000 814d 	beq.w	8004b6e <bme68x_selftest_check+0x4de>
 80048d4:	9e27      	ldr	r6, [sp, #156]	@ 0x9c
 80048d6:	4630      	mov	r0, r6
 80048d8:	2e00      	cmp	r6, #0
 80048da:	f000 8148 	beq.w	8004b6e <bme68x_selftest_check+0x4de>
 80048de:	9928      	ldr	r1, [sp, #160]	@ 0xa0
 80048e0:	2900      	cmp	r1, #0
 80048e2:	f000 8144 	beq.w	8004b6e <bme68x_selftest_check+0x4de>
                if (dev->intf == BME68X_SPI_INTF)
 80048e6:	f89d 1064 	ldrb.w	r1, [sp, #100]	@ 0x64
 80048ea:	2900      	cmp	r1, #0
 80048ec:	f000 80b3 	beq.w	8004a56 <bme68x_selftest_check+0x3c6>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80048f0:	f88d 3045 	strb.w	r3, [sp, #69]	@ 0x45
                    tmp_buff[(2 * index)] = reg_addr[index];
 80048f4:	2371      	movs	r3, #113	@ 0x71
 80048f6:	2070      	movs	r0, #112	@ 0x70
 80048f8:	f88d 3046 	strb.w	r3, [sp, #70]	@ 0x46
 80048fc:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
                tmp_buff[(2 * index) + 1] = reg_data[index];
 80048fe:	f88d 2047 	strb.w	r2, [sp, #71]	@ 0x47
                    tmp_buff[(2 * index)] = reg_addr[index];
 8004902:	f88d 0044 	strb.w	r0, [sp, #68]	@ 0x44
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 8004906:	2203      	movs	r2, #3
 8004908:	f10d 0145 	add.w	r1, sp, #69	@ 0x45
 800490c:	47b0      	blx	r6
 800490e:	f88d 00a4 	strb.w	r0, [sp, #164]	@ 0xa4
                if (dev->intf_rslt != 0)
 8004912:	2800      	cmp	r0, #0
 8004914:	f040 809c 	bne.w	8004a50 <bme68x_selftest_check+0x3c0>
                rslt = bme68x_set_conf(&conf, &t_dev);
 8004918:	a916      	add	r1, sp, #88	@ 0x58
 800491a:	a801      	add	r0, sp, #4
 800491c:	f7fe f9b4 	bl	8002c88 <bme68x_set_conf>
                if (rslt == BME68X_OK)
 8004920:	4606      	mov	r6, r0
 8004922:	2800      	cmp	r0, #0
 8004924:	f47f aed0 	bne.w	80046c8 <bme68x_selftest_check+0x38>
                    rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &t_dev); /* Trigger a measurement */
 8004928:	a916      	add	r1, sp, #88	@ 0x58
 800492a:	2001      	movs	r0, #1
 800492c:	f7fe f946 	bl	8002bbc <bme68x_set_op_mode>
                    if (rslt == BME68X_OK)
 8004930:	4606      	mov	r6, r0
 8004932:	2800      	cmp	r0, #0
 8004934:	f47f aec8 	bne.w	80046c8 <bme68x_selftest_check+0x38>
                        t_dev.delay_us(BME68X_HEATR_DUR2_DELAY, t_dev.intf_ptr);
 8004938:	481a      	ldr	r0, [pc, #104]	@ (80049a4 <bme68x_selftest_check+0x314>)
 800493a:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 800493c:	9917      	ldr	r1, [sp, #92]	@ 0x5c
 800493e:	4798      	blx	r3
                        rslt = bme68x_get_data(BME68X_FORCED_MODE, &data[i], &n_fields, &t_dev);
 8004940:	ab16      	add	r3, sp, #88	@ 0x58
 8004942:	f10d 0203 	add.w	r2, sp, #3
 8004946:	4629      	mov	r1, r5
 8004948:	2001      	movs	r0, #1
 800494a:	f7fe fd57 	bl	80033fc <bme68x_get_data>
        while ((rslt == BME68X_OK) && (i < BME68X_N_MEAS))
 800494e:	4606      	mov	r6, r0
 8004950:	2800      	cmp	r0, #0
 8004952:	f47f aeb9 	bne.w	80046c8 <bme68x_selftest_check+0x38>
 8004956:	3401      	adds	r4, #1
 8004958:	2c06      	cmp	r4, #6
 800495a:	f105 0514 	add.w	r5, r5, #20
 800495e:	f47f aefc 	bne.w	800475a <bme68x_selftest_check+0xca>
    if ((data[0].pressure < BME68X_MIN_PRESSURE) || (data[0].pressure > BME68X_MAX_PRESSURE))
 8004962:	9a2c      	ldr	r2, [sp, #176]	@ 0xb0
    if ((data[0].temperature < BME68X_MIN_TEMPERATURE) || (data[0].temperature > BME68X_MAX_TEMPERATURE))
 8004964:	f8bd 30ae 	ldrh.w	r3, [sp, #174]	@ 0xae
    if ((data[0].pressure < BME68X_MIN_PRESSURE) || (data[0].pressure > BME68X_MAX_PRESSURE))
 8004968:	f5a2 32af 	sub.w	r2, r2, #89600	@ 0x15e00
    if ((data[0].temperature < BME68X_MIN_TEMPERATURE) || (data[0].temperature > BME68X_MAX_TEMPERATURE))
 800496c:	f241 7070 	movw	r0, #6000	@ 0x1770
 8004970:	4283      	cmp	r3, r0
    if ((data[0].pressure < BME68X_MIN_PRESSURE) || (data[0].pressure > BME68X_MAX_PRESSURE))
 8004972:	f5a2 72c8 	sub.w	r2, r2, #400	@ 0x190
 8004976:	f644 6120 	movw	r1, #20000	@ 0x4e20
    if ((data[0].temperature < BME68X_MIN_TEMPERATURE) || (data[0].temperature > BME68X_MAX_TEMPERATURE))
 800497a:	bf94      	ite	ls
 800497c:	2300      	movls	r3, #0
 800497e:	2301      	movhi	r3, #1
    if ((data[0].pressure < BME68X_MIN_PRESSURE) || (data[0].pressure > BME68X_MAX_PRESSURE))
 8004980:	428a      	cmp	r2, r1
 8004982:	d911      	bls.n	80049a8 <bme68x_selftest_check+0x318>
        self_test_failed++;
 8004984:	3301      	adds	r3, #1
 8004986:	b2db      	uxtb	r3, r3
 8004988:	e00e      	b.n	80049a8 <bme68x_selftest_check+0x318>
 800498a:	bf00      	nop
 800498c:	03e8015e 	.word	0x03e8015e
 8004990:	000f4240 	.word	0x000f4240
 8004994:	080167c8 	.word	0x080167c8
 8004998:	cccccccd 	.word	0xcccccccd
 800499c:	10624dd3 	.word	0x10624dd3
 80049a0:	51eb851f 	.word	0x51eb851f
 80049a4:	001e8480 	.word	0x001e8480
    if ((data[0].humidity < BME68X_MIN_HUMIDITY) || (data[0].humidity > BME68X_MAX_HUMIDITY))
 80049a8:	9a2d      	ldr	r2, [sp, #180]	@ 0xb4
 80049aa:	f5a2 429c 	sub.w	r2, r2, #19968	@ 0x4e00
 80049ae:	f64e 2160 	movw	r1, #60000	@ 0xea60
 80049b2:	3a20      	subs	r2, #32
 80049b4:	428a      	cmp	r2, r1
        if (!(data[i].status & BME68X_GASM_VALID_MSK))
 80049b6:	f89d 20a8 	ldrb.w	r2, [sp, #168]	@ 0xa8
        self_test_failed++;
 80049ba:	bf84      	itt	hi
 80049bc:	3301      	addhi	r3, #1
 80049be:	b2db      	uxtbhi	r3, r3
        if (!(data[i].status & BME68X_GASM_VALID_MSK))
 80049c0:	0697      	lsls	r7, r2, #26
 80049c2:	f89d 20bc 	ldrb.w	r2, [sp, #188]	@ 0xbc
            self_test_failed++;
 80049c6:	bf5c      	itt	pl
 80049c8:	3301      	addpl	r3, #1
 80049ca:	b2db      	uxtbpl	r3, r3
        if (!(data[i].status & BME68X_GASM_VALID_MSK))
 80049cc:	0695      	lsls	r5, r2, #26
 80049ce:	f89d 20d0 	ldrb.w	r2, [sp, #208]	@ 0xd0
            self_test_failed++;
 80049d2:	bf5c      	itt	pl
 80049d4:	3301      	addpl	r3, #1
 80049d6:	b2db      	uxtbpl	r3, r3
        if (!(data[i].status & BME68X_GASM_VALID_MSK))
 80049d8:	0694      	lsls	r4, r2, #26
 80049da:	f89d 20e4 	ldrb.w	r2, [sp, #228]	@ 0xe4
            self_test_failed++;
 80049de:	bf5c      	itt	pl
 80049e0:	3301      	addpl	r3, #1
 80049e2:	b2db      	uxtbpl	r3, r3
        if (!(data[i].status & BME68X_GASM_VALID_MSK))
 80049e4:	0690      	lsls	r0, r2, #26
 80049e6:	f89d 20f8 	ldrb.w	r2, [sp, #248]	@ 0xf8
            self_test_failed++;
 80049ea:	bf5c      	itt	pl
 80049ec:	3301      	addpl	r3, #1
 80049ee:	b2db      	uxtbpl	r3, r3
        if (!(data[i].status & BME68X_GASM_VALID_MSK))
 80049f0:	0691      	lsls	r1, r2, #26
 80049f2:	f89d 210c 	ldrb.w	r2, [sp, #268]	@ 0x10c
            self_test_failed++;
 80049f6:	bf5c      	itt	pl
 80049f8:	3301      	addpl	r3, #1
 80049fa:	b2db      	uxtbpl	r3, r3
        if (!(data[i].status & BME68X_GASM_VALID_MSK))
 80049fc:	0692      	lsls	r2, r2, #26
 80049fe:	d512      	bpl.n	8004a26 <bme68x_selftest_check+0x396>
        cent_res = (uint32_t)((5 * (data[3].gas_resistance + data[5].gas_resistance)) / (2 * data[4].gas_resistance));
 8004a00:	9a3d      	ldr	r2, [sp, #244]	@ 0xf4
 8004a02:	9847      	ldr	r0, [sp, #284]	@ 0x11c
 8004a04:	9942      	ldr	r1, [sp, #264]	@ 0x108
 8004a06:	4402      	add	r2, r0
 8004a08:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004a0c:	0049      	lsls	r1, r1, #1
 8004a0e:	fbb2 f2f1 	udiv	r2, r2, r1
    if (cent_res < 6)
 8004a12:	2a05      	cmp	r2, #5
 8004a14:	d907      	bls.n	8004a26 <bme68x_selftest_check+0x396>
        rslt = BME68X_E_SELF_TEST;
 8004a16:	2b00      	cmp	r3, #0
 8004a18:	bf18      	it	ne
 8004a1a:	f06f 0604 	mvnne.w	r6, #4
}
 8004a1e:	4630      	mov	r0, r6
 8004a20:	b049      	add	sp, #292	@ 0x124
 8004a22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        rslt = BME68X_E_SELF_TEST;
 8004a26:	f06f 0604 	mvn.w	r6, #4
 8004a2a:	e64d      	b.n	80046c8 <bme68x_selftest_check+0x38>
            rslt = set_mem_page(reg_addr, dev);
 8004a2c:	a916      	add	r1, sp, #88	@ 0x58
 8004a2e:	2070      	movs	r0, #112	@ 0x70
 8004a30:	f7fd fcf0 	bl	8002414 <set_mem_page>
            if (rslt == BME68X_OK)
 8004a34:	4606      	mov	r6, r0
 8004a36:	b910      	cbnz	r0, 8004a3e <bme68x_selftest_check+0x3ae>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8004a38:	9e26      	ldr	r6, [sp, #152]	@ 0x98
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 8004a3a:	20f0      	movs	r0, #240	@ 0xf0
 8004a3c:	e726      	b.n	800488c <bme68x_selftest_check+0x1fc>
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 8004a3e:	9c26      	ldr	r4, [sp, #152]	@ 0x98
 8004a40:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004a42:	2202      	movs	r2, #2
 8004a44:	a909      	add	r1, sp, #36	@ 0x24
 8004a46:	2070      	movs	r0, #112	@ 0x70
 8004a48:	47a0      	blx	r4
        if (dev->intf_rslt != 0)
 8004a4a:	2800      	cmp	r0, #0
 8004a4c:	f43f ae3c 	beq.w	80046c8 <bme68x_selftest_check+0x38>
        rslt = BME68X_E_NULL_PTR;
 8004a50:	f06f 0601 	mvn.w	r6, #1
        if (rslt == BME68X_OK)
 8004a54:	e638      	b.n	80046c8 <bme68x_selftest_check+0x38>
        if (mem_page != dev->mem_page)
 8004a56:	f89d 2065 	ldrb.w	r2, [sp, #101]	@ 0x65
 8004a5a:	2a10      	cmp	r2, #16
 8004a5c:	d078      	beq.n	8004b50 <bme68x_selftest_check+0x4c0>
            dev->mem_page = mem_page;
 8004a5e:	2310      	movs	r3, #16
 8004a60:	f88d 3065 	strb.w	r3, [sp, #101]	@ 0x65
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8004a64:	2201      	movs	r2, #1
 8004a66:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004a68:	a906      	add	r1, sp, #24
 8004a6a:	20f3      	movs	r0, #243	@ 0xf3
 8004a6c:	47b8      	blx	r7
 8004a6e:	f88d 00a4 	strb.w	r0, [sp, #164]	@ 0xa4
            if (dev->intf_rslt != 0)
 8004a72:	bb38      	cbnz	r0, 8004ac4 <bme68x_selftest_check+0x434>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8004a74:	f89d 2018 	ldrb.w	r2, [sp, #24]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8004a78:	f89d 3065 	ldrb.w	r3, [sp, #101]	@ 0x65
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8004a7c:	9e27      	ldr	r6, [sp, #156]	@ 0x9c
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8004a7e:	f022 0210 	bic.w	r2, r2, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8004a82:	f003 0310 	and.w	r3, r3, #16
 8004a86:	4313      	orrs	r3, r2
 8004a88:	f88d 3018 	strb.w	r3, [sp, #24]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8004a8c:	2201      	movs	r2, #1
 8004a8e:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004a90:	a906      	add	r1, sp, #24
 8004a92:	2073      	movs	r0, #115	@ 0x73
 8004a94:	47b0      	blx	r6
 8004a96:	f88d 00a4 	strb.w	r0, [sp, #164]	@ 0xa4
                if (dev->intf_rslt != 0)
 8004a9a:	b998      	cbnz	r0, 8004ac4 <bme68x_selftest_check+0x434>
                if (dev->intf == BME68X_SPI_INTF)
 8004a9c:	f89d 3064 	ldrb.w	r3, [sp, #100]	@ 0x64
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004aa0:	f89d 2024 	ldrb.w	r2, [sp, #36]	@ 0x24
 8004aa4:	f88d 2045 	strb.w	r2, [sp, #69]	@ 0x45
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8004aa8:	2070      	movs	r0, #112	@ 0x70
 8004aaa:	f88d 0044 	strb.w	r0, [sp, #68]	@ 0x44
                if (dev->intf == BME68X_SPI_INTF)
 8004aae:	b1a3      	cbz	r3, 8004ada <bme68x_selftest_check+0x44a>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004ab0:	f89d 3025 	ldrb.w	r3, [sp, #37]	@ 0x25
 8004ab4:	f88d 3047 	strb.w	r3, [sp, #71]	@ 0x47
                    tmp_buff[(2 * index)] = reg_addr[index];
 8004ab8:	2371      	movs	r3, #113	@ 0x71
 8004aba:	f88d 3046 	strb.w	r3, [sp, #70]	@ 0x46
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8004abe:	9e27      	ldr	r6, [sp, #156]	@ 0x9c
 8004ac0:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004ac2:	e720      	b.n	8004906 <bme68x_selftest_check+0x276>
                if (dev->intf == BME68X_SPI_INTF)
 8004ac4:	f89d 2064 	ldrb.w	r2, [sp, #100]	@ 0x64
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004ac8:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8004acc:	2170      	movs	r1, #112	@ 0x70
 8004ace:	f88d 1044 	strb.w	r1, [sp, #68]	@ 0x44
                if (dev->intf == BME68X_SPI_INTF)
 8004ad2:	2a00      	cmp	r2, #0
 8004ad4:	d1bc      	bne.n	8004a50 <bme68x_selftest_check+0x3c0>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004ad6:	f88d 3045 	strb.w	r3, [sp, #69]	@ 0x45
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8004ada:	9f26      	ldr	r7, [sp, #152]	@ 0x98
 8004adc:	2f00      	cmp	r7, #0
 8004ade:	d046      	beq.n	8004b6e <bme68x_selftest_check+0x4de>
 8004ae0:	9827      	ldr	r0, [sp, #156]	@ 0x9c
 8004ae2:	4606      	mov	r6, r0
 8004ae4:	2800      	cmp	r0, #0
 8004ae6:	d042      	beq.n	8004b6e <bme68x_selftest_check+0x4de>
 8004ae8:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 8004aea:	2b00      	cmp	r3, #0
 8004aec:	d03f      	beq.n	8004b6e <bme68x_selftest_check+0x4de>
        if (mem_page != dev->mem_page)
 8004aee:	f89d 2065 	ldrb.w	r2, [sp, #101]	@ 0x65
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8004af2:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
        if (mem_page != dev->mem_page)
 8004af4:	2a10      	cmp	r2, #16
 8004af6:	d031      	beq.n	8004b5c <bme68x_selftest_check+0x4cc>
            dev->mem_page = mem_page;
 8004af8:	2210      	movs	r2, #16
 8004afa:	f88d 2065 	strb.w	r2, [sp, #101]	@ 0x65
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 8004afe:	a906      	add	r1, sp, #24
 8004b00:	2201      	movs	r2, #1
 8004b02:	20f3      	movs	r0, #243	@ 0xf3
 8004b04:	47b8      	blx	r7
 8004b06:	f88d 00a4 	strb.w	r0, [sp, #164]	@ 0xa4
            if (dev->intf_rslt != 0)
 8004b0a:	2800      	cmp	r0, #0
 8004b0c:	d1a0      	bne.n	8004a50 <bme68x_selftest_check+0x3c0>
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8004b0e:	f89d 2018 	ldrb.w	r2, [sp, #24]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8004b12:	f89d 3065 	ldrb.w	r3, [sp, #101]	@ 0x65
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8004b16:	9e27      	ldr	r6, [sp, #156]	@ 0x9c
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 8004b18:	f022 0210 	bic.w	r2, r2, #16
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 8004b1c:	f003 0310 	and.w	r3, r3, #16
 8004b20:	4313      	orrs	r3, r2
 8004b22:	f88d 3018 	strb.w	r3, [sp, #24]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 8004b26:	a906      	add	r1, sp, #24
 8004b28:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004b2a:	2201      	movs	r2, #1
 8004b2c:	2073      	movs	r0, #115	@ 0x73
 8004b2e:	47b0      	blx	r6
 8004b30:	f88d 00a4 	strb.w	r0, [sp, #164]	@ 0xa4
                if (dev->intf_rslt != 0)
 8004b34:	2800      	cmp	r0, #0
 8004b36:	d18b      	bne.n	8004a50 <bme68x_selftest_check+0x3c0>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004b38:	f89d 3025 	ldrb.w	r3, [sp, #37]	@ 0x25
 8004b3c:	f88d 3047 	strb.w	r3, [sp, #71]	@ 0x47
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8004b40:	2371      	movs	r3, #113	@ 0x71
 8004b42:	f88d 3046 	strb.w	r3, [sp, #70]	@ 0x46
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 8004b46:	9e27      	ldr	r6, [sp, #156]	@ 0x9c
 8004b48:	f89d 0044 	ldrb.w	r0, [sp, #68]	@ 0x44
 8004b4c:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004b4e:	e6da      	b.n	8004906 <bme68x_selftest_check+0x276>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004b50:	f88d 3045 	strb.w	r3, [sp, #69]	@ 0x45
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8004b54:	2370      	movs	r3, #112	@ 0x70
 8004b56:	f88d 3044 	strb.w	r3, [sp, #68]	@ 0x44
    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 8004b5a:	e7c2      	b.n	8004ae2 <bme68x_selftest_check+0x452>
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004b5c:	f89d 2025 	ldrb.w	r2, [sp, #37]	@ 0x25
 8004b60:	f88d 2047 	strb.w	r2, [sp, #71]	@ 0x47
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 8004b64:	2271      	movs	r2, #113	@ 0x71
 8004b66:	f88d 2046 	strb.w	r2, [sp, #70]	@ 0x46
                tmp_buff[(2 * index) + 1] = reg_data[index];
 8004b6a:	2070      	movs	r0, #112	@ 0x70
 8004b6c:	e6cb      	b.n	8004906 <bme68x_selftest_check+0x276>
        rslt = BME68X_E_NULL_PTR;
 8004b6e:	f04f 36ff 	mov.w	r6, #4294967295
 8004b72:	e5a9      	b.n	80046c8 <bme68x_selftest_check+0x38>

08004b74 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8004b74:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8004b76:	2003      	movs	r0, #3
 8004b78:	f000 fd64 	bl	8005644 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8004b7c:	f002 fc88 	bl	8007490 <HAL_RCC_GetHCLKFreq>
 8004b80:	4b07      	ldr	r3, [pc, #28]	@ (8004ba0 <HAL_Init+0x2c>)
 8004b82:	4602      	mov	r2, r0
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8004b84:	200f      	movs	r0, #15
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8004b86:	601a      	str	r2, [r3, #0]
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8004b88:	f7fd f81c 	bl	8001bc4 <HAL_InitTick>
 8004b8c:	b110      	cbz	r0, 8004b94 <HAL_Init+0x20>
  {
    status = HAL_ERROR;
 8004b8e:	2401      	movs	r4, #1
    HAL_MspInit();
  }

  /* Return function status */
  return status;
}
 8004b90:	4620      	mov	r0, r4
 8004b92:	bd10      	pop	{r4, pc}
 8004b94:	4604      	mov	r4, r0
    HAL_MspInit();
 8004b96:	f7fc fecb 	bl	8001930 <HAL_MspInit>
}
 8004b9a:	4620      	mov	r0, r4
 8004b9c:	bd10      	pop	{r4, pc}
 8004b9e:	bf00      	nop
 8004ba0:	20000004 	.word	0x20000004

08004ba4 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8004ba4:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 8004ba8:	6913      	ldr	r3, [r2, #16]
 8004baa:	f023 0302 	bic.w	r3, r3, #2
 8004bae:	6113      	str	r3, [r2, #16]
}
 8004bb0:	4770      	bx	lr
 8004bb2:	bf00      	nop

08004bb4 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8004bb4:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 8004bb8:	6913      	ldr	r3, [r2, #16]
 8004bba:	f043 0302 	orr.w	r3, r3, #2
 8004bbe:	6113      	str	r3, [r2, #16]
}
 8004bc0:	4770      	bx	lr
 8004bc2:	bf00      	nop

08004bc4 <HAL_GetUIDw0>:
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
 8004bc4:	4b01      	ldr	r3, [pc, #4]	@ (8004bcc <HAL_GetUIDw0+0x8>)
}
 8004bc6:	f8d3 0590 	ldr.w	r0, [r3, #1424]	@ 0x590
 8004bca:	4770      	bx	lr
 8004bcc:	1fff7000 	.word	0x1fff7000

08004bd0 <HAL_GetUIDw1>:
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 8004bd0:	4b01      	ldr	r3, [pc, #4]	@ (8004bd8 <HAL_GetUIDw1+0x8>)
}
 8004bd2:	f8d3 0594 	ldr.w	r0, [r3, #1428]	@ 0x594
 8004bd6:	4770      	bx	lr
 8004bd8:	1fff7000 	.word	0x1fff7000

08004bdc <HAL_GetUIDw2>:
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 8004bdc:	4b01      	ldr	r3, [pc, #4]	@ (8004be4 <HAL_GetUIDw2+0x8>)
}
 8004bde:	f8d3 0598 	ldr.w	r0, [r3, #1432]	@ 0x598
 8004be2:	4770      	bx	lr
 8004be4:	1fff7000 	.word	0x1fff7000

08004be8 <HAL_DBGMCU_EnableDBGSleepMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8004be8:	4a02      	ldr	r2, [pc, #8]	@ (8004bf4 <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 8004bea:	6853      	ldr	r3, [r2, #4]
 8004bec:	f043 0301 	orr.w	r3, r3, #1
 8004bf0:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  LL_DBGMCU_EnableDBGSleepMode();
}
 8004bf2:	4770      	bx	lr
 8004bf4:	e0042000 	.word	0xe0042000

08004bf8 <HAL_DBGMCU_EnableDBGStopMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8004bf8:	4a02      	ldr	r2, [pc, #8]	@ (8004c04 <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 8004bfa:	6853      	ldr	r3, [r2, #4]
 8004bfc:	f043 0302 	orr.w	r3, r3, #2
 8004c00:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  LL_DBGMCU_EnableDBGStopMode();
}
 8004c02:	4770      	bx	lr
 8004c04:	e0042000 	.word	0xe0042000

08004c08 <HAL_DBGMCU_EnableDBGStandbyMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8004c08:	4a02      	ldr	r2, [pc, #8]	@ (8004c14 <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 8004c0a:	6853      	ldr	r3, [r2, #4]
 8004c0c:	f043 0304 	orr.w	r3, r3, #4
 8004c10:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  LL_DBGMCU_EnableDBGStandbyMode();
}
 8004c12:	4770      	bx	lr
 8004c14:	e0042000 	.word	0xe0042000

08004c18 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8004c18:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c1a:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR1 = 0UL;
  uint32_t tmpCFGR2 = 0UL;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8004c1c:	2300      	movs	r3, #0
 8004c1e:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 8004c20:	2800      	cmp	r0, #0
 8004c22:	f000 80c0 	beq.w	8004da6 <HAL_ADC_Init+0x18e>
  /* continuous mode is disabled.                                             */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8004c26:	6d85      	ldr	r5, [r0, #88]	@ 0x58
 8004c28:	4604      	mov	r4, r0
 8004c2a:	2d00      	cmp	r5, #0
 8004c2c:	f000 80cb 	beq.w	8004dc6 <HAL_ADC_Init+0x1ae>

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8004c30:	6822      	ldr	r2, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8004c32:	6893      	ldr	r3, [r2, #8]
 8004c34:	00dd      	lsls	r5, r3, #3
 8004c36:	d419      	bmi.n	8004c6c <HAL_ADC_Init+0x54>
    /* Delay for ADC stabilization time */
    /* Wait loop initialization and execution */
    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8004c38:	4b7a      	ldr	r3, [pc, #488]	@ (8004e24 <HAL_ADC_Init+0x20c>)
 8004c3a:	487b      	ldr	r0, [pc, #492]	@ (8004e28 <HAL_ADC_Init+0x210>)
 8004c3c:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(ADCx->CR,
 8004c3e:	6891      	ldr	r1, [r2, #8]
 8004c40:	099b      	lsrs	r3, r3, #6
 8004c42:	fba0 0303 	umull	r0, r3, r0, r3
 8004c46:	f021 4110 	bic.w	r1, r1, #2415919104	@ 0x90000000
 8004c4a:	099b      	lsrs	r3, r3, #6
 8004c4c:	f021 0117 	bic.w	r1, r1, #23
 8004c50:	3301      	adds	r3, #1
 8004c52:	005b      	lsls	r3, r3, #1
 8004c54:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
 8004c58:	6091      	str	r1, [r2, #8]
 8004c5a:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8004c5c:	9b01      	ldr	r3, [sp, #4]
 8004c5e:	b12b      	cbz	r3, 8004c6c <HAL_ADC_Init+0x54>
    {
      wait_loop_index--;
 8004c60:	9b01      	ldr	r3, [sp, #4]
 8004c62:	3b01      	subs	r3, #1
 8004c64:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8004c66:	9b01      	ldr	r3, [sp, #4]
 8004c68:	2b00      	cmp	r3, #0
 8004c6a:	d1f9      	bne.n	8004c60 <HAL_ADC_Init+0x48>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8004c6c:	6893      	ldr	r3, [r2, #8]
 8004c6e:	00d8      	lsls	r0, r3, #3
 8004c70:	f100 809c 	bmi.w	8004dac <HAL_ADC_Init+0x194>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004c74:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004c76:	f043 0310 	orr.w	r3, r3, #16
 8004c7a:	65a3      	str	r3, [r4, #88]	@ 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004c7c:	6de3      	ldr	r3, [r4, #92]	@ 0x5c

    tmp_hal_status = HAL_ERROR;
 8004c7e:	2001      	movs	r0, #1
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004c80:	4303      	orrs	r3, r0
 8004c82:	65e3      	str	r3, [r4, #92]	@ 0x5c
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004c84:	6893      	ldr	r3, [r2, #8]
 8004c86:	f013 0f04 	tst.w	r3, #4
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8004c8a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004c8c:	f040 8096 	bne.w	8004dbc <HAL_ADC_Init+0x1a4>
 8004c90:	06d9      	lsls	r1, r3, #27
 8004c92:	f100 8093 	bmi.w	8004dbc <HAL_ADC_Init+0x1a4>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8004c96:	6da3      	ldr	r3, [r4, #88]	@ 0x58
                   ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
                   ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
                   ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
                   ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
                   hadc->Init.DataAlign                                           |
                   ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8004c98:	6921      	ldr	r1, [r4, #16]
    ADC_STATE_CLR_SET(hadc->State,
 8004c9a:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
 8004c9e:	f043 0302 	orr.w	r3, r3, #2
 8004ca2:	65a3      	str	r3, [r4, #88]	@ 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004ca4:	6893      	ldr	r3, [r2, #8]
 8004ca6:	07db      	lsls	r3, r3, #31
 8004ca8:	d45c      	bmi.n	8004d64 <HAL_ADC_Init+0x14c>
      tmpCFGR1 |= (hadc->Init.Resolution                                          |
 8004caa:	e9d4 3502 	ldrd	r3, r5, [r4, #8]
 8004cae:	432b      	orrs	r3, r5
                   ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 8004cb0:	7e25      	ldrb	r5, [r4, #24]
                   ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 8004cb2:	7e66      	ldrb	r6, [r4, #25]
                   ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 8004cb4:	f894 c01a 	ldrb.w	ip, [r4, #26]
                   ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8004cb8:	f894 702c 	ldrb.w	r7, [r4, #44]	@ 0x2c
 8004cbc:	ea43 3385 	orr.w	r3, r3, r5, lsl #14
                   ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 8004cc0:	6b25      	ldr	r5, [r4, #48]	@ 0x30
 8004cc2:	ea43 33c6 	orr.w	r3, r3, r6, lsl #15
 8004cc6:	3d00      	subs	r5, #0
 8004cc8:	bf18      	it	ne
 8004cca:	2501      	movne	r5, #1
 8004ccc:	ea43 334c 	orr.w	r3, r3, ip, lsl #13
 8004cd0:	032d      	lsls	r5, r5, #12
                   ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8004cd2:	ea43 0347 	orr.w	r3, r3, r7, lsl #1
 8004cd6:	432b      	orrs	r3, r5

      /* Update setting of discontinuous mode only if continuous mode is disabled */
      if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004cd8:	f894 5020 	ldrb.w	r5, [r4, #32]
                   ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8004cdc:	2900      	cmp	r1, #0
 8004cde:	bfb4      	ite	lt
 8004ce0:	f021 4600 	biclt.w	r6, r1, #2147483648	@ 0x80000000
 8004ce4:	f44f 1600 	movge.w	r6, #2097152	@ 0x200000
      if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004ce8:	2d01      	cmp	r5, #1
                   ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8004cea:	ea43 0306 	orr.w	r3, r3, r6
      if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004cee:	f000 808a 	beq.w	8004e06 <HAL_ADC_Init+0x1ee>
      /* Enable external trigger if trigger selection is different of software  */
      /* start.                                                                 */
      /* Note: This configuration keeps the hardware feature of parameter       */
      /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
      /*       software start.                                                  */
      if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8004cf2:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 8004cf4:	b125      	cbz	r5, 8004d00 <HAL_ADC_Init+0xe8>
      {
        tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 8004cf6:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8004cf8:	f405 75e0 	and.w	r5, r5, #448	@ 0x1c0
 8004cfc:	4335      	orrs	r5, r6
 8004cfe:	432b      	orrs	r3, r5
                     hadc->Init.ExternalTrigConvEdge);
      }

      /* Update ADC configuration register with previous settings */
      MODIFY_REG(hadc->Instance->CFGR1,
 8004d00:	68d5      	ldr	r5, [r2, #12]
                 ADC_CFGR1_ALIGN   |
                 ADC_CFGR1_SCANDIR |
                 ADC_CFGR1_DMACFG,
                 tmpCFGR1);

      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 8004d02:	6866      	ldr	r6, [r4, #4]
      MODIFY_REG(hadc->Instance->CFGR1,
 8004d04:	f425 35fe 	bic.w	r5, r5, #130048	@ 0x1fc00
 8004d08:	f425 75ff 	bic.w	r5, r5, #510	@ 0x1fe
 8004d0c:	431d      	orrs	r5, r3
 8004d0e:	60d5      	str	r5, [r2, #12]
                   hadc->Init.TriggerFrequencyMode
                  );

      if (hadc->Init.OversamplingMode == ENABLE)
 8004d10:	f894 303c 	ldrb.w	r3, [r4, #60]	@ 0x3c
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 8004d14:	6ce5      	ldr	r5, [r4, #76]	@ 0x4c
 8004d16:	f006 4c40 	and.w	ip, r6, #3221225472	@ 0xc0000000
      if (hadc->Init.OversamplingMode == ENABLE)
 8004d1a:	2b01      	cmp	r3, #1
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 8004d1c:	ea4c 0505 	orr.w	r5, ip, r5
      if (hadc->Init.OversamplingMode == ENABLE)
 8004d20:	d109      	bne.n	8004d36 <HAL_ADC_Init+0x11e>
      {
        tmpCFGR2 |= (ADC_CFGR2_OVSE |
 8004d22:	e9d4 3710 	ldrd	r3, r7, [r4, #64]	@ 0x40
 8004d26:	433b      	orrs	r3, r7
 8004d28:	432b      	orrs	r3, r5
 8004d2a:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
 8004d2c:	432b      	orrs	r3, r5
 8004d2e:	ea43 030c 	orr.w	r3, r3, ip
 8004d32:	f043 0501 	orr.w	r5, r3, #1
                     hadc->Init.Oversampling.RightBitShift |
                     hadc->Init.Oversampling.TriggeredMode
                    );
      }

      MODIFY_REG(hadc->Instance->CFGR2,
 8004d36:	6917      	ldr	r7, [r2, #16]
 8004d38:	4b3c      	ldr	r3, [pc, #240]	@ (8004e2c <HAL_ADC_Init+0x214>)
 8004d3a:	403b      	ands	r3, r7
 8004d3c:	432b      	orrs	r3, r5
 8004d3e:	6113      	str	r3, [r2, #16]
                 ADC_CFGR2_TOVS,
                 tmpCFGR2);

      /* Configuration of ADC clock mode: asynchronous clock source           */
      /* with selectable prescaler.                                           */
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 8004d40:	f026 4300 	bic.w	r3, r6, #2147483648	@ 0x80000000
 8004d44:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8004d48:	d00c      	beq.n	8004d64 <HAL_ADC_Init+0x14c>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 8004d4a:	f1b6 4f00 	cmp.w	r6, #2147483648	@ 0x80000000
 8004d4e:	d009      	beq.n	8004d64 <HAL_ADC_Init+0x14c>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV4))
      {
        MODIFY_REG(ADC_COMMON->CCR,
 8004d50:	4d37      	ldr	r5, [pc, #220]	@ (8004e30 <HAL_ADC_Init+0x218>)
 8004d52:	f8d5 3708 	ldr.w	r3, [r5, #1800]	@ 0x708
 8004d56:	f406 1670 	and.w	r6, r6, #3932160	@ 0x3c0000
 8004d5a:	f423 1370 	bic.w	r3, r3, #3932160	@ 0x3c0000
 8004d5e:	4333      	orrs	r3, r6
 8004d60:	f8c5 3708 	str.w	r3, [r5, #1800]	@ 0x708
  MODIFY_REG(ADCx->SMPR,
 8004d64:	6953      	ldr	r3, [r2, #20]
                   hadc->Init.ClockPrescaler & ADC_CCR_PRESC);
      }
    }

    /* Channel sampling time configuration */
    LL_ADC_SetSamplingTimeCommonChannels(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_1, hadc->Init.SamplingTimeCommon1);
 8004d66:	6b65      	ldr	r5, [r4, #52]	@ 0x34
 8004d68:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
 8004d6a:	f023 0307 	bic.w	r3, r3, #7
 8004d6e:	432b      	orrs	r3, r5
 8004d70:	6153      	str	r3, [r2, #20]
 8004d72:	6953      	ldr	r3, [r2, #20]
 8004d74:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8004d78:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 8004d7c:	6153      	str	r3, [r2, #20]
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */
    /*   Channels must be configured into each rank using function            */
    /*   "HAL_ADC_ConfigChannel()".                                           */
    if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 8004d7e:	bb41      	cbnz	r1, 8004dd2 <HAL_ADC_Init+0x1ba>
    {
      /* Set sequencer scan length by clearing ranks above rank 1             */
      /* and do not modify rank 1 value.                                      */
      SET_BIT(hadc->Instance->CHSELR,
 8004d80:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8004d82:	f063 030f 	orn	r3, r3, #15
 8004d86:	6293      	str	r3, [r2, #40]	@ 0x28
  return (uint32_t)((READ_BIT(ADCx->SMPR, ADC_SMPR_SMP1 << (SamplingTimeY & ADC_SAMPLING_TIME_SMP_SHIFT_MASK)))
 8004d88:	6953      	ldr	r3, [r2, #20]
 8004d8a:	f003 0307 	and.w	r3, r3, #7
                );
    }

    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core peripheral clocking.        */
    if(LL_ADC_GetSamplingTimeCommonChannels(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_1)
 8004d8e:	429d      	cmp	r5, r3
 8004d90:	d030      	beq.n	8004df4 <HAL_ADC_Init+0x1dc>
                        HAL_ADC_STATE_READY);
    }
    else
    {
      /* Update ADC state machine to error */
      ADC_STATE_CLR_SET(hadc->State,
 8004d92:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004d94:	f023 0312 	bic.w	r3, r3, #18
 8004d98:	f043 0310 	orr.w	r3, r3, #16
 8004d9c:	65a3      	str	r3, [r4, #88]	@ 0x58
                        HAL_ADC_STATE_BUSY_INTERNAL,
                        HAL_ADC_STATE_ERROR_INTERNAL);

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004d9e:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8004da0:	f043 0301 	orr.w	r3, r3, #1
 8004da4:	65e3      	str	r3, [r4, #92]	@ 0x5c
    return HAL_ERROR;
 8004da6:	2001      	movs	r0, #1

    tmp_hal_status = HAL_ERROR;
  }

  return tmp_hal_status;
}
 8004da8:	b003      	add	sp, #12
 8004daa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004dac:	6893      	ldr	r3, [r2, #8]
 8004dae:	f013 0f04 	tst.w	r3, #4
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004db2:	f04f 0000 	mov.w	r0, #0
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8004db6:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004db8:	f43f af6a 	beq.w	8004c90 <HAL_ADC_Init+0x78>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004dbc:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004dbe:	f043 0310 	orr.w	r3, r3, #16
 8004dc2:	65a3      	str	r3, [r4, #88]	@ 0x58
    tmp_hal_status = HAL_ERROR;
 8004dc4:	e7ef      	b.n	8004da6 <HAL_ADC_Init+0x18e>
    HAL_ADC_MspInit(hadc);
 8004dc6:	f7fb ff71 	bl	8000cac <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8004dca:	65e5      	str	r5, [r4, #92]	@ 0x5c
    hadc->Lock = HAL_UNLOCKED;
 8004dcc:	f884 5054 	strb.w	r5, [r4, #84]	@ 0x54
 8004dd0:	e72e      	b.n	8004c30 <HAL_ADC_Init+0x18>
    else if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8004dd2:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 8004dd6:	d1d7      	bne.n	8004d88 <HAL_ADC_Init+0x170>
      MODIFY_REG(hadc->Instance->CHSELR,
 8004dd8:	69e3      	ldr	r3, [r4, #28]
 8004dda:	6a91      	ldr	r1, [r2, #40]	@ 0x28
 8004ddc:	6e26      	ldr	r6, [r4, #96]	@ 0x60
 8004dde:	3b01      	subs	r3, #1
 8004de0:	009b      	lsls	r3, r3, #2
 8004de2:	f003 031c 	and.w	r3, r3, #28
 8004de6:	f06f 010f 	mvn.w	r1, #15
 8004dea:	fa01 f303 	lsl.w	r3, r1, r3
 8004dee:	4333      	orrs	r3, r6
 8004df0:	6293      	str	r3, [r2, #40]	@ 0x28
 8004df2:	e7c9      	b.n	8004d88 <HAL_ADC_Init+0x170>
      ADC_CLEAR_ERRORCODE(hadc);
 8004df4:	2300      	movs	r3, #0
 8004df6:	65e3      	str	r3, [r4, #92]	@ 0x5c
      ADC_STATE_CLR_SET(hadc->State,
 8004df8:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004dfa:	f023 0303 	bic.w	r3, r3, #3
 8004dfe:	f043 0301 	orr.w	r3, r3, #1
 8004e02:	65a3      	str	r3, [r4, #88]	@ 0x58
 8004e04:	e7d0      	b.n	8004da8 <HAL_ADC_Init+0x190>
        if (hadc->Init.ContinuousConvMode == DISABLE)
 8004e06:	f1bc 0f00 	cmp.w	ip, #0
 8004e0a:	d102      	bne.n	8004e12 <HAL_ADC_Init+0x1fa>
          tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8004e0c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8004e10:	e76f      	b.n	8004cf2 <HAL_ADC_Init+0xda>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004e12:	6da5      	ldr	r5, [r4, #88]	@ 0x58
 8004e14:	f045 0520 	orr.w	r5, r5, #32
 8004e18:	65a5      	str	r5, [r4, #88]	@ 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004e1a:	6de5      	ldr	r5, [r4, #92]	@ 0x5c
 8004e1c:	f045 0501 	orr.w	r5, r5, #1
 8004e20:	65e5      	str	r5, [r4, #92]	@ 0x5c
 8004e22:	e766      	b.n	8004cf2 <HAL_ADC_Init+0xda>
 8004e24:	20000004 	.word	0x20000004
 8004e28:	053e2d63 	.word	0x053e2d63
 8004e2c:	1ffffc02 	.word	0x1ffffc02
 8004e30:	40012000 	.word	0x40012000

08004e34 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 8004e34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8004e36:	6944      	ldr	r4, [r0, #20]
 8004e38:	2c08      	cmp	r4, #8
{
 8004e3a:	4605      	mov	r5, r0
 8004e3c:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8004e3e:	d004      	beq.n	8004e4a <HAL_ADC_PollForConversion+0x16>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMAEN) != 0UL)
 8004e40:	6803      	ldr	r3, [r0, #0]
 8004e42:	68db      	ldr	r3, [r3, #12]
 8004e44:	07dc      	lsls	r4, r3, #31
 8004e46:	d438      	bmi.n	8004eba <HAL_ADC_PollForConversion+0x86>

      return HAL_ERROR;
    }
    else
    {
      tmp_flag_end = (ADC_FLAG_EOC);
 8004e48:	2404      	movs	r4, #4
    }
  }

  /* Get tick count */
  tickstart = HAL_GetTick();
 8004e4a:	f7fc febd 	bl	8001bc8 <HAL_GetTick>
 8004e4e:	4607      	mov	r7, r0

  /* Wait until End of unitary conversion or sequence conversions flag is raised */
  while ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 8004e50:	1c70      	adds	r0, r6, #1
 8004e52:	682a      	ldr	r2, [r5, #0]
 8004e54:	d124      	bne.n	8004ea0 <HAL_ADC_PollForConversion+0x6c>
 8004e56:	6813      	ldr	r3, [r2, #0]
 8004e58:	421c      	tst	r4, r3
 8004e5a:	d0fc      	beq.n	8004e56 <HAL_ADC_PollForConversion+0x22>
      }
    }
  }

  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8004e5c:	6dab      	ldr	r3, [r5, #88]	@ 0x58
 8004e5e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8004e62:	65ab      	str	r3, [r5, #88]	@ 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 8004e64:	68d3      	ldr	r3, [r2, #12]
 8004e66:	f413 6f40 	tst.w	r3, #3072	@ 0xc00
 8004e6a:	d10f      	bne.n	8004e8c <HAL_ADC_PollForConversion+0x58>

  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  if ((LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
      && (hadc->Init.ContinuousConvMode == DISABLE)
 8004e6c:	7eab      	ldrb	r3, [r5, #26]
 8004e6e:	b96b      	cbnz	r3, 8004e8c <HAL_ADC_PollForConversion+0x58>
     )
  {
    /* Check whether end of sequence is reached */
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8004e70:	6813      	ldr	r3, [r2, #0]
 8004e72:	0719      	lsls	r1, r3, #28
 8004e74:	d50a      	bpl.n	8004e8c <HAL_ADC_PollForConversion+0x58>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004e76:	6893      	ldr	r3, [r2, #8]
 8004e78:	075b      	lsls	r3, r3, #29
 8004e7a:	d524      	bpl.n	8004ec6 <HAL_ADC_PollForConversion+0x92>
                          HAL_ADC_STATE_READY);
      }
      else
      {
        /* Change ADC state to error state */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004e7c:	6dab      	ldr	r3, [r5, #88]	@ 0x58
 8004e7e:	f043 0320 	orr.w	r3, r3, #32
 8004e82:	65ab      	str	r3, [r5, #88]	@ 0x58

        /* Set ADC error code to ADC peripheral internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004e84:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
 8004e86:	f043 0301 	orr.w	r3, r3, #1
 8004e8a:	65eb      	str	r3, [r5, #92]	@ 0x5c
  }

  /* Clear end of conversion flag of regular group if low power feature       */
  /* "LowPowerAutoWait " is disabled, to not interfere with this feature      */
  /* until data register is read using function HAL_ADC_GetValue().           */
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 8004e8c:	7e2b      	ldrb	r3, [r5, #24]
 8004e8e:	b90b      	cbnz	r3, 8004e94 <HAL_ADC_PollForConversion+0x60>
  {
    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8004e90:	230c      	movs	r3, #12
 8004e92:	6013      	str	r3, [r2, #0]
  }

  /* Return function status */
  return HAL_OK;
 8004e94:	2000      	movs	r0, #0
}
 8004e96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 8004e98:	b916      	cbnz	r6, 8004ea0 <HAL_ADC_PollForConversion+0x6c>
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 8004e9a:	6813      	ldr	r3, [r2, #0]
 8004e9c:	421c      	tst	r4, r3
 8004e9e:	d01f      	beq.n	8004ee0 <HAL_ADC_PollForConversion+0xac>
  while ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 8004ea0:	6813      	ldr	r3, [r2, #0]
 8004ea2:	4223      	tst	r3, r4
 8004ea4:	d1da      	bne.n	8004e5c <HAL_ADC_PollForConversion+0x28>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 8004ea6:	f7fc fe8f 	bl	8001bc8 <HAL_GetTick>
 8004eaa:	1bc0      	subs	r0, r0, r7
 8004eac:	42b0      	cmp	r0, r6
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 8004eae:	682a      	ldr	r2, [r5, #0]
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 8004eb0:	d9f2      	bls.n	8004e98 <HAL_ADC_PollForConversion+0x64>
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 8004eb2:	6813      	ldr	r3, [r2, #0]
 8004eb4:	421c      	tst	r4, r3
 8004eb6:	d1f3      	bne.n	8004ea0 <HAL_ADC_PollForConversion+0x6c>
 8004eb8:	e012      	b.n	8004ee0 <HAL_ADC_PollForConversion+0xac>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004eba:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 8004ebc:	f043 0320 	orr.w	r3, r3, #32
      return HAL_ERROR;
 8004ec0:	2001      	movs	r0, #1
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004ec2:	65ab      	str	r3, [r5, #88]	@ 0x58
}
 8004ec4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8004ec6:	6853      	ldr	r3, [r2, #4]
 8004ec8:	f023 030c 	bic.w	r3, r3, #12
 8004ecc:	6053      	str	r3, [r2, #4]
        ADC_STATE_CLR_SET(hadc->State,
 8004ece:	6dab      	ldr	r3, [r5, #88]	@ 0x58
 8004ed0:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8004ed4:	f023 0301 	bic.w	r3, r3, #1
 8004ed8:	f043 0301 	orr.w	r3, r3, #1
 8004edc:	65ab      	str	r3, [r5, #88]	@ 0x58
 8004ede:	e7d5      	b.n	8004e8c <HAL_ADC_PollForConversion+0x58>
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8004ee0:	6dab      	ldr	r3, [r5, #88]	@ 0x58
          __HAL_UNLOCK(hadc);
 8004ee2:	2200      	movs	r2, #0
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8004ee4:	f043 0304 	orr.w	r3, r3, #4
          __HAL_UNLOCK(hadc);
 8004ee8:	f885 2054 	strb.w	r2, [r5, #84]	@ 0x54
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8004eec:	65ab      	str	r3, [r5, #88]	@ 0x58
          return HAL_TIMEOUT;
 8004eee:	2003      	movs	r0, #3
}
 8004ef0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004ef2:	bf00      	nop

08004ef4 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
 8004ef4:	6803      	ldr	r3, [r0, #0]
 8004ef6:	6c18      	ldr	r0, [r3, #64]	@ 0x40
}
 8004ef8:	4770      	bx	lr
 8004efa:	bf00      	nop

08004efc <HAL_ADC_ConvCpltCallback>:
/**
  * @brief  Conversion complete callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
 8004efc:	4770      	bx	lr
 8004efe:	bf00      	nop

08004f00 <HAL_ADC_LevelOutOfWindowCallback>:
/**
  * @brief  Analog watchdog 1 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef *hadc)
 8004f00:	4770      	bx	lr
 8004f02:	bf00      	nop

08004f04 <HAL_ADC_ErrorCallback>:
  *           "HAL_ADC_Start_DMA()"
  *           (this function is also clearing overrun flag)
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
 8004f04:	4770      	bx	lr
 8004f06:	bf00      	nop

08004f08 <HAL_ADC_IRQHandler>:
  uint32_t tmp_isr = hadc->Instance->ISR;
 8004f08:	6803      	ldr	r3, [r0, #0]
{
 8004f0a:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp_isr = hadc->Instance->ISR;
 8004f0c:	681d      	ldr	r5, [r3, #0]
  uint32_t tmp_ier = hadc->Instance->IER;
 8004f0e:	685e      	ldr	r6, [r3, #4]
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
 8004f10:	07a9      	lsls	r1, r5, #30
{
 8004f12:	4604      	mov	r4, r0
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
 8004f14:	d501      	bpl.n	8004f1a <HAL_ADC_IRQHandler+0x12>
 8004f16:	07b2      	lsls	r2, r6, #30
 8004f18:	d43e      	bmi.n	8004f98 <HAL_ADC_IRQHandler+0x90>
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8004f1a:	0769      	lsls	r1, r5, #29
 8004f1c:	d537      	bpl.n	8004f8e <HAL_ADC_IRQHandler+0x86>
 8004f1e:	0772      	lsls	r2, r6, #29
 8004f20:	d535      	bpl.n	8004f8e <HAL_ADC_IRQHandler+0x86>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8004f22:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 8004f24:	06d2      	lsls	r2, r2, #27
 8004f26:	d403      	bmi.n	8004f30 <HAL_ADC_IRQHandler+0x28>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8004f28:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 8004f2a:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8004f2e:	65a2      	str	r2, [r4, #88]	@ 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 8004f30:	68da      	ldr	r2, [r3, #12]
 8004f32:	f412 6f40 	tst.w	r2, #3072	@ 0xc00
 8004f36:	d10f      	bne.n	8004f58 <HAL_ADC_IRQHandler+0x50>
        && (hadc->Init.ContinuousConvMode == DISABLE)
 8004f38:	7ea2      	ldrb	r2, [r4, #26]
 8004f3a:	b96a      	cbnz	r2, 8004f58 <HAL_ADC_IRQHandler+0x50>
      if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8004f3c:	681a      	ldr	r2, [r3, #0]
 8004f3e:	0710      	lsls	r0, r2, #28
 8004f40:	d50a      	bpl.n	8004f58 <HAL_ADC_IRQHandler+0x50>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004f42:	689a      	ldr	r2, [r3, #8]
 8004f44:	0751      	lsls	r1, r2, #29
 8004f46:	d574      	bpl.n	8005032 <HAL_ADC_IRQHandler+0x12a>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f48:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004f4a:	f043 0320 	orr.w	r3, r3, #32
 8004f4e:	65a3      	str	r3, [r4, #88]	@ 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004f50:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8004f52:	f043 0301 	orr.w	r3, r3, #1
 8004f56:	65e3      	str	r3, [r4, #92]	@ 0x5c
    HAL_ADC_ConvCpltCallback(hadc);
 8004f58:	4620      	mov	r0, r4
 8004f5a:	f7ff ffcf 	bl	8004efc <HAL_ADC_ConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8004f5e:	6823      	ldr	r3, [r4, #0]
 8004f60:	220c      	movs	r2, #12
 8004f62:	601a      	str	r2, [r3, #0]
  if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
 8004f64:	062a      	lsls	r2, r5, #24
 8004f66:	d501      	bpl.n	8004f6c <HAL_ADC_IRQHandler+0x64>
 8004f68:	0630      	lsls	r0, r6, #24
 8004f6a:	d443      	bmi.n	8004ff4 <HAL_ADC_IRQHandler+0xec>
  if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
 8004f6c:	05e9      	lsls	r1, r5, #23
 8004f6e:	d501      	bpl.n	8004f74 <HAL_ADC_IRQHandler+0x6c>
 8004f70:	05f2      	lsls	r2, r6, #23
 8004f72:	d44a      	bmi.n	800500a <HAL_ADC_IRQHandler+0x102>
  if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
 8004f74:	05a8      	lsls	r0, r5, #22
 8004f76:	d501      	bpl.n	8004f7c <HAL_ADC_IRQHandler+0x74>
 8004f78:	05b1      	lsls	r1, r6, #22
 8004f7a:	d42f      	bmi.n	8004fdc <HAL_ADC_IRQHandler+0xd4>
  if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
 8004f7c:	06ea      	lsls	r2, r5, #27
 8004f7e:	d501      	bpl.n	8004f84 <HAL_ADC_IRQHandler+0x7c>
 8004f80:	06f0      	lsls	r0, r6, #27
 8004f82:	d417      	bmi.n	8004fb4 <HAL_ADC_IRQHandler+0xac>
  if (((tmp_isr & ADC_FLAG_CCRDY) == ADC_FLAG_CCRDY) && ((tmp_ier & ADC_IT_CCRDY) == ADC_IT_CCRDY))
 8004f84:	04aa      	lsls	r2, r5, #18
 8004f86:	d501      	bpl.n	8004f8c <HAL_ADC_IRQHandler+0x84>
 8004f88:	04b3      	lsls	r3, r6, #18
 8004f8a:	d44a      	bmi.n	8005022 <HAL_ADC_IRQHandler+0x11a>
}
 8004f8c:	bd70      	pop	{r4, r5, r6, pc}
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8004f8e:	0728      	lsls	r0, r5, #28
 8004f90:	d5e8      	bpl.n	8004f64 <HAL_ADC_IRQHandler+0x5c>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
 8004f92:	0731      	lsls	r1, r6, #28
 8004f94:	d5e6      	bpl.n	8004f64 <HAL_ADC_IRQHandler+0x5c>
 8004f96:	e7c4      	b.n	8004f22 <HAL_ADC_IRQHandler+0x1a>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8004f98:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 8004f9a:	06d8      	lsls	r0, r3, #27
 8004f9c:	d403      	bmi.n	8004fa6 <HAL_ADC_IRQHandler+0x9e>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
 8004f9e:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004fa0:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8004fa4:	65a3      	str	r3, [r4, #88]	@ 0x58
    HAL_ADCEx_EndOfSamplingCallback(hadc);
 8004fa6:	4620      	mov	r0, r4
 8004fa8:	f000 fb48 	bl	800563c <HAL_ADCEx_EndOfSamplingCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
 8004fac:	6823      	ldr	r3, [r4, #0]
 8004fae:	2202      	movs	r2, #2
 8004fb0:	601a      	str	r2, [r3, #0]
 8004fb2:	e7b2      	b.n	8004f1a <HAL_ADC_IRQHandler+0x12>
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
 8004fb4:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8004fb6:	b112      	cbz	r2, 8004fbe <HAL_ADC_IRQHandler+0xb6>
  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG));
 8004fb8:	68da      	ldr	r2, [r3, #12]
      if (LL_ADC_REG_GetDMATransfer(hadc->Instance) != LL_ADC_REG_DMA_TRANSFER_NONE)
 8004fba:	0791      	lsls	r1, r2, #30
 8004fbc:	d00b      	beq.n	8004fd6 <HAL_ADC_IRQHandler+0xce>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8004fbe:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004fc0:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8004fc4:	65a3      	str	r3, [r4, #88]	@ 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8004fc6:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8004fc8:	f043 0302 	orr.w	r3, r3, #2
 8004fcc:	65e3      	str	r3, [r4, #92]	@ 0x5c
      HAL_ADC_ErrorCallback(hadc);
 8004fce:	4620      	mov	r0, r4
 8004fd0:	f7ff ff98 	bl	8004f04 <HAL_ADC_ErrorCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8004fd4:	6823      	ldr	r3, [r4, #0]
 8004fd6:	2210      	movs	r2, #16
 8004fd8:	601a      	str	r2, [r3, #0]
 8004fda:	e7d3      	b.n	8004f84 <HAL_ADC_IRQHandler+0x7c>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8004fdc:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004fde:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8004fe2:	65a3      	str	r3, [r4, #88]	@ 0x58
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8004fe4:	4620      	mov	r0, r4
 8004fe6:	f000 fb27 	bl	8005638 <HAL_ADCEx_LevelOutOfWindow3Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
 8004fea:	6823      	ldr	r3, [r4, #0]
 8004fec:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004ff0:	601a      	str	r2, [r3, #0]
 8004ff2:	e7c3      	b.n	8004f7c <HAL_ADC_IRQHandler+0x74>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8004ff4:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8004ff6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8004ffa:	65a3      	str	r3, [r4, #88]	@ 0x58
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8004ffc:	4620      	mov	r0, r4
 8004ffe:	f7ff ff7f 	bl	8004f00 <HAL_ADC_LevelOutOfWindowCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
 8005002:	6823      	ldr	r3, [r4, #0]
 8005004:	2280      	movs	r2, #128	@ 0x80
 8005006:	601a      	str	r2, [r3, #0]
 8005008:	e7b0      	b.n	8004f6c <HAL_ADC_IRQHandler+0x64>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 800500a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 800500c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8005010:	65a3      	str	r3, [r4, #88]	@ 0x58
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8005012:	4620      	mov	r0, r4
 8005014:	f000 fb0e 	bl	8005634 <HAL_ADCEx_LevelOutOfWindow2Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
 8005018:	6823      	ldr	r3, [r4, #0]
 800501a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800501e:	601a      	str	r2, [r3, #0]
 8005020:	e7a8      	b.n	8004f74 <HAL_ADC_IRQHandler+0x6c>
    HAL_ADCEx_ChannelConfigReadyCallback(hadc);
 8005022:	4620      	mov	r0, r4
 8005024:	f000 fb0c 	bl	8005640 <HAL_ADCEx_ChannelConfigReadyCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_CCRDY);
 8005028:	6823      	ldr	r3, [r4, #0]
 800502a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800502e:	601a      	str	r2, [r3, #0]
}
 8005030:	bd70      	pop	{r4, r5, r6, pc}
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8005032:	685a      	ldr	r2, [r3, #4]
 8005034:	f022 020c 	bic.w	r2, r2, #12
 8005038:	605a      	str	r2, [r3, #4]
          ADC_STATE_CLR_SET(hadc->State,
 800503a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 800503c:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8005040:	f023 0301 	bic.w	r3, r3, #1
 8005044:	f043 0301 	orr.w	r3, r3, #1
 8005048:	65a3      	str	r3, [r4, #88]	@ 0x58
 800504a:	e785      	b.n	8004f58 <HAL_ADC_IRQHandler+0x50>

0800504c <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *pConfig)
{
 800504c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800504e:	4603      	mov	r3, r0
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));

    assert_param(IS_ADC_REGULAR_RANK(pConfig->Rank));
  }

  __HAL_LOCK(hadc);
 8005050:	f890 0054 	ldrb.w	r0, [r0, #84]	@ 0x54
{
 8005054:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
 8005056:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 8005058:	2801      	cmp	r0, #1
  __IO uint32_t wait_loop_index = 0UL;
 800505a:	9201      	str	r2, [sp, #4]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 800505c:	691a      	ldr	r2, [r3, #16]
  __HAL_LOCK(hadc);
 800505e:	d06f      	beq.n	8005140 <HAL_ADC_ConfigChannel+0xf4>
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8005060:	681c      	ldr	r4, [r3, #0]
  __HAL_LOCK(hadc);
 8005062:	2001      	movs	r0, #1
 8005064:	f883 0054 	strb.w	r0, [r3, #84]	@ 0x54
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005068:	68a5      	ldr	r5, [r4, #8]
 800506a:	076d      	lsls	r5, r5, #29
 800506c:	d508      	bpl.n	8005080 <HAL_ADC_ConfigChannel+0x34>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800506e:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8005070:	f042 0220 	orr.w	r2, r2, #32
 8005074:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
  }

  __HAL_UNLOCK(hadc);
 8005076:	2200      	movs	r2, #0
 8005078:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
}
 800507c:	b003      	add	sp, #12
 800507e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (pConfig->Rank != ADC_RANK_NONE)
 8005080:	684d      	ldr	r5, [r1, #4]
        LL_ADC_REG_SetSequencerChAdd(hadc->Instance, pConfig->Channel);
 8005082:	6808      	ldr	r0, [r1, #0]
    if (pConfig->Rank != ADC_RANK_NONE)
 8005084:	2d02      	cmp	r5, #2
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 8005086:	f022 0204 	bic.w	r2, r2, #4
    if (pConfig->Rank != ADC_RANK_NONE)
 800508a:	d038      	beq.n	80050fe <HAL_ADC_ConfigChannel+0xb2>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 800508c:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 8005090:	f3c0 0611 	ubfx	r6, r0, #0, #18
 8005094:	d02f      	beq.n	80050f6 <HAL_ADC_ConfigChannel+0xaa>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 8005096:	6e1f      	ldr	r7, [r3, #96]	@ 0x60
 8005098:	f005 0c1f 	and.w	ip, r5, #31
 800509c:	220f      	movs	r2, #15
 800509e:	fa02 f20c 	lsl.w	r2, r2, ip
 80050a2:	ea27 0702 	bic.w	r7, r7, r2
 80050a6:	ea6f 0e02 	mvn.w	lr, r2
 80050aa:	2e00      	cmp	r6, #0
 80050ac:	d165      	bne.n	800517a <HAL_ADC_ConfigChannel+0x12e>
 80050ae:	f3c0 6284 	ubfx	r2, r0, #26, #5
 80050b2:	fa02 f20c 	lsl.w	r2, r2, ip
 80050b6:	433a      	orrs	r2, r7
 80050b8:	661a      	str	r2, [r3, #96]	@ 0x60
        if (((pConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 80050ba:	08ad      	lsrs	r5, r5, #2
 80050bc:	69da      	ldr	r2, [r3, #28]
 80050be:	3501      	adds	r5, #1
 80050c0:	4295      	cmp	r5, r2
 80050c2:	d808      	bhi.n	80050d6 <HAL_ADC_ConfigChannel+0x8a>
  MODIFY_REG(ADCx->CHSELR,
 80050c4:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 80050c6:	f3c0 6583 	ubfx	r5, r0, #26, #4
 80050ca:	ea0e 0202 	and.w	r2, lr, r2
 80050ce:	fa05 f50c 	lsl.w	r5, r5, ip
 80050d2:	432a      	orrs	r2, r5
 80050d4:	62a2      	str	r2, [r4, #40]	@ 0x28
  MODIFY_REG(ADCx->SMPR,
 80050d6:	688a      	ldr	r2, [r1, #8]
 80050d8:	6961      	ldr	r1, [r4, #20]
 80050da:	ea02 2200 	and.w	r2, r2, r0, lsl #8
 80050de:	f022 427c 	bic.w	r2, r2, #4227858432	@ 0xfc000000
 80050e2:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 80050e6:	ea21 2100 	bic.w	r1, r1, r0, lsl #8
 80050ea:	430a      	orrs	r2, r1
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 80050ec:	2800      	cmp	r0, #0
 80050ee:	6162      	str	r2, [r4, #20]
 80050f0:	db29      	blt.n	8005146 <HAL_ADC_ConfigChannel+0xfa>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80050f2:	2000      	movs	r0, #0
 80050f4:	e7bf      	b.n	8005076 <HAL_ADC_ConfigChannel+0x2a>
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 80050f6:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 80050f8:	4332      	orrs	r2, r6
 80050fa:	62a2      	str	r2, [r4, #40]	@ 0x28
}
 80050fc:	e7eb      	b.n	80050d6 <HAL_ADC_ConfigChannel+0x8a>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 80050fe:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8005102:	d105      	bne.n	8005110 <HAL_ADC_ConfigChannel+0xc4>
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 8005104:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8005106:	f3c0 0111 	ubfx	r1, r0, #0, #18
 800510a:	ea22 0201 	bic.w	r2, r2, r1
 800510e:	62a2      	str	r2, [r4, #40]	@ 0x28
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 8005110:	2800      	cmp	r0, #0
 8005112:	daee      	bge.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
        if (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8005114:	4c3c      	ldr	r4, [pc, #240]	@ (8005208 <HAL_ADC_ConfigChannel+0x1bc>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8005116:	493d      	ldr	r1, [pc, #244]	@ (800520c <HAL_ADC_ConfigChannel+0x1c0>)
 8005118:	42a0      	cmp	r0, r4
 800511a:	f8d1 2708 	ldr.w	r2, [r1, #1800]	@ 0x708
 800511e:	d03d      	beq.n	800519c <HAL_ADC_ConfigChannel+0x150>
        else if (pConfig->Channel == ADC_CHANNEL_VBAT)
 8005120:	4c3b      	ldr	r4, [pc, #236]	@ (8005210 <HAL_ADC_ConfigChannel+0x1c4>)
 8005122:	42a0      	cmp	r0, r4
 8005124:	d065      	beq.n	80051f2 <HAL_ADC_ConfigChannel+0x1a6>
        else if (pConfig->Channel == ADC_CHANNEL_VREFINT)
 8005126:	4c3b      	ldr	r4, [pc, #236]	@ (8005214 <HAL_ADC_ConfigChannel+0x1c8>)
 8005128:	42a0      	cmp	r0, r4
 800512a:	d1e2      	bne.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800512c:	f8d1 0708 	ldr.w	r0, [r1, #1800]	@ 0x708
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005130:	f002 72c0 	and.w	r2, r2, #25165824	@ 0x1800000
 8005134:	f020 70e0 	bic.w	r0, r0, #29360128	@ 0x1c00000
 8005138:	4302      	orrs	r2, r0
 800513a:	f8c1 2708 	str.w	r2, [r1, #1800]	@ 0x708
}
 800513e:	e7d8      	b.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
  __HAL_LOCK(hadc);
 8005140:	2002      	movs	r0, #2
}
 8005142:	b003      	add	sp, #12
 8005144:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8005146:	4931      	ldr	r1, [pc, #196]	@ (800520c <HAL_ADC_ConfigChannel+0x1c0>)
        if ((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 8005148:	4c2f      	ldr	r4, [pc, #188]	@ (8005208 <HAL_ADC_ConfigChannel+0x1bc>)
 800514a:	f8d1 2708 	ldr.w	r2, [r1, #1800]	@ 0x708
 800514e:	42a0      	cmp	r0, r4
 8005150:	f002 75e0 	and.w	r5, r2, #29360128	@ 0x1c00000
 8005154:	d02c      	beq.n	80051b0 <HAL_ADC_ConfigChannel+0x164>
        else if ((pConfig->Channel == ADC_CHANNEL_VBAT)
 8005156:	4c2e      	ldr	r4, [pc, #184]	@ (8005210 <HAL_ADC_ConfigChannel+0x1c4>)
 8005158:	42a0      	cmp	r0, r4
 800515a:	d013      	beq.n	8005184 <HAL_ADC_ConfigChannel+0x138>
        else if ((pConfig->Channel == ADC_CHANNEL_VREFINT) &&
 800515c:	4c2d      	ldr	r4, [pc, #180]	@ (8005214 <HAL_ADC_ConfigChannel+0x1c8>)
 800515e:	42a0      	cmp	r0, r4
 8005160:	d1c7      	bne.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
 8005162:	0252      	lsls	r2, r2, #9
 8005164:	d4c5      	bmi.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8005166:	f8d1 2708 	ldr.w	r2, [r1, #1800]	@ 0x708
 800516a:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 800516e:	432a      	orrs	r2, r5
 8005170:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8005174:	f8c1 2708 	str.w	r2, [r1, #1800]	@ 0x708
}
 8005178:	e7bb      	b.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800517a:	fa90 f2a0 	rbit	r2, r0
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 800517e:	fab2 f282 	clz	r2, r2
 8005182:	e796      	b.n	80050b2 <HAL_ADC_ConfigChannel+0x66>
                 && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8005184:	01d0      	lsls	r0, r2, #7
 8005186:	d4b4      	bmi.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8005188:	f8d1 2708 	ldr.w	r2, [r1, #1800]	@ 0x708
 800518c:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 8005190:	432a      	orrs	r2, r5
 8005192:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 8005196:	f8c1 2708 	str.w	r2, [r1, #1800]	@ 0x708
}
 800519a:	e7aa      	b.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800519c:	f8d1 0708 	ldr.w	r0, [r1, #1800]	@ 0x708
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80051a0:	f002 72a0 	and.w	r2, r2, #20971520	@ 0x1400000
 80051a4:	f020 70e0 	bic.w	r0, r0, #29360128	@ 0x1c00000
 80051a8:	4302      	orrs	r2, r0
 80051aa:	f8c1 2708 	str.w	r2, [r1, #1800]	@ 0x708
}
 80051ae:	e7a0      	b.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
        if ((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 80051b0:	0214      	lsls	r4, r2, #8
 80051b2:	d49e      	bmi.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80051b4:	f8d1 2708 	ldr.w	r2, [r1, #1800]	@ 0x708
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80051b8:	4817      	ldr	r0, [pc, #92]	@ (8005218 <HAL_ADC_ConfigChannel+0x1cc>)
 80051ba:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 80051be:	432a      	orrs	r2, r5
 80051c0:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 80051c4:	f8c1 2708 	str.w	r2, [r1, #1800]	@ 0x708
 80051c8:	6802      	ldr	r2, [r0, #0]
 80051ca:	4914      	ldr	r1, [pc, #80]	@ (800521c <HAL_ADC_ConfigChannel+0x1d0>)
 80051cc:	0992      	lsrs	r2, r2, #6
 80051ce:	fba1 1202 	umull	r1, r2, r1, r2
 80051d2:	0992      	lsrs	r2, r2, #6
 80051d4:	3201      	adds	r2, #1
 80051d6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80051da:	0092      	lsls	r2, r2, #2
 80051dc:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 80051de:	9a01      	ldr	r2, [sp, #4]
 80051e0:	2a00      	cmp	r2, #0
 80051e2:	d086      	beq.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
            wait_loop_index--;
 80051e4:	9a01      	ldr	r2, [sp, #4]
 80051e6:	3a01      	subs	r2, #1
 80051e8:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 80051ea:	9a01      	ldr	r2, [sp, #4]
 80051ec:	2a00      	cmp	r2, #0
 80051ee:	d1f9      	bne.n	80051e4 <HAL_ADC_ConfigChannel+0x198>
 80051f0:	e77f      	b.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
 80051f2:	f8d1 0708 	ldr.w	r0, [r1, #1800]	@ 0x708
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80051f6:	f402 0240 	and.w	r2, r2, #12582912	@ 0xc00000
 80051fa:	f020 70e0 	bic.w	r0, r0, #29360128	@ 0x1c00000
 80051fe:	4302      	orrs	r2, r0
 8005200:	f8c1 2708 	str.w	r2, [r1, #1800]	@ 0x708
}
 8005204:	e775      	b.n	80050f2 <HAL_ADC_ConfigChannel+0xa6>
 8005206:	bf00      	nop
 8005208:	b0001000 	.word	0xb0001000
 800520c:	40012000 	.word	0x40012000
 8005210:	b8004000 	.word	0xb8004000
 8005214:	b4002000 	.word	0xb4002000
 8005218:	20000004 	.word	0x20000004
 800521c:	053e2d63 	.word	0x053e2d63

08005220 <ADC_ConversionStop>:
  *         stopped to disable the ADC.
  * @param  hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc)
{
 8005220:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Verification if ADC is not already stopped on regular group to bypass    */
  /* this function if not needed.                                             */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 8005222:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005224:	689a      	ldr	r2, [r3, #8]
 8005226:	0754      	lsls	r4, r2, #29
 8005228:	d51c      	bpl.n	8005264 <ADC_ConversionStop+0x44>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 800522a:	689a      	ldr	r2, [r3, #8]
 800522c:	4604      	mov	r4, r0
 800522e:	0790      	lsls	r0, r2, #30
 8005230:	d51a      	bpl.n	8005268 <ADC_ConversionStop+0x48>
      LL_ADC_REG_StopConversion(hadc->Instance);
    }

    /* Wait for conversion effectively stopped */
    /* Get tick count */
    tickstart = HAL_GetTick();
 8005232:	f7fc fcc9 	bl	8001bc8 <HAL_GetTick>

    while ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 8005236:	6823      	ldr	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8005238:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 800523a:	689b      	ldr	r3, [r3, #8]
 800523c:	0759      	lsls	r1, r3, #29
 800523e:	d511      	bpl.n	8005264 <ADC_ConversionStop+0x44>
    {
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 8005240:	f7fc fcc2 	bl	8001bc8 <HAL_GetTick>
 8005244:	1b43      	subs	r3, r0, r5
 8005246:	2b02      	cmp	r3, #2
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 8005248:	6823      	ldr	r3, [r4, #0]
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 800524a:	d9f6      	bls.n	800523a <ADC_ConversionStop+0x1a>
        if ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 800524c:	689a      	ldr	r2, [r3, #8]
 800524e:	0752      	lsls	r2, r2, #29
 8005250:	d5f3      	bpl.n	800523a <ADC_ConversionStop+0x1a>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8005252:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8005254:	f043 0310 	orr.w	r3, r3, #16
 8005258:	65a3      	str	r3, [r4, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800525a:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800525c:	2001      	movs	r0, #1
 800525e:	4303      	orrs	r3, r0
 8005260:	65e3      	str	r3, [r4, #92]	@ 0x5c

  }

  /* Return HAL status */
  return HAL_OK;
}
 8005262:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;
 8005264:	2000      	movs	r0, #0
}
 8005266:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
 8005268:	689a      	ldr	r2, [r3, #8]
 800526a:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 800526e:	f022 0217 	bic.w	r2, r2, #23
 8005272:	f042 0210 	orr.w	r2, r2, #16
 8005276:	609a      	str	r2, [r3, #8]
}
 8005278:	e7db      	b.n	8005232 <ADC_ConversionStop+0x12>
 800527a:	bf00      	nop

0800527c <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 800527c:	b570      	push	{r4, r5, r6, lr}
 800527e:	b082      	sub	sp, #8
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0UL;
 8005280:	2200      	movs	r2, #0

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8005282:	6803      	ldr	r3, [r0, #0]
  __IO uint32_t wait_loop_index = 0UL;
 8005284:	9201      	str	r2, [sp, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8005286:	689a      	ldr	r2, [r3, #8]
 8005288:	07d2      	lsls	r2, r2, #31
 800528a:	d425      	bmi.n	80052d8 <ADC_Enable+0x5c>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 800528c:	6899      	ldr	r1, [r3, #8]
 800528e:	4a28      	ldr	r2, [pc, #160]	@ (8005330 <ADC_Enable+0xb4>)
 8005290:	4211      	tst	r1, r2
 8005292:	4604      	mov	r4, r0
 8005294:	d123      	bne.n	80052de <ADC_Enable+0x62>
  MODIFY_REG(ADCx->CR,
 8005296:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8005298:	4926      	ldr	r1, [pc, #152]	@ (8005334 <ADC_Enable+0xb8>)
  MODIFY_REG(ADCx->CR,
 800529a:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 800529e:	f022 0217 	bic.w	r2, r2, #23
 80052a2:	f042 0201 	orr.w	r2, r2, #1
 80052a6:	609a      	str	r2, [r3, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80052a8:	f8d1 3708 	ldr.w	r3, [r1, #1800]	@ 0x708
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);

    if ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) 
 80052ac:	021b      	lsls	r3, r3, #8
 80052ae:	d510      	bpl.n	80052d2 <ADC_Enable+0x56>
      /* Wait loop initialization and execution */
      /* Note: Variable divided by 2 to compensate partially              */
      /*       CPU processing cycles, scaling in us split to not          */
      /*       exceed 32 bits register capacity and handle low frequency. */
      wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) 
                         * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80052b0:	4b21      	ldr	r3, [pc, #132]	@ (8005338 <ADC_Enable+0xbc>)
 80052b2:	4a22      	ldr	r2, [pc, #136]	@ (800533c <ADC_Enable+0xc0>)
 80052b4:	681b      	ldr	r3, [r3, #0]
 80052b6:	099b      	lsrs	r3, r3, #6
 80052b8:	fba2 2303 	umull	r2, r3, r2, r3
 80052bc:	099b      	lsrs	r3, r3, #6
 80052be:	3301      	adds	r3, #1
      wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) 
 80052c0:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 80052c2:	9b01      	ldr	r3, [sp, #4]
 80052c4:	b12b      	cbz	r3, 80052d2 <ADC_Enable+0x56>
      {
        wait_loop_index--;
 80052c6:	9b01      	ldr	r3, [sp, #4]
 80052c8:	3b01      	subs	r3, #1
 80052ca:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 80052cc:	9b01      	ldr	r3, [sp, #4]
 80052ce:	2b00      	cmp	r3, #0
 80052d0:	d1f9      	bne.n	80052c6 <ADC_Enable+0x4a>
      }
    }

    /* If low power mode AutoPowerOff is enabled, power-on/off phases are     */
    /* performed automatically by hardware and flag ADC ready is not set.     */
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 80052d2:	7e63      	ldrb	r3, [r4, #25]
 80052d4:	2b01      	cmp	r3, #1
 80052d6:	d10d      	bne.n	80052f4 <ADC_Enable+0x78>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 80052d8:	2000      	movs	r0, #0
}
 80052da:	b002      	add	sp, #8
 80052dc:	bd70      	pop	{r4, r5, r6, pc}
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80052de:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80052e0:	f043 0310 	orr.w	r3, r3, #16
 80052e4:	65a3      	str	r3, [r4, #88]	@ 0x58
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80052e6:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
      return HAL_ERROR;
 80052e8:	2001      	movs	r0, #1
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80052ea:	f043 0301 	orr.w	r3, r3, #1
 80052ee:	65e3      	str	r3, [r4, #92]	@ 0x5c
}
 80052f0:	b002      	add	sp, #8
 80052f2:	bd70      	pop	{r4, r5, r6, pc}
      tickstart = HAL_GetTick();
 80052f4:	f7fc fc68 	bl	8001bc8 <HAL_GetTick>
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 80052f8:	6823      	ldr	r3, [r4, #0]
 80052fa:	681a      	ldr	r2, [r3, #0]
 80052fc:	07d6      	lsls	r6, r2, #31
      tickstart = HAL_GetTick();
 80052fe:	4605      	mov	r5, r0
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8005300:	d4ea      	bmi.n	80052d8 <ADC_Enable+0x5c>
  MODIFY_REG(ADCx->CR,
 8005302:	4e0f      	ldr	r6, [pc, #60]	@ (8005340 <ADC_Enable+0xc4>)
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8005304:	689a      	ldr	r2, [r3, #8]
 8005306:	07d0      	lsls	r0, r2, #31
 8005308:	d404      	bmi.n	8005314 <ADC_Enable+0x98>
  MODIFY_REG(ADCx->CR,
 800530a:	689a      	ldr	r2, [r3, #8]
 800530c:	4032      	ands	r2, r6
 800530e:	f042 0201 	orr.w	r2, r2, #1
 8005312:	609a      	str	r2, [r3, #8]
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8005314:	f7fc fc58 	bl	8001bc8 <HAL_GetTick>
 8005318:	1b43      	subs	r3, r0, r5
 800531a:	2b02      	cmp	r3, #2
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 800531c:	6823      	ldr	r3, [r4, #0]
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 800531e:	d902      	bls.n	8005326 <ADC_Enable+0xaa>
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8005320:	681a      	ldr	r2, [r3, #0]
 8005322:	07d1      	lsls	r1, r2, #31
 8005324:	d5db      	bpl.n	80052de <ADC_Enable+0x62>
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8005326:	681a      	ldr	r2, [r3, #0]
 8005328:	07d2      	lsls	r2, r2, #31
 800532a:	d5eb      	bpl.n	8005304 <ADC_Enable+0x88>
 800532c:	e7d4      	b.n	80052d8 <ADC_Enable+0x5c>
 800532e:	bf00      	nop
 8005330:	80000017 	.word	0x80000017
 8005334:	40012000 	.word	0x40012000
 8005338:	20000004 	.word	0x20000004
 800533c:	053e2d63 	.word	0x053e2d63
 8005340:	7fffffe8 	.word	0x7fffffe8

08005344 <HAL_ADC_Start>:
{
 8005344:	b538      	push	{r3, r4, r5, lr}
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8005346:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005348:	689d      	ldr	r5, [r3, #8]
 800534a:	f015 0504 	ands.w	r5, r5, #4
 800534e:	d121      	bne.n	8005394 <HAL_ADC_Start+0x50>
    __HAL_LOCK(hadc);
 8005350:	f890 3054 	ldrb.w	r3, [r0, #84]	@ 0x54
 8005354:	2b01      	cmp	r3, #1
 8005356:	4604      	mov	r4, r0
 8005358:	d01c      	beq.n	8005394 <HAL_ADC_Start+0x50>
 800535a:	2301      	movs	r3, #1
 800535c:	f880 3054 	strb.w	r3, [r0, #84]	@ 0x54
    tmp_hal_status = ADC_Enable(hadc);
 8005360:	f7ff ff8c 	bl	800527c <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 8005364:	b9c0      	cbnz	r0, 8005398 <HAL_ADC_Start+0x54>
      ADC_STATE_CLR_SET(hadc->State,
 8005366:	6da3      	ldr	r3, [r4, #88]	@ 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8005368:	6822      	ldr	r2, [r4, #0]
      ADC_STATE_CLR_SET(hadc->State,
 800536a:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 800536e:	f023 0301 	bic.w	r3, r3, #1
 8005372:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8005376:	211c      	movs	r1, #28
      ADC_STATE_CLR_SET(hadc->State,
 8005378:	65a3      	str	r3, [r4, #88]	@ 0x58
      ADC_CLEAR_ERRORCODE(hadc);
 800537a:	65e0      	str	r0, [r4, #92]	@ 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800537c:	6011      	str	r1, [r2, #0]
      __HAL_UNLOCK(hadc);
 800537e:	f884 0054 	strb.w	r0, [r4, #84]	@ 0x54
  MODIFY_REG(ADCx->CR,
 8005382:	6893      	ldr	r3, [r2, #8]
 8005384:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8005388:	f023 0317 	bic.w	r3, r3, #23
 800538c:	f043 0304 	orr.w	r3, r3, #4
 8005390:	6093      	str	r3, [r2, #8]
}
 8005392:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hadc);
 8005394:	2002      	movs	r0, #2
}
 8005396:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 8005398:	f884 5054 	strb.w	r5, [r4, #84]	@ 0x54
}
 800539c:	bd38      	pop	{r3, r4, r5, pc}
 800539e:	bf00      	nop

080053a0 <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
 80053a0:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 80053a2:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 80053a4:	689a      	ldr	r2, [r3, #8]
 80053a6:	0795      	lsls	r5, r2, #30
 80053a8:	d502      	bpl.n	80053b0 <ADC_Disable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80053aa:	689b      	ldr	r3, [r3, #8]
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 80053ac:	2000      	movs	r0, #0
}
 80053ae:	bd38      	pop	{r3, r4, r5, pc}
 80053b0:	689a      	ldr	r2, [r3, #8]
 80053b2:	07d4      	lsls	r4, r2, #31
 80053b4:	d5fa      	bpl.n	80053ac <ADC_Disable+0xc>
    if ((hadc->Instance->CR & (ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 80053b6:	689a      	ldr	r2, [r3, #8]
 80053b8:	f002 0205 	and.w	r2, r2, #5
 80053bc:	2a01      	cmp	r2, #1
 80053be:	4604      	mov	r4, r0
 80053c0:	d009      	beq.n	80053d6 <ADC_Disable+0x36>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80053c2:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80053c4:	f043 0310 	orr.w	r3, r3, #16
 80053c8:	65a3      	str	r3, [r4, #88]	@ 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80053ca:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80053cc:	f043 0301 	orr.w	r3, r3, #1
 80053d0:	65e3      	str	r3, [r4, #92]	@ 0x5c
      return HAL_ERROR;
 80053d2:	2001      	movs	r0, #1
}
 80053d4:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
 80053d6:	689a      	ldr	r2, [r3, #8]
 80053d8:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 80053dc:	f022 0217 	bic.w	r2, r2, #23
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 80053e0:	2103      	movs	r1, #3
 80053e2:	f042 0202 	orr.w	r2, r2, #2
 80053e6:	609a      	str	r2, [r3, #8]
 80053e8:	6019      	str	r1, [r3, #0]
    tickstart = HAL_GetTick();
 80053ea:	f7fc fbed 	bl	8001bc8 <HAL_GetTick>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 80053ee:	6823      	ldr	r3, [r4, #0]
 80053f0:	689b      	ldr	r3, [r3, #8]
 80053f2:	07d9      	lsls	r1, r3, #31
    tickstart = HAL_GetTick();
 80053f4:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 80053f6:	d403      	bmi.n	8005400 <ADC_Disable+0x60>
 80053f8:	e7d8      	b.n	80053ac <ADC_Disable+0xc>
 80053fa:	689b      	ldr	r3, [r3, #8]
 80053fc:	07db      	lsls	r3, r3, #31
 80053fe:	d5d5      	bpl.n	80053ac <ADC_Disable+0xc>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8005400:	f7fc fbe2 	bl	8001bc8 <HAL_GetTick>
 8005404:	1b40      	subs	r0, r0, r5
 8005406:	2802      	cmp	r0, #2
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8005408:	6823      	ldr	r3, [r4, #0]
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 800540a:	d9f6      	bls.n	80053fa <ADC_Disable+0x5a>
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 800540c:	689a      	ldr	r2, [r3, #8]
 800540e:	07d2      	lsls	r2, r2, #31
 8005410:	d5f3      	bpl.n	80053fa <ADC_Disable+0x5a>
 8005412:	e7d6      	b.n	80053c2 <ADC_Disable+0x22>

08005414 <HAL_ADC_DeInit>:
{
 8005414:	b570      	push	{r4, r5, r6, lr}
  if (hadc == NULL)
 8005416:	2800      	cmp	r0, #0
 8005418:	d04e      	beq.n	80054b8 <HAL_ADC_DeInit+0xa4>
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 800541a:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 800541c:	f043 0302 	orr.w	r3, r3, #2
 8005420:	6583      	str	r3, [r0, #88]	@ 0x58
  tmp_hal_status = ADC_ConversionStop(hadc);
 8005422:	4604      	mov	r4, r0
 8005424:	f7ff fefc 	bl	8005220 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 8005428:	4605      	mov	r5, r0
 800542a:	2800      	cmp	r0, #0
 800542c:	d035      	beq.n	800549a <HAL_ADC_DeInit+0x86>
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 |
 800542e:	6823      	ldr	r3, [r4, #0]
 8005430:	685a      	ldr	r2, [r3, #4]
 8005432:	f422 7267 	bic.w	r2, r2, #924	@ 0x39c
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 |
 8005436:	f240 319f 	movw	r1, #927	@ 0x39f
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 |
 800543a:	f022 0203 	bic.w	r2, r2, #3
 800543e:	605a      	str	r2, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 |
 8005440:	6019      	str	r1, [r3, #0]
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWD1CH   | ADC_CFGR1_AWD1EN  | ADC_CFGR1_AWD1SGL | ADC_CFGR1_DISCEN |
 8005442:	68d9      	ldr	r1, [r3, #12]
 8005444:	4a1e      	ldr	r2, [pc, #120]	@ (80054c0 <HAL_ADC_DeInit+0xac>)
 8005446:	400a      	ands	r2, r1
 8005448:	60da      	str	r2, [r3, #12]
  hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;
 800544a:	691a      	ldr	r2, [r3, #16]
 800544c:	f022 4240 	bic.w	r2, r2, #3221225472	@ 0xc0000000
 8005450:	611a      	str	r2, [r3, #16]
  hadc->Instance->SMPR &= ~ADC_SMPR_SMP1;
 8005452:	695a      	ldr	r2, [r3, #20]
 8005454:	f022 0207 	bic.w	r2, r2, #7
 8005458:	615a      	str	r2, [r3, #20]
  hadc->Instance->AWD1TR &= ~(ADC_AWD1TR_HT1 | ADC_AWD1TR_LT1);
 800545a:	6a1a      	ldr	r2, [r3, #32]
 800545c:	f002 22f0 	and.w	r2, r2, #4026593280	@ 0xf000f000
 8005460:	621a      	str	r2, [r3, #32]
  hadc->Instance->AWD2TR &= ~(ADC_AWD2TR_HT2 | ADC_AWD2TR_LT2);
 8005462:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8005464:	f002 22f0 	and.w	r2, r2, #4026593280	@ 0xf000f000
 8005468:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc->Instance->AWD3TR &= ~(ADC_AWD3TR_HT3 | ADC_AWD3TR_LT3);
 800546a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800546c:	f002 22f0 	and.w	r2, r2, #4026593280	@ 0xf000f000
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 8005470:	2600      	movs	r6, #0
  hadc->Instance->AWD3TR &= ~(ADC_AWD3TR_HT3 | ADC_AWD3TR_LT3);
 8005472:	62da      	str	r2, [r3, #44]	@ 0x2c
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 8005474:	4a13      	ldr	r2, [pc, #76]	@ (80054c4 <HAL_ADC_DeInit+0xb0>)
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 8005476:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8005478:	629e      	str	r6, [r3, #40]	@ 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 800547a:	f8d2 3708 	ldr.w	r3, [r2, #1800]	@ 0x708
 800547e:	f023 73fe 	bic.w	r3, r3, #33292288	@ 0x1fc0000
  HAL_ADC_MspDeInit(hadc);
 8005482:	4620      	mov	r0, r4
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 8005484:	f8c2 3708 	str.w	r3, [r2, #1800]	@ 0x708
  HAL_ADC_MspDeInit(hadc);
 8005488:	f7fb fc30 	bl	8000cec <HAL_ADC_MspDeInit>
  __HAL_UNLOCK(hadc);
 800548c:	f884 6054 	strb.w	r6, [r4, #84]	@ 0x54
  ADC_CLEAR_ERRORCODE(hadc);
 8005490:	65e6      	str	r6, [r4, #92]	@ 0x5c
  hadc->ADCGroupRegularSequencerRanks = 0x00000000UL;
 8005492:	6626      	str	r6, [r4, #96]	@ 0x60
  hadc->State = HAL_ADC_STATE_RESET;
 8005494:	65a6      	str	r6, [r4, #88]	@ 0x58
}
 8005496:	4628      	mov	r0, r5
 8005498:	bd70      	pop	{r4, r5, r6, pc}
    tmp_hal_status = ADC_Disable(hadc);
 800549a:	4620      	mov	r0, r4
 800549c:	f7ff ff80 	bl	80053a0 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 80054a0:	4605      	mov	r5, r0
 80054a2:	b908      	cbnz	r0, 80054a8 <HAL_ADC_DeInit+0x94>
      hadc->State = HAL_ADC_STATE_READY;
 80054a4:	2301      	movs	r3, #1
 80054a6:	65a3      	str	r3, [r4, #88]	@ 0x58
    LL_ADC_DisableInternalRegulator(hadc->Instance);
 80054a8:	6823      	ldr	r3, [r4, #0]
  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
 80054aa:	689a      	ldr	r2, [r3, #8]
 80054ac:	f022 4210 	bic.w	r2, r2, #2415919104	@ 0x90000000
 80054b0:	f022 0217 	bic.w	r2, r2, #23
 80054b4:	609a      	str	r2, [r3, #8]
}
 80054b6:	e7bb      	b.n	8005430 <HAL_ADC_DeInit+0x1c>
    return HAL_ERROR;
 80054b8:	2501      	movs	r5, #1
}
 80054ba:	4628      	mov	r0, r5
 80054bc:	bd70      	pop	{r4, r5, r6, pc}
 80054be:	bf00      	nop
 80054c0:	833e0200 	.word	0x833e0200
 80054c4:	40012000 	.word	0x40012000

080054c8 <HAL_ADC_Stop>:
  __HAL_LOCK(hadc);
 80054c8:	f890 3054 	ldrb.w	r3, [r0, #84]	@ 0x54
 80054cc:	2b01      	cmp	r3, #1
 80054ce:	d01c      	beq.n	800550a <HAL_ADC_Stop+0x42>
 80054d0:	2301      	movs	r3, #1
{
 80054d2:	b510      	push	{r4, lr}
  __HAL_LOCK(hadc);
 80054d4:	f880 3054 	strb.w	r3, [r0, #84]	@ 0x54
  tmp_hal_status = ADC_ConversionStop(hadc);
 80054d8:	4604      	mov	r4, r0
 80054da:	f7ff fea1 	bl	8005220 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 80054de:	b118      	cbz	r0, 80054e8 <HAL_ADC_Stop+0x20>
  __HAL_UNLOCK(hadc);
 80054e0:	2300      	movs	r3, #0
 80054e2:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
}
 80054e6:	bd10      	pop	{r4, pc}
    tmp_hal_status = ADC_Disable(hadc);
 80054e8:	4620      	mov	r0, r4
 80054ea:	f7ff ff59 	bl	80053a0 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 80054ee:	2800      	cmp	r0, #0
 80054f0:	d1f6      	bne.n	80054e0 <HAL_ADC_Stop+0x18>
      ADC_STATE_CLR_SET(hadc->State,
 80054f2:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80054f4:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80054f8:	f023 0301 	bic.w	r3, r3, #1
 80054fc:	f043 0301 	orr.w	r3, r3, #1
 8005500:	65a3      	str	r3, [r4, #88]	@ 0x58
  __HAL_UNLOCK(hadc);
 8005502:	2300      	movs	r3, #0
 8005504:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
}
 8005508:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 800550a:	2002      	movs	r0, #2
}
 800550c:	4770      	bx	lr
 800550e:	bf00      	nop

08005510 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc       ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)
{
 8005510:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  __HAL_LOCK(hadc);
 8005512:	f890 3054 	ldrb.w	r3, [r0, #84]	@ 0x54
{
 8005516:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
 8005518:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 800551a:	2b01      	cmp	r3, #1
  __IO uint32_t wait_loop_index = 0UL;
 800551c:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 800551e:	f000 8083 	beq.w	8005628 <HAL_ADCEx_Calibration_Start+0x118>
 8005522:	2301      	movs	r3, #1
 8005524:	4604      	mov	r4, r0
 8005526:	f880 3054 	strb.w	r3, [r0, #84]	@ 0x54

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 800552a:	f7ff ff39 	bl	80053a0 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800552e:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8005530:	6899      	ldr	r1, [r3, #8]
 8005532:	f011 0101 	ands.w	r1, r1, #1
  tmp_hal_status = ADC_Disable(hadc);
 8005536:	4606      	mov	r6, r0
 8005538:	d12f      	bne.n	800559a <HAL_ADCEx_Calibration_Start+0x8a>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800553a:	6da2      	ldr	r2, [r4, #88]	@ 0x58
  MODIFY_REG(ADCx->CR,
 800553c:	4f3c      	ldr	r7, [pc, #240]	@ (8005630 <HAL_ADCEx_Calibration_Start+0x120>)
 800553e:	f422 7281 	bic.w	r2, r2, #258	@ 0x102
 8005542:	f042 0202 	orr.w	r2, r2, #2
 8005546:	65a2      	str	r2, [r4, #88]	@ 0x58
    /* Note: Specificity of this STM32 series: Calibration factor is          */
    /*       available in data register and also transferred by DMA.          */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_cfgr1 = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG | ADC_CFGR1_AUTOFF);
 8005548:	68dd      	ldr	r5, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG | ADC_CFGR1_AUTOFF);
 800554a:	68da      	ldr	r2, [r3, #12]
 800554c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8005550:	f022 0203 	bic.w	r2, r2, #3
 8005554:	60da      	str	r2, [r3, #12]
 8005556:	2008      	movs	r0, #8
 8005558:	e006      	b.n	8005568 <HAL_ADCEx_Calibration_Start+0x58>
  return (uint32_t)(READ_BIT(ADCx->CALFACT, ADC_CALFACT_CALFACT));
 800555a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4

    /* ADC calibration procedure */
    /* Note: Perform an averaging of 8 calibrations for optimized accuracy */
    for (calibration_index = 0UL; calibration_index < 8UL; calibration_index++)
 800555e:	3801      	subs	r0, #1
 8005560:	f002 027f 	and.w	r2, r2, #127	@ 0x7f

          return HAL_ERROR;
        }
      }

      calibration_factor_accumulated += LL_ADC_GetCalibrationFactor(hadc->Instance);
 8005564:	4411      	add	r1, r2
    for (calibration_index = 0UL; calibration_index < 8UL; calibration_index++)
 8005566:	d022      	beq.n	80055ae <HAL_ADCEx_Calibration_Start+0x9e>
  MODIFY_REG(ADCx->CR,
 8005568:	689a      	ldr	r2, [r3, #8]
 800556a:	403a      	ands	r2, r7
 800556c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 8005570:	609a      	str	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8005572:	689a      	ldr	r2, [r3, #8]
 8005574:	2a00      	cmp	r2, #0
 8005576:	daf0      	bge.n	800555a <HAL_ADCEx_Calibration_Start+0x4a>
        wait_loop_index++;
 8005578:	9a01      	ldr	r2, [sp, #4]
 800557a:	3201      	adds	r2, #1
 800557c:	9201      	str	r2, [sp, #4]
        if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 800557e:	9a01      	ldr	r2, [sp, #4]
 8005580:	f5b2 3f2e 	cmp.w	r2, #178176	@ 0x2b800
 8005584:	d3f5      	bcc.n	8005572 <HAL_ADCEx_Calibration_Start+0x62>
          ADC_STATE_CLR_SET(hadc->State,
 8005586:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8005588:	f023 0312 	bic.w	r3, r3, #18
          __HAL_UNLOCK(hadc);
 800558c:	2200      	movs	r2, #0
          ADC_STATE_CLR_SET(hadc->State,
 800558e:	f043 0310 	orr.w	r3, r3, #16
 8005592:	65a3      	str	r3, [r4, #88]	@ 0x58
          __HAL_UNLOCK(hadc);
 8005594:	f884 2054 	strb.w	r2, [r4, #84]	@ 0x54
          return HAL_ERROR;
 8005598:	e034      	b.n	8005604 <HAL_ADCEx_Calibration_Start+0xf4>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800559a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 800559c:	f043 0310 	orr.w	r3, r3, #16
 80055a0:	65a3      	str	r3, [r4, #88]	@ 0x58

    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  __HAL_UNLOCK(hadc);
 80055a2:	2300      	movs	r3, #0
 80055a4:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54

  return tmp_hal_status;
}
 80055a8:	4630      	mov	r0, r6
 80055aa:	b003      	add	sp, #12
 80055ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
  MODIFY_REG(ADCx->CR,
 80055ae:	689a      	ldr	r2, [r3, #8]
 80055b0:	481f      	ldr	r0, [pc, #124]	@ (8005630 <HAL_ADCEx_Calibration_Start+0x120>)
 80055b2:	4002      	ands	r2, r0
 80055b4:	f042 0201 	orr.w	r2, r2, #1
 80055b8:	609a      	str	r2, [r3, #8]
  MODIFY_REG(ADCx->CALFACT,
 80055ba:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
 80055be:	f022 027f 	bic.w	r2, r2, #127	@ 0x7f
 80055c2:	ea42 02d1 	orr.w	r2, r2, r1, lsr #3
 80055c6:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
  MODIFY_REG(ADCx->CR,
 80055ca:	689a      	ldr	r2, [r3, #8]
 80055cc:	4002      	ands	r2, r0
 80055ce:	f042 0202 	orr.w	r2, r2, #2
 80055d2:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
 80055d4:	f7fc faf8 	bl	8001bc8 <HAL_GetTick>
    while (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 80055d8:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80055da:	689a      	ldr	r2, [r3, #8]
    tickstart = HAL_GetTick();
 80055dc:	4607      	mov	r7, r0
 80055de:	07d0      	lsls	r0, r2, #31
 80055e0:	d515      	bpl.n	800560e <HAL_ADCEx_Calibration_Start+0xfe>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 80055e2:	f7fc faf1 	bl	8001bc8 <HAL_GetTick>
 80055e6:	1bc0      	subs	r0, r0, r7
 80055e8:	2802      	cmp	r0, #2
        if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 80055ea:	6823      	ldr	r3, [r4, #0]
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 80055ec:	d90c      	bls.n	8005608 <HAL_ADCEx_Calibration_Start+0xf8>
 80055ee:	689a      	ldr	r2, [r3, #8]
 80055f0:	07d1      	lsls	r1, r2, #31
 80055f2:	d509      	bpl.n	8005608 <HAL_ADCEx_Calibration_Start+0xf8>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80055f4:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80055f6:	f043 0310 	orr.w	r3, r3, #16
 80055fa:	65a3      	str	r3, [r4, #88]	@ 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80055fc:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80055fe:	f043 0301 	orr.w	r3, r3, #1
 8005602:	65e3      	str	r3, [r4, #92]	@ 0x5c
          return HAL_ERROR;
 8005604:	2601      	movs	r6, #1
 8005606:	e7cf      	b.n	80055a8 <HAL_ADCEx_Calibration_Start+0x98>
 8005608:	689a      	ldr	r2, [r3, #8]
 800560a:	07d2      	lsls	r2, r2, #31
 800560c:	d4e9      	bmi.n	80055e2 <HAL_ADCEx_Calibration_Start+0xd2>
    SET_BIT(hadc->Instance->CFGR1, backup_setting_cfgr1);
 800560e:	68da      	ldr	r2, [r3, #12]
    backup_setting_cfgr1 = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG | ADC_CFGR1_AUTOFF);
 8005610:	f248 0103 	movw	r1, #32771	@ 0x8003
 8005614:	400d      	ands	r5, r1
    SET_BIT(hadc->Instance->CFGR1, backup_setting_cfgr1);
 8005616:	4315      	orrs	r5, r2
 8005618:	60dd      	str	r5, [r3, #12]
    ADC_STATE_CLR_SET(hadc->State,
 800561a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 800561c:	f023 0303 	bic.w	r3, r3, #3
 8005620:	f043 0301 	orr.w	r3, r3, #1
 8005624:	65a3      	str	r3, [r4, #88]	@ 0x58
 8005626:	e7bc      	b.n	80055a2 <HAL_ADCEx_Calibration_Start+0x92>
  __HAL_LOCK(hadc);
 8005628:	2602      	movs	r6, #2
}
 800562a:	4630      	mov	r0, r6
 800562c:	b003      	add	sp, #12
 800562e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005630:	7fffffe8 	.word	0x7fffffe8

08005634 <HAL_ADCEx_LevelOutOfWindow2Callback>:
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow2Callback must be implemented in the user file.
  */
}
 8005634:	4770      	bx	lr
 8005636:	bf00      	nop

08005638 <HAL_ADCEx_LevelOutOfWindow3Callback>:
/**
  * @brief  Analog watchdog 3 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow3Callback(ADC_HandleTypeDef *hadc)
 8005638:	4770      	bx	lr
 800563a:	bf00      	nop

0800563c <HAL_ADCEx_EndOfSamplingCallback>:
/**
  * @brief  End Of Sampling callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_EndOfSamplingCallback(ADC_HandleTypeDef *hadc)
 800563c:	4770      	bx	lr
 800563e:	bf00      	nop

08005640 <HAL_ADCEx_ChannelConfigReadyCallback>:
/**
  * @brief  ADC channel configuration ready callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_ChannelConfigReadyCallback(ADC_HandleTypeDef *hadc)
 8005640:	4770      	bx	lr
 8005642:	bf00      	nop

08005644 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8005644:	4907      	ldr	r1, [pc, #28]	@ (8005664 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8005646:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8005648:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800564a:	f64f 00ff 	movw	r0, #63743	@ 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800564e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8005652:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8005654:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8005656:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800565a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 800565e:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8005660:	4770      	bx	lr
 8005662:	bf00      	nop
 8005664:	e000ed00 	.word	0xe000ed00

08005668 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8005668:	4b1b      	ldr	r3, [pc, #108]	@ (80056d8 <HAL_NVIC_SetPriority+0x70>)
 800566a:	68db      	ldr	r3, [r3, #12]
 800566c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8005670:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8005672:	f1c3 0e07 	rsb	lr, r3, #7
 8005676:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800567a:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800567e:	bf28      	it	cs
 8005680:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8005684:	f1bc 0f06 	cmp.w	ip, #6
 8005688:	d91c      	bls.n	80056c4 <HAL_NVIC_SetPriority+0x5c>
 800568a:	f1a3 0c03 	sub.w	ip, r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800568e:	f04f 33ff 	mov.w	r3, #4294967295
 8005692:	fa03 f30c 	lsl.w	r3, r3, ip
 8005696:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800569a:	f04f 33ff 	mov.w	r3, #4294967295
 800569e:	fa03 f30e 	lsl.w	r3, r3, lr
 80056a2:	ea21 0303 	bic.w	r3, r1, r3
 80056a6:	fa03 f30c 	lsl.w	r3, r3, ip
 80056aa:	4313      	orrs	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80056ac:	011b      	lsls	r3, r3, #4
  if ((int32_t)(IRQn) >= 0)
 80056ae:	2800      	cmp	r0, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80056b0:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 80056b2:	db0a      	blt.n	80056ca <HAL_NVIC_SetPriority+0x62>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80056b4:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 80056b8:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 80056bc:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80056c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80056c4:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80056c6:	4694      	mov	ip, r2
 80056c8:	e7e7      	b.n	800569a <HAL_NVIC_SetPriority+0x32>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80056ca:	4a04      	ldr	r2, [pc, #16]	@ (80056dc <HAL_NVIC_SetPriority+0x74>)
 80056cc:	f000 000f 	and.w	r0, r0, #15
 80056d0:	4402      	add	r2, r0
 80056d2:	7613      	strb	r3, [r2, #24]
 80056d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80056d8:	e000ed00 	.word	0xe000ed00
 80056dc:	e000ecfc 	.word	0xe000ecfc

080056e0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80056e0:	2800      	cmp	r0, #0
 80056e2:	db07      	blt.n	80056f4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80056e4:	4a04      	ldr	r2, [pc, #16]	@ (80056f8 <HAL_NVIC_EnableIRQ+0x18>)
 80056e6:	0941      	lsrs	r1, r0, #5
 80056e8:	2301      	movs	r3, #1
 80056ea:	f000 001f 	and.w	r0, r0, #31
 80056ee:	4083      	lsls	r3, r0
 80056f0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80056f4:	4770      	bx	lr
 80056f6:	bf00      	nop
 80056f8:	e000e100 	.word	0xe000e100

080056fc <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80056fc:	2800      	cmp	r0, #0
 80056fe:	db0c      	blt.n	800571a <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8005700:	0943      	lsrs	r3, r0, #5
 8005702:	4906      	ldr	r1, [pc, #24]	@ (800571c <HAL_NVIC_DisableIRQ+0x20>)
 8005704:	f000 001f 	and.w	r0, r0, #31
 8005708:	3320      	adds	r3, #32
 800570a:	2201      	movs	r2, #1
 800570c:	4082      	lsls	r2, r0
 800570e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8005712:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8005716:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800571a:	4770      	bx	lr
 800571c:	e000e100 	.word	0xe000e100

08005720 <HAL_DMA_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  /* Check the DMA handle allocation */
  if (hdma == NULL)
 8005720:	2800      	cmp	r0, #0
 8005722:	d07a      	beq.n	800581a <HAL_DMA_Init+0xfa>
{
 8005724:	b470      	push	{r4, r5, r6}
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8005726:	4a3e      	ldr	r2, [pc, #248]	@ (8005820 <HAL_DMA_Init+0x100>)
 8005728:	6804      	ldr	r4, [r0, #0]
 800572a:	4294      	cmp	r4, r2
 800572c:	4603      	mov	r3, r0
 800572e:	d95c      	bls.n	80057ea <HAL_DMA_Init+0xca>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8005730:	483c      	ldr	r0, [pc, #240]	@ (8005824 <HAL_DMA_Init+0x104>)
 8005732:	4a3d      	ldr	r2, [pc, #244]	@ (8005828 <HAL_DMA_Init+0x108>)
    hdma->DmaBaseAddress = DMA2;
 8005734:	493d      	ldr	r1, [pc, #244]	@ (800582c <HAL_DMA_Init+0x10c>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8005736:	4420      	add	r0, r4
 8005738:	fba2 2000 	umull	r2, r0, r2, r0
 800573c:	0900      	lsrs	r0, r0, #4
 800573e:	0080      	lsls	r0, r0, #2
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8005740:	2202      	movs	r2, #2
 8005742:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
  CLEAR_BIT(hdma->Instance->CCR, (DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8005746:	6822      	ldr	r2, [r4, #0]
 8005748:	6419      	str	r1, [r3, #64]	@ 0x40
 800574a:	f422 42ff 	bic.w	r2, r2, #32640	@ 0x7f80
 800574e:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 8005752:	6458      	str	r0, [r3, #68]	@ 0x44
 8005754:	6022      	str	r2, [r4, #0]
                                  DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                                  DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Set the DMA Channel configuration */
  SET_BIT(hdma->Instance->CCR, (hdma->Init.Direction           |                               \
 8005756:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
 800575a:	691e      	ldr	r6, [r3, #16]
 800575c:	6825      	ldr	r5, [r4, #0]
 800575e:	430a      	orrs	r2, r1
 8005760:	4332      	orrs	r2, r6
 8005762:	695e      	ldr	r6, [r3, #20]
 8005764:	4332      	orrs	r2, r6
 8005766:	699e      	ldr	r6, [r3, #24]
 8005768:	4332      	orrs	r2, r6
 800576a:	69de      	ldr	r6, [r3, #28]
 800576c:	4332      	orrs	r2, r6
 800576e:	6a1e      	ldr	r6, [r3, #32]
 8005770:	4332      	orrs	r2, r6
 8005772:	432a      	orrs	r2, r5
 8005774:	6022      	str	r2, [r4, #0]
    /* DMA1 */
    /* Associate a DMA Channel to a DMAMUX channel */
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));

    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8005776:	4d2c      	ldr	r5, [pc, #176]	@ (8005828 <HAL_DMA_Init+0x108>)
 8005778:	b2e2      	uxtb	r2, r4
 800577a:	3a08      	subs	r2, #8
 800577c:	fba5 5202 	umull	r5, r2, r5, r2
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8005780:	4d27      	ldr	r5, [pc, #156]	@ (8005820 <HAL_DMA_Init+0x100>)
 8005782:	42ac      	cmp	r4, r5
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8005784:	ea4f 1212 	mov.w	r2, r2, lsr #4
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8005788:	d843      	bhi.n	8005812 <HAL_DMA_Init+0xf2>
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 800578a:	f100 4480 	add.w	r4, r0, #1073741824	@ 0x40000000
 800578e:	f504 3402 	add.w	r4, r4, #133120	@ 0x20800
    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
  }

  /* Initialize the field DMAmuxChannelStatus to DMAMUX1_ChannelStatus base */
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8005792:	4827      	ldr	r0, [pc, #156]	@ (8005830 <HAL_DMA_Init+0x110>)

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8005794:	f002 021f 	and.w	r2, r2, #31
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8005798:	e9c3 4012 	strd	r4, r0, [r3, #72]	@ 0x48
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 800579c:	2001      	movs	r0, #1
 800579e:	fa00 f202 	lsl.w	r2, r0, r2
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80057a2:	f5b1 4f80 	cmp.w	r1, #16384	@ 0x4000
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80057a6:	651a      	str	r2, [r3, #80]	@ 0x50
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80057a8:	d028      	beq.n	80057fc <HAL_DMA_Init+0xdc>
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80057aa:	685d      	ldr	r5, [r3, #4]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80057ac:	4e21      	ldr	r6, [pc, #132]	@ (8005834 <HAL_DMA_Init+0x114>)
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80057ae:	f005 017f 	and.w	r1, r5, #127	@ 0x7f
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 80057b2:	3d01      	subs	r5, #1
 80057b4:	2d03      	cmp	r5, #3
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80057b6:	6021      	str	r1, [r4, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80057b8:	f8c6 2084 	str.w	r2, [r6, #132]	@ 0x84
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 80057bc:	d824      	bhi.n	8005808 <HAL_DMA_Init+0xe8>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80057be:	4a1e      	ldr	r2, [pc, #120]	@ (8005838 <HAL_DMA_Init+0x118>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80057c0:	4c1e      	ldr	r4, [pc, #120]	@ (800583c <HAL_DMA_Init+0x11c>)
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80057c2:	440a      	add	r2, r1
 80057c4:	0092      	lsls	r2, r2, #2

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 80057c6:	3901      	subs	r1, #1
 80057c8:	4088      	lsls	r0, r1
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80057ca:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80057cc:	e9c3 2415 	strd	r2, r4, [r3, #84]	@ 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 80057d0:	65d8      	str	r0, [r3, #92]	@ 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80057d2:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80057d4:	4a1a      	ldr	r2, [pc, #104]	@ (8005840 <HAL_DMA_Init+0x120>)
 80057d6:	6450      	str	r0, [r2, #68]	@ 0x44
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80057d8:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 80057da:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80057dc:	63d8      	str	r0, [r3, #60]	@ 0x3c
  __HAL_UNLOCK(hdma);
 80057de:	f883 0024 	strb.w	r0, [r3, #36]	@ 0x24
  hdma->State = HAL_DMA_STATE_READY;
 80057e2:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
}
 80057e6:	bc70      	pop	{r4, r5, r6}
 80057e8:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80057ea:	4816      	ldr	r0, [pc, #88]	@ (8005844 <HAL_DMA_Init+0x124>)
 80057ec:	4a0e      	ldr	r2, [pc, #56]	@ (8005828 <HAL_DMA_Init+0x108>)
    hdma->DmaBaseAddress = DMA1;
 80057ee:	4916      	ldr	r1, [pc, #88]	@ (8005848 <HAL_DMA_Init+0x128>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80057f0:	4420      	add	r0, r4
 80057f2:	fba2 2000 	umull	r2, r0, r2, r0
 80057f6:	0900      	lsrs	r0, r0, #4
 80057f8:	0080      	lsls	r0, r0, #2
    hdma->DmaBaseAddress = DMA1;
 80057fa:	e7a1      	b.n	8005740 <HAL_DMA_Init+0x20>
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80057fc:	480d      	ldr	r0, [pc, #52]	@ (8005834 <HAL_DMA_Init+0x114>)
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 80057fe:	2100      	movs	r1, #0
 8005800:	6059      	str	r1, [r3, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8005802:	6021      	str	r1, [r4, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005804:	f8c0 2084 	str.w	r2, [r0, #132]	@ 0x84
    hdma->DMAmuxRequestGen = NULL;
 8005808:	2200      	movs	r2, #0
 800580a:	e9c3 2215 	strd	r2, r2, [r3, #84]	@ 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 800580e:	65da      	str	r2, [r3, #92]	@ 0x5c
 8005810:	e7e2      	b.n	80057d8 <HAL_DMA_Init+0xb8>
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 8005812:	4c0e      	ldr	r4, [pc, #56]	@ (800584c <HAL_DMA_Init+0x12c>)
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 8005814:	3207      	adds	r2, #7
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 8005816:	4404      	add	r4, r0
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 8005818:	e7bb      	b.n	8005792 <HAL_DMA_Init+0x72>
    return HAL_ERROR;
 800581a:	2001      	movs	r0, #1
}
 800581c:	4770      	bx	lr
 800581e:	bf00      	nop
 8005820:	40020407 	.word	0x40020407
 8005824:	bffdfbf8 	.word	0xbffdfbf8
 8005828:	cccccccd 	.word	0xcccccccd
 800582c:	40020400 	.word	0x40020400
 8005830:	40020880 	.word	0x40020880
 8005834:	40020800 	.word	0x40020800
 8005838:	1000823f 	.word	0x1000823f
 800583c:	40020940 	.word	0x40020940
 8005840:	40020900 	.word	0x40020900
 8005844:	bffdfff8 	.word	0xbffdfff8
 8005848:	40020000 	.word	0x40020000
 800584c:	4002081c 	.word	0x4002081c

08005850 <HAL_DMA_DeInit>:
  if (NULL == hdma)
 8005850:	2800      	cmp	r0, #0
 8005852:	d061      	beq.n	8005918 <HAL_DMA_DeInit+0xc8>
{
 8005854:	b470      	push	{r4, r5, r6}
  __HAL_DMA_DISABLE(hdma);
 8005856:	6804      	ldr	r4, [r0, #0]
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8005858:	4d30      	ldr	r5, [pc, #192]	@ (800591c <HAL_DMA_DeInit+0xcc>)
  __HAL_DMA_DISABLE(hdma);
 800585a:	6822      	ldr	r2, [r4, #0]
 800585c:	f022 0201 	bic.w	r2, r2, #1
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8005860:	b2e1      	uxtb	r1, r4
  __HAL_DMA_DISABLE(hdma);
 8005862:	6022      	str	r2, [r4, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8005864:	4a2e      	ldr	r2, [pc, #184]	@ (8005920 <HAL_DMA_DeInit+0xd0>)
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8005866:	3908      	subs	r1, #8
 8005868:	4603      	mov	r3, r0
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800586a:	4294      	cmp	r4, r2
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 800586c:	fba5 0101 	umull	r0, r1, r5, r1
 8005870:	ea4f 1111 	mov.w	r1, r1, lsr #4
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8005874:	d93b      	bls.n	80058ee <HAL_DMA_DeInit+0x9e>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8005876:	482b      	ldr	r0, [pc, #172]	@ (8005924 <HAL_DMA_DeInit+0xd4>)
    hdma->DmaBaseAddress = DMA2;
 8005878:	4e2b      	ldr	r6, [pc, #172]	@ (8005928 <HAL_DMA_DeInit+0xd8>)
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 800587a:	4a2c      	ldr	r2, [pc, #176]	@ (800592c <HAL_DMA_DeInit+0xdc>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 800587c:	4420      	add	r0, r4
 800587e:	fba5 5000 	umull	r5, r0, r5, r0
 8005882:	0900      	lsrs	r0, r0, #4
 8005884:	0080      	lsls	r0, r0, #2
    hdma->DmaBaseAddress = DMA2;
 8005886:	e9c3 6010 	strd	r6, r0, [r3, #64]	@ 0x40
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800588a:	2501      	movs	r5, #1
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 800588c:	4402      	add	r2, r0
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800588e:	f000 001c 	and.w	r0, r0, #28
 8005892:	fa05 f000 	lsl.w	r0, r5, r0
  hdma->Instance->CCR = 0U;
 8005896:	2500      	movs	r5, #0
 8005898:	6025      	str	r5, [r4, #0]
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 800589a:	3107      	adds	r1, #7
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800589c:	6070      	str	r0, [r6, #4]
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800589e:	4c24      	ldr	r4, [pc, #144]	@ (8005930 <HAL_DMA_DeInit+0xe0>)
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80058a0:	4d24      	ldr	r5, [pc, #144]	@ (8005934 <HAL_DMA_DeInit+0xe4>)
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80058a2:	f001 011f 	and.w	r1, r1, #31
 80058a6:	2001      	movs	r0, #1
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80058a8:	e9c3 2412 	strd	r2, r4, [r3, #72]	@ 0x48
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80058ac:	fa00 f101 	lsl.w	r1, r0, r1
  hdma->DMAmuxChannel->CCR = 0U;
 80058b0:	2400      	movs	r4, #0
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80058b2:	6519      	str	r1, [r3, #80]	@ 0x50
  hdma->DMAmuxChannel->CCR = 0U;
 80058b4:	6014      	str	r4, [r2, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80058b6:	f8c5 1084 	str.w	r1, [r5, #132]	@ 0x84
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 80058ba:	6859      	ldr	r1, [r3, #4]
 80058bc:	1e4a      	subs	r2, r1, #1
 80058be:	2a03      	cmp	r2, #3
 80058c0:	d806      	bhi.n	80058d0 <HAL_DMA_DeInit+0x80>
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 80058c2:	4090      	lsls	r0, r2
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80058c4:	4a1c      	ldr	r2, [pc, #112]	@ (8005938 <HAL_DMA_DeInit+0xe8>)
 80058c6:	440a      	add	r2, r1
 80058c8:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80058ca:	6014      	str	r4, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80058cc:	f8c5 0144 	str.w	r0, [r5, #324]	@ 0x144
  hdma->DMAmuxRequestGen = NULL;
 80058d0:	2000      	movs	r0, #0
 80058d2:	e9c3 0015 	strd	r0, r0, [r3, #84]	@ 0x54
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80058d6:	63d8      	str	r0, [r3, #60]	@ 0x3c
  __HAL_UNLOCK(hdma);
 80058d8:	f883 0024 	strb.w	r0, [r3, #36]	@ 0x24
  hdma->State = HAL_DMA_STATE_RESET;
 80058dc:	f883 0025 	strb.w	r0, [r3, #37]	@ 0x25
}
 80058e0:	bc70      	pop	{r4, r5, r6}
  hdma->XferHalfCpltCallback = NULL;
 80058e2:	e9c3 000b 	strd	r0, r0, [r3, #44]	@ 0x2c
  hdma->XferAbortCallback = NULL;
 80058e6:	e9c3 000d 	strd	r0, r0, [r3, #52]	@ 0x34
  hdma->DMAmuxRequestGenStatusMask = 0U;
 80058ea:	65d8      	str	r0, [r3, #92]	@ 0x5c
}
 80058ec:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80058ee:	4a13      	ldr	r2, [pc, #76]	@ (800593c <HAL_DMA_DeInit+0xec>)
 80058f0:	4422      	add	r2, r4
 80058f2:	fba5 5202 	umull	r5, r2, r5, r2
 80058f6:	0912      	lsrs	r2, r2, #4
 80058f8:	0092      	lsls	r2, r2, #2
    hdma->DmaBaseAddress = DMA1;
 80058fa:	4d11      	ldr	r5, [pc, #68]	@ (8005940 <HAL_DMA_DeInit+0xf0>)
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80058fc:	f002 061c 	and.w	r6, r2, #28
 8005900:	2001      	movs	r0, #1
    hdma->DmaBaseAddress = DMA1;
 8005902:	e9c3 5210 	strd	r5, r2, [r3, #64]	@ 0x40
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005906:	40b0      	lsls	r0, r6
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 8005908:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
  hdma->Instance->CCR = 0U;
 800590c:	2600      	movs	r6, #0
 800590e:	6026      	str	r6, [r4, #0]
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 8005910:	f502 3202 	add.w	r2, r2, #133120	@ 0x20800
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005914:	6068      	str	r0, [r5, #4]
    channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8005916:	e7c2      	b.n	800589e <HAL_DMA_DeInit+0x4e>
    return HAL_ERROR;
 8005918:	2001      	movs	r0, #1
}
 800591a:	4770      	bx	lr
 800591c:	cccccccd 	.word	0xcccccccd
 8005920:	40020407 	.word	0x40020407
 8005924:	bffdfbf8 	.word	0xbffdfbf8
 8005928:	40020400 	.word	0x40020400
 800592c:	4002081c 	.word	0x4002081c
 8005930:	40020880 	.word	0x40020880
 8005934:	40020800 	.word	0x40020800
 8005938:	1000823f 	.word	0x1000823f
 800593c:	bffdfff8 	.word	0xbffdfff8
 8005940:	40020000 	.word	0x40020000

08005944 <HAL_DMA_Start_IT>:
{
 8005944:	4684      	mov	ip, r0
  __HAL_LOCK(hdma);
 8005946:	f890 0024 	ldrb.w	r0, [r0, #36]	@ 0x24
 800594a:	2801      	cmp	r0, #1
 800594c:	d055      	beq.n	80059fa <HAL_DMA_Start_IT+0xb6>
{
 800594e:	b530      	push	{r4, r5, lr}
  if (hdma->State == HAL_DMA_STATE_READY)
 8005950:	f89c 4025 	ldrb.w	r4, [ip, #37]	@ 0x25
  __HAL_LOCK(hdma);
 8005954:	2001      	movs	r0, #1
  if (hdma->State == HAL_DMA_STATE_READY)
 8005956:	4284      	cmp	r4, r0
  __HAL_LOCK(hdma);
 8005958:	f88c 0024 	strb.w	r0, [ip, #36]	@ 0x24
  if (hdma->State == HAL_DMA_STATE_READY)
 800595c:	d006      	beq.n	800596c <HAL_DMA_Start_IT+0x28>
    __HAL_UNLOCK(hdma);
 800595e:	2300      	movs	r3, #0
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8005960:	2280      	movs	r2, #128	@ 0x80
    __HAL_UNLOCK(hdma);
 8005962:	f88c 3024 	strb.w	r3, [ip, #36]	@ 0x24
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8005966:	f8cc 203c 	str.w	r2, [ip, #60]	@ 0x3c
}
 800596a:	bd30      	pop	{r4, r5, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 800596c:	2002      	movs	r0, #2
 800596e:	f88c 0025 	strb.w	r0, [ip, #37]	@ 0x25
    __HAL_DMA_DISABLE(hdma);
 8005972:	f8dc 4000 	ldr.w	r4, [ip]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005976:	f8dc 504c 	ldr.w	r5, [ip, #76]	@ 0x4c
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800597a:	2000      	movs	r0, #0
 800597c:	f8cc 003c 	str.w	r0, [ip, #60]	@ 0x3c
    __HAL_DMA_DISABLE(hdma);
 8005980:	6820      	ldr	r0, [r4, #0]
 8005982:	f020 0001 	bic.w	r0, r0, #1
 8005986:	6020      	str	r0, [r4, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005988:	e9dc e014 	ldrd	lr, r0, [ip, #80]	@ 0x50
 800598c:	f8c5 e004 	str.w	lr, [r5, #4]
  if (hdma->DMAmuxRequestGen != NULL)
 8005990:	b118      	cbz	r0, 800599a <HAL_DMA_Start_IT+0x56>
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005992:	e9dc 5e16 	ldrd	r5, lr, [ip, #88]	@ 0x58
 8005996:	f8c5 e004 	str.w	lr, [r5, #4]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800599a:	f8dc 5044 	ldr.w	r5, [ip, #68]	@ 0x44
 800599e:	f005 0e1c 	and.w	lr, r5, #28
 80059a2:	2501      	movs	r5, #1
 80059a4:	fa05 f50e 	lsl.w	r5, r5, lr
 80059a8:	f8dc e040 	ldr.w	lr, [ip, #64]	@ 0x40
 80059ac:	f8ce 5004 	str.w	r5, [lr, #4]
  hdma->Instance->CNDTR = DataLength;
 80059b0:	6063      	str	r3, [r4, #4]
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80059b2:	f8dc 3008 	ldr.w	r3, [ip, #8]
 80059b6:	2b10      	cmp	r3, #16
    if (NULL != hdma->XferHalfCpltCallback)
 80059b8:	f8dc 3030 	ldr.w	r3, [ip, #48]	@ 0x30
    hdma->Instance->CPAR = DstAddress;
 80059bc:	bf0b      	itete	eq
 80059be:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->CPAR = SrcAddress;
 80059c0:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 80059c2:	60e1      	streq	r1, [r4, #12]
    hdma->Instance->CMAR = DstAddress;
 80059c4:	60e2      	strne	r2, [r4, #12]
    if (NULL != hdma->XferHalfCpltCallback)
 80059c6:	b1d3      	cbz	r3, 80059fe <HAL_DMA_Start_IT+0xba>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80059c8:	6823      	ldr	r3, [r4, #0]
 80059ca:	f043 030e 	orr.w	r3, r3, #14
 80059ce:	6023      	str	r3, [r4, #0]
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 80059d0:	f8dc 3048 	ldr.w	r3, [ip, #72]	@ 0x48
 80059d4:	681a      	ldr	r2, [r3, #0]
 80059d6:	03d2      	lsls	r2, r2, #15
 80059d8:	d40a      	bmi.n	80059f0 <HAL_DMA_Start_IT+0xac>
    if (hdma->DMAmuxRequestGen != NULL)
 80059da:	b118      	cbz	r0, 80059e4 <HAL_DMA_Start_IT+0xa0>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 80059dc:	6803      	ldr	r3, [r0, #0]
 80059de:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80059e2:	6003      	str	r3, [r0, #0]
    __HAL_DMA_ENABLE(hdma);
 80059e4:	6823      	ldr	r3, [r4, #0]
 80059e6:	f043 0301 	orr.w	r3, r3, #1
  HAL_StatusTypeDef status = HAL_OK;
 80059ea:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80059ec:	6023      	str	r3, [r4, #0]
}
 80059ee:	bd30      	pop	{r4, r5, pc}
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 80059f0:	681a      	ldr	r2, [r3, #0]
 80059f2:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80059f6:	601a      	str	r2, [r3, #0]
 80059f8:	e7ef      	b.n	80059da <HAL_DMA_Start_IT+0x96>
  __HAL_LOCK(hdma);
 80059fa:	2002      	movs	r0, #2
}
 80059fc:	4770      	bx	lr
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80059fe:	6823      	ldr	r3, [r4, #0]
 8005a00:	f023 0304 	bic.w	r3, r3, #4
 8005a04:	6023      	str	r3, [r4, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8005a06:	6823      	ldr	r3, [r4, #0]
 8005a08:	f043 030a 	orr.w	r3, r3, #10
 8005a0c:	6023      	str	r3, [r4, #0]
 8005a0e:	e7df      	b.n	80059d0 <HAL_DMA_Start_IT+0x8c>

08005a10 <HAL_DMA_Abort>:
  if (NULL == hdma)
 8005a10:	2800      	cmp	r0, #0
 8005a12:	d033      	beq.n	8005a7c <HAL_DMA_Abort+0x6c>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 8005a14:	f890 3025 	ldrb.w	r3, [r0, #37]	@ 0x25
 8005a18:	2b02      	cmp	r3, #2
 8005a1a:	d12a      	bne.n	8005a72 <HAL_DMA_Abort+0x62>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005a1c:	6803      	ldr	r3, [r0, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005a1e:	6c42      	ldr	r2, [r0, #68]	@ 0x44
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005a20:	6819      	ldr	r1, [r3, #0]
{
 8005a22:	b430      	push	{r4, r5}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005a24:	f021 010e 	bic.w	r1, r1, #14
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005a28:	6c84      	ldr	r4, [r0, #72]	@ 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005a2a:	6019      	str	r1, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005a2c:	6821      	ldr	r1, [r4, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005a2e:	6c05      	ldr	r5, [r0, #64]	@ 0x40
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005a30:	f421 7180 	bic.w	r1, r1, #256	@ 0x100
 8005a34:	6021      	str	r1, [r4, #0]
    __HAL_DMA_DISABLE(hdma);
 8005a36:	6819      	ldr	r1, [r3, #0]
 8005a38:	f021 0101 	bic.w	r1, r1, #1
 8005a3c:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005a3e:	f002 021c 	and.w	r2, r2, #28
 8005a42:	2301      	movs	r3, #1
 8005a44:	4093      	lsls	r3, r2
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005a46:	e9d0 4214 	ldrd	r4, r2, [r0, #80]	@ 0x50
 8005a4a:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005a4c:	606b      	str	r3, [r5, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005a4e:	604c      	str	r4, [r1, #4]
    if (hdma->DMAmuxRequestGen != NULL)
 8005a50:	b132      	cbz	r2, 8005a60 <HAL_DMA_Abort+0x50>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8005a52:	6813      	ldr	r3, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005a54:	e9d0 1416 	ldrd	r1, r4, [r0, #88]	@ 0x58
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8005a58:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8005a5c:	6013      	str	r3, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005a5e:	604c      	str	r4, [r1, #4]
    __HAL_UNLOCK(hdma);
 8005a60:	2300      	movs	r3, #0
    hdma->State = HAL_DMA_STATE_READY;
 8005a62:	2201      	movs	r2, #1
 8005a64:	f880 2025 	strb.w	r2, [r0, #37]	@ 0x25
    __HAL_UNLOCK(hdma);
 8005a68:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
}
 8005a6c:	bc30      	pop	{r4, r5}
  return HAL_OK;
 8005a6e:	4618      	mov	r0, r3
}
 8005a70:	4770      	bx	lr
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8005a72:	2204      	movs	r2, #4
    __HAL_UNLOCK(hdma);
 8005a74:	2300      	movs	r3, #0
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8005a76:	63c2      	str	r2, [r0, #60]	@ 0x3c
    __HAL_UNLOCK(hdma);
 8005a78:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
    return HAL_ERROR;
 8005a7c:	2001      	movs	r0, #1
}
 8005a7e:	4770      	bx	lr

08005a80 <HAL_DMA_Abort_IT>:
{
 8005a80:	b538      	push	{r3, r4, r5, lr}
  if (hdma->State != HAL_DMA_STATE_BUSY)
 8005a82:	f890 3025 	ldrb.w	r3, [r0, #37]	@ 0x25
 8005a86:	2b02      	cmp	r3, #2
 8005a88:	d003      	beq.n	8005a92 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8005a8a:	2304      	movs	r3, #4
 8005a8c:	63c3      	str	r3, [r0, #60]	@ 0x3c
    status = HAL_ERROR;
 8005a8e:	2001      	movs	r0, #1
}
 8005a90:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005a92:	6803      	ldr	r3, [r0, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005a94:	6c84      	ldr	r4, [r0, #72]	@ 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005a96:	6819      	ldr	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005a98:	6c42      	ldr	r2, [r0, #68]	@ 0x44
 8005a9a:	6c05      	ldr	r5, [r0, #64]	@ 0x40
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005a9c:	f021 010e 	bic.w	r1, r1, #14
 8005aa0:	6019      	str	r1, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 8005aa2:	6819      	ldr	r1, [r3, #0]
 8005aa4:	f021 0101 	bic.w	r1, r1, #1
 8005aa8:	6019      	str	r1, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005aaa:	6823      	ldr	r3, [r4, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005aac:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005aae:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8005ab2:	6023      	str	r3, [r4, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005ab4:	f002 021c 	and.w	r2, r2, #28
 8005ab8:	2301      	movs	r3, #1
 8005aba:	4093      	lsls	r3, r2
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005abc:	e9d0 4214 	ldrd	r4, r2, [r0, #80]	@ 0x50
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005ac0:	606b      	str	r3, [r5, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005ac2:	604c      	str	r4, [r1, #4]
    if (hdma->DMAmuxRequestGen != NULL)
 8005ac4:	b132      	cbz	r2, 8005ad4 <HAL_DMA_Abort_IT+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8005ac6:	6813      	ldr	r3, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005ac8:	e9d0 1416 	ldrd	r1, r4, [r0, #88]	@ 0x58
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8005acc:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8005ad0:	6013      	str	r3, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005ad2:	604c      	str	r4, [r1, #4]
    if (hdma->XferAbortCallback != NULL)
 8005ad4:	6b83      	ldr	r3, [r0, #56]	@ 0x38
    hdma->State = HAL_DMA_STATE_READY;
 8005ad6:	2101      	movs	r1, #1
    __HAL_UNLOCK(hdma);
 8005ad8:	2200      	movs	r2, #0
    hdma->State = HAL_DMA_STATE_READY;
 8005ada:	f880 1025 	strb.w	r1, [r0, #37]	@ 0x25
    __HAL_UNLOCK(hdma);
 8005ade:	f880 2024 	strb.w	r2, [r0, #36]	@ 0x24
    if (hdma->XferAbortCallback != NULL)
 8005ae2:	b103      	cbz	r3, 8005ae6 <HAL_DMA_Abort_IT+0x66>
      hdma->XferAbortCallback(hdma);
 8005ae4:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 8005ae6:	2000      	movs	r0, #0
}
 8005ae8:	bd38      	pop	{r3, r4, r5, pc}
 8005aea:	bf00      	nop

08005aec <HAL_DMA_IRQHandler>:
{
 8005aec:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8005aee:	6c43      	ldr	r3, [r0, #68]	@ 0x44
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8005af0:	6c06      	ldr	r6, [r0, #64]	@ 0x40
  uint32_t source_it = hdma->Instance->CCR;
 8005af2:	6805      	ldr	r5, [r0, #0]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8005af4:	6831      	ldr	r1, [r6, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8005af6:	682c      	ldr	r4, [r5, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8005af8:	f003 031c 	and.w	r3, r3, #28
 8005afc:	2204      	movs	r2, #4
 8005afe:	409a      	lsls	r2, r3
 8005b00:	420a      	tst	r2, r1
 8005b02:	d00e      	beq.n	8005b22 <HAL_DMA_IRQHandler+0x36>
 8005b04:	f014 0f04 	tst.w	r4, #4
 8005b08:	d00b      	beq.n	8005b22 <HAL_DMA_IRQHandler+0x36>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8005b0a:	682b      	ldr	r3, [r5, #0]
 8005b0c:	069b      	lsls	r3, r3, #26
 8005b0e:	d403      	bmi.n	8005b18 <HAL_DMA_IRQHandler+0x2c>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8005b10:	682b      	ldr	r3, [r5, #0]
 8005b12:	f023 0304 	bic.w	r3, r3, #4
 8005b16:	602b      	str	r3, [r5, #0]
      if (hdma->XferHalfCpltCallback != NULL)
 8005b18:	6b03      	ldr	r3, [r0, #48]	@ 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 8005b1a:	6072      	str	r2, [r6, #4]
      if (hdma->XferHalfCpltCallback != NULL)
 8005b1c:	b1fb      	cbz	r3, 8005b5e <HAL_DMA_IRQHandler+0x72>
}
 8005b1e:	bc70      	pop	{r4, r5, r6}
        hdma->XferCpltCallback(hdma);
 8005b20:	4718      	bx	r3
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)))) && (0U != (source_it & DMA_IT_TC)))
 8005b22:	2202      	movs	r2, #2
 8005b24:	409a      	lsls	r2, r3
 8005b26:	420a      	tst	r2, r1
 8005b28:	d01b      	beq.n	8005b62 <HAL_DMA_IRQHandler+0x76>
 8005b2a:	f014 0f02 	tst.w	r4, #2
 8005b2e:	d018      	beq.n	8005b62 <HAL_DMA_IRQHandler+0x76>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8005b30:	682b      	ldr	r3, [r5, #0]
 8005b32:	0699      	lsls	r1, r3, #26
 8005b34:	d406      	bmi.n	8005b44 <HAL_DMA_IRQHandler+0x58>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8005b36:	682b      	ldr	r3, [r5, #0]
        hdma->State = HAL_DMA_STATE_READY;
 8005b38:	2101      	movs	r1, #1
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8005b3a:	f023 030a 	bic.w	r3, r3, #10
 8005b3e:	602b      	str	r3, [r5, #0]
        hdma->State = HAL_DMA_STATE_READY;
 8005b40:	f880 1025 	strb.w	r1, [r0, #37]	@ 0x25
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 8005b44:	4b13      	ldr	r3, [pc, #76]	@ (8005b94 <HAL_DMA_IRQHandler+0xa8>)
 8005b46:	429d      	cmp	r5, r3
 8005b48:	bf96      	itet	ls
 8005b4a:	4b13      	ldrls	r3, [pc, #76]	@ (8005b98 <HAL_DMA_IRQHandler+0xac>)
 8005b4c:	f8c3 2384 	strhi.w	r2, [r3, #900]	@ 0x384
 8005b50:	605a      	strls	r2, [r3, #4]
      if (hdma->XferCpltCallback != NULL)
 8005b52:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
      __HAL_UNLOCK(hdma);
 8005b54:	2200      	movs	r2, #0
 8005b56:	f880 2024 	strb.w	r2, [r0, #36]	@ 0x24
      if (hdma->XferCpltCallback != NULL)
 8005b5a:	2b00      	cmp	r3, #0
 8005b5c:	d1df      	bne.n	8005b1e <HAL_DMA_IRQHandler+0x32>
}
 8005b5e:	bc70      	pop	{r4, r5, r6}
 8005b60:	4770      	bx	lr
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 8005b62:	2208      	movs	r2, #8
 8005b64:	409a      	lsls	r2, r3
 8005b66:	420a      	tst	r2, r1
 8005b68:	d0f9      	beq.n	8005b5e <HAL_DMA_IRQHandler+0x72>
 8005b6a:	0722      	lsls	r2, r4, #28
 8005b6c:	d5f7      	bpl.n	8005b5e <HAL_DMA_IRQHandler+0x72>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005b6e:	682a      	ldr	r2, [r5, #0]
    if (hdma->XferErrorCallback != NULL)
 8005b70:	6b41      	ldr	r1, [r0, #52]	@ 0x34
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005b72:	f022 020e 	bic.w	r2, r2, #14
 8005b76:	602a      	str	r2, [r5, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005b78:	2201      	movs	r2, #1
 8005b7a:	fa02 f303 	lsl.w	r3, r2, r3
    __HAL_UNLOCK(hdma);
 8005b7e:	2400      	movs	r4, #0
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005b80:	6073      	str	r3, [r6, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8005b82:	63c2      	str	r2, [r0, #60]	@ 0x3c
    __HAL_UNLOCK(hdma);
 8005b84:	f880 4024 	strb.w	r4, [r0, #36]	@ 0x24
    hdma->State = HAL_DMA_STATE_READY;
 8005b88:	f880 2025 	strb.w	r2, [r0, #37]	@ 0x25
    if (hdma->XferErrorCallback != NULL)
 8005b8c:	2900      	cmp	r1, #0
 8005b8e:	d0e6      	beq.n	8005b5e <HAL_DMA_IRQHandler+0x72>
}
 8005b90:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 8005b92:	4708      	bx	r1
 8005b94:	40020080 	.word	0x40020080
 8005b98:	40020000 	.word	0x40020000

08005b9c <HAL_FLASH_Program>:
  *                are stored the data for the row fast program.
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8005b9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_ADDR_ALIGNED_64BITS(Address));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8005ba0:	4f4c      	ldr	r7, [pc, #304]	@ (8005cd4 <HAL_FLASH_Program+0x138>)
{
 8005ba2:	469a      	mov	sl, r3
  __HAL_LOCK(&pFlash);
 8005ba4:	783b      	ldrb	r3, [r7, #0]
 8005ba6:	2b01      	cmp	r3, #1
 8005ba8:	d07a      	beq.n	8005ca0 <HAL_FLASH_Program+0x104>
 8005baa:	2301      	movs	r3, #1
 8005bac:	703b      	strb	r3, [r7, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8005bae:	2300      	movs	r3, #0
 8005bb0:	4680      	mov	r8, r0
 8005bb2:	460d      	mov	r5, r1
 8005bb4:	4614      	mov	r4, r2
 8005bb6:	607b      	str	r3, [r7, #4]
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
  uint32_t error;
  uint32_t tickstart = HAL_GetTick();
 8005bb8:	f7fc f806 	bl	8001bc8 <HAL_GetTick>

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005bbc:	f8df 9118 	ldr.w	r9, [pc, #280]	@ 8005cd8 <HAL_FLASH_Program+0x13c>
  uint32_t tickstart = HAL_GetTick();
 8005bc0:	4606      	mov	r6, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005bc2:	e005      	b.n	8005bd0 <HAL_FLASH_Program+0x34>
  {
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8005bc4:	f7fc f800 	bl	8001bc8 <HAL_GetTick>
 8005bc8:	1b82      	subs	r2, r0, r6
 8005bca:	f5b2 7f7a 	cmp.w	r2, #1000	@ 0x3e8
 8005bce:	d25b      	bcs.n	8005c88 <HAL_FLASH_Program+0xec>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005bd0:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8005bd4:	03d9      	lsls	r1, r3, #15
 8005bd6:	d4f5      	bmi.n	8005bc4 <HAL_FLASH_Program+0x28>
  /* check flash errors. Only ECC correction can be checked here as ECCD
      generates NMI */
#ifdef CORE_CM0PLUS
  error = FLASH->C2SR;
#else
  error = FLASH->SR;
 8005bd8:	f8d9 3010 	ldr.w	r3, [r9, #16]
#endif

  /* Check FLASH End of Operation flag */
  if ((error & FLASH_FLAG_EOP) != 0U)
 8005bdc:	07da      	lsls	r2, r3, #31
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8005bde:	bf44      	itt	mi
 8005be0:	2201      	movmi	r2, #1
 8005be2:	f8c9 2010 	strmi.w	r2, [r9, #16]
  }

  /* Now update error variable to only error value */
  error &= FLASH_FLAG_SR_ERRORS;
 8005be6:	f24c 32fa 	movw	r2, #50170	@ 0xc3fa

  /* clear error flags */
  __HAL_FLASH_CLEAR_FLAG(error);
 8005bea:	4013      	ands	r3, r2
 8005bec:	d15b      	bne.n	8005ca6 <HAL_FLASH_Program+0x10a>

    return HAL_ERROR;
  }

  /* Wait for control register to be written */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8005bee:	f8df 90e8 	ldr.w	r9, [pc, #232]	@ 8005cd8 <HAL_FLASH_Program+0x13c>
 8005bf2:	e005      	b.n	8005c00 <HAL_FLASH_Program+0x64>
  {
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8005bf4:	f7fb ffe8 	bl	8001bc8 <HAL_GetTick>
 8005bf8:	1b80      	subs	r0, r0, r6
 8005bfa:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8005bfe:	d243      	bcs.n	8005c88 <HAL_FLASH_Program+0xec>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8005c00:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8005c04:	035b      	lsls	r3, r3, #13
 8005c06:	d4f5      	bmi.n	8005bf4 <HAL_FLASH_Program+0x58>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 8005c08:	f1b8 0f01 	cmp.w	r8, #1
 8005c0c:	d050      	beq.n	8005cb0 <HAL_FLASH_Program+0x114>

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
#else
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 8005c0e:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8005c12:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
  __IO uint32_t *src_addr = (__IO uint32_t *)DataAddress;
 8005c16:	4622      	mov	r2, r4
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 8005c18:	f8c9 3014 	str.w	r3, [r9, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005c1c:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8005c20:	b672      	cpsid	i
 8005c22:	1b2d      	subs	r5, r5, r4
 8005c24:	f504 7180 	add.w	r1, r4, #256	@ 0x100
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 8005c28:	6813      	ldr	r3, [r2, #0]
 8005c2a:	5153      	str	r3, [r2, r5]
    dest_addr++;
    src_addr++;
 8005c2c:	3204      	adds	r2, #4
    row_index--;
  }
  while (row_index != 0U);
 8005c2e:	4291      	cmp	r1, r2
 8005c30:	d1fa      	bne.n	8005c28 <HAL_FLASH_Program+0x8c>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
 8005c32:	4a29      	ldr	r2, [pc, #164]	@ (8005cd8 <HAL_FLASH_Program+0x13c>)
 8005c34:	6913      	ldr	r3, [r2, #16]
 8005c36:	03dc      	lsls	r4, r3, #15
 8005c38:	d4fc      	bmi.n	8005c34 <HAL_FLASH_Program+0x98>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005c3a:	f380 8810 	msr	PRIMASK, r0
  uint32_t tickstart = HAL_GetTick();
 8005c3e:	f7fb ffc3 	bl	8001bc8 <HAL_GetTick>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005c42:	4d25      	ldr	r5, [pc, #148]	@ (8005cd8 <HAL_FLASH_Program+0x13c>)
  uint32_t tickstart = HAL_GetTick();
 8005c44:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005c46:	e005      	b.n	8005c54 <HAL_FLASH_Program+0xb8>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8005c48:	f7fb ffbe 	bl	8001bc8 <HAL_GetTick>
 8005c4c:	1b00      	subs	r0, r0, r4
 8005c4e:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8005c52:	d21e      	bcs.n	8005c92 <HAL_FLASH_Program+0xf6>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005c54:	692b      	ldr	r3, [r5, #16]
 8005c56:	03d9      	lsls	r1, r3, #15
 8005c58:	d4f6      	bmi.n	8005c48 <HAL_FLASH_Program+0xac>
  error = FLASH->SR;
 8005c5a:	692b      	ldr	r3, [r5, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 8005c5c:	07da      	lsls	r2, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8005c5e:	bf44      	itt	mi
 8005c60:	2201      	movmi	r2, #1
 8005c62:	612a      	strmi	r2, [r5, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 8005c64:	f24c 32fa 	movw	r2, #50170	@ 0xc3fa
  __HAL_FLASH_CLEAR_FLAG(error);
 8005c68:	4013      	ands	r3, r2
 8005c6a:	d12d      	bne.n	8005cc8 <HAL_FLASH_Program+0x12c>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8005c6c:	4d1a      	ldr	r5, [pc, #104]	@ (8005cd8 <HAL_FLASH_Program+0x13c>)
 8005c6e:	e005      	b.n	8005c7c <HAL_FLASH_Program+0xe0>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8005c70:	f7fb ffaa 	bl	8001bc8 <HAL_GetTick>
 8005c74:	1b00      	subs	r0, r0, r4
 8005c76:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8005c7a:	d20a      	bcs.n	8005c92 <HAL_FLASH_Program+0xf6>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8005c7c:	692b      	ldr	r3, [r5, #16]
 8005c7e:	f413 2380 	ands.w	r3, r3, #262144	@ 0x40000
 8005c82:	d1f5      	bne.n	8005c70 <HAL_FLASH_Program+0xd4>
  return HAL_OK;
 8005c84:	4618      	mov	r0, r3
 8005c86:	e005      	b.n	8005c94 <HAL_FLASH_Program+0xf8>
      return HAL_TIMEOUT;
 8005c88:	2003      	movs	r0, #3
  __HAL_UNLOCK(&pFlash);
 8005c8a:	2300      	movs	r3, #0
 8005c8c:	703b      	strb	r3, [r7, #0]
}
 8005c8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      return HAL_TIMEOUT;
 8005c92:	2003      	movs	r0, #3
    CLEAR_BIT(FLASH->CR, TypeProgram);
 8005c94:	4a10      	ldr	r2, [pc, #64]	@ (8005cd8 <HAL_FLASH_Program+0x13c>)
 8005c96:	6953      	ldr	r3, [r2, #20]
 8005c98:	ea23 0308 	bic.w	r3, r3, r8
 8005c9c:	6153      	str	r3, [r2, #20]
 8005c9e:	e7f4      	b.n	8005c8a <HAL_FLASH_Program+0xee>
  __HAL_LOCK(&pFlash);
 8005ca0:	2002      	movs	r0, #2
}
 8005ca2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 8005ca6:	4a0c      	ldr	r2, [pc, #48]	@ (8005cd8 <HAL_FLASH_Program+0x13c>)
    pFlash.ErrorCode = error;
 8005ca8:	607b      	str	r3, [r7, #4]
    return HAL_ERROR;
 8005caa:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(error);
 8005cac:	6113      	str	r3, [r2, #16]
  if (status == HAL_OK)
 8005cae:	e7ec      	b.n	8005c8a <HAL_FLASH_Program+0xee>
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 8005cb0:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8005cb4:	f043 0301 	orr.w	r3, r3, #1
 8005cb8:	f8c9 3014 	str.w	r3, [r9, #20]
  *(uint32_t *)Address = (uint32_t)Data;
 8005cbc:	602c      	str	r4, [r5, #0]
  __ASM volatile ("isb 0xF":::"memory");
 8005cbe:	f3bf 8f6f 	isb	sy
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 8005cc2:	f8c5 a004 	str.w	sl, [r5, #4]
}
 8005cc6:	e7ba      	b.n	8005c3e <HAL_FLASH_Program+0xa2>
  __HAL_FLASH_CLEAR_FLAG(error);
 8005cc8:	4a03      	ldr	r2, [pc, #12]	@ (8005cd8 <HAL_FLASH_Program+0x13c>)
    pFlash.ErrorCode = error;
 8005cca:	607b      	str	r3, [r7, #4]
    return HAL_ERROR;
 8005ccc:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(error);
 8005cce:	6113      	str	r3, [r2, #16]
    return HAL_ERROR;
 8005cd0:	e7e0      	b.n	8005c94 <HAL_FLASH_Program+0xf8>
 8005cd2:	bf00      	nop
 8005cd4:	20000438 	.word	0x20000438
 8005cd8:	58004000 	.word	0x58004000

08005cdc <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8005cdc:	4b06      	ldr	r3, [pc, #24]	@ (8005cf8 <HAL_FLASH_Unlock+0x1c>)
 8005cde:	695a      	ldr	r2, [r3, #20]
 8005ce0:	2a00      	cmp	r2, #0
 8005ce2:	db01      	blt.n	8005ce8 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 8005ce4:	2000      	movs	r0, #0
}
 8005ce6:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8005ce8:	4904      	ldr	r1, [pc, #16]	@ (8005cfc <HAL_FLASH_Unlock+0x20>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8005cea:	4a05      	ldr	r2, [pc, #20]	@ (8005d00 <HAL_FLASH_Unlock+0x24>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8005cec:	6099      	str	r1, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8005cee:	609a      	str	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8005cf0:	6958      	ldr	r0, [r3, #20]
 8005cf2:	0fc0      	lsrs	r0, r0, #31
 8005cf4:	4770      	bx	lr
 8005cf6:	bf00      	nop
 8005cf8:	58004000 	.word	0x58004000
 8005cfc:	45670123 	.word	0x45670123
 8005d00:	cdef89ab 	.word	0xcdef89ab

08005d04 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8005d04:	4b04      	ldr	r3, [pc, #16]	@ (8005d18 <HAL_FLASH_Lock+0x14>)
 8005d06:	695a      	ldr	r2, [r3, #20]
 8005d08:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 8005d0c:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 8005d0e:	6958      	ldr	r0, [r3, #20]
}
 8005d10:	43c0      	mvns	r0, r0
 8005d12:	0fc0      	lsrs	r0, r0, #31
 8005d14:	4770      	bx	lr
 8005d16:	bf00      	nop
 8005d18:	58004000 	.word	0x58004000

08005d1c <FLASH_WaitForLastOperation>:
{
 8005d1c:	b570      	push	{r4, r5, r6, lr}
 8005d1e:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 8005d20:	f7fb ff52 	bl	8001bc8 <HAL_GetTick>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005d24:	4e14      	ldr	r6, [pc, #80]	@ (8005d78 <FLASH_WaitForLastOperation+0x5c>)
  uint32_t tickstart = HAL_GetTick();
 8005d26:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005d28:	e004      	b.n	8005d34 <FLASH_WaitForLastOperation+0x18>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8005d2a:	f7fb ff4d 	bl	8001bc8 <HAL_GetTick>
 8005d2e:	1b00      	subs	r0, r0, r4
 8005d30:	42a8      	cmp	r0, r5
 8005d32:	d218      	bcs.n	8005d66 <FLASH_WaitForLastOperation+0x4a>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8005d34:	6933      	ldr	r3, [r6, #16]
 8005d36:	03d9      	lsls	r1, r3, #15
 8005d38:	d4f7      	bmi.n	8005d2a <FLASH_WaitForLastOperation+0xe>
  error = FLASH->SR;
 8005d3a:	6933      	ldr	r3, [r6, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 8005d3c:	07da      	lsls	r2, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8005d3e:	bf44      	itt	mi
 8005d40:	2201      	movmi	r2, #1
 8005d42:	6132      	strmi	r2, [r6, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 8005d44:	f24c 32fa 	movw	r2, #50170	@ 0xc3fa
  __HAL_FLASH_CLEAR_FLAG(error);
 8005d48:	4013      	ands	r3, r2
 8005d4a:	d10e      	bne.n	8005d6a <FLASH_WaitForLastOperation+0x4e>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8005d4c:	4e0a      	ldr	r6, [pc, #40]	@ (8005d78 <FLASH_WaitForLastOperation+0x5c>)
 8005d4e:	e004      	b.n	8005d5a <FLASH_WaitForLastOperation+0x3e>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8005d50:	f7fb ff3a 	bl	8001bc8 <HAL_GetTick>
 8005d54:	1b00      	subs	r0, r0, r4
 8005d56:	42a8      	cmp	r0, r5
 8005d58:	d205      	bcs.n	8005d66 <FLASH_WaitForLastOperation+0x4a>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8005d5a:	6933      	ldr	r3, [r6, #16]
 8005d5c:	f413 2380 	ands.w	r3, r3, #262144	@ 0x40000
 8005d60:	d1f6      	bne.n	8005d50 <FLASH_WaitForLastOperation+0x34>
  return HAL_OK;
 8005d62:	4618      	mov	r0, r3
}
 8005d64:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_TIMEOUT;
 8005d66:	2003      	movs	r0, #3
}
 8005d68:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 8005d6a:	4903      	ldr	r1, [pc, #12]	@ (8005d78 <FLASH_WaitForLastOperation+0x5c>)
    pFlash.ErrorCode = error;
 8005d6c:	4a03      	ldr	r2, [pc, #12]	@ (8005d7c <FLASH_WaitForLastOperation+0x60>)
  __HAL_FLASH_CLEAR_FLAG(error);
 8005d6e:	610b      	str	r3, [r1, #16]
    return HAL_ERROR;
 8005d70:	2001      	movs	r0, #1
    pFlash.ErrorCode = error;
 8005d72:	6053      	str	r3, [r2, #4]
}
 8005d74:	bd70      	pop	{r4, r5, r6, pc}
 8005d76:	bf00      	nop
 8005d78:	58004000 	.word	0x58004000
 8005d7c:	20000438 	.word	0x20000438

08005d80 <HAL_FLASHEx_Erase>:
  *         information on faulty page in case of error (0xFFFFFFFF means that all
  *         the pages have been correctly erased)
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 8005d80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8005d84:	4e2c      	ldr	r6, [pc, #176]	@ (8005e38 <HAL_FLASHEx_Erase+0xb8>)
 8005d86:	7833      	ldrb	r3, [r6, #0]
 8005d88:	2b01      	cmp	r3, #1
 8005d8a:	d043      	beq.n	8005e14 <HAL_FLASHEx_Erase+0x94>
 8005d8c:	2201      	movs	r2, #1

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8005d8e:	2300      	movs	r3, #0
 8005d90:	4681      	mov	r9, r0

  /* Verify that next operation can be proceed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8005d92:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8005d96:	460f      	mov	r7, r1
  __HAL_LOCK(&pFlash);
 8005d98:	7032      	strb	r2, [r6, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8005d9a:	6073      	str	r3, [r6, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8005d9c:	f7ff ffbe 	bl	8005d1c <FLASH_WaitForLastOperation>

  if (status == HAL_OK)
 8005da0:	4605      	mov	r5, r0
 8005da2:	bb90      	cbnz	r0, 8005e0a <HAL_FLASHEx_Erase+0x8a>
  {
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8005da4:	f8d9 3000 	ldr.w	r3, [r9]
 8005da8:	2b04      	cmp	r3, #4
 8005daa:	d037      	beq.n	8005e1c <HAL_FLASHEx_Erase+0x9c>
      /* If operation is completed or interrupted, no need to clear the Mass Erase Bit */
    }
    else
    {
      /*Initialization of PageError variable*/
      *PageError = 0xFFFFFFFFU;
 8005dac:	f04f 33ff 	mov.w	r3, #4294967295
 8005db0:	603b      	str	r3, [r7, #0]

      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 8005db2:	e9d9 4301 	ldrd	r4, r3, [r9, #4]
 8005db6:	4423      	add	r3, r4
 8005db8:	429c      	cmp	r4, r3
 8005dba:	d21c      	bcs.n	8005df6 <HAL_FLASHEx_Erase+0x76>

  /* Proceed to erase the page */
#ifdef CORE_CM0PLUS
  MODIFY_REG(FLASH->C2CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
#else
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 8005dbc:	f8df a07c 	ldr.w	sl, [pc, #124]	@ 8005e3c <HAL_FLASHEx_Erase+0xbc>
 8005dc0:	f8df 807c 	ldr.w	r8, [pc, #124]	@ 8005e40 <HAL_FLASHEx_Erase+0xc0>
 8005dc4:	e005      	b.n	8005dd2 <HAL_FLASHEx_Erase+0x52>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 8005dc6:	e9d9 3201 	ldrd	r3, r2, [r9, #4]
 8005dca:	3401      	adds	r4, #1
 8005dcc:	4413      	add	r3, r2
 8005dce:	42a3      	cmp	r3, r4
 8005dd0:	d911      	bls.n	8005df6 <HAL_FLASHEx_Erase+0x76>
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 8005dd2:	f8da 3014 	ldr.w	r3, [sl, #20]
 8005dd6:	f423 737e 	bic.w	r3, r3, #1016	@ 0x3f8
 8005dda:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
 8005dde:	ea43 0308 	orr.w	r3, r3, r8
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8005de2:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 8005de6:	f8ca 3014 	str.w	r3, [sl, #20]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8005dea:	f7ff ff97 	bl	8005d1c <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 8005dee:	2800      	cmp	r0, #0
 8005df0:	d0e9      	beq.n	8005dc6 <HAL_FLASHEx_Erase+0x46>
          *PageError = index;
 8005df2:	603c      	str	r4, [r7, #0]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8005df4:	4605      	mov	r5, r0
static void FLASH_AcknowledgePageErase(void)
{
#ifdef CORE_CM0PLUS
  CLEAR_BIT(FLASH->C2CR, (FLASH_CR_PER | FLASH_CR_PNB));
#else
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 8005df6:	4a11      	ldr	r2, [pc, #68]	@ (8005e3c <HAL_FLASHEx_Erase+0xbc>)
 8005df8:	6953      	ldr	r3, [r2, #20]
 8005dfa:	f423 737e 	bic.w	r3, r3, #1016	@ 0x3f8
 8005dfe:	f023 0302 	bic.w	r3, r3, #2
 8005e02:	6153      	str	r3, [r2, #20]
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 8005e04:	4b0d      	ldr	r3, [pc, #52]	@ (8005e3c <HAL_FLASHEx_Erase+0xbc>)
 8005e06:	681a      	ldr	r2, [r3, #0]
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) == 1U)
 8005e08:	681b      	ldr	r3, [r3, #0]
  __HAL_UNLOCK(&pFlash);
 8005e0a:	2300      	movs	r3, #0
 8005e0c:	7033      	strb	r3, [r6, #0]
}
 8005e0e:	4628      	mov	r0, r5
 8005e10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __HAL_LOCK(&pFlash);
 8005e14:	2502      	movs	r5, #2
}
 8005e16:	4628      	mov	r0, r5
 8005e18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 8005e1c:	4a07      	ldr	r2, [pc, #28]	@ (8005e3c <HAL_FLASHEx_Erase+0xbc>)
 8005e1e:	6953      	ldr	r3, [r2, #20]
 8005e20:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8005e24:	f043 0304 	orr.w	r3, r3, #4
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8005e28:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 8005e2c:	6153      	str	r3, [r2, #20]
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8005e2e:	f7ff ff75 	bl	8005d1c <FLASH_WaitForLastOperation>
 8005e32:	4605      	mov	r5, r0
 8005e34:	e7e6      	b.n	8005e04 <HAL_FLASHEx_Erase+0x84>
 8005e36:	bf00      	nop
 8005e38:	20000438 	.word	0x20000438
 8005e3c:	58004000 	.word	0x58004000
 8005e40:	00010002 	.word	0x00010002

08005e44 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8005e44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8005e48:	680c      	ldr	r4, [r1, #0]
{
 8005e4a:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8005e4c:	2c00      	cmp	r4, #0
 8005e4e:	f000 80bf 	beq.w	8005fd0 <HAL_GPIO_Init+0x18c>
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2u] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8005e52:	4e6b      	ldr	r6, [pc, #428]	@ (8006000 <HAL_GPIO_Init+0x1bc>)
  uint32_t position = 0x00u;
 8005e54:	2300      	movs	r3, #0
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8005e56:	f04f 0b01 	mov.w	fp, #1
 8005e5a:	e05d      	b.n	8005f18 <HAL_GPIO_Init+0xd4>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8005e5c:	2a03      	cmp	r2, #3
 8005e5e:	f040 80ba 	bne.w	8005fd6 <HAL_GPIO_Init+0x192>
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8005e62:	fa02 f20c 	lsl.w	r2, r2, ip
      temp = GPIOx->MODER;
 8005e66:	f8d0 c000 	ldr.w	ip, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8005e6a:	ea0c 0707 	and.w	r7, ip, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8005e6e:	433a      	orrs	r2, r7
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8005e70:	f415 3f40 	tst.w	r5, #196608	@ 0x30000
      GPIOx->MODER = temp;
 8005e74:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8005e76:	d04b      	beq.n	8005f10 <HAL_GPIO_Init+0xcc>
        temp = SYSCFG->EXTICR[position >> 2u];
 8005e78:	f023 0203 	bic.w	r2, r3, #3
 8005e7c:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 8005e80:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 8005e84:	f003 0703 	and.w	r7, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 8005e88:	f8d2 c008 	ldr.w	ip, [r2, #8]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 8005e8c:	00bf      	lsls	r7, r7, #2
 8005e8e:	f04f 0e07 	mov.w	lr, #7
 8005e92:	fa0e fe07 	lsl.w	lr, lr, r7
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8005e96:	f1b0 4f90 	cmp.w	r0, #1207959552	@ 0x48000000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 8005e9a:	ea2c 080e 	bic.w	r8, ip, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8005e9e:	d010      	beq.n	8005ec2 <HAL_GPIO_Init+0x7e>
 8005ea0:	f8df 9160 	ldr.w	r9, [pc, #352]	@ 8006004 <HAL_GPIO_Init+0x1c0>
 8005ea4:	4548      	cmp	r0, r9
 8005ea6:	f000 80a3 	beq.w	8005ff0 <HAL_GPIO_Init+0x1ac>
 8005eaa:	f8df 915c 	ldr.w	r9, [pc, #348]	@ 8006008 <HAL_GPIO_Init+0x1c4>
 8005eae:	4548      	cmp	r0, r9
 8005eb0:	bf03      	ittte	eq
 8005eb2:	f04f 0c02 	moveq.w	ip, #2
 8005eb6:	fa0c f707 	lsleq.w	r7, ip, r7
 8005eba:	ea48 0807 	orreq.w	r8, r8, r7
 8005ebe:	ea4e 080c 	orrne.w	r8, lr, ip
        SYSCFG->EXTICR[position >> 2u] = temp;
 8005ec2:	f8c2 8008 	str.w	r8, [r2, #8]
        temp = EXTI->RTSR1;
 8005ec6:	6832      	ldr	r2, [r6, #0]
        temp &= ~(iocurrent);
 8005ec8:	ea6f 070a 	mvn.w	r7, sl
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8005ecc:	f415 1f80 	tst.w	r5, #1048576	@ 0x100000
        temp &= ~(iocurrent);
 8005ed0:	bf0c      	ite	eq
 8005ed2:	403a      	andeq	r2, r7
        {
          temp |= iocurrent;
 8005ed4:	ea4a 0202 	orrne.w	r2, sl, r2
        }
        EXTI->RTSR1 = temp;
 8005ed8:	6032      	str	r2, [r6, #0]

        temp = EXTI->FTSR1;
 8005eda:	6872      	ldr	r2, [r6, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8005edc:	f415 1f00 	tst.w	r5, #2097152	@ 0x200000
        temp &= ~(iocurrent);
 8005ee0:	bf0c      	ite	eq
 8005ee2:	403a      	andeq	r2, r7
        {
          temp |= iocurrent;
 8005ee4:	ea4a 0202 	orrne.w	r2, sl, r2
        }
        EXTI->FTSR1 = temp;
 8005ee8:	6072      	str	r2, [r6, #4]

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 8005eea:	f8d6 2080 	ldr.w	r2, [r6, #128]	@ 0x80
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8005eee:	f415 3f80 	tst.w	r5, #65536	@ 0x10000
        temp &= ~(iocurrent);
 8005ef2:	bf0c      	ite	eq
 8005ef4:	403a      	andeq	r2, r7
        {
          temp |= iocurrent;
 8005ef6:	ea4a 0202 	orrne.w	r2, sl, r2
        }
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 = temp;
#else
        EXTI->IMR1 = temp;
 8005efa:	f8c6 2080 	str.w	r2, [r6, #128]	@ 0x80
#endif /* CORE_CM0PLUS */

#ifdef CORE_CM0PLUS
        temp = EXTI->C2EMR1;
#else
        temp = EXTI->EMR1;
 8005efe:	f8d6 2084 	ldr.w	r2, [r6, #132]	@ 0x84
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8005f02:	03ad      	lsls	r5, r5, #14
        temp &= ~(iocurrent);
 8005f04:	bf54      	ite	pl
 8005f06:	403a      	andpl	r2, r7
        {
          temp |= iocurrent;
 8005f08:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
#ifdef CORE_CM0PLUS
        EXTI->C2EMR1 = temp;
#else
        EXTI->EMR1 = temp;
 8005f0c:	f8c6 2084 	str.w	r2, [r6, #132]	@ 0x84
#endif /* CORE_CM0PLUS */
      }
    }

    position++;
 8005f10:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8005f12:	fa34 f203 	lsrs.w	r2, r4, r3
 8005f16:	d05b      	beq.n	8005fd0 <HAL_GPIO_Init+0x18c>
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8005f18:	fa0b fe03 	lsl.w	lr, fp, r3
    if (iocurrent != 0x00u)
 8005f1c:	ea1e 0a04 	ands.w	sl, lr, r4
 8005f20:	d0f6      	beq.n	8005f10 <HAL_GPIO_Init+0xcc>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8005f22:	684d      	ldr	r5, [r1, #4]
 8005f24:	f005 0203 	and.w	r2, r5, #3
 8005f28:	ea4f 0c43 	mov.w	ip, r3, lsl #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005f2c:	2703      	movs	r7, #3
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8005f2e:	f102 38ff 	add.w	r8, r2, #4294967295
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005f32:	fa07 f70c 	lsl.w	r7, r7, ip
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8005f36:	f1b8 0f01 	cmp.w	r8, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005f3a:	ea6f 0707 	mvn.w	r7, r7
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8005f3e:	d88d      	bhi.n	8005e5c <HAL_GPIO_Init+0x18>
        temp = GPIOx->OSPEEDR;
 8005f40:	f8d0 9008 	ldr.w	r9, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8005f44:	f8d1 800c 	ldr.w	r8, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005f48:	ea09 0907 	and.w	r9, r9, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 8005f4c:	fa08 f80c 	lsl.w	r8, r8, ip
 8005f50:	ea48 0809 	orr.w	r8, r8, r9
        GPIOx->OSPEEDR = temp;
 8005f54:	f8c0 8008 	str.w	r8, [r0, #8]
        temp = GPIOx->OTYPER;
 8005f58:	f8d0 8004 	ldr.w	r8, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8005f5c:	ea28 080e 	bic.w	r8, r8, lr
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8005f60:	f3c5 1e00 	ubfx	lr, r5, #4, #1
 8005f64:	fa0e fe03 	lsl.w	lr, lr, r3
 8005f68:	ea4e 0e08 	orr.w	lr, lr, r8
        GPIOx->OTYPER = temp;
 8005f6c:	f8c0 e004 	str.w	lr, [r0, #4]
        temp = GPIOx->PUPDR;
 8005f70:	f8d0 800c 	ldr.w	r8, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005f74:	f8d1 e008 	ldr.w	lr, [r1, #8]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8005f78:	ea08 0807 	and.w	r8, r8, r7
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005f7c:	fa0e fe0c 	lsl.w	lr, lr, ip
 8005f80:	ea4e 0e08 	orr.w	lr, lr, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8005f84:	2a02      	cmp	r2, #2
        GPIOx->PUPDR = temp;
 8005f86:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8005f8a:	f47f af6a 	bne.w	8005e62 <HAL_GPIO_Init+0x1e>
        temp = GPIOx->AFR[position >> 3U];
 8005f8e:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 8005f92:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8005f96:	f003 0e07 	and.w	lr, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8005f9a:	f8d8 9020 	ldr.w	r9, [r8, #32]
 8005f9e:	f8cd 9000 	str.w	r9, [sp]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8005fa2:	f8d1 9010 	ldr.w	r9, [r1, #16]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8005fa6:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8005faa:	fa09 f90e 	lsl.w	r9, r9, lr
 8005fae:	f8cd 9004 	str.w	r9, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8005fb2:	f04f 090f 	mov.w	r9, #15
 8005fb6:	fa09 fe0e 	lsl.w	lr, r9, lr
 8005fba:	f8dd 9000 	ldr.w	r9, [sp]
 8005fbe:	ea29 090e 	bic.w	r9, r9, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8005fc2:	f8dd e004 	ldr.w	lr, [sp, #4]
 8005fc6:	ea4e 0e09 	orr.w	lr, lr, r9
        GPIOx->AFR[position >> 3u] = temp;
 8005fca:	f8c8 e020 	str.w	lr, [r8, #32]
 8005fce:	e748      	b.n	8005e62 <HAL_GPIO_Init+0x1e>
  }
}
 8005fd0:	b003      	add	sp, #12
 8005fd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->PUPDR;
 8005fd6:	f8d0 800c 	ldr.w	r8, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005fda:	f8d1 e008 	ldr.w	lr, [r1, #8]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8005fde:	ea07 0808 	and.w	r8, r7, r8
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005fe2:	fa0e fe0c 	lsl.w	lr, lr, ip
 8005fe6:	ea4e 0e08 	orr.w	lr, lr, r8
        GPIOx->PUPDR = temp;
 8005fea:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8005fee:	e738      	b.n	8005e62 <HAL_GPIO_Init+0x1e>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8005ff0:	f04f 0c01 	mov.w	ip, #1
 8005ff4:	fa0c f707 	lsl.w	r7, ip, r7
 8005ff8:	ea48 0807 	orr.w	r8, r8, r7
 8005ffc:	e761      	b.n	8005ec2 <HAL_GPIO_Init+0x7e>
 8005ffe:	bf00      	nop
 8006000:	58000800 	.word	0x58000800
 8006004:	48000400 	.word	0x48000400
 8006008:	48000800 	.word	0x48000800

0800600c <HAL_GPIO_DeInit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
 800600c:	2900      	cmp	r1, #0
 800600e:	d074      	beq.n	80060fa <HAL_GPIO_DeInit+0xee>
{
 8006010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
 8006014:	2300      	movs	r3, #0
        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 &= ~(iocurrent);
        EXTI->C2EMR1 &= ~(iocurrent);
#else
        EXTI->IMR1 &= ~(iocurrent);
 8006016:	4e39      	ldr	r6, [pc, #228]	@ (80060fc <HAL_GPIO_DeInit+0xf0>)
    iocurrent = (GPIO_Pin) & (1uL << position);
 8006018:	f04f 0801 	mov.w	r8, #1
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 800601c:	f04f 0a07 	mov.w	sl, #7
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8006020:	f04f 0b0f 	mov.w	fp, #15
 8006024:	e047      	b.n	80060b6 <HAL_GPIO_DeInit+0xaa>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8006026:	f8df 90d8 	ldr.w	r9, [pc, #216]	@ 8006100 <HAL_GPIO_DeInit+0xf4>
 800602a:	4548      	cmp	r0, r9
 800602c:	d05d      	beq.n	80060ea <HAL_GPIO_DeInit+0xde>
 800602e:	f8df 90d4 	ldr.w	r9, [pc, #212]	@ 8006104 <HAL_GPIO_DeInit+0xf8>
 8006032:	4548      	cmp	r0, r9
 8006034:	d05c      	beq.n	80060f0 <HAL_GPIO_DeInit+0xe4>
 8006036:	4675      	mov	r5, lr
 8006038:	42af      	cmp	r7, r5
 800603a:	d117      	bne.n	800606c <HAL_GPIO_DeInit+0x60>
        EXTI->IMR1 &= ~(iocurrent);
 800603c:	f8d6 5080 	ldr.w	r5, [r6, #128]	@ 0x80
 8006040:	ea25 050c 	bic.w	r5, r5, ip
 8006044:	f8c6 5080 	str.w	r5, [r6, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
 8006048:	f8d6 5084 	ldr.w	r5, [r6, #132]	@ 0x84
 800604c:	ea25 050c 	bic.w	r5, r5, ip
 8006050:	f8c6 5084 	str.w	r5, [r6, #132]	@ 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 8006054:	6835      	ldr	r5, [r6, #0]
 8006056:	ea25 050c 	bic.w	r5, r5, ip
 800605a:	6035      	str	r5, [r6, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 800605c:	6875      	ldr	r5, [r6, #4]
 800605e:	ea25 050c 	bic.w	r5, r5, ip
 8006062:	6075      	str	r5, [r6, #4]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 8006064:	68a5      	ldr	r5, [r4, #8]
 8006066:	ea25 050e 	bic.w	r5, r5, lr
 800606a:	60a5      	str	r5, [r4, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800606c:	6805      	ldr	r5, [r0, #0]
 800606e:	2703      	movs	r7, #3
 8006070:	005c      	lsls	r4, r3, #1
 8006072:	fa07 f404 	lsl.w	r4, r7, r4
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8006076:	fa23 f707 	lsr.w	r7, r3, r7
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800607a:	4325      	orrs	r5, r4
 800607c:	eb00 0787 	add.w	r7, r0, r7, lsl #2
 8006080:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8006082:	f003 0507 	and.w	r5, r3, #7
 8006086:	f8d7 c020 	ldr.w	ip, [r7, #32]
 800608a:	00ad      	lsls	r5, r5, #2
 800608c:	fa0b f505 	lsl.w	r5, fp, r5
 8006090:	ea2c 0505 	bic.w	r5, ip, r5
 8006094:	623d      	str	r5, [r7, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8006096:	6885      	ldr	r5, [r0, #8]
 8006098:	ea25 0504 	bic.w	r5, r5, r4
 800609c:	6085      	str	r5, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 800609e:	6845      	ldr	r5, [r0, #4]
 80060a0:	ea25 0202 	bic.w	r2, r5, r2
 80060a4:	6042      	str	r2, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80060a6:	68c2      	ldr	r2, [r0, #12]
 80060a8:	ea22 0204 	bic.w	r2, r2, r4
 80060ac:	60c2      	str	r2, [r0, #12]
    }

    position++;
 80060ae:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00u)
 80060b0:	fa31 f203 	lsrs.w	r2, r1, r3
 80060b4:	d017      	beq.n	80060e6 <HAL_GPIO_DeInit+0xda>
    iocurrent = (GPIO_Pin) & (1uL << position);
 80060b6:	fa08 f203 	lsl.w	r2, r8, r3
    if (iocurrent != 0x00u)
 80060ba:	ea12 0c01 	ands.w	ip, r2, r1
 80060be:	d0f6      	beq.n	80060ae <HAL_GPIO_DeInit+0xa2>
      tmp = SYSCFG->EXTICR[position >> 2u];
 80060c0:	f023 0403 	bic.w	r4, r3, #3
 80060c4:	f104 4480 	add.w	r4, r4, #1073741824	@ 0x40000000
 80060c8:	f504 3480 	add.w	r4, r4, #65536	@ 0x10000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 80060cc:	f003 0503 	and.w	r5, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 80060d0:	68a7      	ldr	r7, [r4, #8]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 80060d2:	00ad      	lsls	r5, r5, #2
 80060d4:	fa0a fe05 	lsl.w	lr, sl, r5
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 80060d8:	f1b0 4f90 	cmp.w	r0, #1207959552	@ 0x48000000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 80060dc:	ea0e 0707 	and.w	r7, lr, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 80060e0:	d1a1      	bne.n	8006026 <HAL_GPIO_DeInit+0x1a>
 80060e2:	2500      	movs	r5, #0
 80060e4:	e7a8      	b.n	8006038 <HAL_GPIO_DeInit+0x2c>
  }
}
 80060e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 80060ea:	fa08 f505 	lsl.w	r5, r8, r5
 80060ee:	e7a3      	b.n	8006038 <HAL_GPIO_DeInit+0x2c>
 80060f0:	f04f 0902 	mov.w	r9, #2
 80060f4:	fa09 f505 	lsl.w	r5, r9, r5
 80060f8:	e79e      	b.n	8006038 <HAL_GPIO_DeInit+0x2c>
 80060fa:	4770      	bx	lr
 80060fc:	58000800 	.word	0x58000800
 8006100:	48000400 	.word	0x48000400
 8006104:	48000800 	.word	0x48000800

08006108 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8006108:	b10a      	cbz	r2, 800610e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800610a:	6181      	str	r1, [r0, #24]
 800610c:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800610e:	6281      	str	r1, [r0, #40]	@ 0x28
  }
}
 8006110:	4770      	bx	lr
 8006112:	bf00      	nop

08006114 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 8006114:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8006116:	ea01 0203 	and.w	r2, r1, r3
 800611a:	ea21 0103 	bic.w	r1, r1, r3
 800611e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8006122:	6181      	str	r1, [r0, #24]
}
 8006124:	4770      	bx	lr
 8006126:	bf00      	nop

08006128 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8006128:	4a04      	ldr	r2, [pc, #16]	@ (800613c <HAL_GPIO_EXTI_IRQHandler+0x14>)
 800612a:	68d1      	ldr	r1, [r2, #12]
 800612c:	4201      	tst	r1, r0
 800612e:	d100      	bne.n	8006132 <HAL_GPIO_EXTI_IRQHandler+0xa>
 8006130:	4770      	bx	lr
{
 8006132:	b508      	push	{r3, lr}
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8006134:	60d0      	str	r0, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8006136:	f003 ffbf 	bl	800a0b8 <HAL_GPIO_EXTI_Callback>
  }
}
 800613a:	bd08      	pop	{r3, pc}
 800613c:	58000800 	.word	0x58000800

08006140 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 8006140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006144:	4680      	mov	r8, r0
 8006146:	460d      	mov	r5, r1
 8006148:	4617      	mov	r7, r2
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800614a:	2610      	movs	r6, #16
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800614c:	f8d8 3000 	ldr.w	r3, [r8]
 8006150:	699c      	ldr	r4, [r3, #24]
 8006152:	f014 0402 	ands.w	r4, r4, #2
 8006156:	d163      	bne.n	8006220 <I2C_WaitOnTXISFlagUntilTimeout+0xe0>
  uint32_t itflag   = hi2c->Instance->ISR;
 8006158:	699a      	ldr	r2, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 800615a:	f012 0c10 	ands.w	ip, r2, #16
 800615e:	d05d      	beq.n	800621c <I2C_WaitOnTXISFlagUntilTimeout+0xdc>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006160:	1c68      	adds	r0, r5, #1
 8006162:	61de      	str	r6, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8006164:	d15f      	bne.n	8006226 <I2C_WaitOnTXISFlagUntilTimeout+0xe6>
 8006166:	699a      	ldr	r2, [r3, #24]
 8006168:	0691      	lsls	r1, r2, #26
 800616a:	d5fc      	bpl.n	8006166 <I2C_WaitOnTXISFlagUntilTimeout+0x26>

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800616c:	2220      	movs	r2, #32
 800616e:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
 8006170:	f044 0c04 	orr.w	ip, r4, #4

    status = HAL_ERROR;
 8006174:	2101      	movs	r1, #1
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
 8006176:	699a      	ldr	r2, [r3, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 8006178:	05d0      	lsls	r0, r2, #23
 800617a:	d534      	bpl.n	80061e6 <I2C_WaitOnTXISFlagUntilTimeout+0xa6>
  {
    error_code |= HAL_I2C_ERROR_BERR;

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800617c:	f44f 7180 	mov.w	r1, #256	@ 0x100

    status = HAL_ERROR;
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8006180:	0554      	lsls	r4, r2, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8006182:	61d9      	str	r1, [r3, #28]
    error_code |= HAL_I2C_ERROR_BERR;
 8006184:	f04c 0c01 	orr.w	ip, ip, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8006188:	d504      	bpl.n	8006194 <I2C_WaitOnTXISFlagUntilTimeout+0x54>
  {
    error_code |= HAL_I2C_ERROR_OVR;

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 800618a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 800618e:	61d9      	str	r1, [r3, #28]
    error_code |= HAL_I2C_ERROR_OVR;
 8006190:	f04c 0c08 	orr.w	ip, ip, #8

    status = HAL_ERROR;
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 8006194:	0595      	lsls	r5, r2, #22
 8006196:	d504      	bpl.n	80061a2 <I2C_WaitOnTXISFlagUntilTimeout+0x62>
  {
    error_code |= HAL_I2C_ERROR_ARLO;

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8006198:	f44f 7200 	mov.w	r2, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
 800619c:	f04c 0c02 	orr.w	ip, ip, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80061a0:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80061a2:	699a      	ldr	r2, [r3, #24]
 80061a4:	0790      	lsls	r0, r2, #30
    hi2c->Instance->TXDR = 0x00U;
 80061a6:	bf44      	itt	mi
 80061a8:	2200      	movmi	r2, #0
 80061aa:	629a      	strmi	r2, [r3, #40]	@ 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80061ac:	699a      	ldr	r2, [r3, #24]
 80061ae:	07d1      	lsls	r1, r2, #31
 80061b0:	d403      	bmi.n	80061ba <I2C_WaitOnTXISFlagUntilTimeout+0x7a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80061b2:	699a      	ldr	r2, [r3, #24]
 80061b4:	f042 0201 	orr.w	r2, r2, #1
 80061b8:	619a      	str	r2, [r3, #24]
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80061ba:	685a      	ldr	r2, [r3, #4]
 80061bc:	4838      	ldr	r0, [pc, #224]	@ (80062a0 <I2C_WaitOnTXISFlagUntilTimeout+0x160>)
 80061be:	4002      	ands	r2, r0
 80061c0:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= error_code;
 80061c2:	f8d8 3044 	ldr.w	r3, [r8, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80061c6:	2120      	movs	r1, #32
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80061c8:	2200      	movs	r2, #0
    hi2c->ErrorCode |= error_code;
 80061ca:	ea43 030c 	orr.w	r3, r3, ip
 80061ce:	f8c8 3044 	str.w	r3, [r8, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80061d2:	f888 1041 	strb.w	r1, [r8, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80061d6:	f888 2042 	strb.w	r2, [r8, #66]	@ 0x42
        __HAL_UNLOCK(hi2c);
 80061da:	2300      	movs	r3, #0
 80061dc:	f888 3040 	strb.w	r3, [r8, #64]	@ 0x40
      return HAL_ERROR;
 80061e0:	2001      	movs	r0, #1
}
 80061e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 80061e6:	0550      	lsls	r0, r2, #21
 80061e8:	d4cf      	bmi.n	800618a <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80061ea:	0594      	lsls	r4, r2, #22
 80061ec:	d4d4      	bmi.n	8006198 <I2C_WaitOnTXISFlagUntilTimeout+0x58>
  if (status != HAL_OK)
 80061ee:	2900      	cmp	r1, #0
 80061f0:	d1d7      	bne.n	80061a2 <I2C_WaitOnTXISFlagUntilTimeout+0x62>
    if (Timeout != HAL_MAX_DELAY)
 80061f2:	1c6a      	adds	r2, r5, #1
 80061f4:	d0ac      	beq.n	8006150 <I2C_WaitOnTXISFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80061f6:	f7fb fce7 	bl	8001bc8 <HAL_GetTick>
 80061fa:	1bc3      	subs	r3, r0, r7
 80061fc:	42ab      	cmp	r3, r5
 80061fe:	d801      	bhi.n	8006204 <I2C_WaitOnTXISFlagUntilTimeout+0xc4>
 8006200:	2d00      	cmp	r5, #0
 8006202:	d1a3      	bne.n	800614c <I2C_WaitOnTXISFlagUntilTimeout+0xc>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006204:	f8d8 3044 	ldr.w	r3, [r8, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006208:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800620a:	430b      	orrs	r3, r1
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800620c:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800620e:	f8c8 3044 	str.w	r3, [r8, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006212:	f888 1041 	strb.w	r1, [r8, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006216:	f888 2042 	strb.w	r2, [r8, #66]	@ 0x42
        return HAL_ERROR;
 800621a:	e7de      	b.n	80061da <I2C_WaitOnTXISFlagUntilTimeout+0x9a>
  HAL_StatusTypeDef status = HAL_OK;
 800621c:	4661      	mov	r1, ip
 800621e:	e7aa      	b.n	8006176 <I2C_WaitOnTXISFlagUntilTimeout+0x36>
  return HAL_OK;
 8006220:	2000      	movs	r0, #0
}
 8006222:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  uint32_t tickstart = Tickstart;
 8006226:	46b9      	mov	r9, r7
  HAL_StatusTypeDef status = HAL_OK;
 8006228:	46a2      	mov	sl, r4
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 800622a:	699a      	ldr	r2, [r3, #24]
 800622c:	0692      	lsls	r2, r2, #26
 800622e:	d432      	bmi.n	8006296 <I2C_WaitOnTXISFlagUntilTimeout+0x156>
 8006230:	f1ba 0f00 	cmp.w	sl, #0
 8006234:	d19c      	bne.n	8006170 <I2C_WaitOnTXISFlagUntilTimeout+0x30>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8006236:	f7fb fcc7 	bl	8001bc8 <HAL_GetTick>
 800623a:	eba0 0009 	sub.w	r0, r0, r9
 800623e:	4285      	cmp	r5, r0
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8006240:	f8d8 3000 	ldr.w	r3, [r8]
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8006244:	d301      	bcc.n	800624a <I2C_WaitOnTXISFlagUntilTimeout+0x10a>
 8006246:	2d00      	cmp	r5, #0
 8006248:	d1ef      	bne.n	800622a <I2C_WaitOnTXISFlagUntilTimeout+0xea>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 800624a:	6858      	ldr	r0, [r3, #4]
          tmp2 = hi2c->Mode;
 800624c:	f898 2042 	ldrb.w	r2, [r8, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 8006250:	6999      	ldr	r1, [r3, #24]
 8006252:	0409      	lsls	r1, r1, #16
          tmp2 = hi2c->Mode;
 8006254:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 8006256:	d50c      	bpl.n	8006272 <I2C_WaitOnTXISFlagUntilTimeout+0x132>
 8006258:	0441      	lsls	r1, r0, #17
 800625a:	d40a      	bmi.n	8006272 <I2C_WaitOnTXISFlagUntilTimeout+0x132>
              (tmp1 != I2C_CR2_STOP) && \
 800625c:	2a20      	cmp	r2, #32
 800625e:	d008      	beq.n	8006272 <I2C_WaitOnTXISFlagUntilTimeout+0x132>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 8006260:	685a      	ldr	r2, [r3, #4]
 8006262:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8006266:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
 8006268:	f7fb fcae 	bl	8001bc8 <HAL_GetTick>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800626c:	f8d8 3000 	ldr.w	r3, [r8]
            tickstart = HAL_GetTick();
 8006270:	4681      	mov	r9, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006272:	699a      	ldr	r2, [r3, #24]
 8006274:	0690      	lsls	r0, r2, #26
 8006276:	d4d8      	bmi.n	800622a <I2C_WaitOnTXISFlagUntilTimeout+0xea>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 8006278:	f7fb fca6 	bl	8001bc8 <HAL_GetTick>
 800627c:	eba0 0009 	sub.w	r0, r0, r9
 8006280:	2819      	cmp	r0, #25
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8006282:	f8d8 3000 	ldr.w	r3, [r8]
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 8006286:	d9f4      	bls.n	8006272 <I2C_WaitOnTXISFlagUntilTimeout+0x132>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8006288:	699a      	ldr	r2, [r3, #24]
 800628a:	0692      	lsls	r2, r2, #26
              error_code |=HAL_I2C_ERROR_TIMEOUT;
 800628c:	f04f 0420 	mov.w	r4, #32
              status = HAL_ERROR;
 8006290:	f04f 0a01 	mov.w	sl, #1
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8006294:	d5cc      	bpl.n	8006230 <I2C_WaitOnTXISFlagUntilTimeout+0xf0>
    if (status == HAL_OK)
 8006296:	f1ba 0f00 	cmp.w	sl, #0
 800629a:	f43f af67 	beq.w	800616c <I2C_WaitOnTXISFlagUntilTimeout+0x2c>
 800629e:	e767      	b.n	8006170 <I2C_WaitOnTXISFlagUntilTimeout+0x30>
 80062a0:	fe00e800 	.word	0xfe00e800

080062a4 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 80062a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80062a8:	4604      	mov	r4, r0
 80062aa:	460d      	mov	r5, r1
 80062ac:	4616      	mov	r6, r2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80062ae:	2710      	movs	r7, #16
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80062b0:	6823      	ldr	r3, [r4, #0]
 80062b2:	6998      	ldr	r0, [r3, #24]
 80062b4:	f010 0820 	ands.w	r8, r0, #32
 80062b8:	d15d      	bne.n	8006376 <I2C_WaitOnSTOPFlagUntilTimeout+0xd2>
  uint32_t itflag   = hi2c->Instance->ISR;
 80062ba:	699a      	ldr	r2, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 80062bc:	f012 0c10 	ands.w	ip, r2, #16
 80062c0:	d057      	beq.n	8006372 <I2C_WaitOnSTOPFlagUntilTimeout+0xce>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80062c2:	1c68      	adds	r0, r5, #1
 80062c4:	61df      	str	r7, [r3, #28]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80062c6:	d159      	bne.n	800637c <I2C_WaitOnSTOPFlagUntilTimeout+0xd8>
 80062c8:	699a      	ldr	r2, [r3, #24]
 80062ca:	0691      	lsls	r1, r2, #26
 80062cc:	d5fc      	bpl.n	80062c8 <I2C_WaitOnSTOPFlagUntilTimeout+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80062ce:	2220      	movs	r2, #32
 80062d0:	61da      	str	r2, [r3, #28]
    error_code |= HAL_I2C_ERROR_AF;
 80062d2:	f048 0c04 	orr.w	ip, r8, #4
    status = HAL_ERROR;
 80062d6:	2101      	movs	r1, #1
  itflag = hi2c->Instance->ISR;
 80062d8:	699a      	ldr	r2, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 80062da:	05d0      	lsls	r0, r2, #23
 80062dc:	d532      	bpl.n	8006344 <I2C_WaitOnSTOPFlagUntilTimeout+0xa0>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 80062de:	f44f 7180 	mov.w	r1, #256	@ 0x100
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 80062e2:	0555      	lsls	r5, r2, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 80062e4:	61d9      	str	r1, [r3, #28]
    error_code |= HAL_I2C_ERROR_BERR;
 80062e6:	f04c 0c01 	orr.w	ip, ip, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 80062ea:	d504      	bpl.n	80062f6 <I2C_WaitOnSTOPFlagUntilTimeout+0x52>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 80062ec:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 80062f0:	61d9      	str	r1, [r3, #28]
    error_code |= HAL_I2C_ERROR_OVR;
 80062f2:	f04c 0c08 	orr.w	ip, ip, #8
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80062f6:	0595      	lsls	r5, r2, #22
 80062f8:	d504      	bpl.n	8006304 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80062fa:	f44f 7200 	mov.w	r2, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
 80062fe:	f04c 0c02 	orr.w	ip, ip, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8006302:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8006304:	699a      	ldr	r2, [r3, #24]
 8006306:	0791      	lsls	r1, r2, #30
    hi2c->Instance->TXDR = 0x00U;
 8006308:	bf44      	itt	mi
 800630a:	2200      	movmi	r2, #0
 800630c:	629a      	strmi	r2, [r3, #40]	@ 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800630e:	699a      	ldr	r2, [r3, #24]
 8006310:	07d2      	lsls	r2, r2, #31
 8006312:	d403      	bmi.n	800631c <I2C_WaitOnSTOPFlagUntilTimeout+0x78>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8006314:	699a      	ldr	r2, [r3, #24]
 8006316:	f042 0201 	orr.w	r2, r2, #1
 800631a:	619a      	str	r2, [r3, #24]
    I2C_RESET_CR2(hi2c);
 800631c:	685a      	ldr	r2, [r3, #4]
 800631e:	4833      	ldr	r0, [pc, #204]	@ (80063ec <I2C_WaitOnSTOPFlagUntilTimeout+0x148>)
 8006320:	4002      	ands	r2, r0
 8006322:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= error_code;
 8006324:	6c63      	ldr	r3, [r4, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8006326:	2120      	movs	r1, #32
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8006328:	2200      	movs	r2, #0
    hi2c->ErrorCode |= error_code;
 800632a:	ea43 030c 	orr.w	r3, r3, ip
 800632e:	6463      	str	r3, [r4, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8006330:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8006334:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
 8006338:	2300      	movs	r3, #0
 800633a:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
 800633e:	2001      	movs	r0, #1
}
 8006340:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8006344:	0550      	lsls	r0, r2, #21
 8006346:	d4d1      	bmi.n	80062ec <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 8006348:	0590      	lsls	r0, r2, #22
 800634a:	d4d6      	bmi.n	80062fa <I2C_WaitOnSTOPFlagUntilTimeout+0x56>
  if (status != HAL_OK)
 800634c:	2900      	cmp	r1, #0
 800634e:	d1d9      	bne.n	8006304 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006350:	f7fb fc3a 	bl	8001bc8 <HAL_GetTick>
 8006354:	1b80      	subs	r0, r0, r6
 8006356:	42a8      	cmp	r0, r5
 8006358:	d801      	bhi.n	800635e <I2C_WaitOnSTOPFlagUntilTimeout+0xba>
 800635a:	2d00      	cmp	r5, #0
 800635c:	d1a8      	bne.n	80062b0 <I2C_WaitOnSTOPFlagUntilTimeout+0xc>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800635e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8006360:	2120      	movs	r1, #32
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006362:	430b      	orrs	r3, r1
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8006364:	2200      	movs	r2, #0
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006366:	6463      	str	r3, [r4, #68]	@ 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8006368:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800636c:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
      return HAL_ERROR;
 8006370:	e7e2      	b.n	8006338 <I2C_WaitOnSTOPFlagUntilTimeout+0x94>
  HAL_StatusTypeDef status = HAL_OK;
 8006372:	4661      	mov	r1, ip
 8006374:	e7b0      	b.n	80062d8 <I2C_WaitOnSTOPFlagUntilTimeout+0x34>
  return HAL_OK;
 8006376:	2000      	movs	r0, #0
}
 8006378:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  uint32_t tickstart = Tickstart;
 800637c:	46b1      	mov	r9, r6
  HAL_StatusTypeDef status = HAL_OK;
 800637e:	46c2      	mov	sl, r8
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8006380:	699a      	ldr	r2, [r3, #24]
 8006382:	0692      	lsls	r2, r2, #26
 8006384:	d42d      	bmi.n	80063e2 <I2C_WaitOnSTOPFlagUntilTimeout+0x13e>
 8006386:	f1ba 0f00 	cmp.w	sl, #0
 800638a:	d1a2      	bne.n	80062d2 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800638c:	f7fb fc1c 	bl	8001bc8 <HAL_GetTick>
 8006390:	eba0 0009 	sub.w	r0, r0, r9
 8006394:	4285      	cmp	r5, r0
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8006396:	6823      	ldr	r3, [r4, #0]
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8006398:	d301      	bcc.n	800639e <I2C_WaitOnSTOPFlagUntilTimeout+0xfa>
 800639a:	2d00      	cmp	r5, #0
 800639c:	d1f0      	bne.n	8006380 <I2C_WaitOnSTOPFlagUntilTimeout+0xdc>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 800639e:	6858      	ldr	r0, [r3, #4]
          tmp2 = hi2c->Mode;
 80063a0:	f894 2042 	ldrb.w	r2, [r4, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 80063a4:	6999      	ldr	r1, [r3, #24]
 80063a6:	0409      	lsls	r1, r1, #16
          tmp2 = hi2c->Mode;
 80063a8:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 80063aa:	d50b      	bpl.n	80063c4 <I2C_WaitOnSTOPFlagUntilTimeout+0x120>
 80063ac:	0441      	lsls	r1, r0, #17
 80063ae:	d409      	bmi.n	80063c4 <I2C_WaitOnSTOPFlagUntilTimeout+0x120>
              (tmp1 != I2C_CR2_STOP) && \
 80063b0:	2a20      	cmp	r2, #32
 80063b2:	d007      	beq.n	80063c4 <I2C_WaitOnSTOPFlagUntilTimeout+0x120>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 80063b4:	685a      	ldr	r2, [r3, #4]
 80063b6:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 80063ba:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
 80063bc:	f7fb fc04 	bl	8001bc8 <HAL_GetTick>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80063c0:	6823      	ldr	r3, [r4, #0]
            tickstart = HAL_GetTick();
 80063c2:	4681      	mov	r9, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80063c4:	699a      	ldr	r2, [r3, #24]
 80063c6:	0690      	lsls	r0, r2, #26
 80063c8:	d4da      	bmi.n	8006380 <I2C_WaitOnSTOPFlagUntilTimeout+0xdc>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 80063ca:	f7fb fbfd 	bl	8001bc8 <HAL_GetTick>
 80063ce:	eba0 0009 	sub.w	r0, r0, r9
 80063d2:	2819      	cmp	r0, #25
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80063d4:	6823      	ldr	r3, [r4, #0]
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 80063d6:	d9f5      	bls.n	80063c4 <I2C_WaitOnSTOPFlagUntilTimeout+0x120>
              error_code |=HAL_I2C_ERROR_TIMEOUT;
 80063d8:	f04f 0820 	mov.w	r8, #32
              status = HAL_ERROR;
 80063dc:	f04f 0a01 	mov.w	sl, #1
 80063e0:	e7ce      	b.n	8006380 <I2C_WaitOnSTOPFlagUntilTimeout+0xdc>
    if (status == HAL_OK)
 80063e2:	f1ba 0f00 	cmp.w	sl, #0
 80063e6:	f43f af72 	beq.w	80062ce <I2C_WaitOnSTOPFlagUntilTimeout+0x2a>
 80063ea:	e772      	b.n	80062d2 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
 80063ec:	fe00e800 	.word	0xfe00e800

080063f0 <HAL_I2C_Init>:
  if (hi2c == NULL)
 80063f0:	2800      	cmp	r0, #0
 80063f2:	d04f      	beq.n	8006494 <HAL_I2C_Init+0xa4>
{
 80063f4:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_RESET)
 80063f6:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
 80063fa:	4604      	mov	r4, r0
 80063fc:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8006400:	2b00      	cmp	r3, #0
 8006402:	d042      	beq.n	800648a <HAL_I2C_Init+0x9a>
  __HAL_I2C_DISABLE(hi2c);
 8006404:	6823      	ldr	r3, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8006406:	2224      	movs	r2, #36	@ 0x24
 8006408:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
 800640c:	6819      	ldr	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800640e:	6862      	ldr	r2, [r4, #4]
  __HAL_I2C_DISABLE(hi2c);
 8006410:	f021 0101 	bic.w	r1, r1, #1
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8006414:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
  __HAL_I2C_DISABLE(hi2c);
 8006418:	6019      	str	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800641a:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800641c:	689a      	ldr	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800641e:	68e1      	ldr	r1, [r4, #12]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8006420:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8006424:	2901      	cmp	r1, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8006426:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8006428:	68a2      	ldr	r2, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800642a:	d02a      	beq.n	8006482 <HAL_I2C_Init+0x92>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800642c:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8006430:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8006432:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8006434:	bf04      	itt	eq
 8006436:	f44f 6200 	moveq.w	r2, #2048	@ 0x800
 800643a:	605a      	streq	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800643c:	6859      	ldr	r1, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 800643e:	6922      	ldr	r2, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8006440:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 8006444:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
 8006448:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 800644a:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800644c:	68d8      	ldr	r0, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 800644e:	430a      	orrs	r2, r1
                          (hi2c->Init.OwnAddress2Masks << 8));
 8006450:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8006452:	f420 4000 	bic.w	r0, r0, #32768	@ 0x8000
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 8006456:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800645a:	69e1      	ldr	r1, [r4, #28]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800645c:	60d8      	str	r0, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800645e:	6a20      	ldr	r0, [r4, #32]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 8006460:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8006462:	4301      	orrs	r1, r0
 8006464:	6019      	str	r1, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8006466:	6819      	ldr	r1, [r3, #0]
 8006468:	f041 0101 	orr.w	r1, r1, #1
 800646c:	6019      	str	r1, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800646e:	2200      	movs	r2, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8006470:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006472:	6462      	str	r2, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8006474:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8006478:	6322      	str	r2, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800647a:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
  return HAL_OK;
 800647e:	4610      	mov	r0, r2
}
 8006480:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8006482:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 8006486:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8006488:	e7d8      	b.n	800643c <HAL_I2C_Init+0x4c>
    hi2c->Lock = HAL_UNLOCKED;
 800648a:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
 800648e:	f7fa ff53 	bl	8001338 <HAL_I2C_MspInit>
 8006492:	e7b7      	b.n	8006404 <HAL_I2C_Init+0x14>
    return HAL_ERROR;
 8006494:	2001      	movs	r0, #1
}
 8006496:	4770      	bx	lr

08006498 <HAL_I2C_Mem_Write>:
{
 8006498:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800649c:	4699      	mov	r9, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 800649e:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
 80064a2:	f8bd b02c 	ldrh.w	fp, [sp, #44]	@ 0x2c
 80064a6:	f8dd a030 	ldr.w	sl, [sp, #48]	@ 0x30
  if (hi2c->State == HAL_I2C_STATE_READY)
 80064aa:	2b20      	cmp	r3, #32
 80064ac:	f040 809f 	bne.w	80065ee <HAL_I2C_Mem_Write+0x156>
    if ((pData == NULL) || (Size == 0U))
 80064b0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80064b2:	4604      	mov	r4, r0
 80064b4:	2b00      	cmp	r3, #0
 80064b6:	f000 8094 	beq.w	80065e2 <HAL_I2C_Mem_Write+0x14a>
 80064ba:	f1bb 0f00 	cmp.w	fp, #0
 80064be:	f000 8090 	beq.w	80065e2 <HAL_I2C_Mem_Write+0x14a>
    __HAL_LOCK(hi2c);
 80064c2:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
 80064c6:	2b01      	cmp	r3, #1
 80064c8:	f000 8091 	beq.w	80065ee <HAL_I2C_Mem_Write+0x156>
 80064cc:	2301      	movs	r3, #1
 80064ce:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
 80064d2:	460f      	mov	r7, r1
 80064d4:	4690      	mov	r8, r2
    tickstart = HAL_GetTick();
 80064d6:	f7fb fb77 	bl	8001bc8 <HAL_GetTick>
 80064da:	4606      	mov	r6, r0
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
 80064dc:	e005      	b.n	80064ea <HAL_I2C_Mem_Write+0x52>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80064de:	f7fb fb73 	bl	8001bc8 <HAL_GetTick>
 80064e2:	1b80      	subs	r0, r0, r6
 80064e4:	2819      	cmp	r0, #25
 80064e6:	f200 8085 	bhi.w	80065f4 <HAL_I2C_Mem_Write+0x15c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80064ea:	6823      	ldr	r3, [r4, #0]
 80064ec:	699d      	ldr	r5, [r3, #24]
 80064ee:	f415 4500 	ands.w	r5, r5, #32768	@ 0x8000
 80064f2:	d1f4      	bne.n	80064de <HAL_I2C_Mem_Write+0x46>
    hi2c->pBuffPtr  = pData;
 80064f4:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80064f6:	6262      	str	r2, [r4, #36]	@ 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80064f8:	2221      	movs	r2, #33	@ 0x21
 80064fa:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80064fe:	2240      	movs	r2, #64	@ 0x40
 8006500:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006504:	6465      	str	r5, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
 8006506:	f8a4 b02a 	strh.w	fp, [r4, #42]	@ 0x2a
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                             (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
 800650a:	685a      	ldr	r2, [r3, #4]
 800650c:	4973      	ldr	r1, [pc, #460]	@ (80066dc <HAL_I2C_Mem_Write+0x244>)
    hi2c->XferISR   = NULL;
 800650e:	6365      	str	r5, [r4, #52]	@ 0x34
  MODIFY_REG(hi2c->Instance->CR2, \
 8006510:	400a      	ands	r2, r1
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8006512:	fa5f f189 	uxtb.w	r1, r9
  MODIFY_REG(hi2c->Instance->CR2, \
 8006516:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 800651a:	f3c7 0709 	ubfx	r7, r7, #0, #10
  MODIFY_REG(hi2c->Instance->CR2, \
 800651e:	433a      	orrs	r2, r7
 8006520:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 8006524:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8006528:	605a      	str	r2, [r3, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800652a:	4651      	mov	r1, sl
 800652c:	4632      	mov	r2, r6
 800652e:	4620      	mov	r0, r4
 8006530:	f7ff fe06 	bl	8006140 <I2C_WaitOnTXISFlagUntilTimeout>
 8006534:	2800      	cmp	r0, #0
 8006536:	f040 80a9 	bne.w	800668c <HAL_I2C_Mem_Write+0x1f4>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800653a:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800653e:	6822      	ldr	r2, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8006540:	d17f      	bne.n	8006642 <HAL_I2C_Mem_Write+0x1aa>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006542:	fa5f f388 	uxtb.w	r3, r8
 8006546:	6293      	str	r3, [r2, #40]	@ 0x28
 8006548:	f1ba 3fff 	cmp.w	sl, #4294967295
 800654c:	d175      	bne.n	800663a <HAL_I2C_Mem_Write+0x1a2>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800654e:	6993      	ldr	r3, [r2, #24]
 8006550:	061d      	lsls	r5, r3, #24
 8006552:	d5fc      	bpl.n	800654e <HAL_I2C_Mem_Write+0xb6>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006554:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 8006556:	b29b      	uxth	r3, r3
 8006558:	2bff      	cmp	r3, #255	@ 0xff
 800655a:	f240 809b 	bls.w	8006694 <HAL_I2C_Mem_Write+0x1fc>
  MODIFY_REG(hi2c->Instance->CR2, \
 800655e:	6853      	ldr	r3, [r2, #4]
 8006560:	495f      	ldr	r1, [pc, #380]	@ (80066e0 <HAL_I2C_Mem_Write+0x248>)
 8006562:	400b      	ands	r3, r1
 8006564:	433b      	orrs	r3, r7
 8006566:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
 800656a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800656e:	21ff      	movs	r1, #255	@ 0xff
 8006570:	8521      	strh	r1, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 8006572:	6053      	str	r3, [r2, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
 8006574:	e004      	b.n	8006580 <HAL_I2C_Mem_Write+0xe8>
    } while (hi2c->XferCount > 0U);
 8006576:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 8006578:	b29b      	uxth	r3, r3
 800657a:	2b00      	cmp	r3, #0
 800657c:	f000 8098 	beq.w	80066b0 <HAL_I2C_Mem_Write+0x218>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006580:	4632      	mov	r2, r6
 8006582:	4651      	mov	r1, sl
 8006584:	4620      	mov	r0, r4
 8006586:	f7ff fddb 	bl	8006140 <I2C_WaitOnTXISFlagUntilTimeout>
 800658a:	2800      	cmp	r0, #0
 800658c:	d12c      	bne.n	80065e8 <HAL_I2C_Mem_Write+0x150>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800658e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8006590:	6822      	ldr	r2, [r4, #0]
 8006592:	f813 1b01 	ldrb.w	r1, [r3], #1
 8006596:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
 8006598:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
 800659a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 800659c:	3b01      	subs	r3, #1
 800659e:	b29b      	uxth	r3, r3
 80065a0:	8563      	strh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 80065a2:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80065a4:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 80065a6:	3b01      	subs	r3, #1
 80065a8:	b29b      	uxth	r3, r3
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80065aa:	b289      	uxth	r1, r1
      hi2c->XferSize--;
 80065ac:	8523      	strh	r3, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80065ae:	2900      	cmp	r1, #0
 80065b0:	d0e1      	beq.n	8006576 <HAL_I2C_Mem_Write+0xde>
 80065b2:	2b00      	cmp	r3, #0
 80065b4:	d1df      	bne.n	8006576 <HAL_I2C_Mem_Write+0xde>
 80065b6:	f1ba 3fff 	cmp.w	sl, #4294967295
 80065ba:	d131      	bne.n	8006620 <HAL_I2C_Mem_Write+0x188>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80065bc:	6993      	ldr	r3, [r2, #24]
 80065be:	0619      	lsls	r1, r3, #24
 80065c0:	d5fc      	bpl.n	80065bc <HAL_I2C_Mem_Write+0x124>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80065c2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 80065c4:	b29b      	uxth	r3, r3
 80065c6:	2bff      	cmp	r3, #255	@ 0xff
 80065c8:	d949      	bls.n	800665e <HAL_I2C_Mem_Write+0x1c6>
  MODIFY_REG(hi2c->Instance->CR2, \
 80065ca:	6853      	ldr	r3, [r2, #4]
 80065cc:	4944      	ldr	r1, [pc, #272]	@ (80066e0 <HAL_I2C_Mem_Write+0x248>)
 80065ce:	400b      	ands	r3, r1
 80065d0:	433b      	orrs	r3, r7
 80065d2:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
 80065d6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80065da:	21ff      	movs	r1, #255	@ 0xff
 80065dc:	8521      	strh	r1, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 80065de:	6053      	str	r3, [r2, #4]
}
 80065e0:	e7c9      	b.n	8006576 <HAL_I2C_Mem_Write+0xde>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80065e2:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80065e6:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
 80065e8:	2001      	movs	r0, #1
}
 80065ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
 80065ee:	2002      	movs	r0, #2
}
 80065f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80065f4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80065f6:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80065f8:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 80065fc:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80065fe:	6463      	str	r3, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
 8006600:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 8006604:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006608:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
        return HAL_ERROR;
 800660c:	e7ec      	b.n	80065e8 <HAL_I2C_Mem_Write+0x150>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800660e:	f7fb fadb 	bl	8001bc8 <HAL_GetTick>
 8006612:	1b80      	subs	r0, r0, r6
 8006614:	4582      	cmp	sl, r0
 8006616:	d3ed      	bcc.n	80065f4 <HAL_I2C_Mem_Write+0x15c>
 8006618:	f1ba 0f00 	cmp.w	sl, #0
 800661c:	d0ea      	beq.n	80065f4 <HAL_I2C_Mem_Write+0x15c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800661e:	6822      	ldr	r2, [r4, #0]
 8006620:	6993      	ldr	r3, [r2, #24]
 8006622:	061b      	lsls	r3, r3, #24
 8006624:	d5f3      	bpl.n	800660e <HAL_I2C_Mem_Write+0x176>
 8006626:	e7cc      	b.n	80065c2 <HAL_I2C_Mem_Write+0x12a>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006628:	f7fb face 	bl	8001bc8 <HAL_GetTick>
 800662c:	1b80      	subs	r0, r0, r6
 800662e:	4582      	cmp	sl, r0
 8006630:	d323      	bcc.n	800667a <HAL_I2C_Mem_Write+0x1e2>
 8006632:	f1ba 0f00 	cmp.w	sl, #0
 8006636:	d020      	beq.n	800667a <HAL_I2C_Mem_Write+0x1e2>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8006638:	6822      	ldr	r2, [r4, #0]
 800663a:	6993      	ldr	r3, [r2, #24]
 800663c:	0618      	lsls	r0, r3, #24
 800663e:	d5f3      	bpl.n	8006628 <HAL_I2C_Mem_Write+0x190>
 8006640:	e788      	b.n	8006554 <HAL_I2C_Mem_Write+0xbc>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8006642:	ea4f 2318 	mov.w	r3, r8, lsr #8
 8006646:	6293      	str	r3, [r2, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006648:	4651      	mov	r1, sl
 800664a:	4632      	mov	r2, r6
 800664c:	4620      	mov	r0, r4
 800664e:	f7ff fd77 	bl	8006140 <I2C_WaitOnTXISFlagUntilTimeout>
 8006652:	b9d8      	cbnz	r0, 800668c <HAL_I2C_Mem_Write+0x1f4>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006654:	6822      	ldr	r2, [r4, #0]
 8006656:	fa5f f388 	uxtb.w	r3, r8
 800665a:	6293      	str	r3, [r2, #40]	@ 0x28
 800665c:	e774      	b.n	8006548 <HAL_I2C_Mem_Write+0xb0>
          hi2c->XferSize = hi2c->XferCount;
 800665e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8006660:	481f      	ldr	r0, [pc, #124]	@ (80066e0 <HAL_I2C_Mem_Write+0x248>)
          hi2c->XferSize = hi2c->XferCount;
 8006662:	b29b      	uxth	r3, r3
 8006664:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8006666:	b2d9      	uxtb	r1, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8006668:	6853      	ldr	r3, [r2, #4]
 800666a:	4003      	ands	r3, r0
 800666c:	433b      	orrs	r3, r7
 800666e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8006672:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8006676:	6053      	str	r3, [r2, #4]
}
 8006678:	e77d      	b.n	8006576 <HAL_I2C_Mem_Write+0xde>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800667a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800667c:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800667e:	430b      	orrs	r3, r1
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006680:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006682:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006684:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006688:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
 800668c:	2300      	movs	r3, #0
 800668e:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
 8006692:	e7a9      	b.n	80065e8 <HAL_I2C_Mem_Write+0x150>
      hi2c->XferSize = hi2c->XferCount;
 8006694:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8006696:	4812      	ldr	r0, [pc, #72]	@ (80066e0 <HAL_I2C_Mem_Write+0x248>)
      hi2c->XferSize = hi2c->XferCount;
 8006698:	b29b      	uxth	r3, r3
 800669a:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 800669c:	b2d9      	uxtb	r1, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 800669e:	6853      	ldr	r3, [r2, #4]
 80066a0:	4003      	ands	r3, r0
 80066a2:	433b      	orrs	r3, r7
 80066a4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80066a8:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 80066ac:	6053      	str	r3, [r2, #4]
}
 80066ae:	e767      	b.n	8006580 <HAL_I2C_Mem_Write+0xe8>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80066b0:	4632      	mov	r2, r6
 80066b2:	4651      	mov	r1, sl
 80066b4:	4620      	mov	r0, r4
 80066b6:	f7ff fdf5 	bl	80062a4 <I2C_WaitOnSTOPFlagUntilTimeout>
 80066ba:	2800      	cmp	r0, #0
 80066bc:	d194      	bne.n	80065e8 <HAL_I2C_Mem_Write+0x150>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80066be:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 80066c0:	4d08      	ldr	r5, [pc, #32]	@ (80066e4 <HAL_I2C_Mem_Write+0x24c>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80066c2:	2120      	movs	r1, #32
 80066c4:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 80066c6:	685a      	ldr	r2, [r3, #4]
 80066c8:	402a      	ands	r2, r5
 80066ca:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80066cc:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 80066d0:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 80066d4:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
 80066d8:	e787      	b.n	80065ea <HAL_I2C_Mem_Write+0x152>
 80066da:	bf00      	nop
 80066dc:	fc009800 	.word	0xfc009800
 80066e0:	fc009c00 	.word	0xfc009c00
 80066e4:	fe00e800 	.word	0xfe00e800

080066e8 <HAL_I2C_Mem_Read>:
{
 80066e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80066ec:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 80066ee:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
 80066f2:	f8bd a024 	ldrh.w	sl, [sp, #36]	@ 0x24
 80066f6:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
 80066f8:	2b20      	cmp	r3, #32
 80066fa:	d17f      	bne.n	80067fc <HAL_I2C_Mem_Read+0x114>
    if ((pData == NULL) || (Size == 0U))
 80066fc:	9b08      	ldr	r3, [sp, #32]
 80066fe:	4604      	mov	r4, r0
 8006700:	2b00      	cmp	r3, #0
 8006702:	d075      	beq.n	80067f0 <HAL_I2C_Mem_Read+0x108>
 8006704:	f1ba 0f00 	cmp.w	sl, #0
 8006708:	d072      	beq.n	80067f0 <HAL_I2C_Mem_Read+0x108>
    __HAL_LOCK(hi2c);
 800670a:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
 800670e:	2b01      	cmp	r3, #1
 8006710:	d074      	beq.n	80067fc <HAL_I2C_Mem_Read+0x114>
 8006712:	2301      	movs	r3, #1
 8006714:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
 8006718:	460f      	mov	r7, r1
 800671a:	4691      	mov	r9, r2
    tickstart = HAL_GetTick();
 800671c:	f7fb fa54 	bl	8001bc8 <HAL_GetTick>
 8006720:	4605      	mov	r5, r0
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
 8006722:	e004      	b.n	800672e <HAL_I2C_Mem_Read+0x46>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006724:	f7fb fa50 	bl	8001bc8 <HAL_GetTick>
 8006728:	1b40      	subs	r0, r0, r5
 800672a:	2819      	cmp	r0, #25
 800672c:	d869      	bhi.n	8006802 <HAL_I2C_Mem_Read+0x11a>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800672e:	6823      	ldr	r3, [r4, #0]
 8006730:	6998      	ldr	r0, [r3, #24]
 8006732:	f410 4000 	ands.w	r0, r0, #32768	@ 0x8000
 8006736:	d1f5      	bne.n	8006724 <HAL_I2C_Mem_Read+0x3c>
    hi2c->pBuffPtr  = pData;
 8006738:	9a08      	ldr	r2, [sp, #32]
 800673a:	6262      	str	r2, [r4, #36]	@ 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800673c:	2222      	movs	r2, #34	@ 0x22
 800673e:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8006742:	2240      	movs	r2, #64	@ 0x40
 8006744:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006748:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
 800674a:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 800674e:	685a      	ldr	r2, [r3, #4]
 8006750:	4977      	ldr	r1, [pc, #476]	@ (8006930 <HAL_I2C_Mem_Read+0x248>)
    hi2c->XferISR   = NULL;
 8006752:	6360      	str	r0, [r4, #52]	@ 0x34
  MODIFY_REG(hi2c->Instance->CR2, \
 8006754:	400a      	ands	r2, r1
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8006756:	fa5f f188 	uxtb.w	r1, r8
  MODIFY_REG(hi2c->Instance->CR2, \
 800675a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 800675e:	f3c7 0709 	ubfx	r7, r7, #0, #10
  MODIFY_REG(hi2c->Instance->CR2, \
 8006762:	433a      	orrs	r2, r7
 8006764:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8006768:	605a      	str	r2, [r3, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800676a:	4631      	mov	r1, r6
 800676c:	462a      	mov	r2, r5
 800676e:	4620      	mov	r0, r4
 8006770:	f7ff fce6 	bl	8006140 <I2C_WaitOnTXISFlagUntilTimeout>
 8006774:	2800      	cmp	r0, #0
 8006776:	f040 80c1 	bne.w	80068fc <HAL_I2C_Mem_Read+0x214>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800677a:	f1b8 0f01 	cmp.w	r8, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800677e:	6821      	ldr	r1, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8006780:	d164      	bne.n	800684c <HAL_I2C_Mem_Read+0x164>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006782:	fa5f f389 	uxtb.w	r3, r9
 8006786:	628b      	str	r3, [r1, #40]	@ 0x28
 8006788:	1c70      	adds	r0, r6, #1
 800678a:	d15b      	bne.n	8006844 <HAL_I2C_Mem_Read+0x15c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800678c:	698b      	ldr	r3, [r1, #24]
 800678e:	065a      	lsls	r2, r3, #25
 8006790:	d5fc      	bpl.n	800678c <HAL_I2C_Mem_Read+0xa4>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006792:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 8006794:	b29b      	uxth	r3, r3
 8006796:	2bff      	cmp	r3, #255	@ 0xff
 8006798:	f240 8097 	bls.w	80068ca <HAL_I2C_Mem_Read+0x1e2>
  MODIFY_REG(hi2c->Instance->CR2, \
 800679c:	684b      	ldr	r3, [r1, #4]
 800679e:	4a64      	ldr	r2, [pc, #400]	@ (8006930 <HAL_I2C_Mem_Read+0x248>)
 80067a0:	4013      	ands	r3, r2
 80067a2:	433b      	orrs	r3, r7
 80067a4:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
 80067a8:	f443 3392 	orr.w	r3, r3, #74752	@ 0x12400
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80067ac:	22ff      	movs	r2, #255	@ 0xff
 80067ae:	8522      	strh	r2, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 80067b0:	604b      	str	r3, [r1, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80067b2:	1c70      	adds	r0, r6, #1
 80067b4:	d13a      	bne.n	800682c <HAL_I2C_Mem_Read+0x144>
 80067b6:	698b      	ldr	r3, [r1, #24]
 80067b8:	075a      	lsls	r2, r3, #29
 80067ba:	d5fc      	bpl.n	80067b6 <HAL_I2C_Mem_Read+0xce>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 80067bc:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80067be:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
 80067c0:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 80067c2:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 80067c4:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
 80067c6:	6a61      	ldr	r1, [r4, #36]	@ 0x24
      hi2c->XferCount--;
 80067c8:	3a01      	subs	r2, #1
 80067ca:	b292      	uxth	r2, r2
 80067cc:	8562      	strh	r2, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80067ce:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 80067d0:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 80067d2:	3101      	adds	r1, #1
      hi2c->XferSize--;
 80067d4:	b29b      	uxth	r3, r3
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80067d6:	b292      	uxth	r2, r2
      hi2c->pBuffPtr++;
 80067d8:	6261      	str	r1, [r4, #36]	@ 0x24
      hi2c->XferSize--;
 80067da:	8523      	strh	r3, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80067dc:	b10a      	cbz	r2, 80067e2 <HAL_I2C_Mem_Read+0xfa>
 80067de:	2b00      	cmp	r3, #0
 80067e0:	d043      	beq.n	800686a <HAL_I2C_Mem_Read+0x182>
    } while (hi2c->XferCount > 0U);
 80067e2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 80067e4:	b29b      	uxth	r3, r3
 80067e6:	2b00      	cmp	r3, #0
 80067e8:	f000 808c 	beq.w	8006904 <HAL_I2C_Mem_Read+0x21c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80067ec:	6821      	ldr	r1, [r4, #0]
 80067ee:	e7e0      	b.n	80067b2 <HAL_I2C_Mem_Read+0xca>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80067f0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80067f4:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
 80067f6:	2001      	movs	r0, #1
}
 80067f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    __HAL_LOCK(hi2c);
 80067fc:	2002      	movs	r0, #2
}
 80067fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006802:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006804:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006806:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 800680a:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800680c:	6463      	str	r3, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
 800680e:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 8006812:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006816:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
        return HAL_ERROR;
 800681a:	e7ec      	b.n	80067f6 <HAL_I2C_Mem_Read+0x10e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800681c:	f7fb f9d4 	bl	8001bc8 <HAL_GetTick>
 8006820:	1b40      	subs	r0, r0, r5
 8006822:	4286      	cmp	r6, r0
 8006824:	d3ed      	bcc.n	8006802 <HAL_I2C_Mem_Read+0x11a>
 8006826:	2e00      	cmp	r6, #0
 8006828:	d0eb      	beq.n	8006802 <HAL_I2C_Mem_Read+0x11a>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800682a:	6821      	ldr	r1, [r4, #0]
 800682c:	698b      	ldr	r3, [r1, #24]
 800682e:	075b      	lsls	r3, r3, #29
 8006830:	d5f4      	bpl.n	800681c <HAL_I2C_Mem_Read+0x134>
 8006832:	e7c3      	b.n	80067bc <HAL_I2C_Mem_Read+0xd4>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006834:	f7fb f9c8 	bl	8001bc8 <HAL_GetTick>
 8006838:	1b43      	subs	r3, r0, r5
 800683a:	429e      	cmp	r6, r3
 800683c:	d355      	bcc.n	80068ea <HAL_I2C_Mem_Read+0x202>
 800683e:	2e00      	cmp	r6, #0
 8006840:	d053      	beq.n	80068ea <HAL_I2C_Mem_Read+0x202>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8006842:	6821      	ldr	r1, [r4, #0]
 8006844:	698b      	ldr	r3, [r1, #24]
 8006846:	065b      	lsls	r3, r3, #25
 8006848:	d5f4      	bpl.n	8006834 <HAL_I2C_Mem_Read+0x14c>
 800684a:	e7a2      	b.n	8006792 <HAL_I2C_Mem_Read+0xaa>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 800684c:	ea4f 2319 	mov.w	r3, r9, lsr #8
 8006850:	628b      	str	r3, [r1, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006852:	462a      	mov	r2, r5
 8006854:	4631      	mov	r1, r6
 8006856:	4620      	mov	r0, r4
 8006858:	f7ff fc72 	bl	8006140 <I2C_WaitOnTXISFlagUntilTimeout>
 800685c:	2800      	cmp	r0, #0
 800685e:	d14d      	bne.n	80068fc <HAL_I2C_Mem_Read+0x214>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006860:	6821      	ldr	r1, [r4, #0]
 8006862:	fa5f f389 	uxtb.w	r3, r9
 8006866:	628b      	str	r3, [r1, #40]	@ 0x28
 8006868:	e78e      	b.n	8006788 <HAL_I2C_Mem_Read+0xa0>
 800686a:	1c70      	adds	r0, r6, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800686c:	6822      	ldr	r2, [r4, #0]
 800686e:	d11a      	bne.n	80068a6 <HAL_I2C_Mem_Read+0x1be>
 8006870:	6993      	ldr	r3, [r2, #24]
 8006872:	0619      	lsls	r1, r3, #24
 8006874:	d5fc      	bpl.n	8006870 <HAL_I2C_Mem_Read+0x188>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006876:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 8006878:	b29b      	uxth	r3, r3
 800687a:	2bff      	cmp	r3, #255	@ 0xff
 800687c:	d917      	bls.n	80068ae <HAL_I2C_Mem_Read+0x1c6>
  MODIFY_REG(hi2c->Instance->CR2, \
 800687e:	6853      	ldr	r3, [r2, #4]
 8006880:	492c      	ldr	r1, [pc, #176]	@ (8006934 <HAL_I2C_Mem_Read+0x24c>)
 8006882:	400b      	ands	r3, r1
 8006884:	433b      	orrs	r3, r7
 8006886:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
 800688a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800688e:	21ff      	movs	r1, #255	@ 0xff
 8006890:	8521      	strh	r1, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 8006892:	6053      	str	r3, [r2, #4]
}
 8006894:	e7a5      	b.n	80067e2 <HAL_I2C_Mem_Read+0xfa>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006896:	f7fb f997 	bl	8001bc8 <HAL_GetTick>
 800689a:	1b43      	subs	r3, r0, r5
 800689c:	429e      	cmp	r6, r3
 800689e:	d3b0      	bcc.n	8006802 <HAL_I2C_Mem_Read+0x11a>
 80068a0:	2e00      	cmp	r6, #0
 80068a2:	d0ae      	beq.n	8006802 <HAL_I2C_Mem_Read+0x11a>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80068a4:	6822      	ldr	r2, [r4, #0]
 80068a6:	6993      	ldr	r3, [r2, #24]
 80068a8:	061b      	lsls	r3, r3, #24
 80068aa:	d5f4      	bpl.n	8006896 <HAL_I2C_Mem_Read+0x1ae>
 80068ac:	e7e3      	b.n	8006876 <HAL_I2C_Mem_Read+0x18e>
          hi2c->XferSize = hi2c->XferCount;
 80068ae:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 80068b0:	4820      	ldr	r0, [pc, #128]	@ (8006934 <HAL_I2C_Mem_Read+0x24c>)
          hi2c->XferSize = hi2c->XferCount;
 80068b2:	b29b      	uxth	r3, r3
 80068b4:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 80068b6:	b2d9      	uxtb	r1, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 80068b8:	6853      	ldr	r3, [r2, #4]
 80068ba:	4003      	ands	r3, r0
 80068bc:	433b      	orrs	r3, r7
 80068be:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80068c2:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 80068c6:	6053      	str	r3, [r2, #4]
}
 80068c8:	e78b      	b.n	80067e2 <HAL_I2C_Mem_Read+0xfa>
      hi2c->XferSize = hi2c->XferCount;
 80068ca:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 80068cc:	4818      	ldr	r0, [pc, #96]	@ (8006930 <HAL_I2C_Mem_Read+0x248>)
      hi2c->XferSize = hi2c->XferCount;
 80068ce:	b29b      	uxth	r3, r3
 80068d0:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 80068d2:	b2da      	uxtb	r2, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 80068d4:	684b      	ldr	r3, [r1, #4]
 80068d6:	4003      	ands	r3, r0
 80068d8:	433b      	orrs	r3, r7
 80068da:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80068de:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 80068e2:	f443 5310 	orr.w	r3, r3, #9216	@ 0x2400
 80068e6:	604b      	str	r3, [r1, #4]
}
 80068e8:	e763      	b.n	80067b2 <HAL_I2C_Mem_Read+0xca>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80068ea:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80068ec:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80068ee:	430b      	orrs	r3, r1
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80068f0:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80068f2:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80068f4:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80068f8:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
 80068fc:	2300      	movs	r3, #0
 80068fe:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
 8006902:	e778      	b.n	80067f6 <HAL_I2C_Mem_Read+0x10e>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006904:	462a      	mov	r2, r5
 8006906:	4631      	mov	r1, r6
 8006908:	4620      	mov	r0, r4
 800690a:	f7ff fccb 	bl	80062a4 <I2C_WaitOnSTOPFlagUntilTimeout>
 800690e:	2800      	cmp	r0, #0
 8006910:	f47f af71 	bne.w	80067f6 <HAL_I2C_Mem_Read+0x10e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006914:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8006916:	4d08      	ldr	r5, [pc, #32]	@ (8006938 <HAL_I2C_Mem_Read+0x250>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006918:	2120      	movs	r1, #32
 800691a:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 800691c:	685a      	ldr	r2, [r3, #4]
 800691e:	402a      	ands	r2, r5
 8006920:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8006922:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 8006926:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800692a:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
 800692e:	e763      	b.n	80067f8 <HAL_I2C_Mem_Read+0x110>
 8006930:	fc009800 	.word	0xfc009800
 8006934:	fc009c00 	.word	0xfc009c00
 8006938:	fe00e800 	.word	0xfe00e800

0800693c <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800693c:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
 8006940:	2a20      	cmp	r2, #32
 8006942:	d123      	bne.n	800698c <HAL_I2CEx_ConfigAnalogFilter+0x50>
 8006944:	fa5f fc82 	uxtb.w	ip, r2
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8006948:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
 800694c:	2a01      	cmp	r2, #1
 800694e:	4603      	mov	r3, r0
 8006950:	d01c      	beq.n	800698c <HAL_I2CEx_ConfigAnalogFilter+0x50>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8006952:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8006954:	2024      	movs	r0, #36	@ 0x24
{
 8006956:	b500      	push	{lr}
    hi2c->State = HAL_I2C_STATE_BUSY;
 8006958:	f883 0041 	strb.w	r0, [r3, #65]	@ 0x41
    __HAL_I2C_DISABLE(hi2c);
 800695c:	6810      	ldr	r0, [r2, #0]
 800695e:	f020 0001 	bic.w	r0, r0, #1
 8006962:	6010      	str	r0, [r2, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8006964:	6810      	ldr	r0, [r2, #0]
 8006966:	f420 5080 	bic.w	r0, r0, #4096	@ 0x1000
 800696a:	6010      	str	r0, [r2, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 800696c:	6810      	ldr	r0, [r2, #0]
 800696e:	4301      	orrs	r1, r0
 8006970:	6011      	str	r1, [r2, #0]

    __HAL_I2C_ENABLE(hi2c);
 8006972:	6811      	ldr	r1, [r2, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8006974:	f04f 0e00 	mov.w	lr, #0
    __HAL_I2C_ENABLE(hi2c);
 8006978:	f041 0101 	orr.w	r1, r1, #1
 800697c:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 800697e:	f883 c041 	strb.w	ip, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 8006982:	f883 e040 	strb.w	lr, [r3, #64]	@ 0x40

    return HAL_OK;
 8006986:	4670      	mov	r0, lr
  }
  else
  {
    return HAL_BUSY;
  }
}
 8006988:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_LOCK(hi2c);
 800698c:	2002      	movs	r0, #2
}
 800698e:	4770      	bx	lr

08006990 <HAL_I2CEx_ConfigDigitalFilter>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8006990:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
 8006994:	2a20      	cmp	r2, #32
 8006996:	d122      	bne.n	80069de <HAL_I2CEx_ConfigDigitalFilter+0x4e>
{
 8006998:	b500      	push	{lr}
 800699a:	fa5f fe82 	uxtb.w	lr, r2
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800699e:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
 80069a2:	2a01      	cmp	r2, #1
 80069a4:	4603      	mov	r3, r0
 80069a6:	d01c      	beq.n	80069e2 <HAL_I2CEx_ConfigDigitalFilter+0x52>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80069a8:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 80069aa:	2024      	movs	r0, #36	@ 0x24
 80069ac:	f883 0041 	strb.w	r0, [r3, #65]	@ 0x41
    __HAL_I2C_DISABLE(hi2c);
 80069b0:	6810      	ldr	r0, [r2, #0]
 80069b2:	f020 0001 	bic.w	r0, r0, #1
 80069b6:	6010      	str	r0, [r2, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 80069b8:	6810      	ldr	r0, [r2, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 80069ba:	f420 6070 	bic.w	r0, r0, #3840	@ 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 80069be:	ea40 2101 	orr.w	r1, r0, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 80069c2:	6011      	str	r1, [r2, #0]

    __HAL_I2C_ENABLE(hi2c);
 80069c4:	6811      	ldr	r1, [r2, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80069c6:	f04f 0c00 	mov.w	ip, #0
    __HAL_I2C_ENABLE(hi2c);
 80069ca:	f041 0101 	orr.w	r1, r1, #1
 80069ce:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 80069d0:	f883 e041 	strb.w	lr, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 80069d4:	f883 c040 	strb.w	ip, [r3, #64]	@ 0x40

    return HAL_OK;
 80069d8:	4660      	mov	r0, ip
  }
  else
  {
    return HAL_BUSY;
  }
}
 80069da:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_LOCK(hi2c);
 80069de:	2002      	movs	r0, #2
}
 80069e0:	4770      	bx	lr
    __HAL_LOCK(hi2c);
 80069e2:	2002      	movs	r0, #2
}
 80069e4:	f85d fb04 	ldr.w	pc, [sp], #4

080069e8 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80069e8:	4a02      	ldr	r2, [pc, #8]	@ (80069f4 <HAL_PWR_EnableBkUpAccess+0xc>)
 80069ea:	6813      	ldr	r3, [r2, #0]
 80069ec:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80069f0:	6013      	str	r3, [r2, #0]
}
 80069f2:	4770      	bx	lr
 80069f4:	58000400 	.word	0x58000400

080069f8 <HAL_PWR_EnterSLEEPMode>:

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 80069f8:	4b0e      	ldr	r3, [pc, #56]	@ (8006a34 <HAL_PWR_EnterSLEEPMode+0x3c>)
{
 80069fa:	b510      	push	{r4, lr}
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 80069fc:	695b      	ldr	r3, [r3, #20]
{
 80069fe:	460c      	mov	r4, r1
  if (Regulator == PWR_MAINREGULATOR_ON)
 8006a00:	b960      	cbnz	r0, 8006a1c <HAL_PWR_EnterSLEEPMode+0x24>
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8006a02:	059a      	lsls	r2, r3, #22
 8006a04:	d411      	bmi.n	8006a2a <HAL_PWR_EnterSLEEPMode+0x32>
      HAL_PWREx_EnableLowPowerRunMode();
    }
  }

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006a06:	4a0c      	ldr	r2, [pc, #48]	@ (8006a38 <HAL_PWR_EnterSLEEPMode+0x40>)
 8006a08:	6913      	ldr	r3, [r2, #16]

  /* Select SLEEP mode entry -------------------------------------------------*/
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 8006a0a:	2c01      	cmp	r4, #1
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006a0c:	f023 0304 	bic.w	r3, r3, #4
 8006a10:	6113      	str	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 8006a12:	d008      	beq.n	8006a26 <HAL_PWR_EnterSLEEPMode+0x2e>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 8006a14:	bf40      	sev
    __WFE();
 8006a16:	bf20      	wfe
    __WFE();
 8006a18:	bf20      	wfe
  }
}
 8006a1a:	bd10      	pop	{r4, pc}
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 8006a1c:	059b      	lsls	r3, r3, #22
 8006a1e:	d4f2      	bmi.n	8006a06 <HAL_PWR_EnterSLEEPMode+0xe>
      HAL_PWREx_EnableLowPowerRunMode();
 8006a20:	f000 f814 	bl	8006a4c <HAL_PWREx_EnableLowPowerRunMode>
 8006a24:	e7ef      	b.n	8006a06 <HAL_PWR_EnterSLEEPMode+0xe>
    __WFI();
 8006a26:	bf30      	wfi
}
 8006a28:	bd10      	pop	{r4, pc}
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 8006a2a:	f000 f817 	bl	8006a5c <HAL_PWREx_DisableLowPowerRunMode>
 8006a2e:	2800      	cmp	r0, #0
 8006a30:	d0e9      	beq.n	8006a06 <HAL_PWR_EnterSLEEPMode+0xe>
}
 8006a32:	bd10      	pop	{r4, pc}
 8006a34:	58000400 	.word	0x58000400
 8006a38:	e000ed00 	.word	0xe000ed00

08006a3c <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 8006a3c:	4b02      	ldr	r3, [pc, #8]	@ (8006a48 <HAL_PWREx_GetVoltageRange+0xc>)
 8006a3e:	6818      	ldr	r0, [r3, #0]
}
 8006a40:	f400 60c0 	and.w	r0, r0, #1536	@ 0x600
 8006a44:	4770      	bx	lr
 8006a46:	bf00      	nop
 8006a48:	58000400 	.word	0x58000400

08006a4c <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 8006a4c:	4a02      	ldr	r2, [pc, #8]	@ (8006a58 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 8006a4e:	6813      	ldr	r3, [r2, #0]
 8006a50:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8006a54:	6013      	str	r3, [r2, #0]
}
 8006a56:	4770      	bx	lr
 8006a58:	58000400 	.word	0x58000400

08006a5c <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 8006a5c:	4912      	ldr	r1, [pc, #72]	@ (8006aa8 <HAL_PWREx_DisableLowPowerRunMode+0x4c>)

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8006a5e:	4813      	ldr	r0, [pc, #76]	@ (8006aac <HAL_PWREx_DisableLowPowerRunMode+0x50>)
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 8006a60:	680a      	ldr	r2, [r1, #0]
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8006a62:	4b13      	ldr	r3, [pc, #76]	@ (8006ab0 <HAL_PWREx_DisableLowPowerRunMode+0x54>)
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 8006a64:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8006a68:	600a      	str	r2, [r1, #0]
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8006a6a:	6802      	ldr	r2, [r0, #0]
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8006a6c:	6948      	ldr	r0, [r1, #20]
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8006a6e:	f04f 0c32 	mov.w	ip, #50	@ 0x32
 8006a72:	fb0c f202 	mul.w	r2, ip, r2
 8006a76:	fba3 c302 	umull	ip, r3, r3, r2
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8006a7a:	f410 7f00 	tst.w	r0, #512	@ 0x200
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8006a7e:	ea4f 4393 	mov.w	r3, r3, lsr #18
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8006a82:	d009      	beq.n	8006a98 <HAL_PWREx_DisableLowPowerRunMode+0x3c>
 8006a84:	480b      	ldr	r0, [pc, #44]	@ (8006ab4 <HAL_PWREx_DisableLowPowerRunMode+0x58>)
 8006a86:	4282      	cmp	r2, r0
 8006a88:	d801      	bhi.n	8006a8e <HAL_PWREx_DisableLowPowerRunMode+0x32>
 8006a8a:	e005      	b.n	8006a98 <HAL_PWREx_DisableLowPowerRunMode+0x3c>
 8006a8c:	b123      	cbz	r3, 8006a98 <HAL_PWREx_DisableLowPowerRunMode+0x3c>
 8006a8e:	694a      	ldr	r2, [r1, #20]
 8006a90:	0592      	lsls	r2, r2, #22
  {
    wait_loop_index--;
 8006a92:	f103 33ff 	add.w	r3, r3, #4294967295
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8006a96:	d4f9      	bmi.n	8006a8c <HAL_PWREx_DisableLowPowerRunMode+0x30>
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8006a98:	4b03      	ldr	r3, [pc, #12]	@ (8006aa8 <HAL_PWREx_DisableLowPowerRunMode+0x4c>)
 8006a9a:	695b      	ldr	r3, [r3, #20]
  {
    return HAL_TIMEOUT;
  }

  return HAL_OK;
 8006a9c:	f413 7f00 	tst.w	r3, #512	@ 0x200
}
 8006aa0:	bf14      	ite	ne
 8006aa2:	2003      	movne	r0, #3
 8006aa4:	2000      	moveq	r0, #0
 8006aa6:	4770      	bx	lr
 8006aa8:	58000400 	.word	0x58000400
 8006aac:	20000004 	.word	0x20000004
 8006ab0:	431bde83 	.word	0x431bde83
 8006ab4:	000f423f 	.word	0x000f423f

08006ab8 <HAL_PWREx_EnterSTOP2Mode>:
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 8006ab8:	490c      	ldr	r1, [pc, #48]	@ (8006aec <HAL_PWREx_EnterSTOP2Mode+0x34>)
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006aba:	4a0d      	ldr	r2, [pc, #52]	@ (8006af0 <HAL_PWREx_EnterSTOP2Mode+0x38>)
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 8006abc:	680b      	ldr	r3, [r1, #0]
 8006abe:	f023 0307 	bic.w	r3, r3, #7
 8006ac2:	f043 0302 	orr.w	r3, r3, #2
 8006ac6:	600b      	str	r3, [r1, #0]
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006ac8:	6913      	ldr	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 8006aca:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006acc:	f043 0304 	orr.w	r3, r3, #4
 8006ad0:	6113      	str	r3, [r2, #16]
  if (STOPEntry == PWR_STOPENTRY_WFI)
 8006ad2:	d008      	beq.n	8006ae6 <HAL_PWREx_EnterSTOP2Mode+0x2e>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 8006ad4:	bf40      	sev
    __WFE();
 8006ad6:	bf20      	wfe
    __WFE();
 8006ad8:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006ada:	4a05      	ldr	r2, [pc, #20]	@ (8006af0 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 8006adc:	6913      	ldr	r3, [r2, #16]
 8006ade:	f023 0304 	bic.w	r3, r3, #4
 8006ae2:	6113      	str	r3, [r2, #16]
}
 8006ae4:	4770      	bx	lr
    __WFI();
 8006ae6:	bf30      	wfi
 8006ae8:	e7f7      	b.n	8006ada <HAL_PWREx_EnterSTOP2Mode+0x22>
 8006aea:	bf00      	nop
 8006aec:	58000400 	.word	0x58000400
 8006af0:	e000ed00 	.word	0xe000ed00

08006af4 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 8006af4:	b570      	push	{r4, r5, r6, lr}
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 8006af6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 8006afa:	492e      	ldr	r1, [pc, #184]	@ (8006bb4 <RCC_SetFlashLatencyFromMSIRange+0xc0>)
 8006afc:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 8006b00:	4a2d      	ldr	r2, [pc, #180]	@ (8006bb8 <RCC_SetFlashLatencyFromMSIRange+0xc4>)
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 8006b02:	f3c0 1003 	ubfx	r0, r0, #4, #4
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 8006b06:	f003 030f 	and.w	r3, r3, #15
{
 8006b0a:	b084      	sub	sp, #16
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 8006b0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8006b10:	f851 4020 	ldr.w	r4, [r1, r0, lsl #2]
 8006b14:	fbb4 f4f3 	udiv	r4, r4, r3

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 8006b18:	f7ff ff90 	bl	8006a3c <HAL_PWREx_GetVoltageRange>

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 8006b1c:	4b27      	ldr	r3, [pc, #156]	@ (8006bbc <RCC_SetFlashLatencyFromMSIRange+0xc8>)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 8006b1e:	4605      	mov	r5, r0
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 8006b20:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 8006b24:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 8006b28:	ab04      	add	r3, sp, #16
 8006b2a:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 8006b2e:	d029      	beq.n	8006b84 <RCC_SetFlashLatencyFromMSIRange+0x90>
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 8006b30:	4b23      	ldr	r3, [pc, #140]	@ (8006bc0 <RCC_SetFlashLatencyFromMSIRange+0xcc>)
 8006b32:	429c      	cmp	r4, r3
 8006b34:	d339      	bcc.n	8006baa <RCC_SetFlashLatencyFromMSIRange+0xb6>
 8006b36:	f503 03b7 	add.w	r3, r3, #5996544	@ 0x5b8000
 8006b3a:	f603 537f 	addw	r3, r3, #3455	@ 0xd7f
 8006b3e:	429c      	cmp	r4, r3
 8006b40:	d935      	bls.n	8006bae <RCC_SetFlashLatencyFromMSIRange+0xba>
 8006b42:	f503 1374 	add.w	r3, r3, #3997696	@ 0x3d0000
 8006b46:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006b4a:	429c      	cmp	r4, r3
 8006b4c:	d926      	bls.n	8006b9c <RCC_SetFlashLatencyFromMSIRange+0xa8>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8006b4e:	2600      	movs	r6, #0
        break;
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8006b50:	4c1c      	ldr	r4, [pc, #112]	@ (8006bc4 <RCC_SetFlashLatencyFromMSIRange+0xd0>)
 8006b52:	6823      	ldr	r3, [r4, #0]
 8006b54:	f023 0307 	bic.w	r3, r3, #7
 8006b58:	4333      	orrs	r3, r6
 8006b5a:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8006b5c:	f7fb f834 	bl	8001bc8 <HAL_GetTick>
 8006b60:	4605      	mov	r5, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8006b62:	e004      	b.n	8006b6e <RCC_SetFlashLatencyFromMSIRange+0x7a>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8006b64:	f7fb f830 	bl	8001bc8 <HAL_GetTick>
 8006b68:	1b40      	subs	r0, r0, r5
 8006b6a:	2802      	cmp	r0, #2
 8006b6c:	d807      	bhi.n	8006b7e <RCC_SetFlashLatencyFromMSIRange+0x8a>
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8006b6e:	6823      	ldr	r3, [r4, #0]
 8006b70:	f003 0307 	and.w	r3, r3, #7
 8006b74:	429e      	cmp	r6, r3
 8006b76:	d1f5      	bne.n	8006b64 <RCC_SetFlashLatencyFromMSIRange+0x70>
    {
      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 8006b78:	2000      	movs	r0, #0
}
 8006b7a:	b004      	add	sp, #16
 8006b7c:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_TIMEOUT;
 8006b7e:	2003      	movs	r0, #3
}
 8006b80:	b004      	add	sp, #16
 8006b82:	bd70      	pop	{r4, r5, r6, pc}
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 8006b84:	4b10      	ldr	r3, [pc, #64]	@ (8006bc8 <RCC_SetFlashLatencyFromMSIRange+0xd4>)
 8006b86:	429c      	cmp	r4, r3
 8006b88:	d90f      	bls.n	8006baa <RCC_SetFlashLatencyFromMSIRange+0xb6>
 8006b8a:	4b10      	ldr	r3, [pc, #64]	@ (8006bcc <RCC_SetFlashLatencyFromMSIRange+0xd8>)
 8006b8c:	429c      	cmp	r4, r3
 8006b8e:	d90e      	bls.n	8006bae <RCC_SetFlashLatencyFromMSIRange+0xba>
 8006b90:	f503 0337 	add.w	r3, r3, #11993088	@ 0xb70000
 8006b94:	f503 53d8 	add.w	r3, r3, #6912	@ 0x1b00
 8006b98:	429c      	cmp	r4, r3
 8006b9a:	d8d8      	bhi.n	8006b4e <RCC_SetFlashLatencyFromMSIRange+0x5a>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8006b9c:	2302      	movs	r3, #2
        latency = FLASH_LATENCY_RANGE[index];
 8006b9e:	aa04      	add	r2, sp, #16
 8006ba0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8006ba4:	f853 6c0c 	ldr.w	r6, [r3, #-12]
        break;
 8006ba8:	e7d2      	b.n	8006b50 <RCC_SetFlashLatencyFromMSIRange+0x5c>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8006baa:	2300      	movs	r3, #0
 8006bac:	e7f7      	b.n	8006b9e <RCC_SetFlashLatencyFromMSIRange+0xaa>
 8006bae:	2301      	movs	r3, #1
 8006bb0:	e7f5      	b.n	8006b9e <RCC_SetFlashLatencyFromMSIRange+0xaa>
 8006bb2:	bf00      	nop
 8006bb4:	08016a0c 	.word	0x08016a0c
 8006bb8:	08016a6c 	.word	0x08016a6c
 8006bbc:	080167d4 	.word	0x080167d4
 8006bc0:	006acfc0 	.word	0x006acfc0
 8006bc4:	58004000 	.word	0x58004000
 8006bc8:	0121eabf 	.word	0x0121eabf
 8006bcc:	0234933f 	.word	0x0234933f

08006bd0 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8006bd0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8006bd4:	689a      	ldr	r2, [r3, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8006bd6:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8006bd8:	f012 020c 	ands.w	r2, r2, #12
 8006bdc:	d027      	beq.n	8006c2e <HAL_RCC_GetSysClockFreq+0x5e>
 8006bde:	2a0c      	cmp	r2, #12
 8006be0:	d04b      	beq.n	8006c7a <HAL_RCC_GetSysClockFreq+0xaa>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8006be2:	2a04      	cmp	r2, #4
 8006be4:	d158      	bne.n	8006c98 <HAL_RCC_GetSysClockFreq+0xc8>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8006be6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
    sysclockfreq = HSI_VALUE;
 8006bea:	4832      	ldr	r0, [pc, #200]	@ (8006cb4 <HAL_RCC_GetSysClockFreq+0xe4>)
 8006bec:	6893      	ldr	r3, [r2, #8]
 8006bee:	f003 030c 	and.w	r3, r3, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8006bf2:	2b0c      	cmp	r3, #12
  uint32_t msifreq = 0U;
 8006bf4:	f04f 0100 	mov.w	r1, #0
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8006bf8:	d136      	bne.n	8006c68 <HAL_RCC_GetSysClockFreq+0x98>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8006bfa:	68d3      	ldr	r3, [r2, #12]
 8006bfc:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 8006c00:	2b02      	cmp	r3, #2
 8006c02:	d054      	beq.n	8006cae <HAL_RCC_GetSysClockFreq+0xde>
 8006c04:	2b03      	cmp	r3, #3
 8006c06:	d03f      	beq.n	8006c88 <HAL_RCC_GetSysClockFreq+0xb8>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8006c08:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8006c0c:	68d8      	ldr	r0, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8006c0e:	68da      	ldr	r2, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 8006c10:	68db      	ldr	r3, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8006c12:	f3c0 2006 	ubfx	r0, r0, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8006c16:	f3c2 1202 	ubfx	r2, r2, #4, #3
 8006c1a:	0f5b      	lsrs	r3, r3, #29
 8006c1c:	fb01 f000 	mul.w	r0, r1, r0
 8006c20:	3201      	adds	r2, #1
 8006c22:	3301      	adds	r3, #1
 8006c24:	fbb0 f0f2 	udiv	r0, r0, r2
 8006c28:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8006c2c:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8006c2e:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8006c32:	680b      	ldr	r3, [r1, #0]
 8006c34:	f013 0308 	ands.w	r3, r3, #8
 8006c38:	d117      	bne.n	8006c6a <HAL_RCC_GetSysClockFreq+0x9a>
 8006c3a:	6808      	ldr	r0, [r1, #0]
 8006c3c:	f010 0f08 	tst.w	r0, #8
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8006c40:	bf0a      	itet	eq
 8006c42:	f8d1 3094 	ldreq.w	r3, [r1, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8006c46:	6809      	ldrne	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8006c48:	f3c3 2303 	ubfxeq	r3, r3, #8, #4
 8006c4c:	491a      	ldr	r1, [pc, #104]	@ (8006cb8 <HAL_RCC_GetSysClockFreq+0xe8>)
 8006c4e:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
  uint32_t sysclockfreq = 0U;
 8006c52:	2a00      	cmp	r2, #0
 8006c54:	bf0c      	ite	eq
 8006c56:	4608      	moveq	r0, r1
 8006c58:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8006c5a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8006c5e:	6893      	ldr	r3, [r2, #8]
 8006c60:	f003 030c 	and.w	r3, r3, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8006c64:	2b0c      	cmp	r3, #12
 8006c66:	d0c8      	beq.n	8006bfa <HAL_RCC_GetSysClockFreq+0x2a>
}
 8006c68:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8006c6a:	680b      	ldr	r3, [r1, #0]
 8006c6c:	f013 0308 	ands.w	r3, r3, #8
 8006c70:	d01a      	beq.n	8006ca8 <HAL_RCC_GetSysClockFreq+0xd8>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8006c72:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8006c74:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8006c78:	e7e8      	b.n	8006c4c <HAL_RCC_GetSysClockFreq+0x7c>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8006c7a:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 8006c7e:	2901      	cmp	r1, #1
 8006c80:	d0d5      	beq.n	8006c2e <HAL_RCC_GetSysClockFreq+0x5e>
  uint32_t msifreq = 0U;
 8006c82:	2100      	movs	r1, #0
  uint32_t sysclockfreq = 0U;
 8006c84:	4608      	mov	r0, r1
 8006c86:	e7e8      	b.n	8006c5a <HAL_RCC_GetSysClockFreq+0x8a>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8006c88:	6812      	ldr	r2, [r2, #0]
        pllinputfreq = HSI_VALUE;
 8006c8a:	4b0a      	ldr	r3, [pc, #40]	@ (8006cb4 <HAL_RCC_GetSysClockFreq+0xe4>)
 8006c8c:	490b      	ldr	r1, [pc, #44]	@ (8006cbc <HAL_RCC_GetSysClockFreq+0xec>)
 8006c8e:	f412 1f80 	tst.w	r2, #1048576	@ 0x100000
 8006c92:	bf18      	it	ne
 8006c94:	4619      	movne	r1, r3
 8006c96:	e7b7      	b.n	8006c08 <HAL_RCC_GetSysClockFreq+0x38>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8006c98:	2a08      	cmp	r2, #8
 8006c9a:	d1f2      	bne.n	8006c82 <HAL_RCC_GetSysClockFreq+0xb2>
 8006c9c:	6819      	ldr	r1, [r3, #0]
 8006c9e:	f411 1180 	ands.w	r1, r1, #1048576	@ 0x100000
 8006ca2:	d1a0      	bne.n	8006be6 <HAL_RCC_GetSysClockFreq+0x16>
      sysclockfreq = HSE_VALUE;
 8006ca4:	4805      	ldr	r0, [pc, #20]	@ (8006cbc <HAL_RCC_GetSysClockFreq+0xec>)
 8006ca6:	e7d8      	b.n	8006c5a <HAL_RCC_GetSysClockFreq+0x8a>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8006ca8:	f8d1 1094 	ldr.w	r1, [r1, #148]	@ 0x94
 8006cac:	e7ce      	b.n	8006c4c <HAL_RCC_GetSysClockFreq+0x7c>
        pllinputfreq = HSI_VALUE;
 8006cae:	4901      	ldr	r1, [pc, #4]	@ (8006cb4 <HAL_RCC_GetSysClockFreq+0xe4>)
 8006cb0:	e7aa      	b.n	8006c08 <HAL_RCC_GetSysClockFreq+0x38>
 8006cb2:	bf00      	nop
 8006cb4:	00f42400 	.word	0x00f42400
 8006cb8:	08016a0c 	.word	0x08016a0c
 8006cbc:	01e84800 	.word	0x01e84800

08006cc0 <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
 8006cc0:	2800      	cmp	r0, #0
 8006cc2:	f000 82db 	beq.w	800727c <HAL_RCC_OscConfig+0x5bc>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8006cc6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8006cca:	6803      	ldr	r3, [r0, #0]
{
 8006ccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006cd0:	6895      	ldr	r5, [r2, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8006cd2:	68d6      	ldr	r6, [r2, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8006cd4:	0699      	lsls	r1, r3, #26
 8006cd6:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8006cd8:	f005 050c 	and.w	r5, r5, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8006cdc:	f006 0603 	and.w	r6, r6, #3
 8006ce0:	d528      	bpl.n	8006d34 <HAL_RCC_OscConfig+0x74>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8006ce2:	2d00      	cmp	r5, #0
 8006ce4:	f000 813b 	beq.w	8006f5e <HAL_RCC_OscConfig+0x29e>
 8006ce8:	2d0c      	cmp	r5, #12
 8006cea:	f000 8135 	beq.w	8006f58 <HAL_RCC_OscConfig+0x298>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8006cee:	6a23      	ldr	r3, [r4, #32]
  SET_BIT(RCC->CR, RCC_CR_MSION);
 8006cf0:	f04f 47b0 	mov.w	r7, #1476395008	@ 0x58000000
 8006cf4:	2b00      	cmp	r3, #0
 8006cf6:	f000 820c 	beq.w	8007112 <HAL_RCC_OscConfig+0x452>
 8006cfa:	683b      	ldr	r3, [r7, #0]
 8006cfc:	f043 0301 	orr.w	r3, r3, #1
 8006d00:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 8006d02:	f7fa ff61 	bl	8001bc8 <HAL_GetTick>
 8006d06:	4680      	mov	r8, r0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8006d08:	683b      	ldr	r3, [r7, #0]
 8006d0a:	079b      	lsls	r3, r3, #30
 8006d0c:	f140 8213 	bpl.w	8007136 <HAL_RCC_OscConfig+0x476>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8006d10:	683b      	ldr	r3, [r7, #0]
 8006d12:	f043 0308 	orr.w	r3, r3, #8
 8006d16:	603b      	str	r3, [r7, #0]
 8006d18:	683b      	ldr	r3, [r7, #0]
 8006d1a:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8006d1c:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8006d20:	4313      	orrs	r3, r2
 8006d22:	603b      	str	r3, [r7, #0]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 8006d24:	687b      	ldr	r3, [r7, #4]
 8006d26:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8006d28:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8006d2c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006d30:	607b      	str	r3, [r7, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8006d32:	6823      	ldr	r3, [r4, #0]
 8006d34:	07d9      	lsls	r1, r3, #31
 8006d36:	d531      	bpl.n	8006d9c <HAL_RCC_OscConfig+0xdc>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8006d38:	2d08      	cmp	r5, #8
      if (RCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8006d3a:	6862      	ldr	r2, [r4, #4]
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8006d3c:	f000 81a8 	beq.w	8007090 <HAL_RCC_OscConfig+0x3d0>
 8006d40:	2d0c      	cmp	r5, #12
 8006d42:	f000 81a2 	beq.w	800708a <HAL_RCC_OscConfig+0x3ca>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 8006d46:	f04f 47b0 	mov.w	r7, #1476395008	@ 0x58000000
 8006d4a:	68a1      	ldr	r1, [r4, #8]
 8006d4c:	683b      	ldr	r3, [r7, #0]
 8006d4e:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8006d52:	430b      	orrs	r3, r1
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006d54:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 8006d58:	603b      	str	r3, [r7, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006d5a:	f000 81a3 	beq.w	80070a4 <HAL_RCC_OscConfig+0x3e4>
 8006d5e:	f5b2 1f04 	cmp.w	r2, #2162688	@ 0x210000
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 8006d62:	683b      	ldr	r3, [r7, #0]
 8006d64:	f000 819b 	beq.w	800709e <HAL_RCC_OscConfig+0x3de>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 8006d68:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8006d6c:	603b      	str	r3, [r7, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 8006d6e:	683b      	ldr	r3, [r7, #0]
 8006d70:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8006d74:	603b      	str	r3, [r7, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8006d76:	2a00      	cmp	r2, #0
 8006d78:	f040 8198 	bne.w	80070ac <HAL_RCC_OscConfig+0x3ec>
        tickstart = HAL_GetTick();
 8006d7c:	f7fa ff24 	bl	8001bc8 <HAL_GetTick>
 8006d80:	4680      	mov	r8, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8006d82:	683b      	ldr	r3, [r7, #0]
 8006d84:	0398      	lsls	r0, r3, #14
 8006d86:	d508      	bpl.n	8006d9a <HAL_RCC_OscConfig+0xda>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8006d88:	f7fa ff1e 	bl	8001bc8 <HAL_GetTick>
 8006d8c:	eba0 0008 	sub.w	r0, r0, r8
 8006d90:	2864      	cmp	r0, #100	@ 0x64
 8006d92:	d9f6      	bls.n	8006d82 <HAL_RCC_OscConfig+0xc2>
            return HAL_TIMEOUT;
 8006d94:	2003      	movs	r0, #3
}
 8006d96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8006d9a:	6823      	ldr	r3, [r4, #0]
 8006d9c:	0799      	lsls	r1, r3, #30
 8006d9e:	d526      	bpl.n	8006dee <HAL_RCC_OscConfig+0x12e>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8006da0:	2d04      	cmp	r5, #4
 8006da2:	f000 8121 	beq.w	8006fe8 <HAL_RCC_OscConfig+0x328>
 8006da6:	2d0c      	cmp	r5, #12
 8006da8:	f000 811b 	beq.w	8006fe2 <HAL_RCC_OscConfig+0x322>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8006dac:	6923      	ldr	r3, [r4, #16]
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8006dae:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 8006db2:	b183      	cbz	r3, 8006dd6 <HAL_RCC_OscConfig+0x116>
 8006db4:	6833      	ldr	r3, [r6, #0]
 8006db6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8006dba:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8006dbc:	f7fa ff04 	bl	8001bc8 <HAL_GetTick>
 8006dc0:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8006dc2:	6833      	ldr	r3, [r6, #0]
 8006dc4:	055a      	lsls	r2, r3, #21
 8006dc6:	f100 81be 	bmi.w	8007146 <HAL_RCC_OscConfig+0x486>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8006dca:	f7fa fefd 	bl	8001bc8 <HAL_GetTick>
 8006dce:	1bc0      	subs	r0, r0, r7
 8006dd0:	2802      	cmp	r0, #2
 8006dd2:	d9f6      	bls.n	8006dc2 <HAL_RCC_OscConfig+0x102>
 8006dd4:	e7de      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 8006dd6:	6833      	ldr	r3, [r6, #0]
 8006dd8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8006ddc:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8006dde:	f7fa fef3 	bl	8001bc8 <HAL_GetTick>
 8006de2:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8006de4:	6833      	ldr	r3, [r6, #0]
 8006de6:	055b      	lsls	r3, r3, #21
 8006de8:	f100 81b6 	bmi.w	8007158 <HAL_RCC_OscConfig+0x498>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8006dec:	6823      	ldr	r3, [r4, #0]
 8006dee:	0718      	lsls	r0, r3, #28
 8006df0:	d479      	bmi.n	8006ee6 <HAL_RCC_OscConfig+0x226>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8006df2:	0759      	lsls	r1, r3, #29
 8006df4:	d55b      	bpl.n	8006eae <HAL_RCC_OscConfig+0x1ee>
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 8006df6:	4ebc      	ldr	r6, [pc, #752]	@ (80070e8 <HAL_RCC_OscConfig+0x428>)
 8006df8:	6833      	ldr	r3, [r6, #0]
 8006dfa:	05da      	lsls	r2, r3, #23
 8006dfc:	d40f      	bmi.n	8006e1e <HAL_RCC_OscConfig+0x15e>
      HAL_PWR_EnableBkUpAccess();
 8006dfe:	f7ff fdf3 	bl	80069e8 <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 8006e02:	f7fa fee1 	bl	8001bc8 <HAL_GetTick>
 8006e06:	6833      	ldr	r3, [r6, #0]
 8006e08:	05db      	lsls	r3, r3, #23
 8006e0a:	4607      	mov	r7, r0
 8006e0c:	d407      	bmi.n	8006e1e <HAL_RCC_OscConfig+0x15e>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8006e0e:	f7fa fedb 	bl	8001bc8 <HAL_GetTick>
 8006e12:	1bc0      	subs	r0, r0, r7
 8006e14:	2802      	cmp	r0, #2
 8006e16:	d8bd      	bhi.n	8006d94 <HAL_RCC_OscConfig+0xd4>
 8006e18:	6833      	ldr	r3, [r6, #0]
 8006e1a:	05db      	lsls	r3, r3, #23
 8006e1c:	d5f7      	bpl.n	8006e0e <HAL_RCC_OscConfig+0x14e>
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8006e1e:	68e3      	ldr	r3, [r4, #12]
 8006e20:	2b00      	cmp	r3, #0
 8006e22:	f000 8102 	beq.w	800702a <HAL_RCC_OscConfig+0x36a>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS)
 8006e26:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8006e2a:	2b05      	cmp	r3, #5
 8006e2c:	d107      	bne.n	8006e3e <HAL_RCC_OscConfig+0x17e>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8006e2e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8006e32:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8006e36:	f043 0304 	orr.w	r3, r3, #4
 8006e3a:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8006e3e:	f04f 47b0 	mov.w	r7, #1476395008	@ 0x58000000
      tickstart = HAL_GetTick();
 8006e42:	f7fa fec1 	bl	8001bc8 <HAL_GetTick>
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8006e46:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006e4a:	f043 0301 	orr.w	r3, r3, #1
 8006e4e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8006e52:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
      tickstart = HAL_GetTick();
 8006e56:	4606      	mov	r6, r0
 8006e58:	0798      	lsls	r0, r3, #30
 8006e5a:	d40a      	bmi.n	8006e72 <HAL_RCC_OscConfig+0x1b2>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006e5c:	f7fa feb4 	bl	8001bc8 <HAL_GetTick>
 8006e60:	f241 3388 	movw	r3, #5000	@ 0x1388
 8006e64:	1b80      	subs	r0, r0, r6
 8006e66:	4298      	cmp	r0, r3
 8006e68:	d894      	bhi.n	8006d94 <HAL_RCC_OscConfig+0xd4>
 8006e6a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006e6e:	0798      	lsls	r0, r3, #30
 8006e70:	d5f4      	bpl.n	8006e5c <HAL_RCC_OscConfig+0x19c>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 8006e72:	68e3      	ldr	r3, [r4, #12]
 8006e74:	f023 0304 	bic.w	r3, r3, #4
 8006e78:	2b81      	cmp	r3, #129	@ 0x81
 8006e7a:	f000 8127 	beq.w	80070cc <HAL_RCC_OscConfig+0x40c>
        tickstart = HAL_GetTick();
 8006e7e:	f7fa fea3 	bl	8001bc8 <HAL_GetTick>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8006e82:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006e86:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8006e8a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
        tickstart = HAL_GetTick();
 8006e8e:	4606      	mov	r6, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8006e90:	f04f 47b0 	mov.w	r7, #1476395008	@ 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006e94:	f241 3888 	movw	r8, #5000	@ 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8006e98:	e005      	b.n	8006ea6 <HAL_RCC_OscConfig+0x1e6>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006e9a:	f7fa fe95 	bl	8001bc8 <HAL_GetTick>
 8006e9e:	1b80      	subs	r0, r0, r6
 8006ea0:	4540      	cmp	r0, r8
 8006ea2:	f63f af77 	bhi.w	8006d94 <HAL_RCC_OscConfig+0xd4>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8006ea6:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8006eaa:	051a      	lsls	r2, r3, #20
 8006eac:	d4f5      	bmi.n	8006e9a <HAL_RCC_OscConfig+0x1da>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8006eae:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8006eb0:	b1b3      	cbz	r3, 8006ee0 <HAL_RCC_OscConfig+0x220>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8006eb2:	2d0c      	cmp	r5, #12
 8006eb4:	f000 8177 	beq.w	80071a6 <HAL_RCC_OscConfig+0x4e6>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8006eb8:	2b02      	cmp	r3, #2
 8006eba:	f000 8190 	beq.w	80071de <HAL_RCC_OscConfig+0x51e>
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8006ebe:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
 8006ec2:	6823      	ldr	r3, [r4, #0]
 8006ec4:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8006ec8:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8006eca:	f7fa fe7d 	bl	8001bc8 <HAL_GetTick>
 8006ece:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8006ed0:	6823      	ldr	r3, [r4, #0]
 8006ed2:	019b      	lsls	r3, r3, #6
 8006ed4:	f100 8147 	bmi.w	8007166 <HAL_RCC_OscConfig+0x4a6>
        CLEAR_BIT(RCC->PLLCFGR, (RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLPEN | RCC_PLLCFGR_PLLQEN | RCC_PLLCFGR_PLLREN));
 8006ed8:	68e2      	ldr	r2, [r4, #12]
 8006eda:	4b84      	ldr	r3, [pc, #528]	@ (80070ec <HAL_RCC_OscConfig+0x42c>)
 8006edc:	4013      	ands	r3, r2
 8006ede:	60e3      	str	r3, [r4, #12]
  return HAL_OK;
 8006ee0:	2000      	movs	r0, #0
}
 8006ee2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8006ee6:	69a3      	ldr	r3, [r4, #24]
      uint32_t csr_temp = RCC->CSR;
 8006ee8:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8006eec:	2b00      	cmp	r3, #0
 8006eee:	f000 8089 	beq.w	8007004 <HAL_RCC_OscConfig+0x344>
      uint32_t csr_temp = RCC->CSR;
 8006ef2:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 8006ef6:	69e2      	ldr	r2, [r4, #28]
 8006ef8:	f003 0110 	and.w	r1, r3, #16
 8006efc:	428a      	cmp	r2, r1
 8006efe:	d010      	beq.n	8006f22 <HAL_RCC_OscConfig+0x262>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 8006f00:	f003 0103 	and.w	r1, r3, #3
 8006f04:	2902      	cmp	r1, #2
 8006f06:	f000 814c 	beq.w	80071a2 <HAL_RCC_OscConfig+0x4e2>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 8006f0a:	07d9      	lsls	r1, r3, #31
 8006f0c:	f100 81a1 	bmi.w	8007252 <HAL_RCC_OscConfig+0x592>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 8006f10:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8006f14:	f8d1 3094 	ldr.w	r3, [r1, #148]	@ 0x94
 8006f18:	f023 0310 	bic.w	r3, r3, #16
 8006f1c:	4313      	orrs	r3, r2
 8006f1e:	f8c1 3094 	str.w	r3, [r1, #148]	@ 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 8006f22:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 8006f26:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 8006f2a:	f043 0301 	orr.w	r3, r3, #1
 8006f2e:	f8c6 3094 	str.w	r3, [r6, #148]	@ 0x94
      tickstart = HAL_GetTick();
 8006f32:	f7fa fe49 	bl	8001bc8 <HAL_GetTick>
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 8006f36:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 8006f3a:	079b      	lsls	r3, r3, #30
 8006f3c:	4607      	mov	r7, r0
 8006f3e:	d409      	bmi.n	8006f54 <HAL_RCC_OscConfig+0x294>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8006f40:	f7fa fe42 	bl	8001bc8 <HAL_GetTick>
 8006f44:	1bc0      	subs	r0, r0, r7
 8006f46:	2811      	cmp	r0, #17
 8006f48:	f63f af24 	bhi.w	8006d94 <HAL_RCC_OscConfig+0xd4>
 8006f4c:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 8006f50:	079b      	lsls	r3, r3, #30
 8006f52:	d5f5      	bpl.n	8006f40 <HAL_RCC_OscConfig+0x280>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8006f54:	6823      	ldr	r3, [r4, #0]
 8006f56:	e74c      	b.n	8006df2 <HAL_RCC_OscConfig+0x132>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 8006f58:	2e01      	cmp	r6, #1
 8006f5a:	f47f aec8 	bne.w	8006cee <HAL_RCC_OscConfig+0x2e>
      if (RCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 8006f5e:	6a23      	ldr	r3, [r4, #32]
 8006f60:	2b00      	cmp	r3, #0
 8006f62:	f000 811e 	beq.w	80071a2 <HAL_RCC_OscConfig+0x4e2>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8006f66:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8006f6a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8006f6c:	681a      	ldr	r2, [r3, #0]
 8006f6e:	0712      	lsls	r2, r2, #28
 8006f70:	bf56      	itet	pl
 8006f72:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	@ 0x94
 8006f76:	681b      	ldrmi	r3, [r3, #0]
 8006f78:	091b      	lsrpl	r3, r3, #4
 8006f7a:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8006f7e:	4298      	cmp	r0, r3
 8006f80:	f240 80f8 	bls.w	8007174 <HAL_RCC_OscConfig+0x4b4>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8006f84:	f7ff fdb6 	bl	8006af4 <RCC_SetFlashLatencyFromMSIRange>
 8006f88:	2800      	cmp	r0, #0
 8006f8a:	f040 810a 	bne.w	80071a2 <HAL_RCC_OscConfig+0x4e2>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8006f8e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8006f92:	681a      	ldr	r2, [r3, #0]
 8006f94:	f042 0208 	orr.w	r2, r2, #8
 8006f98:	601a      	str	r2, [r3, #0]
 8006f9a:	681a      	ldr	r2, [r3, #0]
 8006f9c:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8006f9e:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8006fa2:	430a      	orrs	r2, r1
 8006fa4:	601a      	str	r2, [r3, #0]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 8006fa6:	685a      	ldr	r2, [r3, #4]
 8006fa8:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8006faa:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
 8006fae:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8006fb2:	605a      	str	r2, [r3, #4]
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8006fb4:	f7ff fe0c 	bl	8006bd0 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8006fb8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
        status = HAL_InitTick(uwTickPrio);
 8006fbc:	494c      	ldr	r1, [pc, #304]	@ (80070f0 <HAL_RCC_OscConfig+0x430>)
 8006fbe:	6892      	ldr	r2, [r2, #8]
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8006fc0:	4f4c      	ldr	r7, [pc, #304]	@ (80070f4 <HAL_RCC_OscConfig+0x434>)
 8006fc2:	4603      	mov	r3, r0
 8006fc4:	f3c2 1203 	ubfx	r2, r2, #4, #4
        status = HAL_InitTick(uwTickPrio);
 8006fc8:	6808      	ldr	r0, [r1, #0]
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8006fca:	494b      	ldr	r1, [pc, #300]	@ (80070f8 <HAL_RCC_OscConfig+0x438>)
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8006fcc:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 8006fd0:	fbb3 f3f2 	udiv	r3, r3, r2
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8006fd4:	600b      	str	r3, [r1, #0]
        status = HAL_InitTick(uwTickPrio);
 8006fd6:	f7fa fdf5 	bl	8001bc4 <HAL_InitTick>
        if (status != HAL_OK)
 8006fda:	2800      	cmp	r0, #0
 8006fdc:	f43f aea9 	beq.w	8006d32 <HAL_RCC_OscConfig+0x72>
 8006fe0:	e77f      	b.n	8006ee2 <HAL_RCC_OscConfig+0x222>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8006fe2:	2e02      	cmp	r6, #2
 8006fe4:	f47f aee2 	bne.w	8006dac <HAL_RCC_OscConfig+0xec>
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8006fe8:	6922      	ldr	r2, [r4, #16]
 8006fea:	2a00      	cmp	r2, #0
 8006fec:	f000 80d9 	beq.w	80071a2 <HAL_RCC_OscConfig+0x4e2>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8006ff0:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8006ff4:	6960      	ldr	r0, [r4, #20]
 8006ff6:	684a      	ldr	r2, [r1, #4]
 8006ff8:	f022 42fe 	bic.w	r2, r2, #2130706432	@ 0x7f000000
 8006ffc:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8007000:	604a      	str	r2, [r1, #4]
}
 8007002:	e6f4      	b.n	8006dee <HAL_RCC_OscConfig+0x12e>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 8007004:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 8007008:	f023 0301 	bic.w	r3, r3, #1
 800700c:	f8c6 3094 	str.w	r3, [r6, #148]	@ 0x94
      tickstart = HAL_GetTick();
 8007010:	f7fa fdda 	bl	8001bc8 <HAL_GetTick>
 8007014:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 8007016:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 800701a:	0798      	lsls	r0, r3, #30
 800701c:	d59a      	bpl.n	8006f54 <HAL_RCC_OscConfig+0x294>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800701e:	f7fa fdd3 	bl	8001bc8 <HAL_GetTick>
 8007022:	1bc0      	subs	r0, r0, r7
 8007024:	2811      	cmp	r0, #17
 8007026:	d9f6      	bls.n	8007016 <HAL_RCC_OscConfig+0x356>
 8007028:	e6b4      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800702a:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
      tickstart = HAL_GetTick();
 800702e:	f7fa fdcb 	bl	8001bc8 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8007032:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 8007036:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
      tickstart = HAL_GetTick();
 800703a:	4607      	mov	r7, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800703c:	f8c6 3090 	str.w	r3, [r6, #144]	@ 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007040:	f241 3888 	movw	r8, #5000	@ 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8007044:	e005      	b.n	8007052 <HAL_RCC_OscConfig+0x392>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007046:	f7fa fdbf 	bl	8001bc8 <HAL_GetTick>
 800704a:	1bc0      	subs	r0, r0, r7
 800704c:	4540      	cmp	r0, r8
 800704e:	f63f aea1 	bhi.w	8006d94 <HAL_RCC_OscConfig+0xd4>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8007052:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 8007056:	051b      	lsls	r3, r3, #20
 8007058:	d4f5      	bmi.n	8007046 <HAL_RCC_OscConfig+0x386>
      tickstart = HAL_GetTick();
 800705a:	f7fa fdb5 	bl	8001bc8 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800705e:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 8007062:	f023 0301 	bic.w	r3, r3, #1
 8007066:	f8c6 3090 	str.w	r3, [r6, #144]	@ 0x90
      tickstart = HAL_GetTick();
 800706a:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 800706c:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 8007070:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 8007074:	0798      	lsls	r0, r3, #30
 8007076:	f57f af1a 	bpl.w	8006eae <HAL_RCC_OscConfig+0x1ee>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800707a:	f7fa fda5 	bl	8001bc8 <HAL_GetTick>
 800707e:	f241 3388 	movw	r3, #5000	@ 0x1388
 8007082:	1bc0      	subs	r0, r0, r7
 8007084:	4298      	cmp	r0, r3
 8007086:	d9f3      	bls.n	8007070 <HAL_RCC_OscConfig+0x3b0>
 8007088:	e684      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 800708a:	2e03      	cmp	r6, #3
 800708c:	f47f ae5b 	bne.w	8006d46 <HAL_RCC_OscConfig+0x86>
      if (RCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8007090:	2a00      	cmp	r2, #0
 8007092:	f000 8086 	beq.w	80071a2 <HAL_RCC_OscConfig+0x4e2>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8007096:	079a      	lsls	r2, r3, #30
 8007098:	f53f ae88 	bmi.w	8006dac <HAL_RCC_OscConfig+0xec>
 800709c:	e6a7      	b.n	8006dee <HAL_RCC_OscConfig+0x12e>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 800709e:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80070a2:	603b      	str	r3, [r7, #0]
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 80070a4:	683b      	ldr	r3, [r7, #0]
 80070a6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80070aa:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 80070ac:	f7fa fd8c 	bl	8001bc8 <HAL_GetTick>
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 80070b0:	f04f 48b0 	mov.w	r8, #1476395008	@ 0x58000000
 80070b4:	4607      	mov	r7, r0
 80070b6:	f8d8 3000 	ldr.w	r3, [r8]
 80070ba:	039b      	lsls	r3, r3, #14
 80070bc:	f53f ae6d 	bmi.w	8006d9a <HAL_RCC_OscConfig+0xda>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80070c0:	f7fa fd82 	bl	8001bc8 <HAL_GetTick>
 80070c4:	1bc0      	subs	r0, r0, r7
 80070c6:	2864      	cmp	r0, #100	@ 0x64
 80070c8:	d9f5      	bls.n	80070b6 <HAL_RCC_OscConfig+0x3f6>
 80070ca:	e663      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
        tickstart = HAL_GetTick();
 80070cc:	f7fa fd7c 	bl	8001bc8 <HAL_GetTick>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 80070d0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80070d4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80070d8:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
        tickstart = HAL_GetTick();
 80070dc:	4606      	mov	r6, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 80070de:	f04f 47b0 	mov.w	r7, #1476395008	@ 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80070e2:	f241 3888 	movw	r8, #5000	@ 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 80070e6:	e00f      	b.n	8007108 <HAL_RCC_OscConfig+0x448>
 80070e8:	58000400 	.word	0x58000400
 80070ec:	eefefffc 	.word	0xeefefffc
 80070f0:	20000008 	.word	0x20000008
 80070f4:	08016a6c 	.word	0x08016a6c
 80070f8:	20000004 	.word	0x20000004
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80070fc:	f7fa fd64 	bl	8001bc8 <HAL_GetTick>
 8007100:	1b80      	subs	r0, r0, r6
 8007102:	4540      	cmp	r0, r8
 8007104:	f63f ae46 	bhi.w	8006d94 <HAL_RCC_OscConfig+0xd4>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8007108:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800710c:	0519      	lsls	r1, r3, #20
 800710e:	d5f5      	bpl.n	80070fc <HAL_RCC_OscConfig+0x43c>
 8007110:	e6cd      	b.n	8006eae <HAL_RCC_OscConfig+0x1ee>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 8007112:	683b      	ldr	r3, [r7, #0]
 8007114:	f023 0301 	bic.w	r3, r3, #1
 8007118:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 800711a:	f7fa fd55 	bl	8001bc8 <HAL_GetTick>
 800711e:	4680      	mov	r8, r0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8007120:	683b      	ldr	r3, [r7, #0]
 8007122:	0798      	lsls	r0, r3, #30
 8007124:	f57f ae05 	bpl.w	8006d32 <HAL_RCC_OscConfig+0x72>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8007128:	f7fa fd4e 	bl	8001bc8 <HAL_GetTick>
 800712c:	eba0 0008 	sub.w	r0, r0, r8
 8007130:	2802      	cmp	r0, #2
 8007132:	d9f5      	bls.n	8007120 <HAL_RCC_OscConfig+0x460>
 8007134:	e62e      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8007136:	f7fa fd47 	bl	8001bc8 <HAL_GetTick>
 800713a:	eba0 0008 	sub.w	r0, r0, r8
 800713e:	2802      	cmp	r0, #2
 8007140:	f67f ade2 	bls.w	8006d08 <HAL_RCC_OscConfig+0x48>
 8007144:	e626      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8007146:	6873      	ldr	r3, [r6, #4]
 8007148:	6962      	ldr	r2, [r4, #20]
 800714a:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 800714e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8007152:	6073      	str	r3, [r6, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8007154:	6823      	ldr	r3, [r4, #0]
}
 8007156:	e64a      	b.n	8006dee <HAL_RCC_OscConfig+0x12e>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8007158:	f7fa fd36 	bl	8001bc8 <HAL_GetTick>
 800715c:	1bc0      	subs	r0, r0, r7
 800715e:	2802      	cmp	r0, #2
 8007160:	f67f ae40 	bls.w	8006de4 <HAL_RCC_OscConfig+0x124>
 8007164:	e616      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8007166:	f7fa fd2f 	bl	8001bc8 <HAL_GetTick>
 800716a:	1b40      	subs	r0, r0, r5
 800716c:	280a      	cmp	r0, #10
 800716e:	f67f aeaf 	bls.w	8006ed0 <HAL_RCC_OscConfig+0x210>
 8007172:	e60f      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8007174:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8007178:	681a      	ldr	r2, [r3, #0]
 800717a:	f042 0208 	orr.w	r2, r2, #8
 800717e:	601a      	str	r2, [r3, #0]
 8007180:	681a      	ldr	r2, [r3, #0]
 8007182:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8007186:	4302      	orrs	r2, r0
 8007188:	601a      	str	r2, [r3, #0]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 800718a:	685a      	ldr	r2, [r3, #4]
 800718c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800718e:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
 8007192:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8007196:	605a      	str	r2, [r3, #4]
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8007198:	f7ff fcac 	bl	8006af4 <RCC_SetFlashLatencyFromMSIRange>
 800719c:	2800      	cmp	r0, #0
 800719e:	f43f af09 	beq.w	8006fb4 <HAL_RCC_OscConfig+0x2f4>
    return HAL_ERROR;
 80071a2:	2001      	movs	r0, #1
 80071a4:	e69d      	b.n	8006ee2 <HAL_RCC_OscConfig+0x222>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80071a6:	2b01      	cmp	r3, #1
 80071a8:	d0fb      	beq.n	80071a2 <HAL_RCC_OscConfig+0x4e2>
        pll_config = RCC->PLLCFGR;
 80071aa:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 80071ae:	6b22      	ldr	r2, [r4, #48]	@ 0x30
        pll_config = RCC->PLLCFGR;
 80071b0:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 80071b2:	f003 0103 	and.w	r1, r3, #3
 80071b6:	4291      	cmp	r1, r2
 80071b8:	d1f3      	bne.n	80071a2 <HAL_RCC_OscConfig+0x4e2>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 80071ba:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 80071bc:	f003 0170 	and.w	r1, r3, #112	@ 0x70
 80071c0:	4291      	cmp	r1, r2
 80071c2:	d1ee      	bne.n	80071a2 <HAL_RCC_OscConfig+0x4e2>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 80071c4:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 80071c6:	f403 42fe 	and.w	r2, r3, #32512	@ 0x7f00
 80071ca:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 80071ce:	d1e8      	bne.n	80071a2 <HAL_RCC_OscConfig+0x4e2>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 80071d0:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 80071d2:	f003 4360 	and.w	r3, r3, #3758096384	@ 0xe0000000
 80071d6:	1a18      	subs	r0, r3, r0
 80071d8:	bf18      	it	ne
 80071da:	2001      	movne	r0, #1
 80071dc:	e681      	b.n	8006ee2 <HAL_RCC_OscConfig+0x222>
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 80071de:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
 80071e2:	682b      	ldr	r3, [r5, #0]
 80071e4:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80071e8:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80071ea:	f7fa fced 	bl	8001bc8 <HAL_GetTick>
 80071ee:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 80071f0:	682b      	ldr	r3, [r5, #0]
 80071f2:	0199      	lsls	r1, r3, #6
 80071f4:	d427      	bmi.n	8007246 <HAL_RCC_OscConfig+0x586>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80071f6:	e9d4 320c 	ldrd	r3, r2, [r4, #48]	@ 0x30
 80071fa:	68e9      	ldr	r1, [r5, #12]
 80071fc:	4313      	orrs	r3, r2
 80071fe:	4a20      	ldr	r2, [pc, #128]	@ (8007280 <HAL_RCC_OscConfig+0x5c0>)
 8007200:	400a      	ands	r2, r1
 8007202:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8007204:	4313      	orrs	r3, r2
 8007206:	430b      	orrs	r3, r1
 8007208:	e9d4 0110 	ldrd	r0, r1, [r4, #64]	@ 0x40
 800720c:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800720e:	4303      	orrs	r3, r0
 8007210:	430b      	orrs	r3, r1
 8007212:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007216:	60eb      	str	r3, [r5, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8007218:	682b      	ldr	r3, [r5, #0]
 800721a:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800721e:	602b      	str	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8007220:	68eb      	ldr	r3, [r5, #12]
 8007222:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8007226:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8007228:	f7fa fcce 	bl	8001bc8 <HAL_GetTick>
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 800722c:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 8007230:	4604      	mov	r4, r0
 8007232:	6833      	ldr	r3, [r6, #0]
 8007234:	019a      	lsls	r2, r3, #6
 8007236:	f53f ae53 	bmi.w	8006ee0 <HAL_RCC_OscConfig+0x220>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800723a:	f7fa fcc5 	bl	8001bc8 <HAL_GetTick>
 800723e:	1b00      	subs	r0, r0, r4
 8007240:	280a      	cmp	r0, #10
 8007242:	d9f6      	bls.n	8007232 <HAL_RCC_OscConfig+0x572>
 8007244:	e5a6      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8007246:	f7fa fcbf 	bl	8001bc8 <HAL_GetTick>
 800724a:	1b80      	subs	r0, r0, r6
 800724c:	280a      	cmp	r0, #10
 800724e:	d9cf      	bls.n	80071f0 <HAL_RCC_OscConfig+0x530>
 8007250:	e5a0      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 8007252:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 8007256:	f023 0301 	bic.w	r3, r3, #1
 800725a:	f8c6 3094 	str.w	r3, [r6, #148]	@ 0x94
          tickstart = HAL_GetTick();
 800725e:	f7fa fcb3 	bl	8001bc8 <HAL_GetTick>
 8007262:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 8007264:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 8007268:	079a      	lsls	r2, r3, #30
 800726a:	d401      	bmi.n	8007270 <HAL_RCC_OscConfig+0x5b0>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 800726c:	69e2      	ldr	r2, [r4, #28]
 800726e:	e64f      	b.n	8006f10 <HAL_RCC_OscConfig+0x250>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8007270:	f7fa fcaa 	bl	8001bc8 <HAL_GetTick>
 8007274:	1bc0      	subs	r0, r0, r7
 8007276:	2811      	cmp	r0, #17
 8007278:	d9f4      	bls.n	8007264 <HAL_RCC_OscConfig+0x5a4>
 800727a:	e58b      	b.n	8006d94 <HAL_RCC_OscConfig+0xd4>
    return HAL_ERROR;
 800727c:	2001      	movs	r0, #1
}
 800727e:	4770      	bx	lr
 8007280:	11c1808c 	.word	0x11c1808c

08007284 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8007284:	2800      	cmp	r0, #0
 8007286:	f000 80f8 	beq.w	800747a <HAL_RCC_ClockConfig+0x1f6>
{
 800728a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800728e:	4e7c      	ldr	r6, [pc, #496]	@ (8007480 <HAL_RCC_ClockConfig+0x1fc>)
 8007290:	6833      	ldr	r3, [r6, #0]
 8007292:	f003 0307 	and.w	r3, r3, #7
 8007296:	428b      	cmp	r3, r1
 8007298:	460c      	mov	r4, r1
 800729a:	4605      	mov	r5, r0
 800729c:	f0c0 80b2 	bcc.w	8007404 <HAL_RCC_ClockConfig+0x180>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80072a0:	682b      	ldr	r3, [r5, #0]
 80072a2:	0798      	lsls	r0, r3, #30
 80072a4:	d462      	bmi.n	800736c <HAL_RCC_ClockConfig+0xe8>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 80072a6:	065a      	lsls	r2, r3, #25
 80072a8:	d471      	bmi.n	800738e <HAL_RCC_ClockConfig+0x10a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80072aa:	0758      	lsls	r0, r3, #29
 80072ac:	f100 8085 	bmi.w	80073ba <HAL_RCC_ClockConfig+0x136>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80072b0:	071a      	lsls	r2, r3, #28
 80072b2:	f100 8094 	bmi.w	80073de <HAL_RCC_ClockConfig+0x15a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80072b6:	07df      	lsls	r7, r3, #31
 80072b8:	d42e      	bmi.n	8007318 <HAL_RCC_ClockConfig+0x94>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80072ba:	4d71      	ldr	r5, [pc, #452]	@ (8007480 <HAL_RCC_ClockConfig+0x1fc>)
 80072bc:	682b      	ldr	r3, [r5, #0]
 80072be:	f003 0307 	and.w	r3, r3, #7
 80072c2:	42a3      	cmp	r3, r4
 80072c4:	d913      	bls.n	80072ee <HAL_RCC_ClockConfig+0x6a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80072c6:	682b      	ldr	r3, [r5, #0]
 80072c8:	f023 0307 	bic.w	r3, r3, #7
 80072cc:	4323      	orrs	r3, r4
 80072ce:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 80072d0:	f7fa fc7a 	bl	8001bc8 <HAL_GetTick>
 80072d4:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80072d6:	e005      	b.n	80072e4 <HAL_RCC_ClockConfig+0x60>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 80072d8:	f7fa fc76 	bl	8001bc8 <HAL_GetTick>
 80072dc:	1b80      	subs	r0, r0, r6
 80072de:	2802      	cmp	r0, #2
 80072e0:	f200 80a3 	bhi.w	800742a <HAL_RCC_ClockConfig+0x1a6>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80072e4:	682b      	ldr	r3, [r5, #0]
 80072e6:	f003 0307 	and.w	r3, r3, #7
 80072ea:	42a3      	cmp	r3, r4
 80072ec:	d1f4      	bne.n	80072d8 <HAL_RCC_ClockConfig+0x54>
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 80072ee:	f7ff fc6f 	bl	8006bd0 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80072f2:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80072f6:	4c63      	ldr	r4, [pc, #396]	@ (8007484 <HAL_RCC_ClockConfig+0x200>)
 80072f8:	6892      	ldr	r2, [r2, #8]
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 80072fa:	4963      	ldr	r1, [pc, #396]	@ (8007488 <HAL_RCC_ClockConfig+0x204>)
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 80072fc:	4603      	mov	r3, r0
 80072fe:	f3c2 1203 	ubfx	r2, r2, #4, #4
  return HAL_InitTick(uwTickPrio);
 8007302:	4862      	ldr	r0, [pc, #392]	@ (800748c <HAL_RCC_ClockConfig+0x208>)
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8007304:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
  return HAL_InitTick(uwTickPrio);
 8007308:	6800      	ldr	r0, [r0, #0]
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 800730a:	fbb3 f3f2 	udiv	r3, r3, r2
}
 800730e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8007312:	600b      	str	r3, [r1, #0]
  return HAL_InitTick(uwTickPrio);
 8007314:	f7fa bc56 	b.w	8001bc4 <HAL_InitTick>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8007318:	686b      	ldr	r3, [r5, #4]
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800731a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800731e:	2b02      	cmp	r3, #2
 8007320:	6812      	ldr	r2, [r2, #0]
 8007322:	f000 80a3 	beq.w	800746c <HAL_RCC_ClockConfig+0x1e8>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8007326:	2b03      	cmp	r3, #3
 8007328:	f000 809a 	beq.w	8007460 <HAL_RCC_ClockConfig+0x1dc>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800732c:	2b00      	cmp	r3, #0
 800732e:	f040 80a1 	bne.w	8007474 <HAL_RCC_ClockConfig+0x1f0>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8007332:	0791      	lsls	r1, r2, #30
 8007334:	f140 8097 	bpl.w	8007466 <HAL_RCC_ClockConfig+0x1e2>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8007338:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800733c:	f241 3888 	movw	r8, #5000	@ 0x1388
 8007340:	68b2      	ldr	r2, [r6, #8]
 8007342:	f022 0203 	bic.w	r2, r2, #3
 8007346:	4313      	orrs	r3, r2
 8007348:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800734a:	f7fa fc3d 	bl	8001bc8 <HAL_GetTick>
 800734e:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8007350:	e004      	b.n	800735c <HAL_RCC_ClockConfig+0xd8>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8007352:	f7fa fc39 	bl	8001bc8 <HAL_GetTick>
 8007356:	1bc0      	subs	r0, r0, r7
 8007358:	4540      	cmp	r0, r8
 800735a:	d866      	bhi.n	800742a <HAL_RCC_ClockConfig+0x1a6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800735c:	68b3      	ldr	r3, [r6, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800735e:	686a      	ldr	r2, [r5, #4]
 8007360:	f003 030c 	and.w	r3, r3, #12
 8007364:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8007368:	d1f3      	bne.n	8007352 <HAL_RCC_ClockConfig+0xce>
 800736a:	e7a6      	b.n	80072ba <HAL_RCC_ClockConfig+0x36>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800736c:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 8007370:	68aa      	ldr	r2, [r5, #8]
 8007372:	68b3      	ldr	r3, [r6, #8]
 8007374:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8007378:	4313      	orrs	r3, r2
 800737a:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800737c:	f7fa fc24 	bl	8001bc8 <HAL_GetTick>
 8007380:	4607      	mov	r7, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 8007382:	68b3      	ldr	r3, [r6, #8]
 8007384:	03d9      	lsls	r1, r3, #15
 8007386:	d553      	bpl.n	8007430 <HAL_RCC_ClockConfig+0x1ac>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 8007388:	682b      	ldr	r3, [r5, #0]
 800738a:	065a      	lsls	r2, r3, #25
 800738c:	d58d      	bpl.n	80072aa <HAL_RCC_ClockConfig+0x26>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 800738e:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 8007392:	696a      	ldr	r2, [r5, #20]
 8007394:	f8d6 3108 	ldr.w	r3, [r6, #264]	@ 0x108
 8007398:	f023 030f 	bic.w	r3, r3, #15
 800739c:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 80073a0:	f8c6 3108 	str.w	r3, [r6, #264]	@ 0x108
    tickstart = HAL_GetTick();
 80073a4:	f7fa fc10 	bl	8001bc8 <HAL_GetTick>
 80073a8:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 80073aa:	f8d6 3108 	ldr.w	r3, [r6, #264]	@ 0x108
 80073ae:	03db      	lsls	r3, r3, #15
 80073b0:	d544      	bpl.n	800743c <HAL_RCC_ClockConfig+0x1b8>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80073b2:	682b      	ldr	r3, [r5, #0]
 80073b4:	0758      	lsls	r0, r3, #29
 80073b6:	f57f af7b 	bpl.w	80072b0 <HAL_RCC_ClockConfig+0x2c>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 80073ba:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 80073be:	68ea      	ldr	r2, [r5, #12]
 80073c0:	68b3      	ldr	r3, [r6, #8]
 80073c2:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 80073c6:	4313      	orrs	r3, r2
 80073c8:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80073ca:	f7fa fbfd 	bl	8001bc8 <HAL_GetTick>
 80073ce:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 80073d0:	68b3      	ldr	r3, [r6, #8]
 80073d2:	0399      	lsls	r1, r3, #14
 80073d4:	d538      	bpl.n	8007448 <HAL_RCC_ClockConfig+0x1c4>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80073d6:	682b      	ldr	r3, [r5, #0]
 80073d8:	071a      	lsls	r2, r3, #28
 80073da:	f57f af6c 	bpl.w	80072b6 <HAL_RCC_ClockConfig+0x32>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 80073de:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 80073e2:	692a      	ldr	r2, [r5, #16]
 80073e4:	68b3      	ldr	r3, [r6, #8]
 80073e6:	f423 5360 	bic.w	r3, r3, #14336	@ 0x3800
 80073ea:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80073ee:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80073f0:	f7fa fbea 	bl	8001bc8 <HAL_GetTick>
 80073f4:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 80073f6:	68b3      	ldr	r3, [r6, #8]
 80073f8:	035b      	lsls	r3, r3, #13
 80073fa:	d52b      	bpl.n	8007454 <HAL_RCC_ClockConfig+0x1d0>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80073fc:	682b      	ldr	r3, [r5, #0]
 80073fe:	07df      	lsls	r7, r3, #31
 8007400:	d48a      	bmi.n	8007318 <HAL_RCC_ClockConfig+0x94>
 8007402:	e75a      	b.n	80072ba <HAL_RCC_ClockConfig+0x36>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8007404:	6833      	ldr	r3, [r6, #0]
 8007406:	f023 0307 	bic.w	r3, r3, #7
 800740a:	430b      	orrs	r3, r1
 800740c:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 800740e:	f7fa fbdb 	bl	8001bc8 <HAL_GetTick>
 8007412:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8007414:	6833      	ldr	r3, [r6, #0]
 8007416:	f003 0307 	and.w	r3, r3, #7
 800741a:	42a3      	cmp	r3, r4
 800741c:	f43f af40 	beq.w	80072a0 <HAL_RCC_ClockConfig+0x1c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8007420:	f7fa fbd2 	bl	8001bc8 <HAL_GetTick>
 8007424:	1bc3      	subs	r3, r0, r7
 8007426:	2b02      	cmp	r3, #2
 8007428:	d9f4      	bls.n	8007414 <HAL_RCC_ClockConfig+0x190>
        return HAL_TIMEOUT;
 800742a:	2003      	movs	r0, #3
}
 800742c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8007430:	f7fa fbca 	bl	8001bc8 <HAL_GetTick>
 8007434:	1bc0      	subs	r0, r0, r7
 8007436:	2802      	cmp	r0, #2
 8007438:	d9a3      	bls.n	8007382 <HAL_RCC_ClockConfig+0xfe>
 800743a:	e7f6      	b.n	800742a <HAL_RCC_ClockConfig+0x1a6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800743c:	f7fa fbc4 	bl	8001bc8 <HAL_GetTick>
 8007440:	1bc0      	subs	r0, r0, r7
 8007442:	2802      	cmp	r0, #2
 8007444:	d9b1      	bls.n	80073aa <HAL_RCC_ClockConfig+0x126>
 8007446:	e7f0      	b.n	800742a <HAL_RCC_ClockConfig+0x1a6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8007448:	f7fa fbbe 	bl	8001bc8 <HAL_GetTick>
 800744c:	1bc0      	subs	r0, r0, r7
 800744e:	2802      	cmp	r0, #2
 8007450:	d9be      	bls.n	80073d0 <HAL_RCC_ClockConfig+0x14c>
 8007452:	e7ea      	b.n	800742a <HAL_RCC_ClockConfig+0x1a6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8007454:	f7fa fbb8 	bl	8001bc8 <HAL_GetTick>
 8007458:	1bc0      	subs	r0, r0, r7
 800745a:	2802      	cmp	r0, #2
 800745c:	d9cb      	bls.n	80073f6 <HAL_RCC_ClockConfig+0x172>
 800745e:	e7e4      	b.n	800742a <HAL_RCC_ClockConfig+0x1a6>
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8007460:	0190      	lsls	r0, r2, #6
 8007462:	f53f af69 	bmi.w	8007338 <HAL_RCC_ClockConfig+0xb4>
    return HAL_ERROR;
 8007466:	2001      	movs	r0, #1
}
 8007468:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800746c:	0396      	lsls	r6, r2, #14
 800746e:	f53f af63 	bmi.w	8007338 <HAL_RCC_ClockConfig+0xb4>
 8007472:	e7f8      	b.n	8007466 <HAL_RCC_ClockConfig+0x1e2>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8007474:	0552      	lsls	r2, r2, #21
 8007476:	d5f6      	bpl.n	8007466 <HAL_RCC_ClockConfig+0x1e2>
 8007478:	e75e      	b.n	8007338 <HAL_RCC_ClockConfig+0xb4>
    return HAL_ERROR;
 800747a:	2001      	movs	r0, #1
}
 800747c:	4770      	bx	lr
 800747e:	bf00      	nop
 8007480:	58004000 	.word	0x58004000
 8007484:	08016a6c 	.word	0x08016a6c
 8007488:	20000004 	.word	0x20000004
 800748c:	20000008 	.word	0x20000008

08007490 <HAL_RCC_GetHCLKFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8007490:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8007494:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8007496:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8007498:	f012 020c 	ands.w	r2, r2, #12
 800749c:	d027      	beq.n	80074ee <HAL_RCC_GetHCLKFreq+0x5e>
 800749e:	2a0c      	cmp	r2, #12
 80074a0:	d054      	beq.n	800754c <HAL_RCC_GetHCLKFreq+0xbc>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80074a2:	2a04      	cmp	r2, #4
 80074a4:	d161      	bne.n	800756a <HAL_RCC_GetHCLKFreq+0xda>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80074a6:	f04f 40b0 	mov.w	r0, #1476395008	@ 0x58000000
    sysclockfreq = HSI_VALUE;
 80074aa:	4b36      	ldr	r3, [pc, #216]	@ (8007584 <HAL_RCC_GetHCLKFreq+0xf4>)
 80074ac:	6882      	ldr	r2, [r0, #8]
 80074ae:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80074b2:	2a0c      	cmp	r2, #12
  uint32_t msifreq = 0U;
 80074b4:	f04f 0100 	mov.w	r1, #0
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80074b8:	d135      	bne.n	8007526 <HAL_RCC_GetHCLKFreq+0x96>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80074ba:	68c3      	ldr	r3, [r0, #12]
 80074bc:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 80074c0:	2b02      	cmp	r3, #2
 80074c2:	d05d      	beq.n	8007580 <HAL_RCC_GetHCLKFreq+0xf0>
 80074c4:	2b03      	cmp	r3, #3
 80074c6:	d048      	beq.n	800755a <HAL_RCC_GetHCLKFreq+0xca>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80074c8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80074cc:	68d3      	ldr	r3, [r2, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80074ce:	68d0      	ldr	r0, [r2, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80074d0:	68d2      	ldr	r2, [r2, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80074d2:	f3c3 2306 	ubfx	r3, r3, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 80074d6:	f3c0 1002 	ubfx	r0, r0, #4, #3
 80074da:	0f52      	lsrs	r2, r2, #29
 80074dc:	fb01 f303 	mul.w	r3, r1, r3
 80074e0:	3201      	adds	r2, #1
 80074e2:	1c41      	adds	r1, r0, #1
 80074e4:	fbb3 f3f1 	udiv	r3, r3, r1
 80074e8:	fbb3 f3f2 	udiv	r3, r3, r2
 80074ec:	e01b      	b.n	8007526 <HAL_RCC_GetHCLKFreq+0x96>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 80074ee:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 80074f2:	680b      	ldr	r3, [r1, #0]
 80074f4:	f013 0308 	ands.w	r3, r3, #8
 80074f8:	d120      	bne.n	800753c <HAL_RCC_GetHCLKFreq+0xac>
 80074fa:	6808      	ldr	r0, [r1, #0]
 80074fc:	0700      	lsls	r0, r0, #28
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80074fe:	bf56      	itet	pl
 8007500:	f8d1 3094 	ldrpl.w	r3, [r1, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8007504:	6809      	ldrmi	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8007506:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 800750a:	491f      	ldr	r1, [pc, #124]	@ (8007588 <HAL_RCC_GetHCLKFreq+0xf8>)
 800750c:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
  uint32_t sysclockfreq = 0U;
 8007510:	2a00      	cmp	r2, #0
 8007512:	bf0c      	ite	eq
 8007514:	460b      	moveq	r3, r1
 8007516:	2300      	movne	r3, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8007518:	f04f 40b0 	mov.w	r0, #1476395008	@ 0x58000000
 800751c:	6882      	ldr	r2, [r0, #8]
 800751e:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8007522:	2a0c      	cmp	r2, #12
 8007524:	d0c9      	beq.n	80074ba <HAL_RCC_GetHCLKFreq+0x2a>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8007526:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 800752a:	4918      	ldr	r1, [pc, #96]	@ (800758c <HAL_RCC_GetHCLKFreq+0xfc>)
 800752c:	6892      	ldr	r2, [r2, #8]
 800752e:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8007532:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
}
 8007536:	fbb3 f0f0 	udiv	r0, r3, r0
 800753a:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 800753c:	680b      	ldr	r3, [r1, #0]
 800753e:	f013 0308 	ands.w	r3, r3, #8
 8007542:	d01a      	beq.n	800757a <HAL_RCC_GetHCLKFreq+0xea>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8007544:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8007546:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800754a:	e7de      	b.n	800750a <HAL_RCC_GetHCLKFreq+0x7a>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800754c:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 8007550:	2901      	cmp	r1, #1
 8007552:	d0cc      	beq.n	80074ee <HAL_RCC_GetHCLKFreq+0x5e>
  uint32_t msifreq = 0U;
 8007554:	2100      	movs	r1, #0
  uint32_t sysclockfreq = 0U;
 8007556:	460b      	mov	r3, r1
 8007558:	e7de      	b.n	8007518 <HAL_RCC_GetHCLKFreq+0x88>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 800755a:	6802      	ldr	r2, [r0, #0]
        pllinputfreq = HSI_VALUE;
 800755c:	4b09      	ldr	r3, [pc, #36]	@ (8007584 <HAL_RCC_GetHCLKFreq+0xf4>)
 800755e:	490c      	ldr	r1, [pc, #48]	@ (8007590 <HAL_RCC_GetHCLKFreq+0x100>)
 8007560:	f412 1f80 	tst.w	r2, #1048576	@ 0x100000
 8007564:	bf18      	it	ne
 8007566:	4619      	movne	r1, r3
 8007568:	e7ae      	b.n	80074c8 <HAL_RCC_GetHCLKFreq+0x38>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800756a:	2a08      	cmp	r2, #8
 800756c:	d1f2      	bne.n	8007554 <HAL_RCC_GetHCLKFreq+0xc4>
 800756e:	6819      	ldr	r1, [r3, #0]
 8007570:	f411 1180 	ands.w	r1, r1, #1048576	@ 0x100000
 8007574:	d197      	bne.n	80074a6 <HAL_RCC_GetHCLKFreq+0x16>
      sysclockfreq = HSE_VALUE;
 8007576:	4b06      	ldr	r3, [pc, #24]	@ (8007590 <HAL_RCC_GetHCLKFreq+0x100>)
 8007578:	e7ce      	b.n	8007518 <HAL_RCC_GetHCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 800757a:	f8d1 1094 	ldr.w	r1, [r1, #148]	@ 0x94
 800757e:	e7c4      	b.n	800750a <HAL_RCC_GetHCLKFreq+0x7a>
        pllinputfreq = HSI_VALUE;
 8007580:	4900      	ldr	r1, [pc, #0]	@ (8007584 <HAL_RCC_GetHCLKFreq+0xf4>)
 8007582:	e7a1      	b.n	80074c8 <HAL_RCC_GetHCLKFreq+0x38>
 8007584:	00f42400 	.word	0x00f42400
 8007588:	08016a0c 	.word	0x08016a0c
 800758c:	08016a6c 	.word	0x08016a6c
 8007590:	01e84800 	.word	0x01e84800

08007594 <HAL_RCC_GetPCLK1Freq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8007594:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8007598:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800759a:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800759c:	f012 020c 	ands.w	r2, r2, #12
 80075a0:	d027      	beq.n	80075f2 <HAL_RCC_GetPCLK1Freq+0x5e>
 80075a2:	2a0c      	cmp	r2, #12
 80075a4:	d05c      	beq.n	8007660 <HAL_RCC_GetPCLK1Freq+0xcc>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80075a6:	2a04      	cmp	r2, #4
 80075a8:	d169      	bne.n	800767e <HAL_RCC_GetPCLK1Freq+0xea>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80075aa:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
    sysclockfreq = HSI_VALUE;
 80075ae:	483a      	ldr	r0, [pc, #232]	@ (8007698 <HAL_RCC_GetPCLK1Freq+0x104>)
 80075b0:	6893      	ldr	r3, [r2, #8]
 80075b2:	f003 030c 	and.w	r3, r3, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80075b6:	2b0c      	cmp	r3, #12
  uint32_t msifreq = 0U;
 80075b8:	f04f 0100 	mov.w	r1, #0
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80075bc:	d136      	bne.n	800762c <HAL_RCC_GetPCLK1Freq+0x98>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80075be:	68d3      	ldr	r3, [r2, #12]
 80075c0:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 80075c4:	2b02      	cmp	r3, #2
 80075c6:	d065      	beq.n	8007694 <HAL_RCC_GetPCLK1Freq+0x100>
 80075c8:	2b03      	cmp	r3, #3
 80075ca:	d050      	beq.n	800766e <HAL_RCC_GetPCLK1Freq+0xda>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80075cc:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80075d0:	68d8      	ldr	r0, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80075d2:	68da      	ldr	r2, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80075d4:	68db      	ldr	r3, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80075d6:	f3c0 2006 	ubfx	r0, r0, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 80075da:	f3c2 1202 	ubfx	r2, r2, #4, #3
 80075de:	0f5b      	lsrs	r3, r3, #29
 80075e0:	fb01 f000 	mul.w	r0, r1, r0
 80075e4:	3201      	adds	r2, #1
 80075e6:	3301      	adds	r3, #1
 80075e8:	fbb0 f0f2 	udiv	r0, r0, r2
 80075ec:	fbb0 f0f3 	udiv	r0, r0, r3
 80075f0:	e01c      	b.n	800762c <HAL_RCC_GetPCLK1Freq+0x98>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 80075f2:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 80075f6:	680b      	ldr	r3, [r1, #0]
 80075f8:	f013 0308 	ands.w	r3, r3, #8
 80075fc:	d128      	bne.n	8007650 <HAL_RCC_GetPCLK1Freq+0xbc>
 80075fe:	6808      	ldr	r0, [r1, #0]
 8007600:	f010 0f08 	tst.w	r0, #8
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8007604:	bf0a      	itet	eq
 8007606:	f8d1 3094 	ldreq.w	r3, [r1, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 800760a:	6809      	ldrne	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 800760c:	f3c3 2303 	ubfxeq	r3, r3, #8, #4
 8007610:	4922      	ldr	r1, [pc, #136]	@ (800769c <HAL_RCC_GetPCLK1Freq+0x108>)
 8007612:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
  uint32_t sysclockfreq = 0U;
 8007616:	2a00      	cmp	r2, #0
 8007618:	bf0c      	ite	eq
 800761a:	4608      	moveq	r0, r1
 800761c:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800761e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8007622:	6893      	ldr	r3, [r2, #8]
 8007624:	f003 030c 	and.w	r3, r3, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8007628:	2b0c      	cmp	r3, #12
 800762a:	d0c8      	beq.n	80075be <HAL_RCC_GetPCLK1Freq+0x2a>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 800762c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8007630:	491b      	ldr	r1, [pc, #108]	@ (80076a0 <HAL_RCC_GetPCLK1Freq+0x10c>)
 8007632:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8007634:	689b      	ldr	r3, [r3, #8]
 8007636:	f3c2 1203 	ubfx	r2, r2, #4, #4
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 800763a:	f3c3 2302 	ubfx	r3, r3, #8, #3
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 800763e:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 8007642:	4a18      	ldr	r2, [pc, #96]	@ (80076a4 <HAL_RCC_GetPCLK1Freq+0x110>)
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8007644:	fbb0 f0f1 	udiv	r0, r0, r1
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 8007648:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 800764c:	40d8      	lsrs	r0, r3
 800764e:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8007650:	680b      	ldr	r3, [r1, #0]
 8007652:	f013 0308 	ands.w	r3, r3, #8
 8007656:	d01a      	beq.n	800768e <HAL_RCC_GetPCLK1Freq+0xfa>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8007658:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 800765a:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800765e:	e7d7      	b.n	8007610 <HAL_RCC_GetPCLK1Freq+0x7c>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8007660:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 8007664:	2901      	cmp	r1, #1
 8007666:	d0c4      	beq.n	80075f2 <HAL_RCC_GetPCLK1Freq+0x5e>
  uint32_t msifreq = 0U;
 8007668:	2100      	movs	r1, #0
  uint32_t sysclockfreq = 0U;
 800766a:	4608      	mov	r0, r1
 800766c:	e7d7      	b.n	800761e <HAL_RCC_GetPCLK1Freq+0x8a>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 800766e:	6812      	ldr	r2, [r2, #0]
        pllinputfreq = HSI_VALUE;
 8007670:	4b09      	ldr	r3, [pc, #36]	@ (8007698 <HAL_RCC_GetPCLK1Freq+0x104>)
 8007672:	490d      	ldr	r1, [pc, #52]	@ (80076a8 <HAL_RCC_GetPCLK1Freq+0x114>)
 8007674:	f412 1f80 	tst.w	r2, #1048576	@ 0x100000
 8007678:	bf18      	it	ne
 800767a:	4619      	movne	r1, r3
 800767c:	e7a6      	b.n	80075cc <HAL_RCC_GetPCLK1Freq+0x38>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800767e:	2a08      	cmp	r2, #8
 8007680:	d1f2      	bne.n	8007668 <HAL_RCC_GetPCLK1Freq+0xd4>
 8007682:	6819      	ldr	r1, [r3, #0]
 8007684:	f411 1180 	ands.w	r1, r1, #1048576	@ 0x100000
 8007688:	d18f      	bne.n	80075aa <HAL_RCC_GetPCLK1Freq+0x16>
      sysclockfreq = HSE_VALUE;
 800768a:	4807      	ldr	r0, [pc, #28]	@ (80076a8 <HAL_RCC_GetPCLK1Freq+0x114>)
 800768c:	e7c7      	b.n	800761e <HAL_RCC_GetPCLK1Freq+0x8a>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 800768e:	f8d1 1094 	ldr.w	r1, [r1, #148]	@ 0x94
 8007692:	e7bd      	b.n	8007610 <HAL_RCC_GetPCLK1Freq+0x7c>
        pllinputfreq = HSI_VALUE;
 8007694:	4900      	ldr	r1, [pc, #0]	@ (8007698 <HAL_RCC_GetPCLK1Freq+0x104>)
 8007696:	e799      	b.n	80075cc <HAL_RCC_GetPCLK1Freq+0x38>
 8007698:	00f42400 	.word	0x00f42400
 800769c:	08016a0c 	.word	0x08016a0c
 80076a0:	08016a6c 	.word	0x08016a6c
 80076a4:	08016a4c 	.word	0x08016a4c
 80076a8:	01e84800 	.word	0x01e84800

080076ac <HAL_RCC_GetPCLK2Freq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80076ac:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80076b0:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80076b2:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80076b4:	f012 020c 	ands.w	r2, r2, #12
 80076b8:	d027      	beq.n	800770a <HAL_RCC_GetPCLK2Freq+0x5e>
 80076ba:	2a0c      	cmp	r2, #12
 80076bc:	d05c      	beq.n	8007778 <HAL_RCC_GetPCLK2Freq+0xcc>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80076be:	2a04      	cmp	r2, #4
 80076c0:	d169      	bne.n	8007796 <HAL_RCC_GetPCLK2Freq+0xea>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80076c2:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
    sysclockfreq = HSI_VALUE;
 80076c6:	483a      	ldr	r0, [pc, #232]	@ (80077b0 <HAL_RCC_GetPCLK2Freq+0x104>)
 80076c8:	6893      	ldr	r3, [r2, #8]
 80076ca:	f003 030c 	and.w	r3, r3, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80076ce:	2b0c      	cmp	r3, #12
  uint32_t msifreq = 0U;
 80076d0:	f04f 0100 	mov.w	r1, #0
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80076d4:	d136      	bne.n	8007744 <HAL_RCC_GetPCLK2Freq+0x98>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80076d6:	68d3      	ldr	r3, [r2, #12]
 80076d8:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 80076dc:	2b02      	cmp	r3, #2
 80076de:	d065      	beq.n	80077ac <HAL_RCC_GetPCLK2Freq+0x100>
 80076e0:	2b03      	cmp	r3, #3
 80076e2:	d050      	beq.n	8007786 <HAL_RCC_GetPCLK2Freq+0xda>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80076e4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80076e8:	68d8      	ldr	r0, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80076ea:	68da      	ldr	r2, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80076ec:	68db      	ldr	r3, [r3, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80076ee:	f3c0 2006 	ubfx	r0, r0, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 80076f2:	f3c2 1202 	ubfx	r2, r2, #4, #3
 80076f6:	0f5b      	lsrs	r3, r3, #29
 80076f8:	fb01 f000 	mul.w	r0, r1, r0
 80076fc:	3201      	adds	r2, #1
 80076fe:	3301      	adds	r3, #1
 8007700:	fbb0 f0f2 	udiv	r0, r0, r2
 8007704:	fbb0 f0f3 	udiv	r0, r0, r3
 8007708:	e01c      	b.n	8007744 <HAL_RCC_GetPCLK2Freq+0x98>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 800770a:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 800770e:	680b      	ldr	r3, [r1, #0]
 8007710:	f013 0308 	ands.w	r3, r3, #8
 8007714:	d128      	bne.n	8007768 <HAL_RCC_GetPCLK2Freq+0xbc>
 8007716:	6808      	ldr	r0, [r1, #0]
 8007718:	f010 0f08 	tst.w	r0, #8
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 800771c:	bf0a      	itet	eq
 800771e:	f8d1 3094 	ldreq.w	r3, [r1, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8007722:	6809      	ldrne	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8007724:	f3c3 2303 	ubfxeq	r3, r3, #8, #4
 8007728:	4922      	ldr	r1, [pc, #136]	@ (80077b4 <HAL_RCC_GetPCLK2Freq+0x108>)
 800772a:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
  uint32_t sysclockfreq = 0U;
 800772e:	2a00      	cmp	r2, #0
 8007730:	bf0c      	ite	eq
 8007732:	4608      	moveq	r0, r1
 8007734:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8007736:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800773a:	6893      	ldr	r3, [r2, #8]
 800773c:	f003 030c 	and.w	r3, r3, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8007740:	2b0c      	cmp	r3, #12
 8007742:	d0c8      	beq.n	80076d6 <HAL_RCC_GetPCLK2Freq+0x2a>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8007744:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8007748:	491b      	ldr	r1, [pc, #108]	@ (80077b8 <HAL_RCC_GetPCLK2Freq+0x10c>)
 800774a:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 800774c:	689b      	ldr	r3, [r3, #8]
 800774e:	f3c2 1203 	ubfx	r2, r2, #4, #4
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 8007752:	f3c3 23c2 	ubfx	r3, r3, #11, #3
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8007756:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 800775a:	4a18      	ldr	r2, [pc, #96]	@ (80077bc <HAL_RCC_GetPCLK2Freq+0x110>)
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 800775c:	fbb0 f0f1 	udiv	r0, r0, r1
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 8007760:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 8007764:	40d8      	lsrs	r0, r3
 8007766:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8007768:	680b      	ldr	r3, [r1, #0]
 800776a:	f013 0308 	ands.w	r3, r3, #8
 800776e:	d01a      	beq.n	80077a6 <HAL_RCC_GetPCLK2Freq+0xfa>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8007770:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8007772:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8007776:	e7d7      	b.n	8007728 <HAL_RCC_GetPCLK2Freq+0x7c>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8007778:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 800777c:	2901      	cmp	r1, #1
 800777e:	d0c4      	beq.n	800770a <HAL_RCC_GetPCLK2Freq+0x5e>
  uint32_t msifreq = 0U;
 8007780:	2100      	movs	r1, #0
  uint32_t sysclockfreq = 0U;
 8007782:	4608      	mov	r0, r1
 8007784:	e7d7      	b.n	8007736 <HAL_RCC_GetPCLK2Freq+0x8a>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8007786:	6812      	ldr	r2, [r2, #0]
        pllinputfreq = HSI_VALUE;
 8007788:	4b09      	ldr	r3, [pc, #36]	@ (80077b0 <HAL_RCC_GetPCLK2Freq+0x104>)
 800778a:	490d      	ldr	r1, [pc, #52]	@ (80077c0 <HAL_RCC_GetPCLK2Freq+0x114>)
 800778c:	f412 1f80 	tst.w	r2, #1048576	@ 0x100000
 8007790:	bf18      	it	ne
 8007792:	4619      	movne	r1, r3
 8007794:	e7a6      	b.n	80076e4 <HAL_RCC_GetPCLK2Freq+0x38>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8007796:	2a08      	cmp	r2, #8
 8007798:	d1f2      	bne.n	8007780 <HAL_RCC_GetPCLK2Freq+0xd4>
 800779a:	6819      	ldr	r1, [r3, #0]
 800779c:	f411 1180 	ands.w	r1, r1, #1048576	@ 0x100000
 80077a0:	d18f      	bne.n	80076c2 <HAL_RCC_GetPCLK2Freq+0x16>
      sysclockfreq = HSE_VALUE;
 80077a2:	4807      	ldr	r0, [pc, #28]	@ (80077c0 <HAL_RCC_GetPCLK2Freq+0x114>)
 80077a4:	e7c7      	b.n	8007736 <HAL_RCC_GetPCLK2Freq+0x8a>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80077a6:	f8d1 1094 	ldr.w	r1, [r1, #148]	@ 0x94
 80077aa:	e7bd      	b.n	8007728 <HAL_RCC_GetPCLK2Freq+0x7c>
        pllinputfreq = HSI_VALUE;
 80077ac:	4900      	ldr	r1, [pc, #0]	@ (80077b0 <HAL_RCC_GetPCLK2Freq+0x104>)
 80077ae:	e799      	b.n	80076e4 <HAL_RCC_GetPCLK2Freq+0x38>
 80077b0:	00f42400 	.word	0x00f42400
 80077b4:	08016a0c 	.word	0x08016a0c
 80077b8:	08016a6c 	.word	0x08016a6c
 80077bc:	08016a4c 	.word	0x08016a4c
 80077c0:	01e84800 	.word	0x01e84800

080077c4 <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80077c4:	6803      	ldr	r3, [r0, #0]
{
 80077c6:	b570      	push	{r4, r5, r6, lr}
 80077c8:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80077ca:	f413 3080 	ands.w	r0, r3, #65536	@ 0x10000
 80077ce:	f040 80ba 	bne.w	8007946 <HAL_RCCEx_PeriphCLKConfig+0x182>
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80077d2:	07dd      	lsls	r5, r3, #31
 80077d4:	d50a      	bpl.n	80077ec <HAL_RCCEx_PeriphCLKConfig+0x28>
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 80077d6:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80077da:	6861      	ldr	r1, [r4, #4]
 80077dc:	f8d5 2088 	ldr.w	r2, [r5, #136]	@ 0x88
 80077e0:	ea22 4211 	bic.w	r2, r2, r1, lsr #16
 80077e4:	b289      	uxth	r1, r1
 80077e6:	430a      	orrs	r2, r1
 80077e8:	f8c5 2088 	str.w	r2, [r5, #136]	@ 0x88
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80077ec:	0799      	lsls	r1, r3, #30
 80077ee:	d50a      	bpl.n	8007806 <HAL_RCCEx_PeriphCLKConfig+0x42>
 80077f0:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80077f4:	68a1      	ldr	r1, [r4, #8]
 80077f6:	f8d5 2088 	ldr.w	r2, [r5, #136]	@ 0x88
 80077fa:	ea22 4211 	bic.w	r2, r2, r1, lsr #16
 80077fe:	b289      	uxth	r1, r1
 8007800:	430a      	orrs	r2, r1
 8007802:	f8c5 2088 	str.w	r2, [r5, #136]	@ 0x88
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8007806:	069a      	lsls	r2, r3, #26
 8007808:	d509      	bpl.n	800781e <HAL_RCCEx_PeriphCLKConfig+0x5a>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 800780a:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 800780e:	6925      	ldr	r5, [r4, #16]
 8007810:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8007814:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 8007818:	432a      	orrs	r2, r5
 800781a:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800781e:	059e      	lsls	r6, r3, #22
 8007820:	d50c      	bpl.n	800783c <HAL_RCCEx_PeriphCLKConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8007822:	6a26      	ldr	r6, [r4, #32]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8007824:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
 8007828:	0c31      	lsrs	r1, r6, #16
 800782a:	f8d5 2088 	ldr.w	r2, [r5, #136]	@ 0x88
 800782e:	0409      	lsls	r1, r1, #16
 8007830:	ea22 0201 	bic.w	r2, r2, r1
 8007834:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
 8007838:	f8c5 2088 	str.w	r2, [r5, #136]	@ 0x88
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 800783c:	055d      	lsls	r5, r3, #21
 800783e:	d50c      	bpl.n	800785a <HAL_RCCEx_PeriphCLKConfig+0x96>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8007840:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 8007842:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
 8007846:	0c31      	lsrs	r1, r6, #16
 8007848:	f8d5 2088 	ldr.w	r2, [r5, #136]	@ 0x88
 800784c:	0409      	lsls	r1, r1, #16
 800784e:	ea22 0201 	bic.w	r2, r2, r1
 8007852:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
 8007856:	f8c5 2088 	str.w	r2, [r5, #136]	@ 0x88
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 800785a:	0519      	lsls	r1, r3, #20
 800785c:	d50c      	bpl.n	8007878 <HAL_RCCEx_PeriphCLKConfig+0xb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 800785e:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8007860:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
 8007864:	0c31      	lsrs	r1, r6, #16
 8007866:	f8d5 2088 	ldr.w	r2, [r5, #136]	@ 0x88
 800786a:	0409      	lsls	r1, r1, #16
 800786c:	ea22 0201 	bic.w	r2, r2, r1
 8007870:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
 8007874:	f8c5 2088 	str.w	r2, [r5, #136]	@ 0x88
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8007878:	065a      	lsls	r2, r3, #25
 800787a:	d50f      	bpl.n	800789c <HAL_RCCEx_PeriphCLKConfig+0xd8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800787c:	6962      	ldr	r2, [r4, #20]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 800787e:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 8007882:	0915      	lsrs	r5, r2, #4
 8007884:	f8d6 1088 	ldr.w	r1, [r6, #136]	@ 0x88
 8007888:	f405 257f 	and.w	r5, r5, #1044480	@ 0xff000
 800788c:	0112      	lsls	r2, r2, #4
 800788e:	f402 227f 	and.w	r2, r2, #1044480	@ 0xff000
 8007892:	ea21 0105 	bic.w	r1, r1, r5
 8007896:	430a      	orrs	r2, r1
 8007898:	f8c6 2088 	str.w	r2, [r6, #136]	@ 0x88
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800789c:	061e      	lsls	r6, r3, #24
 800789e:	d50f      	bpl.n	80078c0 <HAL_RCCEx_PeriphCLKConfig+0xfc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80078a0:	69a2      	ldr	r2, [r4, #24]
 80078a2:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 80078a6:	0915      	lsrs	r5, r2, #4
 80078a8:	f8d6 1088 	ldr.w	r1, [r6, #136]	@ 0x88
 80078ac:	f405 257f 	and.w	r5, r5, #1044480	@ 0xff000
 80078b0:	0112      	lsls	r2, r2, #4
 80078b2:	f402 227f 	and.w	r2, r2, #1044480	@ 0xff000
 80078b6:	ea21 0105 	bic.w	r1, r1, r5
 80078ba:	430a      	orrs	r2, r1
 80078bc:	f8c6 2088 	str.w	r2, [r6, #136]	@ 0x88
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80078c0:	05dd      	lsls	r5, r3, #23
 80078c2:	d50f      	bpl.n	80078e4 <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80078c4:	69e2      	ldr	r2, [r4, #28]
 80078c6:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
 80078ca:	0915      	lsrs	r5, r2, #4
 80078cc:	f8d6 1088 	ldr.w	r1, [r6, #136]	@ 0x88
 80078d0:	f405 257f 	and.w	r5, r5, #1044480	@ 0xff000
 80078d4:	0112      	lsls	r2, r2, #4
 80078d6:	f402 227f 	and.w	r2, r2, #1044480	@ 0xff000
 80078da:	ea21 0105 	bic.w	r1, r1, r5
 80078de:	430a      	orrs	r2, r1
 80078e0:	f8c6 2088 	str.w	r2, [r6, #136]	@ 0x88
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 80078e4:	06d9      	lsls	r1, r3, #27
 80078e6:	d50c      	bpl.n	8007902 <HAL_RCCEx_PeriphCLKConfig+0x13e>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 80078e8:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 80078ec:	68e5      	ldr	r5, [r4, #12]
 80078ee:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80078f2:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 80078f6:	432a      	orrs	r2, r5

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 80078f8:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
 80078fc:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
 8007900:	d061      	beq.n	80079c6 <HAL_RCCEx_PeriphCLKConfig+0x202>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8007902:	041a      	lsls	r2, r3, #16
 8007904:	d50a      	bpl.n	800791c <HAL_RCCEx_PeriphCLKConfig+0x158>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 8007906:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800790a:	6b25      	ldr	r5, [r4, #48]	@ 0x30
 800790c:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8007910:	f022 4240 	bic.w	r2, r2, #3221225472	@ 0xc0000000
 8007914:	432a      	orrs	r2, r5
 8007916:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800791a:	b17d      	cbz	r5, 800793c <HAL_RCCEx_PeriphCLKConfig+0x178>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800791c:	045b      	lsls	r3, r3, #17
 800791e:	d50c      	bpl.n	800793a <HAL_RCCEx_PeriphCLKConfig+0x176>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 8007920:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8007924:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8007926:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 800792a:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
 800792e:	430b      	orrs	r3, r1

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 8007930:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
 8007934:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
 8007938:	d04a      	beq.n	80079d0 <HAL_RCCEx_PeriphCLKConfig+0x20c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
    }
  }

  return status;
}
 800793a:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 800793c:	68ca      	ldr	r2, [r1, #12]
 800793e:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 8007942:	60ca      	str	r2, [r1, #12]
 8007944:	e7ea      	b.n	800791c <HAL_RCCEx_PeriphCLKConfig+0x158>
    HAL_PWR_EnableBkUpAccess();
 8007946:	f7ff f84f 	bl	80069e8 <HAL_PWR_EnableBkUpAccess>
    tickstart = HAL_GetTick();
 800794a:	f7fa f93d 	bl	8001bc8 <HAL_GetTick>
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 800794e:	4e28      	ldr	r6, [pc, #160]	@ (80079f0 <HAL_RCCEx_PeriphCLKConfig+0x22c>)
    tickstart = HAL_GetTick();
 8007950:	4605      	mov	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 8007952:	e004      	b.n	800795e <HAL_RCCEx_PeriphCLKConfig+0x19a>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8007954:	f7fa f938 	bl	8001bc8 <HAL_GetTick>
 8007958:	1b43      	subs	r3, r0, r5
 800795a:	2b02      	cmp	r3, #2
 800795c:	d844      	bhi.n	80079e8 <HAL_RCCEx_PeriphCLKConfig+0x224>
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 800795e:	6833      	ldr	r3, [r6, #0]
 8007960:	05d8      	lsls	r0, r3, #23
 8007962:	d5f7      	bpl.n	8007954 <HAL_RCCEx_PeriphCLKConfig+0x190>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8007964:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 8007968:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 800796a:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 800796e:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8007972:	429a      	cmp	r2, r3
 8007974:	d01b      	beq.n	80079ae <HAL_RCCEx_PeriphCLKConfig+0x1ea>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8007976:	f8d5 1090 	ldr.w	r1, [r5, #144]	@ 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 800797a:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 800797e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8007982:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8007986:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 800798a:	f421 7040 	bic.w	r0, r1, #768	@ 0x300
 800798e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8007992:	0789      	lsls	r1, r1, #30
 8007994:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
        RCC->BDCR = tmpregister;
 8007998:	f8c5 0090 	str.w	r0, [r5, #144]	@ 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 800799c:	d507      	bpl.n	80079ae <HAL_RCCEx_PeriphCLKConfig+0x1ea>
        tickstart = HAL_GetTick();
 800799e:	f7fa f913 	bl	8001bc8 <HAL_GetTick>
 80079a2:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 80079a4:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 80079a8:	079b      	lsls	r3, r3, #30
 80079aa:	d516      	bpl.n	80079da <HAL_RCCEx_PeriphCLKConfig+0x216>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80079ac:	6b62      	ldr	r2, [r4, #52]	@ 0x34
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 80079ae:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 80079b2:	2000      	movs	r0, #0
 80079b4:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
 80079b8:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 80079bc:	4313      	orrs	r3, r2
 80079be:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80079c2:	6823      	ldr	r3, [r4, #0]
}
 80079c4:	e705      	b.n	80077d2 <HAL_RCCEx_PeriphCLKConfig+0xe>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 80079c6:	68ca      	ldr	r2, [r1, #12]
 80079c8:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 80079cc:	60ca      	str	r2, [r1, #12]
 80079ce:	e798      	b.n	8007902 <HAL_RCCEx_PeriphCLKConfig+0x13e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80079d0:	68d3      	ldr	r3, [r2, #12]
 80079d2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80079d6:	60d3      	str	r3, [r2, #12]
}
 80079d8:	bd70      	pop	{r4, r5, r6, pc}
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80079da:	f7fa f8f5 	bl	8001bc8 <HAL_GetTick>
 80079de:	f241 3388 	movw	r3, #5000	@ 0x1388
 80079e2:	1b80      	subs	r0, r0, r6
 80079e4:	4298      	cmp	r0, r3
 80079e6:	d9dd      	bls.n	80079a4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80079e8:	6823      	ldr	r3, [r4, #0]
        status = ret;
 80079ea:	2003      	movs	r0, #3
 80079ec:	e6f1      	b.n	80077d2 <HAL_RCCEx_PeriphCLKConfig+0xe>
 80079ee:	bf00      	nop
 80079f0:	58000400 	.word	0x58000400

080079f4 <HAL_RTC_SetAlarm_IT>:
{
  uint32_t tmpreg = 0;
  uint32_t binaryMode;

  /* Process Locked */
  __HAL_LOCK(hrtc);
 80079f4:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
 80079f8:	2b01      	cmp	r3, #1
 80079fa:	f000 80e3 	beq.w	8007bc4 <HAL_RTC_SetAlarm_IT+0x1d0>
{
 80079fe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    assert_param((sAlarm->AlarmSubSecondMask >> RTC_ALRMASSR_MASKSS_Pos) <= (8U + (READ_BIT(RTC->ICSR, RTC_ICSR_BCDU) >> RTC_ICSR_BCDU_Pos)));
  }
#endif

  /* Get Binary mode (32-bit free-running counter configuration) */
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 8007a02:	4b71      	ldr	r3, [pc, #452]	@ (8007bc8 <HAL_RTC_SetAlarm_IT+0x1d4>)
  __HAL_LOCK(hrtc);
 8007a04:	2701      	movs	r7, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007a06:	2402      	movs	r4, #2
  __HAL_LOCK(hrtc);
 8007a08:	f880 702c 	strb.w	r7, [r0, #44]	@ 0x2c
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007a0c:	f880 402d 	strb.w	r4, [r0, #45]	@ 0x2d
 8007a10:	4686      	mov	lr, r0
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 8007a12:	68d8      	ldr	r0, [r3, #12]
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
    }
    else
    {
      WRITE_REG(RTC->ALRMBR, tmpreg);
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 8007a14:	698e      	ldr	r6, [r1, #24]
  if (sAlarm->Alarm == RTC_ALARM_A)
 8007a16:	6a8d      	ldr	r5, [r1, #40]	@ 0x28
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 8007a18:	f400 7040 	and.w	r0, r0, #768	@ 0x300
  if (binaryMode != RTC_BINARY_ONLY)
 8007a1c:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 8007a20:	f000 80a0 	beq.w	8007b64 <HAL_RTC_SetAlarm_IT+0x170>
      if( sAlarm->AlarmMask != RTC_ALARMMASK_DATEWEEKDAY )
 8007a24:	6948      	ldr	r0, [r1, #20]
    if (Format == RTC_FORMAT_BIN)
 8007a26:	2a00      	cmp	r2, #0
 8007a28:	d17e      	bne.n	8007b28 <HAL_RTC_SetAlarm_IT+0x134>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8007a2a:	699c      	ldr	r4, [r3, #24]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8007a2c:	780b      	ldrb	r3, [r1, #0]
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8007a2e:	f014 0440 	ands.w	r4, r4, #64	@ 0x40
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8007a32:	bf16      	itet	ne
 8007a34:	78cc      	ldrbne	r4, [r1, #3]
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 8007a36:	70cc      	strbeq	r4, [r1, #3]
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8007a38:	05a4      	lslne	r4, r4, #22
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 8007a3a:	2b09      	cmp	r3, #9
 8007a3c:	d909      	bls.n	8007a52 <HAL_RTC_SetAlarm_IT+0x5e>
  uint32_t bcdhigh = 0U;
 8007a3e:	2700      	movs	r7, #0
  {
    bcdhigh++;
    tmp_Value -= 10U;
 8007a40:	3b0a      	subs	r3, #10
 8007a42:	b2db      	uxtb	r3, r3
  while (tmp_Value >= 10U)
 8007a44:	2b09      	cmp	r3, #9
    bcdhigh++;
 8007a46:	f107 0701 	add.w	r7, r7, #1
  while (tmp_Value >= 10U)
 8007a4a:	d8f9      	bhi.n	8007a40 <HAL_RTC_SetAlarm_IT+0x4c>
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8007a4c:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
 8007a50:	b2db      	uxtb	r3, r3
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8007a52:	ea4f 4c03 	mov.w	ip, r3, lsl #16
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8007a56:	784b      	ldrb	r3, [r1, #1]
  while (tmp_Value >= 10U)
 8007a58:	2b09      	cmp	r3, #9
 8007a5a:	d909      	bls.n	8007a70 <HAL_RTC_SetAlarm_IT+0x7c>
  uint32_t bcdhigh = 0U;
 8007a5c:	2700      	movs	r7, #0
    tmp_Value -= 10U;
 8007a5e:	3b0a      	subs	r3, #10
 8007a60:	b2db      	uxtb	r3, r3
  while (tmp_Value >= 10U)
 8007a62:	2b09      	cmp	r3, #9
    bcdhigh++;
 8007a64:	f107 0701 	add.w	r7, r7, #1
  while (tmp_Value >= 10U)
 8007a68:	d8f9      	bhi.n	8007a5e <HAL_RTC_SetAlarm_IT+0x6a>
  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8007a6a:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
 8007a6e:	b2db      	uxtb	r3, r3
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8007a70:	f891 8002 	ldrb.w	r8, [r1, #2]
  while (tmp_Value >= 10U)
 8007a74:	f1b8 0f09 	cmp.w	r8, #9
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8007a78:	ea4f 2303 	mov.w	r3, r3, lsl #8
  while (tmp_Value >= 10U)
 8007a7c:	d90d      	bls.n	8007a9a <HAL_RTC_SetAlarm_IT+0xa6>
  uint32_t bcdhigh = 0U;
 8007a7e:	2700      	movs	r7, #0
    tmp_Value -= 10U;
 8007a80:	f1a8 080a 	sub.w	r8, r8, #10
 8007a84:	fa5f f888 	uxtb.w	r8, r8
  while (tmp_Value >= 10U)
 8007a88:	f1b8 0f09 	cmp.w	r8, #9
    bcdhigh++;
 8007a8c:	f107 0701 	add.w	r7, r7, #1
  while (tmp_Value >= 10U)
 8007a90:	d8f6      	bhi.n	8007a80 <HAL_RTC_SetAlarm_IT+0x8c>
  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8007a92:	ea48 1707 	orr.w	r7, r8, r7, lsl #4
 8007a96:	fa5f f887 	uxtb.w	r8, r7
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8007a9a:	f891 7024 	ldrb.w	r7, [r1, #36]	@ 0x24
  while (tmp_Value >= 10U)
 8007a9e:	2f09      	cmp	r7, #9
 8007aa0:	d908      	bls.n	8007ab4 <HAL_RTC_SetAlarm_IT+0xc0>
    tmp_Value -= 10U;
 8007aa2:	3f0a      	subs	r7, #10
 8007aa4:	b2ff      	uxtb	r7, r7
  while (tmp_Value >= 10U)
 8007aa6:	2f09      	cmp	r7, #9
    bcdhigh++;
 8007aa8:	f102 0201 	add.w	r2, r2, #1
  while (tmp_Value >= 10U)
 8007aac:	d8f9      	bhi.n	8007aa2 <HAL_RTC_SetAlarm_IT+0xae>
  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8007aae:	ea47 1202 	orr.w	r2, r7, r2, lsl #4
 8007ab2:	b2d7      	uxtb	r7, r2
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8007ab4:	6a0a      	ldr	r2, [r1, #32]
 8007ab6:	4302      	orrs	r2, r0
 8007ab8:	4322      	orrs	r2, r4
 8007aba:	ea42 020c 	orr.w	r2, r2, ip
 8007abe:	4313      	orrs	r3, r2
 8007ac0:	ea43 0308 	orr.w	r3, r3, r8
 8007ac4:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007ac8:	4a3f      	ldr	r2, [pc, #252]	@ (8007bc8 <HAL_RTC_SetAlarm_IT+0x1d4>)
 8007aca:	20ca      	movs	r0, #202	@ 0xca
 8007acc:	6250      	str	r0, [r2, #36]	@ 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 8007ace:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007ad2:	f04f 0053 	mov.w	r0, #83	@ 0x53
 8007ad6:	6250      	str	r0, [r2, #36]	@ 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 8007ad8:	d06b      	beq.n	8007bb2 <HAL_RTC_SetAlarm_IT+0x1be>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8007ada:	6990      	ldr	r0, [r2, #24]
 8007adc:	f420 5008 	bic.w	r0, r0, #8704	@ 0x2200
 8007ae0:	6190      	str	r0, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8007ae2:	2002      	movs	r0, #2
 8007ae4:	65d0      	str	r0, [r2, #92]	@ 0x5c
      WRITE_REG(RTC->ALRMBR, tmpreg);
 8007ae6:	6493      	str	r3, [r2, #72]	@ 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 8007ae8:	64d6      	str	r6, [r2, #76]	@ 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 8007aea:	4b37      	ldr	r3, [pc, #220]	@ (8007bc8 <HAL_RTC_SetAlarm_IT+0x1d4>)
 8007aec:	684a      	ldr	r2, [r1, #4]
 8007aee:	675a      	str	r2, [r3, #116]	@ 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8007af0:	f8de 2030 	ldr.w	r2, [lr, #48]	@ 0x30
 8007af4:	f042 0202 	orr.w	r2, r2, #2
 8007af8:	f8ce 2030 	str.w	r2, [lr, #48]	@ 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8007afc:	699a      	ldr	r2, [r3, #24]
 8007afe:	f442 5208 	orr.w	r2, r2, #8704	@ 0x2200
 8007b02:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8007b04:	4a31      	ldr	r2, [pc, #196]	@ (8007bcc <HAL_RTC_SetAlarm_IT+0x1d8>)
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007b06:	4930      	ldr	r1, [pc, #192]	@ (8007bc8 <HAL_RTC_SetAlarm_IT+0x1d4>)
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8007b08:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
 8007b0c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8007b10:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
  __HAL_UNLOCK(hrtc);
 8007b14:	2000      	movs	r0, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007b16:	24ff      	movs	r4, #255	@ 0xff
  hrtc->State = HAL_RTC_STATE_READY;
 8007b18:	2301      	movs	r3, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007b1a:	624c      	str	r4, [r1, #36]	@ 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8007b1c:	f88e 302d 	strb.w	r3, [lr, #45]	@ 0x2d
  __HAL_UNLOCK(hrtc);
 8007b20:	f88e 002c 	strb.w	r0, [lr, #44]	@ 0x2c
}
 8007b24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 8007b28:	f1b0 3f80 	cmp.w	r0, #2155905152	@ 0x80808080
 8007b2c:	d008      	beq.n	8007b40 <HAL_RTC_SetAlarm_IT+0x14c>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 8007b2e:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 8007b32:	d005      	beq.n	8007b40 <HAL_RTC_SetAlarm_IT+0x14c>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8007b34:	699a      	ldr	r2, [r3, #24]
 8007b36:	f012 0240 	ands.w	r2, r2, #64	@ 0x40
 8007b3a:	d101      	bne.n	8007b40 <HAL_RTC_SetAlarm_IT+0x14c>
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 8007b3c:	70ca      	strb	r2, [r1, #3]
 8007b3e:	e001      	b.n	8007b44 <HAL_RTC_SetAlarm_IT+0x150>
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8007b40:	78ca      	ldrb	r2, [r1, #3]
 8007b42:	0592      	lsls	r2, r2, #22
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8007b44:	6a0b      	ldr	r3, [r1, #32]
 8007b46:	4303      	orrs	r3, r0
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8007b48:	7888      	ldrb	r0, [r1, #2]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8007b4a:	4303      	orrs	r3, r0
 8007b4c:	7808      	ldrb	r0, [r1, #0]
 8007b4e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8007b52:	7848      	ldrb	r0, [r1, #1]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8007b54:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8007b58:	f891 0024 	ldrb.w	r0, [r1, #36]	@ 0x24
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8007b5c:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8007b60:	4313      	orrs	r3, r2
 8007b62:	e7b1      	b.n	8007ac8 <HAL_RTC_SetAlarm_IT+0xd4>
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007b64:	22ca      	movs	r2, #202	@ 0xca
 8007b66:	625a      	str	r2, [r3, #36]	@ 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 8007b68:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007b6c:	f04f 0253 	mov.w	r2, #83	@ 0x53
 8007b70:	625a      	str	r2, [r3, #36]	@ 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 8007b72:	d008      	beq.n	8007b86 <HAL_RTC_SetAlarm_IT+0x192>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8007b74:	699a      	ldr	r2, [r3, #24]
 8007b76:	f422 5208 	bic.w	r2, r2, #8704	@ 0x2200
 8007b7a:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8007b7c:	65dc      	str	r4, [r3, #92]	@ 0x5c
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 8007b7e:	69ca      	ldr	r2, [r1, #28]
 8007b80:	4332      	orrs	r2, r6
 8007b82:	64da      	str	r2, [r3, #76]	@ 0x4c
 8007b84:	e7b1      	b.n	8007aea <HAL_RTC_SetAlarm_IT+0xf6>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8007b86:	699a      	ldr	r2, [r3, #24]
 8007b88:	f422 5288 	bic.w	r2, r2, #4352	@ 0x1100
 8007b8c:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8007b8e:	65df      	str	r7, [r3, #92]	@ 0x5c
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 8007b90:	69ca      	ldr	r2, [r1, #28]
 8007b92:	4332      	orrs	r2, r6
 8007b94:	645a      	str	r2, [r3, #68]	@ 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 8007b96:	4b0c      	ldr	r3, [pc, #48]	@ (8007bc8 <HAL_RTC_SetAlarm_IT+0x1d4>)
 8007b98:	684a      	ldr	r2, [r1, #4]
 8007b9a:	671a      	str	r2, [r3, #112]	@ 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8007b9c:	f8de 2030 	ldr.w	r2, [lr, #48]	@ 0x30
 8007ba0:	f042 0201 	orr.w	r2, r2, #1
 8007ba4:	f8ce 2030 	str.w	r2, [lr, #48]	@ 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8007ba8:	699a      	ldr	r2, [r3, #24]
 8007baa:	f442 5288 	orr.w	r2, r2, #4352	@ 0x1100
 8007bae:	619a      	str	r2, [r3, #24]
 8007bb0:	e7a8      	b.n	8007b04 <HAL_RTC_SetAlarm_IT+0x110>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8007bb2:	6990      	ldr	r0, [r2, #24]
 8007bb4:	f420 5088 	bic.w	r0, r0, #4352	@ 0x1100
 8007bb8:	6190      	str	r0, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8007bba:	2001      	movs	r0, #1
 8007bbc:	65d0      	str	r0, [r2, #92]	@ 0x5c
      WRITE_REG(RTC->ALRMAR, tmpreg);
 8007bbe:	6413      	str	r3, [r2, #64]	@ 0x40
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 8007bc0:	6456      	str	r6, [r2, #68]	@ 0x44
 8007bc2:	e7e8      	b.n	8007b96 <HAL_RTC_SetAlarm_IT+0x1a2>
  __HAL_LOCK(hrtc);
 8007bc4:	2002      	movs	r0, #2
}
 8007bc6:	4770      	bx	lr
 8007bc8:	40002800 	.word	0x40002800
 8007bcc:	58000800 	.word	0x58000800

08007bd0 <HAL_RTC_DeactivateAlarm>:
  __HAL_LOCK(hrtc);
 8007bd0:	f890 202c 	ldrb.w	r2, [r0, #44]	@ 0x2c
 8007bd4:	2a01      	cmp	r2, #1
 8007bd6:	d034      	beq.n	8007c42 <HAL_RTC_DeactivateAlarm+0x72>
{
 8007bd8:	b430      	push	{r4, r5}
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007bda:	4a1b      	ldr	r2, [pc, #108]	@ (8007c48 <HAL_RTC_DeactivateAlarm+0x78>)
  __HAL_LOCK(hrtc);
 8007bdc:	2501      	movs	r5, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007bde:	2402      	movs	r4, #2
  __HAL_LOCK(hrtc);
 8007be0:	f880 502c 	strb.w	r5, [r0, #44]	@ 0x2c
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007be4:	f880 402d 	strb.w	r4, [r0, #45]	@ 0x2d
 8007be8:	4603      	mov	r3, r0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007bea:	20ca      	movs	r0, #202	@ 0xca
 8007bec:	6250      	str	r0, [r2, #36]	@ 0x24
 8007bee:	2053      	movs	r0, #83	@ 0x53
 8007bf0:	6250      	str	r0, [r2, #36]	@ 0x24
  if (Alarm == RTC_ALARM_A)
 8007bf2:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8007bf6:	6b18      	ldr	r0, [r3, #48]	@ 0x30
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8007bf8:	6991      	ldr	r1, [r2, #24]
  if (Alarm == RTC_ALARM_A)
 8007bfa:	d016      	beq.n	8007c2a <HAL_RTC_DeactivateAlarm+0x5a>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8007bfc:	f421 5108 	bic.w	r1, r1, #8704	@ 0x2200
 8007c00:	6191      	str	r1, [r2, #24]
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8007c02:	6cd1      	ldr	r1, [r2, #76]	@ 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8007c04:	f020 0002 	bic.w	r0, r0, #2
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8007c08:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8007c0c:	64d1      	str	r1, [r2, #76]	@ 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8007c0e:	6318      	str	r0, [r3, #48]	@ 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8007c10:	65d4      	str	r4, [r2, #92]	@ 0x5c
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007c12:	480d      	ldr	r0, [pc, #52]	@ (8007c48 <HAL_RTC_DeactivateAlarm+0x78>)
  __HAL_UNLOCK(hrtc);
 8007c14:	2200      	movs	r2, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007c16:	24ff      	movs	r4, #255	@ 0xff
  hrtc->State = HAL_RTC_STATE_READY;
 8007c18:	2101      	movs	r1, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007c1a:	6244      	str	r4, [r0, #36]	@ 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8007c1c:	f883 102d 	strb.w	r1, [r3, #45]	@ 0x2d
  __HAL_UNLOCK(hrtc);
 8007c20:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c
  return HAL_OK;
 8007c24:	4610      	mov	r0, r2
}
 8007c26:	bc30      	pop	{r4, r5}
 8007c28:	4770      	bx	lr
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8007c2a:	f421 5188 	bic.w	r1, r1, #4352	@ 0x1100
 8007c2e:	6191      	str	r1, [r2, #24]
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8007c30:	6c51      	ldr	r1, [r2, #68]	@ 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8007c32:	f020 0001 	bic.w	r0, r0, #1
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8007c36:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8007c3a:	6451      	str	r1, [r2, #68]	@ 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8007c3c:	6318      	str	r0, [r3, #48]	@ 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8007c3e:	65d5      	str	r5, [r2, #92]	@ 0x5c
 8007c40:	e7e7      	b.n	8007c12 <HAL_RTC_DeactivateAlarm+0x42>
  __HAL_LOCK(hrtc);
 8007c42:	2002      	movs	r0, #2
}
 8007c44:	4770      	bx	lr
 8007c46:	bf00      	nop
 8007c48:	40002800 	.word	0x40002800

08007c4c <HAL_RTC_AlarmIRQHandler>:
{
 8007c4c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 8007c4e:	4b0e      	ldr	r3, [pc, #56]	@ (8007c88 <HAL_RTC_AlarmIRQHandler+0x3c>)
 8007c50:	6b02      	ldr	r2, [r0, #48]	@ 0x30
 8007c52:	6d5d      	ldr	r5, [r3, #84]	@ 0x54
 8007c54:	4015      	ands	r5, r2
  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 8007c56:	07ea      	lsls	r2, r5, #31
{
 8007c58:	4604      	mov	r4, r0
  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 8007c5a:	d405      	bmi.n	8007c68 <HAL_RTC_AlarmIRQHandler+0x1c>
  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 8007c5c:	07ab      	lsls	r3, r5, #30
 8007c5e:	d409      	bmi.n	8007c74 <HAL_RTC_AlarmIRQHandler+0x28>
  hrtc->State = HAL_RTC_STATE_READY;
 8007c60:	2301      	movs	r3, #1
 8007c62:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
}
 8007c66:	bd38      	pop	{r3, r4, r5, pc}
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8007c68:	2201      	movs	r2, #1
 8007c6a:	65da      	str	r2, [r3, #92]	@ 0x5c
    HAL_RTC_AlarmAEventCallback(hrtc);
 8007c6c:	f7fa f968 	bl	8001f40 <HAL_RTC_AlarmAEventCallback>
  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 8007c70:	07ab      	lsls	r3, r5, #30
 8007c72:	d5f5      	bpl.n	8007c60 <HAL_RTC_AlarmIRQHandler+0x14>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8007c74:	4b04      	ldr	r3, [pc, #16]	@ (8007c88 <HAL_RTC_AlarmIRQHandler+0x3c>)
 8007c76:	2202      	movs	r2, #2
 8007c78:	65da      	str	r2, [r3, #92]	@ 0x5c
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 8007c7a:	4620      	mov	r0, r4
 8007c7c:	f000 f91c 	bl	8007eb8 <HAL_RTCEx_AlarmBEventCallback>
  hrtc->State = HAL_RTC_STATE_READY;
 8007c80:	2301      	movs	r3, #1
 8007c82:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
}
 8007c86:	bd38      	pop	{r3, r4, r5, pc}
 8007c88:	40002800 	.word	0x40002800

08007c8c <RTC_ExitInitMode>:
{
 8007c8c:	b570      	push	{r4, r5, r6, lr}
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8007c8e:	4c20      	ldr	r4, [pc, #128]	@ (8007d10 <RTC_ExitInitMode+0x84>)
 8007c90:	68e3      	ldr	r3, [r4, #12]
 8007c92:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8007c96:	60e3      	str	r3, [r4, #12]
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8007c98:	69a3      	ldr	r3, [r4, #24]
 8007c9a:	0699      	lsls	r1, r3, #26
{
 8007c9c:	4605      	mov	r5, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8007c9e:	d412      	bmi.n	8007cc6 <RTC_ExitInitMode+0x3a>
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 8007ca0:	68e3      	ldr	r3, [r4, #12]
 8007ca2:	f023 0320 	bic.w	r3, r3, #32
 8007ca6:	60e3      	str	r3, [r4, #12]
  tickstart = HAL_GetTick();
 8007ca8:	f7f9 ff8e 	bl	8001bc8 <HAL_GetTick>
 8007cac:	4606      	mov	r6, r0
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8007cae:	e005      	b.n	8007cbc <RTC_ExitInitMode+0x30>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8007cb0:	f7f9 ff8a 	bl	8001bc8 <HAL_GetTick>
 8007cb4:	1b83      	subs	r3, r0, r6
 8007cb6:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007cba:	d824      	bhi.n	8007d06 <RTC_ExitInitMode+0x7a>
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8007cbc:	68e3      	ldr	r3, [r4, #12]
 8007cbe:	069a      	lsls	r2, r3, #26
 8007cc0:	d5f6      	bpl.n	8007cb0 <RTC_ExitInitMode+0x24>
  HAL_StatusTypeDef status = HAL_OK;
 8007cc2:	2000      	movs	r0, #0
}
 8007cc4:	bd70      	pop	{r4, r5, r6, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8007cc6:	69a3      	ldr	r3, [r4, #24]
 8007cc8:	f023 0320 	bic.w	r3, r3, #32
 8007ccc:	61a3      	str	r3, [r4, #24]
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 8007cce:	68e3      	ldr	r3, [r4, #12]
 8007cd0:	f023 0320 	bic.w	r3, r3, #32
 8007cd4:	60e3      	str	r3, [r4, #12]
  tickstart = HAL_GetTick();
 8007cd6:	f7f9 ff77 	bl	8001bc8 <HAL_GetTick>
 8007cda:	4606      	mov	r6, r0
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8007cdc:	e005      	b.n	8007cea <RTC_ExitInitMode+0x5e>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8007cde:	f7f9 ff73 	bl	8001bc8 <HAL_GetTick>
 8007ce2:	1b83      	subs	r3, r0, r6
 8007ce4:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007ce8:	d809      	bhi.n	8007cfe <RTC_ExitInitMode+0x72>
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8007cea:	68e3      	ldr	r3, [r4, #12]
 8007cec:	069b      	lsls	r3, r3, #26
 8007cee:	d5f6      	bpl.n	8007cde <RTC_ExitInitMode+0x52>
  HAL_StatusTypeDef status = HAL_OK;
 8007cf0:	2000      	movs	r0, #0
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8007cf2:	4a07      	ldr	r2, [pc, #28]	@ (8007d10 <RTC_ExitInitMode+0x84>)
 8007cf4:	6993      	ldr	r3, [r2, #24]
 8007cf6:	f043 0320 	orr.w	r3, r3, #32
 8007cfa:	6193      	str	r3, [r2, #24]
}
 8007cfc:	bd70      	pop	{r4, r5, r6, pc}
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007cfe:	2003      	movs	r0, #3
 8007d00:	f885 002d 	strb.w	r0, [r5, #45]	@ 0x2d
      status = HAL_TIMEOUT;
 8007d04:	e7f5      	b.n	8007cf2 <RTC_ExitInitMode+0x66>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007d06:	2003      	movs	r0, #3
 8007d08:	f885 002d 	strb.w	r0, [r5, #45]	@ 0x2d
}
 8007d0c:	bd70      	pop	{r4, r5, r6, pc}
 8007d0e:	bf00      	nop
 8007d10:	40002800 	.word	0x40002800

08007d14 <HAL_RTC_Init>:
  if (hrtc != NULL)
 8007d14:	2800      	cmp	r0, #0
 8007d16:	d04b      	beq.n	8007db0 <HAL_RTC_Init+0x9c>
{
 8007d18:	b570      	push	{r4, r5, r6, lr}
    if (hrtc->State == HAL_RTC_STATE_RESET)
 8007d1a:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 8007d1e:	4604      	mov	r4, r0
 8007d20:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8007d24:	2b00      	cmp	r3, #0
 8007d26:	d03e      	beq.n	8007da6 <HAL_RTC_Init+0x92>
    hrtc->State = HAL_RTC_STATE_BUSY;
 8007d28:	2302      	movs	r3, #2
    if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 8007d2a:	4d32      	ldr	r5, [pc, #200]	@ (8007df4 <HAL_RTC_Init+0xe0>)
    hrtc->State = HAL_RTC_STATE_BUSY;
 8007d2c:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
    if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 8007d30:	68eb      	ldr	r3, [r5, #12]
 8007d32:	06d8      	lsls	r0, r3, #27
 8007d34:	d432      	bmi.n	8007d9c <HAL_RTC_Init+0x88>
      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007d36:	2353      	movs	r3, #83	@ 0x53
 8007d38:	22ca      	movs	r2, #202	@ 0xca
 8007d3a:	626a      	str	r2, [r5, #36]	@ 0x24
 8007d3c:	626b      	str	r3, [r5, #36]	@ 0x24
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 8007d3e:	68eb      	ldr	r3, [r5, #12]
 8007d40:	0659      	lsls	r1, r3, #25
 8007d42:	d53a      	bpl.n	8007dba <HAL_RTC_Init+0xa6>
        CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 8007d44:	4d2b      	ldr	r5, [pc, #172]	@ (8007df4 <HAL_RTC_Init+0xe0>)
 8007d46:	69ab      	ldr	r3, [r5, #24]
 8007d48:	f023 638e 	bic.w	r3, r3, #74448896	@ 0x4700000
 8007d4c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8007d50:	61ab      	str	r3, [r5, #24]
        SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 8007d52:	6922      	ldr	r2, [r4, #16]
 8007d54:	6863      	ldr	r3, [r4, #4]
 8007d56:	69a9      	ldr	r1, [r5, #24]
 8007d58:	4313      	orrs	r3, r2
 8007d5a:	69a2      	ldr	r2, [r4, #24]
 8007d5c:	430b      	orrs	r3, r1
 8007d5e:	4313      	orrs	r3, r2
 8007d60:	61ab      	str	r3, [r5, #24]
        WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 8007d62:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8007d66:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8007d6a:	612b      	str	r3, [r5, #16]
        MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 8007d6c:	e9d4 3109 	ldrd	r3, r1, [r4, #36]	@ 0x24
 8007d70:	68ea      	ldr	r2, [r5, #12]
 8007d72:	430b      	orrs	r3, r1
 8007d74:	f422 52f8 	bic.w	r2, r2, #7936	@ 0x1f00
 8007d78:	4313      	orrs	r3, r2
 8007d7a:	60eb      	str	r3, [r5, #12]
        status = RTC_ExitInitMode(hrtc);
 8007d7c:	4620      	mov	r0, r4
 8007d7e:	f7ff ff85 	bl	8007c8c <RTC_ExitInitMode>
        if (status == HAL_OK)
 8007d82:	b9b8      	cbnz	r0, 8007db4 <HAL_RTC_Init+0xa0>
          MODIFY_REG(RTC->CR, \
 8007d84:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 8007d88:	69aa      	ldr	r2, [r5, #24]
 8007d8a:	430b      	orrs	r3, r1
 8007d8c:	f022 4260 	bic.w	r2, r2, #3758096384	@ 0xe0000000
 8007d90:	6961      	ldr	r1, [r4, #20]
 8007d92:	4313      	orrs	r3, r2
 8007d94:	430b      	orrs	r3, r1
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007d96:	22ff      	movs	r2, #255	@ 0xff
          MODIFY_REG(RTC->CR, \
 8007d98:	61ab      	str	r3, [r5, #24]
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007d9a:	626a      	str	r2, [r5, #36]	@ 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 8007d9c:	2301      	movs	r3, #1
 8007d9e:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
 8007da2:	2000      	movs	r0, #0
}
 8007da4:	bd70      	pop	{r4, r5, r6, pc}
      hrtc->Lock = HAL_UNLOCKED;
 8007da6:	f880 202c 	strb.w	r2, [r0, #44]	@ 0x2c
      HAL_RTC_MspInit(hrtc);
 8007daa:	f7f9 fd5b 	bl	8001864 <HAL_RTC_MspInit>
 8007dae:	e7bb      	b.n	8007d28 <HAL_RTC_Init+0x14>
  HAL_StatusTypeDef status = HAL_ERROR;
 8007db0:	2001      	movs	r0, #1
}
 8007db2:	4770      	bx	lr
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007db4:	23ff      	movs	r3, #255	@ 0xff
 8007db6:	626b      	str	r3, [r5, #36]	@ 0x24
}
 8007db8:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8007dba:	68eb      	ldr	r3, [r5, #12]
 8007dbc:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8007dc0:	60eb      	str	r3, [r5, #12]
    tickstart = HAL_GetTick();
 8007dc2:	f7f9 ff01 	bl	8001bc8 <HAL_GetTick>
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8007dc6:	68eb      	ldr	r3, [r5, #12]
 8007dc8:	065a      	lsls	r2, r3, #25
    tickstart = HAL_GetTick();
 8007dca:	4606      	mov	r6, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8007dcc:	d4ba      	bmi.n	8007d44 <HAL_RTC_Init+0x30>
 8007dce:	e002      	b.n	8007dd6 <HAL_RTC_Init+0xc2>
 8007dd0:	68eb      	ldr	r3, [r5, #12]
 8007dd2:	065b      	lsls	r3, r3, #25
 8007dd4:	d4b6      	bmi.n	8007d44 <HAL_RTC_Init+0x30>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8007dd6:	f7f9 fef7 	bl	8001bc8 <HAL_GetTick>
 8007dda:	1b80      	subs	r0, r0, r6
 8007ddc:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8007de0:	d9f6      	bls.n	8007dd0 <HAL_RTC_Init+0xbc>
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8007de2:	4b04      	ldr	r3, [pc, #16]	@ (8007df4 <HAL_RTC_Init+0xe0>)
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007de4:	2003      	movs	r0, #3
 8007de6:	f884 002d 	strb.w	r0, [r4, #45]	@ 0x2d
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007dea:	22ff      	movs	r2, #255	@ 0xff
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8007dec:	68d9      	ldr	r1, [r3, #12]
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007dee:	625a      	str	r2, [r3, #36]	@ 0x24
}
 8007df0:	bd70      	pop	{r4, r5, r6, pc}
 8007df2:	bf00      	nop
 8007df4:	40002800 	.word	0x40002800

08007df8 <HAL_RTCEx_EnableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007df8:	f890 202c 	ldrb.w	r2, [r0, #44]	@ 0x2c
 8007dfc:	2a01      	cmp	r2, #1
{
 8007dfe:	4603      	mov	r3, r0
  __HAL_LOCK(hrtc);
 8007e00:	d017      	beq.n	8007e32 <HAL_RTCEx_EnableBypassShadow+0x3a>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007e02:	4a0d      	ldr	r2, [pc, #52]	@ (8007e38 <HAL_RTCEx_EnableBypassShadow+0x40>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007e04:	f04f 0c02 	mov.w	ip, #2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007e08:	20ca      	movs	r0, #202	@ 0xca
 8007e0a:	2153      	movs	r1, #83	@ 0x53
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007e0c:	f883 c02d 	strb.w	ip, [r3, #45]	@ 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007e10:	6250      	str	r0, [r2, #36]	@ 0x24
 8007e12:	6251      	str	r1, [r2, #36]	@ 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8007e14:	6991      	ldr	r1, [r2, #24]
 8007e16:	f041 0120 	orr.w	r1, r1, #32
 8007e1a:	6191      	str	r1, [r2, #24]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007e1c:	f04f 0c00 	mov.w	ip, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007e20:	20ff      	movs	r0, #255	@ 0xff
  hrtc->State = HAL_RTC_STATE_READY;
 8007e22:	2101      	movs	r1, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007e24:	6250      	str	r0, [r2, #36]	@ 0x24

  return HAL_OK;
 8007e26:	4660      	mov	r0, ip
  hrtc->State = HAL_RTC_STATE_READY;
 8007e28:	f883 102d 	strb.w	r1, [r3, #45]	@ 0x2d
  __HAL_UNLOCK(hrtc);
 8007e2c:	f883 c02c 	strb.w	ip, [r3, #44]	@ 0x2c
  return HAL_OK;
 8007e30:	4770      	bx	lr
  __HAL_LOCK(hrtc);
 8007e32:	2002      	movs	r0, #2
}
 8007e34:	4770      	bx	lr
 8007e36:	bf00      	nop
 8007e38:	40002800 	.word	0x40002800

08007e3c <HAL_RTCEx_SetSSRU_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007e3c:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
 8007e40:	2b01      	cmp	r3, #1
 8007e42:	d01e      	beq.n	8007e82 <HAL_RTCEx_SetSSRU_IT+0x46>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007e44:	4b10      	ldr	r3, [pc, #64]	@ (8007e88 <HAL_RTCEx_SetSSRU_IT+0x4c>)
{
 8007e46:	b430      	push	{r4, r5}
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007e48:	21ca      	movs	r1, #202	@ 0xca
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007e4a:	2402      	movs	r4, #2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007e4c:	2253      	movs	r2, #83	@ 0x53
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007e4e:	f880 402d 	strb.w	r4, [r0, #45]	@ 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007e52:	6259      	str	r1, [r3, #36]	@ 0x24
 8007e54:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 8007e56:	699a      	ldr	r2, [r3, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8007e58:	4c0c      	ldr	r4, [pc, #48]	@ (8007e8c <HAL_RTCEx_SetSSRU_IT+0x50>)
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 8007e5a:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8007e5e:	619a      	str	r2, [r3, #24]
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8007e60:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007e64:	25ff      	movs	r5, #255	@ 0xff
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8007e66:	f441 2180 	orr.w	r1, r1, #262144	@ 0x40000
 8007e6a:	f8c4 1080 	str.w	r1, [r4, #128]	@ 0x80

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007e6e:	2200      	movs	r2, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007e70:	625d      	str	r5, [r3, #36]	@ 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8007e72:	2301      	movs	r3, #1
 8007e74:	f880 302d 	strb.w	r3, [r0, #45]	@ 0x2d
  __HAL_UNLOCK(hrtc);
 8007e78:	f880 202c 	strb.w	r2, [r0, #44]	@ 0x2c

  return HAL_OK;
}
 8007e7c:	bc30      	pop	{r4, r5}
  return HAL_OK;
 8007e7e:	4610      	mov	r0, r2
}
 8007e80:	4770      	bx	lr
  __HAL_LOCK(hrtc);
 8007e82:	2002      	movs	r0, #2
}
 8007e84:	4770      	bx	lr
 8007e86:	bf00      	nop
 8007e88:	40002800 	.word	0x40002800
 8007e8c:	58000800 	.word	0x58000800

08007e90 <HAL_RTCEx_SSRUIRQHandler>:
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 8007e90:	4b08      	ldr	r3, [pc, #32]	@ (8007eb4 <HAL_RTCEx_SSRUIRQHandler+0x24>)
 8007e92:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8007e94:	0652      	lsls	r2, r2, #25
{
 8007e96:	b510      	push	{r4, lr}
 8007e98:	4604      	mov	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 8007e9a:	d403      	bmi.n	8007ea4 <HAL_RTCEx_SSRUIRQHandler+0x14>
    HAL_RTCEx_SSRUEventCallback(hrtc);
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8007e9c:	2301      	movs	r3, #1
 8007e9e:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
}
 8007ea2:	bd10      	pop	{r4, pc}
    RTC->SCR = RTC_SCR_CSSRUF;
 8007ea4:	2240      	movs	r2, #64	@ 0x40
 8007ea6:	65da      	str	r2, [r3, #92]	@ 0x5c
    HAL_RTCEx_SSRUEventCallback(hrtc);
 8007ea8:	f7fa f84c 	bl	8001f44 <HAL_RTCEx_SSRUEventCallback>
  hrtc->State = HAL_RTC_STATE_READY;
 8007eac:	2301      	movs	r3, #1
 8007eae:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
}
 8007eb2:	bd10      	pop	{r4, pc}
 8007eb4:	40002800 	.word	0x40002800

08007eb8 <HAL_RTCEx_AlarmBEventCallback>:
/**
  * @brief  Alarm B callback.
  * @param  hrtc RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
 8007eb8:	4770      	bx	lr
 8007eba:	bf00      	nop

08007ebc <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8007ebc:	0089      	lsls	r1, r1, #2
 8007ebe:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 8007ec2:	f501 4131 	add.w	r1, r1, #45312	@ 0xb100

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8007ec6:	600a      	str	r2, [r1, #0]
}
 8007ec8:	4770      	bx	lr
 8007eca:	bf00      	nop

08007ecc <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8007ecc:	0089      	lsls	r1, r1, #2
 8007ece:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 8007ed2:	f501 4131 	add.w	r1, r1, #45312	@ 0xb100

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8007ed6:	6808      	ldr	r0, [r1, #0]
}
 8007ed8:	4770      	bx	lr
 8007eda:	bf00      	nop

08007edc <HAL_SUBGHZ_Init>:
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  HAL_SUBGHZ_StateTypeDef subghz_state;

  /* Check the hsubghz handle allocation */
  if (hsubghz == NULL)
 8007edc:	2800      	cmp	r0, #0
 8007ede:	d078      	beq.n	8007fd2 <HAL_SUBGHZ_Init+0xf6>
{
 8007ee0:	b510      	push	{r4, lr}
    status = HAL_OK;
  }

  assert_param(IS_SUBGHZSPI_BAUDRATE_PRESCALER(hsubghz->Init.BaudratePrescaler));

  subghz_state = hsubghz->State;
 8007ee2:	7983      	ldrb	r3, [r0, #6]
{
 8007ee4:	b082      	sub	sp, #8
 8007ee6:	4604      	mov	r4, r0
  if ((subghz_state == HAL_SUBGHZ_STATE_RESET) ||
 8007ee8:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8007eec:	b1eb      	cbz	r3, 8007f2a <HAL_SUBGHZ_Init+0x4e>
 8007eee:	2a03      	cmp	r2, #3
 8007ef0:	d063      	beq.n	8007fba <HAL_SUBGHZ_Init+0xde>
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 8007ef2:	4b39      	ldr	r3, [pc, #228]	@ (8007fd8 <HAL_SUBGHZ_Init+0xfc>)
 8007ef4:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8007ef8:	619a      	str	r2, [r3, #24]
{
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8007efa:	4b38      	ldr	r3, [pc, #224]	@ (8007fdc <HAL_SUBGHZ_Init+0x100>)
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 8007efc:	6822      	ldr	r2, [r4, #0]
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8007efe:	6819      	ldr	r1, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 8007f00:	f442 7241 	orr.w	r2, r2, #772	@ 0x304
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8007f04:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 8007f08:	f44f 50b8 	mov.w	r0, #5888	@ 0x1700
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8007f0c:	6019      	str	r1, [r3, #0]
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 8007f0e:	601a      	str	r2, [r3, #0]
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 8007f10:	6058      	str	r0, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8007f12:	681a      	ldr	r2, [r3, #0]
 8007f14:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8007f18:	601a      	str	r2, [r3, #0]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 8007f1a:	2000      	movs	r0, #0
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 8007f1c:	2101      	movs	r1, #1
  hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8007f1e:	2301      	movs	r3, #1
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 8007f20:	60a0      	str	r0, [r4, #8]
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 8007f22:	7121      	strb	r1, [r4, #4]
  hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8007f24:	71a3      	strb	r3, [r4, #6]
}
 8007f26:	b002      	add	sp, #8
 8007f28:	bd10      	pop	{r4, pc}
    hsubghz->Lock = HAL_UNLOCKED;
 8007f2a:	7142      	strb	r2, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 8007f2c:	f7f9 fd5c 	bl	80019e8 <HAL_SUBGHZ_MspInit>
  SET_BIT(EXTI->IMR2, ExtiLine);
 8007f30:	492b      	ldr	r1, [pc, #172]	@ (8007fe0 <HAL_SUBGHZ_Init+0x104>)
 8007f32:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 8007f36:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8007f3a:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8007f3e:	2002      	movs	r0, #2
 8007f40:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
 8007f44:	71a0      	strb	r0, [r4, #6]
 8007f46:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
    count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8007f4a:	4926      	ldr	r1, [pc, #152]	@ (8007fe4 <HAL_SUBGHZ_Init+0x108>)
 8007f4c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8007f50:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8007f54:	680b      	ldr	r3, [r1, #0]
 8007f56:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8007f5a:	2164      	movs	r1, #100	@ 0x64
 8007f5c:	f3c3 434c 	ubfx	r3, r3, #17, #13
 8007f60:	fb01 f303 	mul.w	r3, r1, r3
 8007f64:	9301      	str	r3, [sp, #4]
      if (count == 0U)
 8007f66:	9b01      	ldr	r3, [sp, #4]
 8007f68:	b1a3      	cbz	r3, 8007f94 <HAL_SUBGHZ_Init+0xb8>
      count--;
 8007f6a:	9b01      	ldr	r3, [sp, #4]
 8007f6c:	3b01      	subs	r3, #1
 8007f6e:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 8007f70:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
 8007f74:	045b      	lsls	r3, r3, #17
 8007f76:	d4f6      	bmi.n	8007f66 <HAL_SUBGHZ_Init+0x8a>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8007f78:	4b17      	ldr	r3, [pc, #92]	@ (8007fd8 <HAL_SUBGHZ_Init+0xfc>)
 8007f7a:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8007f7e:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 8007f82:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 8007f86:	689a      	ldr	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 8007f88:	f44f 6100 	mov.w	r1, #2048	@ 0x800
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 8007f8c:	430a      	orrs	r2, r1
 8007f8e:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 8007f90:	6199      	str	r1, [r3, #24]
  if (status == HAL_OK)
 8007f92:	e7b2      	b.n	8007efa <HAL_SUBGHZ_Init+0x1e>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8007f94:	4b10      	ldr	r3, [pc, #64]	@ (8007fd8 <HAL_SUBGHZ_Init+0xfc>)
        hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8007f96:	2001      	movs	r0, #1
 8007f98:	60a0      	str	r0, [r4, #8]
 8007f9a:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8007f9e:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 8007fa2:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 8007fa6:	689a      	ldr	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 8007fa8:	f44f 6100 	mov.w	r1, #2048	@ 0x800
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 8007fac:	430a      	orrs	r2, r1
 8007fae:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 8007fb0:	6199      	str	r1, [r3, #24]
  hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8007fb2:	2301      	movs	r3, #1
 8007fb4:	71a3      	strb	r3, [r4, #6]
}
 8007fb6:	b002      	add	sp, #8
 8007fb8:	bd10      	pop	{r4, pc}
    hsubghz->Lock = HAL_UNLOCKED;
 8007fba:	2300      	movs	r3, #0
 8007fbc:	7143      	strb	r3, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 8007fbe:	f7f9 fd13 	bl	80019e8 <HAL_SUBGHZ_MspInit>
 8007fc2:	4a07      	ldr	r2, [pc, #28]	@ (8007fe0 <HAL_SUBGHZ_Init+0x104>)
 8007fc4:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8007fc8:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8007fcc:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  if (subghz_state == HAL_SUBGHZ_STATE_RESET)
 8007fd0:	e78f      	b.n	8007ef2 <HAL_SUBGHZ_Init+0x16>
    return status;
 8007fd2:	2001      	movs	r0, #1
}
 8007fd4:	4770      	bx	lr
 8007fd6:	bf00      	nop
 8007fd8:	58000400 	.word	0x58000400
 8007fdc:	58010000 	.word	0x58010000
 8007fe0:	58000800 	.word	0x58000800
 8007fe4:	20000004 	.word	0x20000004

08007fe8 <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 8007fe8:	b410      	push	{r4}
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8007fea:	4c1c      	ldr	r4, [pc, #112]	@ (800805c <SUBGHZSPI_Transmit+0x74>)
 8007fec:	6823      	ldr	r3, [r4, #0]
 8007fee:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8007ff2:	2264      	movs	r2, #100	@ 0x64
{
 8007ff4:	b083      	sub	sp, #12
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8007ff6:	f3c3 434c 	ubfx	r3, r3, #17, #13
 8007ffa:	fb02 f303 	mul.w	r3, r2, r3
{
 8007ffe:	4684      	mov	ip, r0
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 8008000:	4a17      	ldr	r2, [pc, #92]	@ (8008060 <SUBGHZSPI_Transmit+0x78>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8008002:	9301      	str	r3, [sp, #4]
 8008004:	e005      	b.n	8008012 <SUBGHZSPI_Transmit+0x2a>
    count--;
 8008006:	9b01      	ldr	r3, [sp, #4]
 8008008:	3b01      	subs	r3, #1
 800800a:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 800800c:	6893      	ldr	r3, [r2, #8]
 800800e:	0798      	lsls	r0, r3, #30
 8008010:	d422      	bmi.n	8008058 <SUBGHZSPI_Transmit+0x70>
    if (count == 0U)
 8008012:	9b01      	ldr	r3, [sp, #4]
 8008014:	2b00      	cmp	r3, #0
 8008016:	d1f6      	bne.n	8008006 <SUBGHZSPI_Transmit+0x1e>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8008018:	2001      	movs	r0, #1
 800801a:	f8cc 0008 	str.w	r0, [ip, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 800801e:	4a10      	ldr	r2, [pc, #64]	@ (8008060 <SUBGHZSPI_Transmit+0x78>)
 8008020:	7311      	strb	r1, [r2, #12]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8008022:	6823      	ldr	r3, [r4, #0]
 8008024:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8008028:	2164      	movs	r1, #100	@ 0x64
 800802a:	f3c3 434c 	ubfx	r3, r3, #17, #13
 800802e:	fb01 f303 	mul.w	r3, r1, r3
 8008032:	9301      	str	r3, [sp, #4]
 8008034:	e005      	b.n	8008042 <SUBGHZSPI_Transmit+0x5a>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 8008036:	9b01      	ldr	r3, [sp, #4]
 8008038:	3b01      	subs	r3, #1
 800803a:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 800803c:	6893      	ldr	r3, [r2, #8]
 800803e:	07db      	lsls	r3, r3, #31
 8008040:	d405      	bmi.n	800804e <SUBGHZSPI_Transmit+0x66>
    if (count == 0U)
 8008042:	9b01      	ldr	r3, [sp, #4]
 8008044:	2b00      	cmp	r3, #0
 8008046:	d1f6      	bne.n	8008036 <SUBGHZSPI_Transmit+0x4e>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8008048:	2001      	movs	r0, #1
 800804a:	f8cc 0008 	str.w	r0, [ip, #8]

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 800804e:	4b04      	ldr	r3, [pc, #16]	@ (8008060 <SUBGHZSPI_Transmit+0x78>)
 8008050:	68db      	ldr	r3, [r3, #12]

  return status;
}
 8008052:	b003      	add	sp, #12
 8008054:	bc10      	pop	{r4}
 8008056:	4770      	bx	lr
  HAL_StatusTypeDef status = HAL_OK;
 8008058:	2000      	movs	r0, #0
 800805a:	e7e0      	b.n	800801e <SUBGHZSPI_Transmit+0x36>
 800805c:	20000004 	.word	0x20000004
 8008060:	58010000 	.word	0x58010000

08008064 <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 8008064:	b410      	push	{r4}
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8008066:	4c1d      	ldr	r4, [pc, #116]	@ (80080dc <SUBGHZSPI_Receive+0x78>)
 8008068:	6823      	ldr	r3, [r4, #0]
 800806a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800806e:	2264      	movs	r2, #100	@ 0x64
{
 8008070:	b083      	sub	sp, #12
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8008072:	f3c3 434c 	ubfx	r3, r3, #17, #13
 8008076:	fb02 f303 	mul.w	r3, r2, r3
{
 800807a:	4684      	mov	ip, r0
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 800807c:	4a18      	ldr	r2, [pc, #96]	@ (80080e0 <SUBGHZSPI_Receive+0x7c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 800807e:	9301      	str	r3, [sp, #4]
 8008080:	e005      	b.n	800808e <SUBGHZSPI_Receive+0x2a>
    count--;
 8008082:	9b01      	ldr	r3, [sp, #4]
 8008084:	3b01      	subs	r3, #1
 8008086:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 8008088:	6893      	ldr	r3, [r2, #8]
 800808a:	0798      	lsls	r0, r3, #30
 800808c:	d424      	bmi.n	80080d8 <SUBGHZSPI_Receive+0x74>
    if (count == 0U)
 800808e:	9b01      	ldr	r3, [sp, #4]
 8008090:	2b00      	cmp	r3, #0
 8008092:	d1f6      	bne.n	8008082 <SUBGHZSPI_Receive+0x1e>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8008094:	2001      	movs	r0, #1
 8008096:	f8cc 0008 	str.w	r0, [ip, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 800809a:	4a11      	ldr	r2, [pc, #68]	@ (80080e0 <SUBGHZSPI_Receive+0x7c>)
 800809c:	23ff      	movs	r3, #255	@ 0xff
 800809e:	7313      	strb	r3, [r2, #12]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 80080a0:	6823      	ldr	r3, [r4, #0]
 80080a2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80080a6:	f3c3 434c 	ubfx	r3, r3, #17, #13
 80080aa:	2464      	movs	r4, #100	@ 0x64
 80080ac:	fb04 f303 	mul.w	r3, r4, r3
 80080b0:	9301      	str	r3, [sp, #4]
 80080b2:	e005      	b.n	80080c0 <SUBGHZSPI_Receive+0x5c>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 80080b4:	9b01      	ldr	r3, [sp, #4]
 80080b6:	3b01      	subs	r3, #1
 80080b8:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 80080ba:	6893      	ldr	r3, [r2, #8]
 80080bc:	07db      	lsls	r3, r3, #31
 80080be:	d405      	bmi.n	80080cc <SUBGHZSPI_Receive+0x68>
    if (count == 0U)
 80080c0:	9b01      	ldr	r3, [sp, #4]
 80080c2:	2b00      	cmp	r3, #0
 80080c4:	d1f6      	bne.n	80080b4 <SUBGHZSPI_Receive+0x50>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 80080c6:	2001      	movs	r0, #1
 80080c8:	f8cc 0008 	str.w	r0, [ip, #8]

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 80080cc:	4b04      	ldr	r3, [pc, #16]	@ (80080e0 <SUBGHZSPI_Receive+0x7c>)
 80080ce:	68db      	ldr	r3, [r3, #12]
 80080d0:	700b      	strb	r3, [r1, #0]

  return status;
}
 80080d2:	b003      	add	sp, #12
 80080d4:	bc10      	pop	{r4}
 80080d6:	4770      	bx	lr
  HAL_StatusTypeDef status = HAL_OK;
 80080d8:	2000      	movs	r0, #0
 80080da:	e7de      	b.n	800809a <SUBGHZSPI_Receive+0x36>
 80080dc:	20000004 	.word	0x20000004
 80080e0:	58010000 	.word	0x58010000

080080e4 <SUBGHZ_CheckDeviceReady>:

  /* Wakeup radio in case of sleep mode: Select-Unselect radio */
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
  {
    /* Initialize NSS switch Delay */
    count  = SUBGHZ_NSS_LOOP_TIME;
 80080e4:	4b1f      	ldr	r3, [pc, #124]	@ (8008164 <SUBGHZ_CheckDeviceReady+0x80>)
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 80080e6:	7901      	ldrb	r1, [r0, #4]
    count  = SUBGHZ_NSS_LOOP_TIME;
 80080e8:	681b      	ldr	r3, [r3, #0]
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 80080ea:	2901      	cmp	r1, #1
    count  = SUBGHZ_NSS_LOOP_TIME;
 80080ec:	eb03 0343 	add.w	r3, r3, r3, lsl #1
{
 80080f0:	b082      	sub	sp, #8
    count  = SUBGHZ_NSS_LOOP_TIME;
 80080f2:	ea4f 02c3 	mov.w	r2, r3, lsl #3
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 80080f6:	d01d      	beq.n	8008134 <SUBGHZ_CheckDeviceReady+0x50>
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80080f8:	0d12      	lsrs	r2, r2, #20
 80080fa:	2364      	movs	r3, #100	@ 0x64
 80080fc:	fb03 f202 	mul.w	r2, r3, r2
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008100:	4919      	ldr	r1, [pc, #100]	@ (8008168 <SUBGHZ_CheckDeviceReady+0x84>)
 8008102:	9201      	str	r2, [sp, #4]
 8008104:	694a      	ldr	r2, [r1, #20]
  /* Wait until Busy signal is set */
  do
  {
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
 8008106:	9b01      	ldr	r3, [sp, #4]
 8008108:	b173      	cbz	r3, 8008128 <SUBGHZ_CheckDeviceReady+0x44>
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
      break;
    }
    count--;
 800810a:	9b01      	ldr	r3, [sp, #4]
 800810c:	3b01      	subs	r3, #1
 800810e:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 8008110:	694b      	ldr	r3, [r1, #20]
 8008112:	f013 0302 	ands.w	r3, r3, #2
 8008116:	d102      	bne.n	800811e <SUBGHZ_CheckDeviceReady+0x3a>
}
 8008118:	4618      	mov	r0, r3
 800811a:	b002      	add	sp, #8
 800811c:	4770      	bx	lr
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 800811e:	f012 0204 	ands.w	r2, r2, #4
 8008122:	d1ef      	bne.n	8008104 <SUBGHZ_CheckDeviceReady+0x20>
  status = HAL_OK;
 8008124:	4613      	mov	r3, r2
 8008126:	e7f7      	b.n	8008118 <SUBGHZ_CheckDeviceReady+0x34>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 8008128:	2302      	movs	r3, #2
 800812a:	6083      	str	r3, [r0, #8]
      status  = HAL_ERROR;
 800812c:	2301      	movs	r3, #1
}
 800812e:	4618      	mov	r0, r3
 8008130:	b002      	add	sp, #8
 8008132:	4770      	bx	lr
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008134:	490c      	ldr	r1, [pc, #48]	@ (8008168 <SUBGHZ_CheckDeviceReady+0x84>)
    count  = SUBGHZ_NSS_LOOP_TIME;
 8008136:	0c13      	lsrs	r3, r2, #16
 8008138:	9300      	str	r3, [sp, #0]
 800813a:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
 800813e:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8008142:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
      count--;
 8008146:	9b00      	ldr	r3, [sp, #0]
 8008148:	3b01      	subs	r3, #1
 800814a:	9300      	str	r3, [sp, #0]
    } while (count != 0UL);
 800814c:	9b00      	ldr	r3, [sp, #0]
 800814e:	2b00      	cmp	r3, #0
 8008150:	d1f9      	bne.n	8008146 <SUBGHZ_CheckDeviceReady+0x62>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008152:	4905      	ldr	r1, [pc, #20]	@ (8008168 <SUBGHZ_CheckDeviceReady+0x84>)
 8008154:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
 8008158:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800815c:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
}
 8008160:	e7ca      	b.n	80080f8 <SUBGHZ_CheckDeviceReady+0x14>
 8008162:	bf00      	nop
 8008164:	20000004 	.word	0x20000004
 8008168:	58000400 	.word	0x58000400

0800816c <HAL_SUBGHZ_WriteBuffer>:
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 800816c:	f890 c006 	ldrb.w	ip, [r0, #6]
 8008170:	f1bc 0f01 	cmp.w	ip, #1
 8008174:	d156      	bne.n	8008224 <HAL_SUBGHZ_WriteBuffer+0xb8>
{
 8008176:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008178:	4614      	mov	r4, r2
    __HAL_LOCK(hsubghz);
 800817a:	7942      	ldrb	r2, [r0, #5]
 800817c:	2a01      	cmp	r2, #1
{
 800817e:	b083      	sub	sp, #12
 8008180:	4605      	mov	r5, r0
    __HAL_LOCK(hsubghz);
 8008182:	d043      	beq.n	800820c <HAL_SUBGHZ_WriteBuffer+0xa0>
 8008184:	461e      	mov	r6, r3
 8008186:	fa5f f38c 	uxtb.w	r3, ip
 800818a:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 800818c:	460f      	mov	r7, r1
 800818e:	f7ff ffa9 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008192:	4a25      	ldr	r2, [pc, #148]	@ (8008228 <HAL_SUBGHZ_WriteBuffer+0xbc>)
 8008194:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8008198:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 800819c:	210e      	movs	r1, #14
 800819e:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 80081a2:	4628      	mov	r0, r5
 80081a4:	f7ff ff20 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 80081a8:	4639      	mov	r1, r7
 80081aa:	4628      	mov	r0, r5
 80081ac:	f7ff ff1c 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80081b0:	b13e      	cbz	r6, 80081c2 <HAL_SUBGHZ_WriteBuffer+0x56>
 80081b2:	4426      	add	r6, r4
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80081b4:	f814 1b01 	ldrb.w	r1, [r4], #1
 80081b8:	4628      	mov	r0, r5
 80081ba:	f7ff ff15 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80081be:	42b4      	cmp	r4, r6
 80081c0:	d1f8      	bne.n	80081b4 <HAL_SUBGHZ_WriteBuffer+0x48>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80081c2:	4a19      	ldr	r2, [pc, #100]	@ (8008228 <HAL_SUBGHZ_WriteBuffer+0xbc>)
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80081c4:	4819      	ldr	r0, [pc, #100]	@ (800822c <HAL_SUBGHZ_WriteBuffer+0xc0>)
 80081c6:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80081ca:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80081ce:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 80081d2:	6803      	ldr	r3, [r0, #0]
 80081d4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80081d8:	2164      	movs	r1, #100	@ 0x64
 80081da:	f3c3 434b 	ubfx	r3, r3, #17, #12
 80081de:	fb01 f303 	mul.w	r3, r1, r3
 80081e2:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 80081e4:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 80081e6:	9b01      	ldr	r3, [sp, #4]
 80081e8:	b1cb      	cbz	r3, 800821e <HAL_SUBGHZ_WriteBuffer+0xb2>
    count--;
 80081ea:	9b01      	ldr	r3, [sp, #4]
 80081ec:	3b01      	subs	r3, #1
 80081ee:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 80081f0:	6953      	ldr	r3, [r2, #20]
 80081f2:	0798      	lsls	r0, r3, #30
 80081f4:	d40d      	bmi.n	8008212 <HAL_SUBGHZ_WriteBuffer+0xa6>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80081f6:	68a8      	ldr	r0, [r5, #8]
    __HAL_UNLOCK(hsubghz);
 80081f8:	2300      	movs	r3, #0
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80081fa:	1ac0      	subs	r0, r0, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80081fc:	f04f 0201 	mov.w	r2, #1
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008200:	bf18      	it	ne
 8008202:	2001      	movne	r0, #1
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008204:	71aa      	strb	r2, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8008206:	716b      	strb	r3, [r5, #5]
}
 8008208:	b003      	add	sp, #12
 800820a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_LOCK(hsubghz);
 800820c:	2002      	movs	r0, #2
}
 800820e:	b003      	add	sp, #12
 8008210:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 8008212:	074b      	lsls	r3, r1, #29
 8008214:	d5ef      	bpl.n	80081f6 <HAL_SUBGHZ_WriteBuffer+0x8a>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008216:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008218:	9b01      	ldr	r3, [sp, #4]
 800821a:	2b00      	cmp	r3, #0
 800821c:	d1e5      	bne.n	80081ea <HAL_SUBGHZ_WriteBuffer+0x7e>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 800821e:	2302      	movs	r3, #2
 8008220:	60ab      	str	r3, [r5, #8]
      break;
 8008222:	e7e8      	b.n	80081f6 <HAL_SUBGHZ_WriteBuffer+0x8a>
    __HAL_LOCK(hsubghz);
 8008224:	2002      	movs	r0, #2
}
 8008226:	4770      	bx	lr
 8008228:	58000400 	.word	0x58000400
 800822c:	20000004 	.word	0x20000004

08008230 <HAL_SUBGHZ_ReadBuffer>:
{
 8008230:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008232:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8008234:	7983      	ldrb	r3, [r0, #6]
 8008236:	2b01      	cmp	r3, #1
{
 8008238:	b083      	sub	sp, #12
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 800823a:	d14a      	bne.n	80082d2 <HAL_SUBGHZ_ReadBuffer+0xa2>
 800823c:	4614      	mov	r4, r2
 800823e:	b2da      	uxtb	r2, r3
    __HAL_LOCK(hsubghz);
 8008240:	7943      	ldrb	r3, [r0, #5]
 8008242:	2b01      	cmp	r3, #1
 8008244:	4605      	mov	r5, r0
 8008246:	d044      	beq.n	80082d2 <HAL_SUBGHZ_ReadBuffer+0xa2>
 8008248:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 800824a:	460f      	mov	r7, r1
 800824c:	f7ff ff4a 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008250:	4a26      	ldr	r2, [pc, #152]	@ (80082ec <HAL_SUBGHZ_ReadBuffer+0xbc>)
 8008252:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8008256:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 800825a:	211e      	movs	r1, #30
 800825c:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 8008260:	4628      	mov	r0, r5
 8008262:	f7ff fec1 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 8008266:	4639      	mov	r1, r7
 8008268:	4628      	mov	r0, r5
 800826a:	f7ff febd 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 800826e:	2100      	movs	r1, #0
 8008270:	4628      	mov	r0, r5
 8008272:	f7ff feb9 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8008276:	b13e      	cbz	r6, 8008288 <HAL_SUBGHZ_ReadBuffer+0x58>
 8008278:	4426      	add	r6, r4
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 800827a:	4621      	mov	r1, r4
 800827c:	4628      	mov	r0, r5
      pData++;
 800827e:	3401      	adds	r4, #1
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8008280:	f7ff fef0 	bl	8008064 <SUBGHZSPI_Receive>
    for (uint16_t i = 0U; i < Size; i++)
 8008284:	42b4      	cmp	r4, r6
 8008286:	d1f8      	bne.n	800827a <HAL_SUBGHZ_ReadBuffer+0x4a>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008288:	4a18      	ldr	r2, [pc, #96]	@ (80082ec <HAL_SUBGHZ_ReadBuffer+0xbc>)
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 800828a:	4819      	ldr	r0, [pc, #100]	@ (80082f0 <HAL_SUBGHZ_ReadBuffer+0xc0>)
 800828c:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8008290:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8008294:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 8008298:	6803      	ldr	r3, [r0, #0]
 800829a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800829e:	2164      	movs	r1, #100	@ 0x64
 80082a0:	f3c3 434b 	ubfx	r3, r3, #17, #12
 80082a4:	fb01 f303 	mul.w	r3, r1, r3
 80082a8:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 80082aa:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 80082ac:	9b01      	ldr	r3, [sp, #4]
 80082ae:	b1cb      	cbz	r3, 80082e4 <HAL_SUBGHZ_ReadBuffer+0xb4>
    count--;
 80082b0:	9b01      	ldr	r3, [sp, #4]
 80082b2:	3b01      	subs	r3, #1
 80082b4:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 80082b6:	6953      	ldr	r3, [r2, #20]
 80082b8:	0798      	lsls	r0, r3, #30
 80082ba:	d40d      	bmi.n	80082d8 <HAL_SUBGHZ_ReadBuffer+0xa8>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80082bc:	68a8      	ldr	r0, [r5, #8]
    __HAL_UNLOCK(hsubghz);
 80082be:	2300      	movs	r3, #0
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80082c0:	1ac0      	subs	r0, r0, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80082c2:	f04f 0201 	mov.w	r2, #1
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80082c6:	bf18      	it	ne
 80082c8:	2001      	movne	r0, #1
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80082ca:	71aa      	strb	r2, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 80082cc:	716b      	strb	r3, [r5, #5]
}
 80082ce:	b003      	add	sp, #12
 80082d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_LOCK(hsubghz);
 80082d2:	2002      	movs	r0, #2
}
 80082d4:	b003      	add	sp, #12
 80082d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 80082d8:	074b      	lsls	r3, r1, #29
 80082da:	d5ef      	bpl.n	80082bc <HAL_SUBGHZ_ReadBuffer+0x8c>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 80082dc:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 80082de:	9b01      	ldr	r3, [sp, #4]
 80082e0:	2b00      	cmp	r3, #0
 80082e2:	d1e5      	bne.n	80082b0 <HAL_SUBGHZ_ReadBuffer+0x80>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 80082e4:	2302      	movs	r3, #2
 80082e6:	60ab      	str	r3, [r5, #8]
      break;
 80082e8:	e7e8      	b.n	80082bc <HAL_SUBGHZ_ReadBuffer+0x8c>
 80082ea:	bf00      	nop
 80082ec:	58000400 	.word	0x58000400
 80082f0:	20000004 	.word	0x20000004

080082f4 <HAL_SUBGHZ_IRQHandler>:
{
 80082f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80082f8:	7983      	ldrb	r3, [r0, #6]
{
 80082fa:	b085      	sub	sp, #20
  uint8_t tmpisr[2U] = {0U};
 80082fc:	2500      	movs	r5, #0
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80082fe:	2b01      	cmp	r3, #1
{
 8008300:	4604      	mov	r4, r0
  uint8_t tmpisr[2U] = {0U};
 8008302:	f8ad 5004 	strh.w	r5, [sp, #4]
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8008306:	f040 80da 	bne.w	80084be <HAL_SUBGHZ_IRQHandler+0x1ca>
 800830a:	b2da      	uxtb	r2, r3
    __HAL_LOCK(hsubghz);
 800830c:	7943      	ldrb	r3, [r0, #5]
 800830e:	2b01      	cmp	r3, #1
 8008310:	f000 809c 	beq.w	800844c <HAL_SUBGHZ_IRQHandler+0x158>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008314:	4e74      	ldr	r6, [pc, #464]	@ (80084e8 <HAL_SUBGHZ_IRQHandler+0x1f4>)
 8008316:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8008318:	f7ff fee4 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
 800831c:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 8008320:	4f72      	ldr	r7, [pc, #456]	@ (80084ec <HAL_SUBGHZ_IRQHandler+0x1f8>)
 8008322:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8008326:	f8c6 3090 	str.w	r3, [r6, #144]	@ 0x90
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 800832a:	2112      	movs	r1, #18
 800832c:	4620      	mov	r0, r4
 800832e:	f7ff fe5b 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 8008332:	4629      	mov	r1, r5
 8008334:	4620      	mov	r0, r4
 8008336:	f7ff fe57 	bl	8007fe8 <SUBGHZSPI_Transmit>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 800833a:	a901      	add	r1, sp, #4
 800833c:	4620      	mov	r0, r4
 800833e:	f7ff fe91 	bl	8008064 <SUBGHZSPI_Receive>
 8008342:	f10d 0105 	add.w	r1, sp, #5
 8008346:	4620      	mov	r0, r4
 8008348:	f7ff fe8c 	bl	8008064 <SUBGHZSPI_Receive>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 800834c:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 8008350:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8008354:	f8c6 3090 	str.w	r3, [r6, #144]	@ 0x90
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 8008358:	683b      	ldr	r3, [r7, #0]
 800835a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800835e:	2264      	movs	r2, #100	@ 0x64
 8008360:	f3c3 434b 	ubfx	r3, r3, #17, #12
 8008364:	fb02 f303 	mul.w	r3, r2, r3
 8008368:	9302      	str	r3, [sp, #8]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 800836a:	6972      	ldr	r2, [r6, #20]
    if (count == 0U)
 800836c:	9b02      	ldr	r3, [sp, #8]
 800836e:	2b00      	cmp	r3, #0
 8008370:	f000 8099 	beq.w	80084a6 <HAL_SUBGHZ_IRQHandler+0x1b2>
    count--;
 8008374:	9b02      	ldr	r3, [sp, #8]
 8008376:	3b01      	subs	r3, #1
 8008378:	9302      	str	r3, [sp, #8]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 800837a:	6973      	ldr	r3, [r6, #20]
 800837c:	0799      	lsls	r1, r3, #30
 800837e:	f100 808a 	bmi.w	8008496 <HAL_SUBGHZ_IRQHandler+0x1a2>
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008382:	2301      	movs	r3, #1
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008384:	68a2      	ldr	r2, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008386:	71a3      	strb	r3, [r4, #6]
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8008388:	79a3      	ldrb	r3, [r4, #6]
 800838a:	f8bd 5004 	ldrh.w	r5, [sp, #4]
    __HAL_UNLOCK(hsubghz);
 800838e:	2200      	movs	r2, #0
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8008390:	2b01      	cmp	r3, #1
    __HAL_UNLOCK(hsubghz);
 8008392:	7162      	strb	r2, [r4, #5]
  itsource = (itsource << 8U) | tmpisr[1U];
 8008394:	baed      	revsh	r5, r5
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8008396:	d13b      	bne.n	8008410 <HAL_SUBGHZ_IRQHandler+0x11c>
  itsource = tmpisr[0U];
 8008398:	f89d 9004 	ldrb.w	r9, [sp, #4]
  itsource = (itsource << 8U) | tmpisr[1U];
 800839c:	f89d 8005 	ldrb.w	r8, [sp, #5]
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80083a0:	4e51      	ldr	r6, [pc, #324]	@ (80084e8 <HAL_SUBGHZ_IRQHandler+0x1f4>)
    __HAL_LOCK(hsubghz);
 80083a2:	2301      	movs	r3, #1
 80083a4:	7163      	strb	r3, [r4, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80083a6:	4620      	mov	r0, r4
 80083a8:	f7ff fe9c 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
      hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_DISABLE;
 80083ac:	2300      	movs	r3, #0
 80083ae:	7123      	strb	r3, [r4, #4]
 80083b0:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 80083b4:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 80083b8:	f8c6 3090 	str.w	r3, [r6, #144]	@ 0x90
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 80083bc:	2102      	movs	r1, #2
 80083be:	4620      	mov	r0, r4
 80083c0:	f7ff fe12 	bl	8007fe8 <SUBGHZSPI_Transmit>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80083c4:	4649      	mov	r1, r9
 80083c6:	4620      	mov	r0, r4
 80083c8:	f7ff fe0e 	bl	8007fe8 <SUBGHZSPI_Transmit>
 80083cc:	4641      	mov	r1, r8
 80083ce:	4620      	mov	r0, r4
 80083d0:	f7ff fe0a 	bl	8007fe8 <SUBGHZSPI_Transmit>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80083d4:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 80083d8:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80083dc:	f8c6 3090 	str.w	r3, [r6, #144]	@ 0x90
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80083e0:	683b      	ldr	r3, [r7, #0]
 80083e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80083e6:	2264      	movs	r2, #100	@ 0x64
 80083e8:	f3c3 434b 	ubfx	r3, r3, #17, #12
 80083ec:	fb02 f303 	mul.w	r3, r2, r3
 80083f0:	9303      	str	r3, [sp, #12]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 80083f2:	6972      	ldr	r2, [r6, #20]
    if (count == 0U)
 80083f4:	9b03      	ldr	r3, [sp, #12]
 80083f6:	2b00      	cmp	r3, #0
 80083f8:	d05e      	beq.n	80084b8 <HAL_SUBGHZ_IRQHandler+0x1c4>
    count--;
 80083fa:	9b03      	ldr	r3, [sp, #12]
 80083fc:	3b01      	subs	r3, #1
 80083fe:	9303      	str	r3, [sp, #12]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 8008400:	6973      	ldr	r3, [r6, #20]
 8008402:	079b      	lsls	r3, r3, #30
 8008404:	d452      	bmi.n	80084ac <HAL_SUBGHZ_IRQHandler+0x1b8>
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008406:	2301      	movs	r3, #1
    __HAL_UNLOCK(hsubghz);
 8008408:	2200      	movs	r2, #0
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 800840a:	68a1      	ldr	r1, [r4, #8]
    __HAL_UNLOCK(hsubghz);
 800840c:	7162      	strb	r2, [r4, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 800840e:	71a3      	strb	r3, [r4, #6]
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 8008410:	07e8      	lsls	r0, r5, #31
 8008412:	d41e      	bmi.n	8008452 <HAL_SUBGHZ_IRQHandler+0x15e>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 8008414:	07a9      	lsls	r1, r5, #30
 8008416:	d421      	bmi.n	800845c <HAL_SUBGHZ_IRQHandler+0x168>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 8008418:	076a      	lsls	r2, r5, #29
 800841a:	d424      	bmi.n	8008466 <HAL_SUBGHZ_IRQHandler+0x172>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 800841c:	072b      	lsls	r3, r5, #28
 800841e:	d427      	bmi.n	8008470 <HAL_SUBGHZ_IRQHandler+0x17c>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 8008420:	06ef      	lsls	r7, r5, #27
 8008422:	d42a      	bmi.n	800847a <HAL_SUBGHZ_IRQHandler+0x186>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 8008424:	06ae      	lsls	r6, r5, #26
 8008426:	d42d      	bmi.n	8008484 <HAL_SUBGHZ_IRQHandler+0x190>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 8008428:	0668      	lsls	r0, r5, #25
 800842a:	d430      	bmi.n	800848e <HAL_SUBGHZ_IRQHandler+0x19a>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 800842c:	0629      	lsls	r1, r5, #24
 800842e:	d506      	bpl.n	800843e <HAL_SUBGHZ_IRQHandler+0x14a>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 8008430:	f415 7180 	ands.w	r1, r5, #256	@ 0x100
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 8008434:	bf18      	it	ne
 8008436:	2101      	movne	r1, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 8008438:	4620      	mov	r0, r4
 800843a:	f00c fb15 	bl	8014a68 <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 800843e:	05aa      	lsls	r2, r5, #22
 8008440:	d44d      	bmi.n	80084de <HAL_SUBGHZ_IRQHandler+0x1ea>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_LR_FHSS_HOP) != RESET)
 8008442:	046b      	lsls	r3, r5, #17
 8008444:	d445      	bmi.n	80084d2 <HAL_SUBGHZ_IRQHandler+0x1de>
}
 8008446:	b005      	add	sp, #20
 8008448:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 800844c:	7983      	ldrb	r3, [r0, #6]
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 800844e:	07e8      	lsls	r0, r5, #31
 8008450:	d5e0      	bpl.n	8008414 <HAL_SUBGHZ_IRQHandler+0x120>
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 8008452:	4620      	mov	r0, r4
 8008454:	f00c faf6 	bl	8014a44 <HAL_SUBGHZ_TxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 8008458:	07a9      	lsls	r1, r5, #30
 800845a:	d5dd      	bpl.n	8008418 <HAL_SUBGHZ_IRQHandler+0x124>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 800845c:	4620      	mov	r0, r4
 800845e:	f00c faf7 	bl	8014a50 <HAL_SUBGHZ_RxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 8008462:	076a      	lsls	r2, r5, #29
 8008464:	d5da      	bpl.n	800841c <HAL_SUBGHZ_IRQHandler+0x128>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 8008466:	4620      	mov	r0, r4
 8008468:	f00c fb1c 	bl	8014aa4 <HAL_SUBGHZ_PreambleDetectedCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 800846c:	072b      	lsls	r3, r5, #28
 800846e:	d5d7      	bpl.n	8008420 <HAL_SUBGHZ_IRQHandler+0x12c>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 8008470:	4620      	mov	r0, r4
 8008472:	f00c fb1d 	bl	8014ab0 <HAL_SUBGHZ_SyncWordValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 8008476:	06ef      	lsls	r7, r5, #27
 8008478:	d5d4      	bpl.n	8008424 <HAL_SUBGHZ_IRQHandler+0x130>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 800847a:	4620      	mov	r0, r4
 800847c:	f00c fb1e 	bl	8014abc <HAL_SUBGHZ_HeaderValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 8008480:	06ae      	lsls	r6, r5, #26
 8008482:	d5d1      	bpl.n	8008428 <HAL_SUBGHZ_IRQHandler+0x134>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 8008484:	4620      	mov	r0, r4
 8008486:	f00c fb07 	bl	8014a98 <HAL_SUBGHZ_HeaderErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 800848a:	0668      	lsls	r0, r5, #25
 800848c:	d5ce      	bpl.n	800842c <HAL_SUBGHZ_IRQHandler+0x138>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 800848e:	4620      	mov	r0, r4
 8008490:	f00c fae4 	bl	8014a5c <HAL_SUBGHZ_CRCErrorCallback>
 8008494:	e7ca      	b.n	800842c <HAL_SUBGHZ_IRQHandler+0x138>
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 8008496:	0752      	lsls	r2, r2, #29
 8008498:	f57f af73 	bpl.w	8008382 <HAL_SUBGHZ_IRQHandler+0x8e>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 800849c:	6972      	ldr	r2, [r6, #20]
    if (count == 0U)
 800849e:	9b02      	ldr	r3, [sp, #8]
 80084a0:	2b00      	cmp	r3, #0
 80084a2:	f47f af67 	bne.w	8008374 <HAL_SUBGHZ_IRQHandler+0x80>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 80084a6:	2302      	movs	r3, #2
 80084a8:	60a3      	str	r3, [r4, #8]
      break;
 80084aa:	e76a      	b.n	8008382 <HAL_SUBGHZ_IRQHandler+0x8e>
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 80084ac:	0757      	lsls	r7, r2, #29
 80084ae:	d5aa      	bpl.n	8008406 <HAL_SUBGHZ_IRQHandler+0x112>
 80084b0:	6972      	ldr	r2, [r6, #20]
    if (count == 0U)
 80084b2:	9b03      	ldr	r3, [sp, #12]
 80084b4:	2b00      	cmp	r3, #0
 80084b6:	d1a0      	bne.n	80083fa <HAL_SUBGHZ_IRQHandler+0x106>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 80084b8:	2302      	movs	r3, #2
 80084ba:	60a3      	str	r3, [r4, #8]
      break;
 80084bc:	e7a3      	b.n	8008406 <HAL_SUBGHZ_IRQHandler+0x112>
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80084be:	7983      	ldrb	r3, [r0, #6]
 80084c0:	2b01      	cmp	r3, #1
 80084c2:	d1a5      	bne.n	8008410 <HAL_SUBGHZ_IRQHandler+0x11c>
    __HAL_LOCK(hsubghz);
 80084c4:	7943      	ldrb	r3, [r0, #5]
 80084c6:	2b01      	cmp	r3, #1
 80084c8:	d0a2      	beq.n	8008410 <HAL_SUBGHZ_IRQHandler+0x11c>
 80084ca:	4f08      	ldr	r7, [pc, #32]	@ (80084ec <HAL_SUBGHZ_IRQHandler+0x1f8>)
  itsource = (itsource << 8U) | tmpisr[1U];
 80084cc:	46a8      	mov	r8, r5
  itsource = tmpisr[0U];
 80084ce:	46a9      	mov	r9, r5
 80084d0:	e766      	b.n	80083a0 <HAL_SUBGHZ_IRQHandler+0xac>
    HAL_SUBGHZ_LrFhssHopCallback(hsubghz);
 80084d2:	4620      	mov	r0, r4
 80084d4:	f00c faf8 	bl	8014ac8 <HAL_SUBGHZ_LrFhssHopCallback>
}
 80084d8:	b005      	add	sp, #20
 80084da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 80084de:	4620      	mov	r0, r4
 80084e0:	f00c fad2 	bl	8014a88 <HAL_SUBGHZ_RxTxTimeoutCallback>
 80084e4:	e7ad      	b.n	8008442 <HAL_SUBGHZ_IRQHandler+0x14e>
 80084e6:	bf00      	nop
 80084e8:	58000400 	.word	0x58000400
 80084ec:	20000004 	.word	0x20000004

080084f0 <HAL_SUBGHZ_ExecGetCmd>:
{
 80084f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80084f2:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80084f4:	7983      	ldrb	r3, [r0, #6]
 80084f6:	2b01      	cmp	r3, #1
{
 80084f8:	b083      	sub	sp, #12
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80084fa:	d146      	bne.n	800858a <HAL_SUBGHZ_ExecGetCmd+0x9a>
 80084fc:	4614      	mov	r4, r2
 80084fe:	b2da      	uxtb	r2, r3
    __HAL_LOCK(hsubghz);
 8008500:	7943      	ldrb	r3, [r0, #5]
 8008502:	2b01      	cmp	r3, #1
 8008504:	4605      	mov	r5, r0
 8008506:	d040      	beq.n	800858a <HAL_SUBGHZ_ExecGetCmd+0x9a>
 8008508:	7142      	strb	r2, [r0, #5]
 800850a:	460f      	mov	r7, r1
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 800850c:	f7ff fdea 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008510:	4a24      	ldr	r2, [pc, #144]	@ (80085a4 <HAL_SUBGHZ_ExecGetCmd+0xb4>)
 8008512:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8008516:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 800851a:	4639      	mov	r1, r7
 800851c:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 8008520:	4628      	mov	r0, r5
 8008522:	f7ff fd61 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 8008526:	2100      	movs	r1, #0
 8008528:	4628      	mov	r0, r5
 800852a:	f7ff fd5d 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 800852e:	b13e      	cbz	r6, 8008540 <HAL_SUBGHZ_ExecGetCmd+0x50>
 8008530:	4426      	add	r6, r4
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8008532:	4621      	mov	r1, r4
 8008534:	4628      	mov	r0, r5
      pData++;
 8008536:	3401      	adds	r4, #1
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8008538:	f7ff fd94 	bl	8008064 <SUBGHZSPI_Receive>
    for (uint16_t i = 0U; i < Size; i++)
 800853c:	42b4      	cmp	r4, r6
 800853e:	d1f8      	bne.n	8008532 <HAL_SUBGHZ_ExecGetCmd+0x42>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8008540:	4a18      	ldr	r2, [pc, #96]	@ (80085a4 <HAL_SUBGHZ_ExecGetCmd+0xb4>)
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 8008542:	4819      	ldr	r0, [pc, #100]	@ (80085a8 <HAL_SUBGHZ_ExecGetCmd+0xb8>)
 8008544:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8008548:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800854c:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 8008550:	6803      	ldr	r3, [r0, #0]
 8008552:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008556:	2164      	movs	r1, #100	@ 0x64
 8008558:	f3c3 434b 	ubfx	r3, r3, #17, #12
 800855c:	fb01 f303 	mul.w	r3, r1, r3
 8008560:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008562:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008564:	9b01      	ldr	r3, [sp, #4]
 8008566:	b1cb      	cbz	r3, 800859c <HAL_SUBGHZ_ExecGetCmd+0xac>
    count--;
 8008568:	9b01      	ldr	r3, [sp, #4]
 800856a:	3b01      	subs	r3, #1
 800856c:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 800856e:	6953      	ldr	r3, [r2, #20]
 8008570:	0798      	lsls	r0, r3, #30
 8008572:	d40d      	bmi.n	8008590 <HAL_SUBGHZ_ExecGetCmd+0xa0>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008574:	68a8      	ldr	r0, [r5, #8]
    __HAL_UNLOCK(hsubghz);
 8008576:	2300      	movs	r3, #0
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008578:	1ac0      	subs	r0, r0, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 800857a:	f04f 0201 	mov.w	r2, #1
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 800857e:	bf18      	it	ne
 8008580:	2001      	movne	r0, #1
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008582:	71aa      	strb	r2, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8008584:	716b      	strb	r3, [r5, #5]
}
 8008586:	b003      	add	sp, #12
 8008588:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_LOCK(hsubghz);
 800858a:	2002      	movs	r0, #2
}
 800858c:	b003      	add	sp, #12
 800858e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 8008590:	074b      	lsls	r3, r1, #29
 8008592:	d5ef      	bpl.n	8008574 <HAL_SUBGHZ_ExecGetCmd+0x84>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008594:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008596:	9b01      	ldr	r3, [sp, #4]
 8008598:	2b00      	cmp	r3, #0
 800859a:	d1e5      	bne.n	8008568 <HAL_SUBGHZ_ExecGetCmd+0x78>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 800859c:	2302      	movs	r3, #2
 800859e:	60ab      	str	r3, [r5, #8]
      break;
 80085a0:	e7e8      	b.n	8008574 <HAL_SUBGHZ_ExecGetCmd+0x84>
 80085a2:	bf00      	nop
 80085a4:	58000400 	.word	0x58000400
 80085a8:	20000004 	.word	0x20000004

080085ac <HAL_SUBGHZ_ExecSetCmd>:
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80085ac:	f890 c006 	ldrb.w	ip, [r0, #6]
 80085b0:	f1bc 0f01 	cmp.w	ip, #1
 80085b4:	d15c      	bne.n	8008670 <HAL_SUBGHZ_ExecSetCmd+0xc4>
{
 80085b6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80085b8:	4614      	mov	r4, r2
    __HAL_LOCK(hsubghz);
 80085ba:	7942      	ldrb	r2, [r0, #5]
 80085bc:	2a01      	cmp	r2, #1
{
 80085be:	b083      	sub	sp, #12
 80085c0:	4605      	mov	r5, r0
    __HAL_LOCK(hsubghz);
 80085c2:	d049      	beq.n	8008658 <HAL_SUBGHZ_ExecSetCmd+0xac>
 80085c4:	461e      	mov	r6, r3
 80085c6:	fa5f f38c 	uxtb.w	r3, ip
 80085ca:	460f      	mov	r7, r1
 80085cc:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80085ce:	f7ff fd89 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 80085d2:	f007 03ef 	and.w	r3, r7, #239	@ 0xef
 80085d6:	f1a3 0384 	sub.w	r3, r3, #132	@ 0x84
 80085da:	fab3 f383 	clz	r3, r3
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80085de:	4a25      	ldr	r2, [pc, #148]	@ (8008674 <HAL_SUBGHZ_ExecSetCmd+0xc8>)
 80085e0:	095b      	lsrs	r3, r3, #5
 80085e2:	712b      	strb	r3, [r5, #4]
 80085e4:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80085e8:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 80085ec:	4639      	mov	r1, r7
 80085ee:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 80085f2:	4628      	mov	r0, r5
 80085f4:	f7ff fcf8 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80085f8:	b13e      	cbz	r6, 800860a <HAL_SUBGHZ_ExecSetCmd+0x5e>
 80085fa:	4426      	add	r6, r4
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80085fc:	f814 1b01 	ldrb.w	r1, [r4], #1
 8008600:	4628      	mov	r0, r5
 8008602:	f7ff fcf1 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8008606:	42a6      	cmp	r6, r4
 8008608:	d1f8      	bne.n	80085fc <HAL_SUBGHZ_ExecSetCmd+0x50>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 800860a:	4a1a      	ldr	r2, [pc, #104]	@ (8008674 <HAL_SUBGHZ_ExecSetCmd+0xc8>)
 800860c:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
    if (Command != RADIO_SET_SLEEP)
 8008610:	2f84      	cmp	r7, #132	@ 0x84
 8008612:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8008616:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 800861a:	d012      	beq.n	8008642 <HAL_SUBGHZ_ExecSetCmd+0x96>
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 800861c:	4b16      	ldr	r3, [pc, #88]	@ (8008678 <HAL_SUBGHZ_ExecSetCmd+0xcc>)
 800861e:	681b      	ldr	r3, [r3, #0]
 8008620:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008624:	2164      	movs	r1, #100	@ 0x64
 8008626:	f3c3 434b 	ubfx	r3, r3, #17, #12
 800862a:	fb01 f303 	mul.w	r3, r1, r3
 800862e:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008630:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008632:	9b01      	ldr	r3, [sp, #4]
 8008634:	b1cb      	cbz	r3, 800866a <HAL_SUBGHZ_ExecSetCmd+0xbe>
    count--;
 8008636:	9b01      	ldr	r3, [sp, #4]
 8008638:	3b01      	subs	r3, #1
 800863a:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 800863c:	6953      	ldr	r3, [r2, #20]
 800863e:	0798      	lsls	r0, r3, #30
 8008640:	d40d      	bmi.n	800865e <HAL_SUBGHZ_ExecSetCmd+0xb2>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008642:	68a8      	ldr	r0, [r5, #8]
    __HAL_UNLOCK(hsubghz);
 8008644:	2300      	movs	r3, #0
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008646:	1ac0      	subs	r0, r0, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008648:	f04f 0201 	mov.w	r2, #1
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 800864c:	bf18      	it	ne
 800864e:	2001      	movne	r0, #1
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008650:	71aa      	strb	r2, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8008652:	716b      	strb	r3, [r5, #5]
}
 8008654:	b003      	add	sp, #12
 8008656:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_LOCK(hsubghz);
 8008658:	2002      	movs	r0, #2
}
 800865a:	b003      	add	sp, #12
 800865c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 800865e:	074b      	lsls	r3, r1, #29
 8008660:	d5ef      	bpl.n	8008642 <HAL_SUBGHZ_ExecSetCmd+0x96>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008662:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008664:	9b01      	ldr	r3, [sp, #4]
 8008666:	2b00      	cmp	r3, #0
 8008668:	d1e5      	bne.n	8008636 <HAL_SUBGHZ_ExecSetCmd+0x8a>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 800866a:	2302      	movs	r3, #2
 800866c:	60ab      	str	r3, [r5, #8]
      break;
 800866e:	e7e8      	b.n	8008642 <HAL_SUBGHZ_ExecSetCmd+0x96>
    __HAL_LOCK(hsubghz);
 8008670:	2002      	movs	r0, #2
}
 8008672:	4770      	bx	lr
 8008674:	58000400 	.word	0x58000400
 8008678:	20000004 	.word	0x20000004

0800867c <HAL_SUBGHZ_WriteRegisters>:
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 800867c:	f890 c006 	ldrb.w	ip, [r0, #6]
 8008680:	f1bc 0f01 	cmp.w	ip, #1
 8008684:	d15c      	bne.n	8008740 <HAL_SUBGHZ_WriteRegisters+0xc4>
{
 8008686:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008688:	4614      	mov	r4, r2
    __HAL_LOCK(hsubghz);
 800868a:	7942      	ldrb	r2, [r0, #5]
 800868c:	2a01      	cmp	r2, #1
{
 800868e:	b083      	sub	sp, #12
 8008690:	4605      	mov	r5, r0
    __HAL_LOCK(hsubghz);
 8008692:	d049      	beq.n	8008728 <HAL_SUBGHZ_WriteRegisters+0xac>
 8008694:	461e      	mov	r6, r3
 8008696:	fa5f f38c 	uxtb.w	r3, ip
 800869a:	7143      	strb	r3, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 800869c:	2302      	movs	r3, #2
 800869e:	7183      	strb	r3, [r0, #6]
 80086a0:	460f      	mov	r7, r1
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80086a2:	f7ff fd1f 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80086a6:	4a27      	ldr	r2, [pc, #156]	@ (8008744 <HAL_SUBGHZ_WriteRegisters+0xc8>)
 80086a8:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80086ac:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 80086b0:	210d      	movs	r1, #13
 80086b2:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 80086b6:	4628      	mov	r0, r5
 80086b8:	f7ff fc96 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 80086bc:	0a39      	lsrs	r1, r7, #8
 80086be:	4628      	mov	r0, r5
 80086c0:	f7ff fc92 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 80086c4:	b2f9      	uxtb	r1, r7
 80086c6:	4628      	mov	r0, r5
 80086c8:	f7ff fc8e 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80086cc:	b13e      	cbz	r6, 80086de <HAL_SUBGHZ_WriteRegisters+0x62>
 80086ce:	4426      	add	r6, r4
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80086d0:	f814 1b01 	ldrb.w	r1, [r4], #1
 80086d4:	4628      	mov	r0, r5
 80086d6:	f7ff fc87 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80086da:	42b4      	cmp	r4, r6
 80086dc:	d1f8      	bne.n	80086d0 <HAL_SUBGHZ_WriteRegisters+0x54>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80086de:	4a19      	ldr	r2, [pc, #100]	@ (8008744 <HAL_SUBGHZ_WriteRegisters+0xc8>)
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80086e0:	4819      	ldr	r0, [pc, #100]	@ (8008748 <HAL_SUBGHZ_WriteRegisters+0xcc>)
 80086e2:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80086e6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80086ea:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 80086ee:	6803      	ldr	r3, [r0, #0]
 80086f0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80086f4:	2164      	movs	r1, #100	@ 0x64
 80086f6:	f3c3 434b 	ubfx	r3, r3, #17, #12
 80086fa:	fb01 f303 	mul.w	r3, r1, r3
 80086fe:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008700:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008702:	9b01      	ldr	r3, [sp, #4]
 8008704:	b1cb      	cbz	r3, 800873a <HAL_SUBGHZ_WriteRegisters+0xbe>
    count--;
 8008706:	9b01      	ldr	r3, [sp, #4]
 8008708:	3b01      	subs	r3, #1
 800870a:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 800870c:	6953      	ldr	r3, [r2, #20]
 800870e:	0798      	lsls	r0, r3, #30
 8008710:	d40d      	bmi.n	800872e <HAL_SUBGHZ_WriteRegisters+0xb2>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008712:	68a8      	ldr	r0, [r5, #8]
    __HAL_UNLOCK(hsubghz);
 8008714:	2300      	movs	r3, #0
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8008716:	1ac0      	subs	r0, r0, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008718:	f04f 0201 	mov.w	r2, #1
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 800871c:	bf18      	it	ne
 800871e:	2001      	movne	r0, #1
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8008720:	71aa      	strb	r2, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8008722:	716b      	strb	r3, [r5, #5]
}
 8008724:	b003      	add	sp, #12
 8008726:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_LOCK(hsubghz);
 8008728:	2002      	movs	r0, #2
}
 800872a:	b003      	add	sp, #12
 800872c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 800872e:	074b      	lsls	r3, r1, #29
 8008730:	d5ef      	bpl.n	8008712 <HAL_SUBGHZ_WriteRegisters+0x96>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008732:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008734:	9b01      	ldr	r3, [sp, #4]
 8008736:	2b00      	cmp	r3, #0
 8008738:	d1e5      	bne.n	8008706 <HAL_SUBGHZ_WriteRegisters+0x8a>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 800873a:	2302      	movs	r3, #2
 800873c:	60ab      	str	r3, [r5, #8]
      break;
 800873e:	e7e8      	b.n	8008712 <HAL_SUBGHZ_WriteRegisters+0x96>
    __HAL_LOCK(hsubghz);
 8008740:	2002      	movs	r0, #2
}
 8008742:	4770      	bx	lr
 8008744:	58000400 	.word	0x58000400
 8008748:	20000004 	.word	0x20000004

0800874c <HAL_SUBGHZ_ReadRegisters>:
{
 800874c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800874e:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8008750:	7983      	ldrb	r3, [r0, #6]
 8008752:	2b01      	cmp	r3, #1
{
 8008754:	b083      	sub	sp, #12
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8008756:	d14e      	bne.n	80087f6 <HAL_SUBGHZ_ReadRegisters+0xaa>
 8008758:	4614      	mov	r4, r2
 800875a:	b2da      	uxtb	r2, r3
    __HAL_LOCK(hsubghz);
 800875c:	7943      	ldrb	r3, [r0, #5]
 800875e:	2b01      	cmp	r3, #1
 8008760:	4605      	mov	r5, r0
 8008762:	d048      	beq.n	80087f6 <HAL_SUBGHZ_ReadRegisters+0xaa>
 8008764:	7142      	strb	r2, [r0, #5]
 8008766:	460f      	mov	r7, r1
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8008768:	f7ff fcbc 	bl	80080e4 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 800876c:	4a28      	ldr	r2, [pc, #160]	@ (8008810 <HAL_SUBGHZ_ReadRegisters+0xc4>)
 800876e:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8008772:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8008776:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 800877a:	211d      	movs	r1, #29
 800877c:	4628      	mov	r0, r5
 800877e:	f7ff fc33 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 8008782:	0a39      	lsrs	r1, r7, #8
 8008784:	4628      	mov	r0, r5
 8008786:	f7ff fc2f 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 800878a:	b2f9      	uxtb	r1, r7
 800878c:	4628      	mov	r0, r5
 800878e:	f7ff fc2b 	bl	8007fe8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 8008792:	2100      	movs	r1, #0
 8008794:	4628      	mov	r0, r5
 8008796:	f7ff fc27 	bl	8007fe8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 800879a:	b13e      	cbz	r6, 80087ac <HAL_SUBGHZ_ReadRegisters+0x60>
 800879c:	4426      	add	r6, r4
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 800879e:	4621      	mov	r1, r4
 80087a0:	4628      	mov	r0, r5
      pData++;
 80087a2:	3401      	adds	r4, #1
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 80087a4:	f7ff fc5e 	bl	8008064 <SUBGHZSPI_Receive>
    for (uint16_t i = 0U; i < Size; i++)
 80087a8:	42b4      	cmp	r4, r6
 80087aa:	d1f8      	bne.n	800879e <HAL_SUBGHZ_ReadRegisters+0x52>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80087ac:	4a18      	ldr	r2, [pc, #96]	@ (8008810 <HAL_SUBGHZ_ReadRegisters+0xc4>)
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80087ae:	4819      	ldr	r0, [pc, #100]	@ (8008814 <HAL_SUBGHZ_ReadRegisters+0xc8>)
 80087b0:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 80087b4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80087b8:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
 80087bc:	6803      	ldr	r3, [r0, #0]
 80087be:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80087c2:	2164      	movs	r1, #100	@ 0x64
 80087c4:	f3c3 434b 	ubfx	r3, r3, #17, #12
 80087c8:	fb01 f303 	mul.w	r3, r1, r3
 80087cc:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 80087ce:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 80087d0:	9b01      	ldr	r3, [sp, #4]
 80087d2:	b1cb      	cbz	r3, 8008808 <HAL_SUBGHZ_ReadRegisters+0xbc>
    count--;
 80087d4:	9b01      	ldr	r3, [sp, #4]
 80087d6:	3b01      	subs	r3, #1
 80087d8:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 80087da:	6953      	ldr	r3, [r2, #20]
 80087dc:	0798      	lsls	r0, r3, #30
 80087de:	d40d      	bmi.n	80087fc <HAL_SUBGHZ_ReadRegisters+0xb0>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80087e0:	68a8      	ldr	r0, [r5, #8]
    __HAL_UNLOCK(hsubghz);
 80087e2:	2300      	movs	r3, #0
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80087e4:	1ac0      	subs	r0, r0, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80087e6:	f04f 0201 	mov.w	r2, #1
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80087ea:	bf18      	it	ne
 80087ec:	2001      	movne	r0, #1
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80087ee:	71aa      	strb	r2, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 80087f0:	716b      	strb	r3, [r5, #5]
}
 80087f2:	b003      	add	sp, #12
 80087f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_LOCK(hsubghz);
 80087f6:	2002      	movs	r0, #2
}
 80087f8:	b003      	add	sp, #12
 80087fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 80087fc:	074b      	lsls	r3, r1, #29
 80087fe:	d5ef      	bpl.n	80087e0 <HAL_SUBGHZ_ReadRegisters+0x94>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8008800:	6951      	ldr	r1, [r2, #20]
    if (count == 0U)
 8008802:	9b01      	ldr	r3, [sp, #4]
 8008804:	2b00      	cmp	r3, #0
 8008806:	d1e5      	bne.n	80087d4 <HAL_SUBGHZ_ReadRegisters+0x88>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 8008808:	2302      	movs	r3, #2
 800880a:	60ab      	str	r3, [r5, #8]
      break;
 800880c:	e7e8      	b.n	80087e0 <HAL_SUBGHZ_ReadRegisters+0x94>
 800880e:	bf00      	nop
 8008810:	58000400 	.word	0x58000400
 8008814:	20000004 	.word	0x20000004

08008818 <HAL_UART_Receive_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 8008818:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
 800881c:	2b20      	cmp	r3, #32
 800881e:	d152      	bne.n	80088c6 <HAL_UART_Receive_IT+0xae>
  {
    if ((pData == NULL) || (Size == 0U))
 8008820:	b101      	cbz	r1, 8008824 <HAL_UART_Receive_IT+0xc>
 8008822:	b90a      	cbnz	r2, 8008828 <HAL_UART_Receive_IT+0x10>
    {
      return HAL_ERROR;
 8008824:	2001      	movs	r0, #1
  }
  else
  {
    return HAL_BUSY;
  }
}
 8008826:	4770      	bx	lr
{
 8008828:	b430      	push	{r4, r5}
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800882a:	6803      	ldr	r3, [r0, #0]
 800882c:	4c52      	ldr	r4, [pc, #328]	@ (8008978 <HAL_UART_Receive_IT+0x160>)
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800882e:	2500      	movs	r5, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8008830:	42a3      	cmp	r3, r4
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008832:	66c5      	str	r5, [r0, #108]	@ 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8008834:	d00a      	beq.n	800884c <HAL_UART_Receive_IT+0x34>
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8008836:	685c      	ldr	r4, [r3, #4]
 8008838:	0224      	lsls	r4, r4, #8
 800883a:	d507      	bpl.n	800884c <HAL_UART_Receive_IT+0x34>
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800883c:	e853 4f00 	ldrex	r4, [r3]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8008840:	f044 6480 	orr.w	r4, r4, #67108864	@ 0x4000000
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008844:	e843 4500 	strex	r5, r4, [r3]
 8008848:	2d00      	cmp	r5, #0
 800884a:	d1f7      	bne.n	800883c <HAL_UART_Receive_IT+0x24>
  huart->RxXferSize  = Size;
  huart->RxXferCount = Size;
  huart->RxISR       = NULL;

  /* Computation of UART mask to apply to RDR register */
  UART_MASK_COMPUTATION(huart);
 800884c:	6885      	ldr	r5, [r0, #8]
  huart->pRxBuffPtr  = pData;
 800884e:	6581      	str	r1, [r0, #88]	@ 0x58
  huart->RxISR       = NULL;
 8008850:	2400      	movs	r4, #0
  UART_MASK_COMPUTATION(huart);
 8008852:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
  huart->RxXferSize  = Size;
 8008856:	f8a0 205c 	strh.w	r2, [r0, #92]	@ 0x5c
  huart->RxXferCount = Size;
 800885a:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
  huart->RxISR       = NULL;
 800885e:	6744      	str	r4, [r0, #116]	@ 0x74
  UART_MASK_COMPUTATION(huart);
 8008860:	d048      	beq.n	80088f4 <HAL_UART_Receive_IT+0xdc>
 8008862:	2d00      	cmp	r5, #0
 8008864:	d164      	bne.n	8008930 <HAL_UART_Receive_IT+0x118>
 8008866:	6901      	ldr	r1, [r0, #16]
 8008868:	2900      	cmp	r1, #0
 800886a:	bf14      	ite	ne
 800886c:	247f      	movne	r4, #127	@ 0x7f
 800886e:	24ff      	moveq	r4, #255	@ 0xff

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8008870:	2100      	movs	r1, #0
 8008872:	f8c0 1090 	str.w	r1, [r0, #144]	@ 0x90
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8008876:	2122      	movs	r1, #34	@ 0x22
  UART_MASK_COMPUTATION(huart);
 8008878:	f8a0 4060 	strh.w	r4, [r0, #96]	@ 0x60
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800887c:	f8c0 108c 	str.w	r1, [r0, #140]	@ 0x8c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008880:	f103 0108 	add.w	r1, r3, #8
 8008884:	e851 1f00 	ldrex	r1, [r1]

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8008888:	f041 0101 	orr.w	r1, r1, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800888c:	f103 0508 	add.w	r5, r3, #8
 8008890:	e845 1400 	strex	r4, r1, [r5]
 8008894:	2c00      	cmp	r4, #0
 8008896:	d1f3      	bne.n	8008880 <HAL_UART_Receive_IT+0x68>

  /* Configure Rx interrupt processing */
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8008898:	6e41      	ldr	r1, [r0, #100]	@ 0x64
  {
    /* Set the Rx ISR function pointer according to the data word length */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800889a:	6885      	ldr	r5, [r0, #8]
 800889c:	6904      	ldr	r4, [r0, #16]
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 800889e:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
 80088a2:	d02e      	beq.n	8008902 <HAL_UART_Receive_IT+0xea>
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
  }
  else
  {
    /* Set the Rx ISR function pointer according to the data word length */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80088a4:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
 80088a8:	d00f      	beq.n	80088ca <HAL_UART_Receive_IT+0xb2>
 80088aa:	4a34      	ldr	r2, [pc, #208]	@ (800897c <HAL_UART_Receive_IT+0x164>)
 80088ac:	6742      	str	r2, [r0, #116]	@ 0x74
    {
      huart->RxISR = UART_RxISR_8BIT;
    }

    /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
    if (huart->Init.Parity != UART_PARITY_NONE)
 80088ae:	b184      	cbz	r4, 80088d2 <HAL_UART_Receive_IT+0xba>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80088b0:	e853 2f00 	ldrex	r2, [r3]
    {
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 80088b4:	f442 7290 	orr.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80088b8:	e843 2100 	strex	r1, r2, [r3]
 80088bc:	2900      	cmp	r1, #0
 80088be:	d1f7      	bne.n	80088b0 <HAL_UART_Receive_IT+0x98>
    return (UART_Start_Receive_IT(huart, pData, Size));
 80088c0:	2000      	movs	r0, #0
}
 80088c2:	bc30      	pop	{r4, r5}
 80088c4:	4770      	bx	lr
    return HAL_BUSY;
 80088c6:	2002      	movs	r0, #2
 80088c8:	4770      	bx	lr
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80088ca:	2c00      	cmp	r4, #0
 80088cc:	d14d      	bne.n	800896a <HAL_UART_Receive_IT+0x152>
 80088ce:	4a2c      	ldr	r2, [pc, #176]	@ (8008980 <HAL_UART_Receive_IT+0x168>)
 80088d0:	6742      	str	r2, [r0, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80088d2:	e853 2f00 	ldrex	r2, [r3]
    }
    else
    {
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80088d6:	f042 0220 	orr.w	r2, r2, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80088da:	e843 2100 	strex	r1, r2, [r3]
 80088de:	2900      	cmp	r1, #0
 80088e0:	d0ee      	beq.n	80088c0 <HAL_UART_Receive_IT+0xa8>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80088e2:	e853 2f00 	ldrex	r2, [r3]
 80088e6:	f042 0220 	orr.w	r2, r2, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80088ea:	e843 2100 	strex	r1, r2, [r3]
 80088ee:	2900      	cmp	r1, #0
 80088f0:	d1ef      	bne.n	80088d2 <HAL_UART_Receive_IT+0xba>
 80088f2:	e7e5      	b.n	80088c0 <HAL_UART_Receive_IT+0xa8>
  UART_MASK_COMPUTATION(huart);
 80088f4:	6901      	ldr	r1, [r0, #16]
 80088f6:	2900      	cmp	r1, #0
 80088f8:	f240 14ff 	movw	r4, #511	@ 0x1ff
 80088fc:	bf18      	it	ne
 80088fe:	24ff      	movne	r4, #255	@ 0xff
 8008900:	e7b6      	b.n	8008870 <HAL_UART_Receive_IT+0x58>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8008902:	f8b0 1068 	ldrh.w	r1, [r0, #104]	@ 0x68
 8008906:	4291      	cmp	r1, r2
 8008908:	d8cc      	bhi.n	80088a4 <HAL_UART_Receive_IT+0x8c>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800890a:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
 800890e:	d018      	beq.n	8008942 <HAL_UART_Receive_IT+0x12a>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 8008910:	4a1c      	ldr	r2, [pc, #112]	@ (8008984 <HAL_UART_Receive_IT+0x16c>)
 8008912:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 8008914:	b9c4      	cbnz	r4, 8008948 <HAL_UART_Receive_IT+0x130>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008916:	f103 0208 	add.w	r2, r3, #8
 800891a:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 800891e:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008922:	f103 0008 	add.w	r0, r3, #8
 8008926:	e840 2100 	strex	r1, r2, [r0]
 800892a:	2900      	cmp	r1, #0
 800892c:	d1f3      	bne.n	8008916 <HAL_UART_Receive_IT+0xfe>
 800892e:	e7c7      	b.n	80088c0 <HAL_UART_Receive_IT+0xa8>
  UART_MASK_COMPUTATION(huart);
 8008930:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
 8008934:	d19c      	bne.n	8008870 <HAL_UART_Receive_IT+0x58>
 8008936:	6901      	ldr	r1, [r0, #16]
 8008938:	2900      	cmp	r1, #0
 800893a:	bf14      	ite	ne
 800893c:	243f      	movne	r4, #63	@ 0x3f
 800893e:	247f      	moveq	r4, #127	@ 0x7f
 8008940:	e796      	b.n	8008870 <HAL_UART_Receive_IT+0x58>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8008942:	b1ac      	cbz	r4, 8008970 <HAL_UART_Receive_IT+0x158>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 8008944:	4a0f      	ldr	r2, [pc, #60]	@ (8008984 <HAL_UART_Receive_IT+0x16c>)
 8008946:	6742      	str	r2, [r0, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008948:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800894c:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008950:	e843 2100 	strex	r1, r2, [r3]
 8008954:	2900      	cmp	r1, #0
 8008956:	d0de      	beq.n	8008916 <HAL_UART_Receive_IT+0xfe>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008958:	e853 2f00 	ldrex	r2, [r3]
 800895c:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008960:	e843 2100 	strex	r1, r2, [r3]
 8008964:	2900      	cmp	r1, #0
 8008966:	d1ef      	bne.n	8008948 <HAL_UART_Receive_IT+0x130>
 8008968:	e7d5      	b.n	8008916 <HAL_UART_Receive_IT+0xfe>
 800896a:	4a04      	ldr	r2, [pc, #16]	@ (800897c <HAL_UART_Receive_IT+0x164>)
 800896c:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 800896e:	e79f      	b.n	80088b0 <HAL_UART_Receive_IT+0x98>
 8008970:	4a05      	ldr	r2, [pc, #20]	@ (8008988 <HAL_UART_Receive_IT+0x170>)
 8008972:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 8008974:	e7cf      	b.n	8008916 <HAL_UART_Receive_IT+0xfe>
 8008976:	bf00      	nop
 8008978:	40008000 	.word	0x40008000
 800897c:	08008fbd 	.word	0x08008fbd
 8008980:	08008f79 	.word	0x08008f79
 8008984:	08009001 	.word	0x08009001
 8008988:	080091e5 	.word	0x080091e5

0800898c <HAL_UART_Transmit_DMA>:
{
 800898c:	b570      	push	{r4, r5, r6, lr}
  if (huart->gState == HAL_UART_STATE_READY)
 800898e:	f8d0 6088 	ldr.w	r6, [r0, #136]	@ 0x88
 8008992:	2e20      	cmp	r6, #32
 8008994:	d124      	bne.n	80089e0 <HAL_UART_Transmit_DMA+0x54>
    if ((pData == NULL) || (Size == 0U))
 8008996:	4604      	mov	r4, r0
 8008998:	b301      	cbz	r1, 80089dc <HAL_UART_Transmit_DMA+0x50>
 800899a:	4613      	mov	r3, r2
 800899c:	b1f2      	cbz	r2, 80089dc <HAL_UART_Transmit_DMA+0x50>
    huart->TxXferCount = Size;
 800899e:	f8a0 2056 	strh.w	r2, [r0, #86]	@ 0x56
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80089a2:	2200      	movs	r2, #0
    huart->pTxBuffPtr  = pData;
 80089a4:	6501      	str	r1, [r0, #80]	@ 0x50
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80089a6:	f8c0 2090 	str.w	r2, [r0, #144]	@ 0x90
    huart->TxXferSize  = Size;
 80089aa:	f8a0 3054 	strh.w	r3, [r0, #84]	@ 0x54
    if (huart->hdmatx != NULL)
 80089ae:	6fc0      	ldr	r0, [r0, #124]	@ 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80089b0:	2521      	movs	r5, #33	@ 0x21
 80089b2:	f8c4 5088 	str.w	r5, [r4, #136]	@ 0x88
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 80089b6:	6825      	ldr	r5, [r4, #0]
    if (huart->hdmatx != NULL)
 80089b8:	b1a8      	cbz	r0, 80089e6 <HAL_UART_Transmit_DMA+0x5a>
      huart->hdmatx->XferAbortCallback = NULL;
 80089ba:	6382      	str	r2, [r0, #56]	@ 0x38
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 80089bc:	f105 0228 	add.w	r2, r5, #40	@ 0x28
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 80089c0:	4d11      	ldr	r5, [pc, #68]	@ (8008a08 <HAL_UART_Transmit_DMA+0x7c>)
 80089c2:	62c5      	str	r5, [r0, #44]	@ 0x2c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 80089c4:	4d11      	ldr	r5, [pc, #68]	@ (8008a0c <HAL_UART_Transmit_DMA+0x80>)
 80089c6:	6305      	str	r5, [r0, #48]	@ 0x30
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 80089c8:	4d11      	ldr	r5, [pc, #68]	@ (8008a10 <HAL_UART_Transmit_DMA+0x84>)
 80089ca:	6345      	str	r5, [r0, #52]	@ 0x34
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 80089cc:	f7fc ffba 	bl	8005944 <HAL_DMA_Start_IT>
 80089d0:	b140      	cbz	r0, 80089e4 <HAL_UART_Transmit_DMA+0x58>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 80089d2:	2310      	movs	r3, #16
 80089d4:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        huart->gState = HAL_UART_STATE_READY;
 80089d8:	f8c4 6088 	str.w	r6, [r4, #136]	@ 0x88
      return HAL_ERROR;
 80089dc:	2001      	movs	r0, #1
}
 80089de:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 80089e0:	2002      	movs	r0, #2
}
 80089e2:	bd70      	pop	{r4, r5, r6, pc}
 80089e4:	6825      	ldr	r5, [r4, #0]
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 80089e6:	2340      	movs	r3, #64	@ 0x40
 80089e8:	622b      	str	r3, [r5, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80089ea:	f105 0308 	add.w	r3, r5, #8
 80089ee:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 80089f2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80089f6:	f105 0108 	add.w	r1, r5, #8
 80089fa:	e841 3200 	strex	r2, r3, [r1]
 80089fe:	2a00      	cmp	r2, #0
 8008a00:	d1f3      	bne.n	80089ea <HAL_UART_Transmit_DMA+0x5e>
    return HAL_OK;
 8008a02:	2000      	movs	r0, #0
}
 8008a04:	bd70      	pop	{r4, r5, r6, pc}
 8008a06:	bf00      	nop
 8008a08:	08008a15 	.word	0x08008a15
 8008a0c:	08008a5d 	.word	0x08008a5d
 8008a10:	08008a6d 	.word	0x08008a6d

08008a14 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 8008a14:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 8008a16:	6803      	ldr	r3, [r0, #0]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8008a18:	6a80      	ldr	r0, [r0, #40]	@ 0x28
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 8008a1a:	681b      	ldr	r3, [r3, #0]
 8008a1c:	f013 0320 	ands.w	r3, r3, #32
 8008a20:	d117      	bne.n	8008a52 <UART_DMATransmitCplt+0x3e>
  {
    huart->TxXferCount = 0U;
 8008a22:	6802      	ldr	r2, [r0, #0]
 8008a24:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008a28:	f102 0308 	add.w	r3, r2, #8
 8008a2c:	e853 3f00 	ldrex	r3, [r3]

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8008a30:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008a34:	f102 0008 	add.w	r0, r2, #8
 8008a38:	e840 3100 	strex	r1, r3, [r0]
 8008a3c:	2900      	cmp	r1, #0
 8008a3e:	d1f3      	bne.n	8008a28 <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008a40:	e852 3f00 	ldrex	r3, [r2]

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8008a44:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008a48:	e842 3100 	strex	r1, r3, [r2]
 8008a4c:	2900      	cmp	r1, #0
 8008a4e:	d1f7      	bne.n	8008a40 <UART_DMATransmitCplt+0x2c>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 8008a50:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 8008a52:	f7f9 fbbf 	bl	80021d4 <HAL_UART_TxCpltCallback>
}
 8008a56:	bd08      	pop	{r3, pc}

08008a58 <HAL_UART_TxHalfCpltCallback>:
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
 8008a58:	4770      	bx	lr
 8008a5a:	bf00      	nop

08008a5c <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8008a5c:	b508      	push	{r3, lr}
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 8008a5e:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 8008a60:	f7ff fffa 	bl	8008a58 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8008a64:	bd08      	pop	{r3, pc}
 8008a66:	bf00      	nop

08008a68 <HAL_UART_ErrorCallback>:
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
 8008a68:	4770      	bx	lr
 8008a6a:	bf00      	nop

08008a6c <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8008a6c:	6a80      	ldr	r0, [r0, #40]	@ 0x28

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 8008a6e:	6803      	ldr	r3, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 8008a70:	f8d0 1088 	ldr.w	r1, [r0, #136]	@ 0x88
{
 8008a74:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 8008a76:	f8d0 408c 	ldr.w	r4, [r0, #140]	@ 0x8c
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 8008a7a:	689a      	ldr	r2, [r3, #8]
 8008a7c:	0612      	lsls	r2, r2, #24
 8008a7e:	d501      	bpl.n	8008a84 <UART_DMAError+0x18>
 8008a80:	2921      	cmp	r1, #33	@ 0x21
 8008a82:	d00d      	beq.n	8008aa0 <UART_DMAError+0x34>
    huart->TxXferCount = 0U;
    UART_EndTxTransfer(huart);
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 8008a84:	689a      	ldr	r2, [r3, #8]
 8008a86:	0652      	lsls	r2, r2, #25
 8008a88:	d501      	bpl.n	8008a8e <UART_DMAError+0x22>
 8008a8a:	2c22      	cmp	r4, #34	@ 0x22
 8008a8c:	d023      	beq.n	8008ad6 <UART_DMAError+0x6a>
  {
    huart->RxXferCount = 0U;
    UART_EndRxTransfer(huart);
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8008a8e:	f8d0 3090 	ldr.w	r3, [r0, #144]	@ 0x90
 8008a92:	f043 0310 	orr.w	r3, r3, #16
 8008a96:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8008a9a:	f7ff ffe5 	bl	8008a68 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8008a9e:	bd10      	pop	{r4, pc}
    huart->TxXferCount = 0U;
 8008aa0:	2200      	movs	r2, #0
 8008aa2:	f8a0 2056 	strh.w	r2, [r0, #86]	@ 0x56
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008aa6:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 8008aaa:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008aae:	e843 2100 	strex	r1, r2, [r3]
 8008ab2:	2900      	cmp	r1, #0
 8008ab4:	d1f7      	bne.n	8008aa6 <UART_DMAError+0x3a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008ab6:	f103 0208 	add.w	r2, r3, #8
 8008aba:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 8008abe:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008ac2:	f103 0c08 	add.w	ip, r3, #8
 8008ac6:	e84c 2100 	strex	r1, r2, [ip]
 8008aca:	2900      	cmp	r1, #0
 8008acc:	d1f3      	bne.n	8008ab6 <UART_DMAError+0x4a>
  huart->gState = HAL_UART_STATE_READY;
 8008ace:	2220      	movs	r2, #32
 8008ad0:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
}
 8008ad4:	e7d6      	b.n	8008a84 <UART_DMAError+0x18>
    huart->RxXferCount = 0U;
 8008ad6:	2200      	movs	r2, #0
 8008ad8:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008adc:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8008ae0:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008ae4:	e843 2100 	strex	r1, r2, [r3]
 8008ae8:	2900      	cmp	r1, #0
 8008aea:	d1f7      	bne.n	8008adc <UART_DMAError+0x70>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8008aec:	4c13      	ldr	r4, [pc, #76]	@ (8008b3c <UART_DMAError+0xd0>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008aee:	f103 0208 	add.w	r2, r3, #8
 8008af2:	e852 2f00 	ldrex	r2, [r2]
 8008af6:	4022      	ands	r2, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008af8:	f103 0c08 	add.w	ip, r3, #8
 8008afc:	e84c 2100 	strex	r1, r2, [ip]
 8008b00:	2900      	cmp	r1, #0
 8008b02:	d1f4      	bne.n	8008aee <UART_DMAError+0x82>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8008b04:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
 8008b06:	2a01      	cmp	r2, #1
 8008b08:	d006      	beq.n	8008b18 <UART_DMAError+0xac>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008b0a:	2300      	movs	r3, #0
  huart->RxState = HAL_UART_STATE_READY;
 8008b0c:	2220      	movs	r2, #32
 8008b0e:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
  huart->RxISR = NULL;
 8008b12:	6743      	str	r3, [r0, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008b14:	66c3      	str	r3, [r0, #108]	@ 0x6c
}
 8008b16:	e7ba      	b.n	8008a8e <UART_DMAError+0x22>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008b18:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8008b1c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008b20:	e843 2100 	strex	r1, r2, [r3]
 8008b24:	2900      	cmp	r1, #0
 8008b26:	d0f0      	beq.n	8008b0a <UART_DMAError+0x9e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008b28:	e853 2f00 	ldrex	r2, [r3]
 8008b2c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008b30:	e843 2100 	strex	r1, r2, [r3]
 8008b34:	2900      	cmp	r1, #0
 8008b36:	d1ef      	bne.n	8008b18 <UART_DMAError+0xac>
 8008b38:	e7e7      	b.n	8008b0a <UART_DMAError+0x9e>
 8008b3a:	bf00      	nop
 8008b3c:	effffffe 	.word	0xeffffffe

08008b40 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8008b40:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8008b42:	6a80      	ldr	r0, [r0, #40]	@ 0x28
  huart->RxXferCount = 0U;
 8008b44:	2300      	movs	r3, #0
 8008b46:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
  huart->TxXferCount = 0U;
 8008b4a:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8008b4e:	f7ff ff8b 	bl	8008a68 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8008b52:	bd08      	pop	{r3, pc}

08008b54 <HAL_UARTEx_RxEventCallback>:
}
 8008b54:	4770      	bx	lr
 8008b56:	bf00      	nop

08008b58 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8008b58:	6803      	ldr	r3, [r0, #0]
 8008b5a:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8008b5c:	6819      	ldr	r1, [r3, #0]
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8008b5e:	f640 0c0f 	movw	ip, #2063	@ 0x80f
  if (errorflags == 0U)
 8008b62:	ea12 0f0c 	tst.w	r2, ip
{
 8008b66:	b570      	push	{r4, r5, r6, lr}
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8008b68:	689d      	ldr	r5, [r3, #8]
{
 8008b6a:	4604      	mov	r4, r0
  if (errorflags == 0U)
 8008b6c:	d145      	bne.n	8008bfa <HAL_UART_IRQHandler+0xa2>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8008b6e:	0696      	lsls	r6, r2, #26
 8008b70:	d507      	bpl.n	8008b82 <HAL_UART_IRQHandler+0x2a>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8008b72:	f001 0c20 	and.w	ip, r1, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8008b76:	f005 5e80 	and.w	lr, r5, #268435456	@ 0x10000000
 8008b7a:	ea5c 0c0e 	orrs.w	ip, ip, lr
 8008b7e:	f040 8106 	bne.w	8008d8e <HAL_UART_IRQHandler+0x236>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8008b82:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
 8008b84:	2801      	cmp	r0, #1
 8008b86:	f000 80d3 	beq.w	8008d30 <HAL_UART_IRQHandler+0x1d8>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8008b8a:	02d6      	lsls	r6, r2, #11
 8008b8c:	d41d      	bmi.n	8008bca <HAL_UART_IRQHandler+0x72>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 8008b8e:	0616      	lsls	r6, r2, #24
 8008b90:	d506      	bpl.n	8008ba0 <HAL_UART_IRQHandler+0x48>
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 8008b92:	f405 0500 	and.w	r5, r5, #8388608	@ 0x800000
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 8008b96:	f001 0080 	and.w	r0, r1, #128	@ 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 8008b9a:	4328      	orrs	r0, r5
 8008b9c:	f040 80fe 	bne.w	8008d9c <HAL_UART_IRQHandler+0x244>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8008ba0:	0650      	lsls	r0, r2, #25
 8008ba2:	d51c      	bpl.n	8008bde <HAL_UART_IRQHandler+0x86>
 8008ba4:	064e      	lsls	r6, r1, #25
 8008ba6:	d51a      	bpl.n	8008bde <HAL_UART_IRQHandler+0x86>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008ba8:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8008bac:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008bb0:	e843 2100 	strex	r1, r2, [r3]
 8008bb4:	2900      	cmp	r1, #0
 8008bb6:	d1f7      	bne.n	8008ba8 <HAL_UART_IRQHandler+0x50>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8008bb8:	2220      	movs	r2, #32

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8008bba:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 8008bbc:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
  huart->TxISR = NULL;
 8008bc0:	67a3      	str	r3, [r4, #120]	@ 0x78
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8008bc2:	4620      	mov	r0, r4
 8008bc4:	f7f9 fb06 	bl	80021d4 <HAL_UART_TxCpltCallback>
}
 8008bc8:	bd70      	pop	{r4, r5, r6, pc}
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8008bca:	0268      	lsls	r0, r5, #9
 8008bcc:	d5df      	bpl.n	8008b8e <HAL_UART_IRQHandler+0x36>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8008bce:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 8008bd2:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8008bd4:	621a      	str	r2, [r3, #32]
}
 8008bd6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_UARTEx_WakeupCallback(huart);
 8008bda:	f000 be5d 	b.w	8009898 <HAL_UARTEx_WakeupCallback>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 8008bde:	0215      	lsls	r5, r2, #8
 8008be0:	d502      	bpl.n	8008be8 <HAL_UART_IRQHandler+0x90>
 8008be2:	0048      	lsls	r0, r1, #1
 8008be4:	f100 80ff 	bmi.w	8008de6 <HAL_UART_IRQHandler+0x28e>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 8008be8:	01d3      	lsls	r3, r2, #7
 8008bea:	d5ed      	bpl.n	8008bc8 <HAL_UART_IRQHandler+0x70>
 8008bec:	2900      	cmp	r1, #0
 8008bee:	daeb      	bge.n	8008bc8 <HAL_UART_IRQHandler+0x70>
    HAL_UARTEx_RxFifoFullCallback(huart);
 8008bf0:	4620      	mov	r0, r4
}
 8008bf2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
 8008bf6:	f000 be51 	b.w	800989c <HAL_UARTEx_RxFifoFullCallback>
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 8008bfa:	48b4      	ldr	r0, [pc, #720]	@ (8008ecc <HAL_UART_IRQHandler+0x374>)
 8008bfc:	ea05 0c00 	and.w	ip, r5, r0
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 8008c00:	48b3      	ldr	r0, [pc, #716]	@ (8008ed0 <HAL_UART_IRQHandler+0x378>)
 8008c02:	4008      	ands	r0, r1
 8008c04:	ea50 000c 	orrs.w	r0, r0, ip
 8008c08:	d0bb      	beq.n	8008b82 <HAL_UART_IRQHandler+0x2a>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8008c0a:	07d6      	lsls	r6, r2, #31
 8008c0c:	d509      	bpl.n	8008c22 <HAL_UART_IRQHandler+0xca>
 8008c0e:	05c8      	lsls	r0, r1, #23
 8008c10:	d507      	bpl.n	8008c22 <HAL_UART_IRQHandler+0xca>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8008c12:	2001      	movs	r0, #1
 8008c14:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8008c16:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 8008c1a:	f040 0001 	orr.w	r0, r0, #1
 8008c1e:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8008c22:	0796      	lsls	r6, r2, #30
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8008c24:	f002 0004 	and.w	r0, r2, #4
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8008c28:	f140 80aa 	bpl.w	8008d80 <HAL_UART_IRQHandler+0x228>
 8008c2c:	07ee      	lsls	r6, r5, #31
 8008c2e:	d510      	bpl.n	8008c52 <HAL_UART_IRQHandler+0xfa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8008c30:	2602      	movs	r6, #2
 8008c32:	621e      	str	r6, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8008c34:	f8d4 6090 	ldr.w	r6, [r4, #144]	@ 0x90
 8008c38:	f046 0604 	orr.w	r6, r6, #4
 8008c3c:	f8c4 6090 	str.w	r6, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8008c40:	b138      	cbz	r0, 8008c52 <HAL_UART_IRQHandler+0xfa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8008c42:	2004      	movs	r0, #4
 8008c44:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8008c46:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 8008c4a:	f040 0002 	orr.w	r0, r0, #2
 8008c4e:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_ORE) != 0U)
 8008c52:	0716      	lsls	r6, r2, #28
 8008c54:	d50c      	bpl.n	8008c70 <HAL_UART_IRQHandler+0x118>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 8008c56:	f001 0020 	and.w	r0, r1, #32
 8008c5a:	ea50 000c 	orrs.w	r0, r0, ip
 8008c5e:	d007      	beq.n	8008c70 <HAL_UART_IRQHandler+0x118>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8008c60:	2008      	movs	r0, #8
 8008c62:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8008c64:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 8008c68:	f040 0008 	orr.w	r0, r0, #8
 8008c6c:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8008c70:	0510      	lsls	r0, r2, #20
 8008c72:	d50a      	bpl.n	8008c8a <HAL_UART_IRQHandler+0x132>
 8008c74:	014e      	lsls	r6, r1, #5
 8008c76:	d508      	bpl.n	8008c8a <HAL_UART_IRQHandler+0x132>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8008c78:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 8008c7c:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8008c7e:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 8008c82:	f040 0020 	orr.w	r0, r0, #32
 8008c86:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8008c8a:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 8008c8e:	2800      	cmp	r0, #0
 8008c90:	d09a      	beq.n	8008bc8 <HAL_UART_IRQHandler+0x70>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8008c92:	0690      	lsls	r0, r2, #26
 8008c94:	d506      	bpl.n	8008ca4 <HAL_UART_IRQHandler+0x14c>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8008c96:	f001 0120 	and.w	r1, r1, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8008c9a:	f005 5580 	and.w	r5, r5, #268435456	@ 0x10000000
 8008c9e:	4329      	orrs	r1, r5
 8008ca0:	f040 8095 	bne.w	8008dce <HAL_UART_IRQHandler+0x276>
      errorcode = huart->ErrorCode;
 8008ca4:	f8d4 1090 	ldr.w	r1, [r4, #144]	@ 0x90
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8008ca8:	689a      	ldr	r2, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8008caa:	f001 0128 	and.w	r1, r1, #40	@ 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8008cae:	f002 0240 	and.w	r2, r2, #64	@ 0x40
 8008cb2:	ea52 0501 	orrs.w	r5, r2, r1
 8008cb6:	f000 80cc 	beq.w	8008e52 <HAL_UART_IRQHandler+0x2fa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008cba:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8008cbe:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008cc2:	e843 2100 	strex	r1, r2, [r3]
 8008cc6:	2900      	cmp	r1, #0
 8008cc8:	d1f7      	bne.n	8008cba <HAL_UART_IRQHandler+0x162>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8008cca:	4882      	ldr	r0, [pc, #520]	@ (8008ed4 <HAL_UART_IRQHandler+0x37c>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008ccc:	f103 0208 	add.w	r2, r3, #8
 8008cd0:	e852 2f00 	ldrex	r2, [r2]
 8008cd4:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008cd6:	f103 0508 	add.w	r5, r3, #8
 8008cda:	e845 2100 	strex	r1, r2, [r5]
 8008cde:	2900      	cmp	r1, #0
 8008ce0:	d1f4      	bne.n	8008ccc <HAL_UART_IRQHandler+0x174>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8008ce2:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8008ce4:	2a01      	cmp	r2, #1
 8008ce6:	d061      	beq.n	8008dac <HAL_UART_IRQHandler+0x254>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008ce8:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 8008cea:	2120      	movs	r1, #32
 8008cec:	f8c4 108c 	str.w	r1, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008cf0:	66e2      	str	r2, [r4, #108]	@ 0x6c
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008cf2:	6899      	ldr	r1, [r3, #8]
  huart->RxISR = NULL;
 8008cf4:	6762      	str	r2, [r4, #116]	@ 0x74
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008cf6:	064a      	lsls	r2, r1, #25
 8008cf8:	d571      	bpl.n	8008dde <HAL_UART_IRQHandler+0x286>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008cfa:	f103 0208 	add.w	r2, r3, #8
 8008cfe:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8008d02:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008d06:	f103 0008 	add.w	r0, r3, #8
 8008d0a:	e840 2100 	strex	r1, r2, [r0]
 8008d0e:	2900      	cmp	r1, #0
 8008d10:	d1f3      	bne.n	8008cfa <HAL_UART_IRQHandler+0x1a2>
          if (huart->hdmarx != NULL)
 8008d12:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 8008d16:	2800      	cmp	r0, #0
 8008d18:	d061      	beq.n	8008dde <HAL_UART_IRQHandler+0x286>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8008d1a:	4b6f      	ldr	r3, [pc, #444]	@ (8008ed8 <HAL_UART_IRQHandler+0x380>)
 8008d1c:	6383      	str	r3, [r0, #56]	@ 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8008d1e:	f7fc feaf 	bl	8005a80 <HAL_DMA_Abort_IT>
 8008d22:	2800      	cmp	r0, #0
 8008d24:	f43f af50 	beq.w	8008bc8 <HAL_UART_IRQHandler+0x70>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8008d28:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 8008d2c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8008d2e:	e032      	b.n	8008d96 <HAL_UART_IRQHandler+0x23e>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 8008d30:	06d6      	lsls	r6, r2, #27
 8008d32:	f57f af2a 	bpl.w	8008b8a <HAL_UART_IRQHandler+0x32>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8008d36:	06c8      	lsls	r0, r1, #27
 8008d38:	f57f af27 	bpl.w	8008b8a <HAL_UART_IRQHandler+0x32>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8008d3c:	2210      	movs	r2, #16
 8008d3e:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008d40:	689a      	ldr	r2, [r3, #8]
 8008d42:	0651      	lsls	r1, r2, #25
 8008d44:	f140 808b 	bpl.w	8008e5e <HAL_UART_IRQHandler+0x306>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8008d48:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 8008d4c:	6801      	ldr	r1, [r0, #0]
 8008d4e:	684a      	ldr	r2, [r1, #4]
 8008d50:	b292      	uxth	r2, r2
      if ((nb_remaining_rx_data > 0U)
 8008d52:	2a00      	cmp	r2, #0
 8008d54:	f43f af38 	beq.w	8008bc8 <HAL_UART_IRQHandler+0x70>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8008d58:	f8b4 505c 	ldrh.w	r5, [r4, #92]	@ 0x5c
 8008d5c:	4295      	cmp	r5, r2
 8008d5e:	f67f af33 	bls.w	8008bc8 <HAL_UART_IRQHandler+0x70>
        huart->RxXferCount = nb_remaining_rx_data;
 8008d62:	f8a4 205e 	strh.w	r2, [r4, #94]	@ 0x5e
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 8008d66:	680a      	ldr	r2, [r1, #0]
 8008d68:	0692      	lsls	r2, r2, #26
 8008d6a:	d541      	bpl.n	8008df0 <HAL_UART_IRQHandler+0x298>
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 8008d6c:	2302      	movs	r3, #2
 8008d6e:	6723      	str	r3, [r4, #112]	@ 0x70
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8008d70:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8008d74:	1ae9      	subs	r1, r5, r3
 8008d76:	4620      	mov	r0, r4
 8008d78:	b289      	uxth	r1, r1
 8008d7a:	f7ff feeb 	bl	8008b54 <HAL_UARTEx_RxEventCallback>
}
 8008d7e:	bd70      	pop	{r4, r5, r6, pc}
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8008d80:	2800      	cmp	r0, #0
 8008d82:	f43f af66 	beq.w	8008c52 <HAL_UART_IRQHandler+0xfa>
 8008d86:	07e8      	lsls	r0, r5, #31
 8008d88:	f53f af5b 	bmi.w	8008c42 <HAL_UART_IRQHandler+0xea>
 8008d8c:	e761      	b.n	8008c52 <HAL_UART_IRQHandler+0xfa>
      if (huart->RxISR != NULL)
 8008d8e:	6f43      	ldr	r3, [r0, #116]	@ 0x74
 8008d90:	2b00      	cmp	r3, #0
 8008d92:	f43f af19 	beq.w	8008bc8 <HAL_UART_IRQHandler+0x70>
}
 8008d96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8008d9a:	4718      	bx	r3
    if (huart->TxISR != NULL)
 8008d9c:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 8008d9e:	2b00      	cmp	r3, #0
 8008da0:	f43f af12 	beq.w	8008bc8 <HAL_UART_IRQHandler+0x70>
      huart->TxISR(huart);
 8008da4:	4620      	mov	r0, r4
}
 8008da6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      huart->TxISR(huart);
 8008daa:	4718      	bx	r3
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008dac:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8008db0:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008db4:	e843 2100 	strex	r1, r2, [r3]
 8008db8:	2900      	cmp	r1, #0
 8008dba:	d095      	beq.n	8008ce8 <HAL_UART_IRQHandler+0x190>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008dbc:	e853 2f00 	ldrex	r2, [r3]
 8008dc0:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008dc4:	e843 2100 	strex	r1, r2, [r3]
 8008dc8:	2900      	cmp	r1, #0
 8008dca:	d1ef      	bne.n	8008dac <HAL_UART_IRQHandler+0x254>
 8008dcc:	e78c      	b.n	8008ce8 <HAL_UART_IRQHandler+0x190>
        if (huart->RxISR != NULL)
 8008dce:	6f62      	ldr	r2, [r4, #116]	@ 0x74
 8008dd0:	2a00      	cmp	r2, #0
 8008dd2:	f43f af67 	beq.w	8008ca4 <HAL_UART_IRQHandler+0x14c>
          huart->RxISR(huart);
 8008dd6:	4620      	mov	r0, r4
 8008dd8:	4790      	blx	r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8008dda:	6823      	ldr	r3, [r4, #0]
 8008ddc:	e762      	b.n	8008ca4 <HAL_UART_IRQHandler+0x14c>
            HAL_UART_ErrorCallback(huart);
 8008dde:	4620      	mov	r0, r4
 8008de0:	f7ff fe42 	bl	8008a68 <HAL_UART_ErrorCallback>
}
 8008de4:	bd70      	pop	{r4, r5, r6, pc}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8008de6:	4620      	mov	r0, r4
}
 8008de8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8008dec:	f000 bd58 	b.w	80098a0 <HAL_UARTEx_TxFifoEmptyCallback>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008df0:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8008df4:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008df8:	e843 2100 	strex	r1, r2, [r3]
 8008dfc:	2900      	cmp	r1, #0
 8008dfe:	d1f7      	bne.n	8008df0 <HAL_UART_IRQHandler+0x298>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008e00:	f103 0208 	add.w	r2, r3, #8
 8008e04:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8008e08:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008e0c:	f103 0508 	add.w	r5, r3, #8
 8008e10:	e845 2100 	strex	r1, r2, [r5]
 8008e14:	2900      	cmp	r1, #0
 8008e16:	d1f3      	bne.n	8008e00 <HAL_UART_IRQHandler+0x2a8>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008e18:	f103 0208 	add.w	r2, r3, #8
 8008e1c:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8008e20:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008e24:	f103 0508 	add.w	r5, r3, #8
 8008e28:	e845 2100 	strex	r1, r2, [r5]
 8008e2c:	2900      	cmp	r1, #0
 8008e2e:	d1f3      	bne.n	8008e18 <HAL_UART_IRQHandler+0x2c0>
          huart->RxState = HAL_UART_STATE_READY;
 8008e30:	2220      	movs	r2, #32
 8008e32:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008e36:	66e1      	str	r1, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008e38:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8008e3c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008e40:	e843 2100 	strex	r1, r2, [r3]
 8008e44:	2900      	cmp	r1, #0
 8008e46:	d1f7      	bne.n	8008e38 <HAL_UART_IRQHandler+0x2e0>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8008e48:	f7fc fde2 	bl	8005a10 <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8008e4c:	f8b4 505c 	ldrh.w	r5, [r4, #92]	@ 0x5c
 8008e50:	e78c      	b.n	8008d6c <HAL_UART_IRQHandler+0x214>
        HAL_UART_ErrorCallback(huart);
 8008e52:	4620      	mov	r0, r4
 8008e54:	f7ff fe08 	bl	8008a68 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8008e58:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
}
 8008e5c:	bd70      	pop	{r4, r5, r6, pc}
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8008e5e:	f8b4 105e 	ldrh.w	r1, [r4, #94]	@ 0x5e
      if ((huart->RxXferCount > 0U)
 8008e62:	f8b4 205e 	ldrh.w	r2, [r4, #94]	@ 0x5e
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8008e66:	f8b4 005c 	ldrh.w	r0, [r4, #92]	@ 0x5c
      if ((huart->RxXferCount > 0U)
 8008e6a:	b292      	uxth	r2, r2
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8008e6c:	b289      	uxth	r1, r1
      if ((huart->RxXferCount > 0U)
 8008e6e:	2a00      	cmp	r2, #0
 8008e70:	f43f aeaa 	beq.w	8008bc8 <HAL_UART_IRQHandler+0x70>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8008e74:	1a41      	subs	r1, r0, r1
 8008e76:	b289      	uxth	r1, r1
          && (nb_rx_data > 0U))
 8008e78:	2900      	cmp	r1, #0
 8008e7a:	f43f aea5 	beq.w	8008bc8 <HAL_UART_IRQHandler+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008e7e:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8008e82:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008e86:	e843 2000 	strex	r0, r2, [r3]
 8008e8a:	2800      	cmp	r0, #0
 8008e8c:	d1f7      	bne.n	8008e7e <HAL_UART_IRQHandler+0x326>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8008e8e:	4d11      	ldr	r5, [pc, #68]	@ (8008ed4 <HAL_UART_IRQHandler+0x37c>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008e90:	f103 0208 	add.w	r2, r3, #8
 8008e94:	e852 2f00 	ldrex	r2, [r2]
 8008e98:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008e9a:	f103 0608 	add.w	r6, r3, #8
 8008e9e:	e846 2000 	strex	r0, r2, [r6]
 8008ea2:	2800      	cmp	r0, #0
 8008ea4:	d1f4      	bne.n	8008e90 <HAL_UART_IRQHandler+0x338>
        huart->RxState = HAL_UART_STATE_READY;
 8008ea6:	2220      	movs	r2, #32
 8008ea8:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        huart->RxISR = NULL;
 8008eac:	6760      	str	r0, [r4, #116]	@ 0x74
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008eae:	66e0      	str	r0, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008eb0:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8008eb4:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008eb8:	e843 2000 	strex	r0, r2, [r3]
 8008ebc:	2800      	cmp	r0, #0
 8008ebe:	d1f7      	bne.n	8008eb0 <HAL_UART_IRQHandler+0x358>
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 8008ec0:	2302      	movs	r3, #2
 8008ec2:	6723      	str	r3, [r4, #112]	@ 0x70
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8008ec4:	4620      	mov	r0, r4
 8008ec6:	f7ff fe45 	bl	8008b54 <HAL_UARTEx_RxEventCallback>
}
 8008eca:	bd70      	pop	{r4, r5, r6, pc}
 8008ecc:	10000001 	.word	0x10000001
 8008ed0:	04000120 	.word	0x04000120
 8008ed4:	effffffe 	.word	0xeffffffe
 8008ed8:	08008b41 	.word	0x08008b41

08008edc <UART_RxISR_16BIT.part.0>:
/**
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
 8008edc:	b510      	push	{r4, lr}
 8008ede:	6803      	ldr	r3, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008ee0:	e853 2f00 	ldrex	r2, [r3]
    huart->RxXferCount--;

    if (huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8008ee4:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008ee8:	e843 2100 	strex	r1, r2, [r3]
 8008eec:	2900      	cmp	r1, #0
 8008eee:	d1f7      	bne.n	8008ee0 <UART_RxISR_16BIT.part.0+0x4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008ef0:	f103 0208 	add.w	r2, r3, #8
 8008ef4:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8008ef8:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008efc:	f103 0408 	add.w	r4, r3, #8
 8008f00:	e844 2100 	strex	r1, r2, [r4]
 8008f04:	2900      	cmp	r1, #0
 8008f06:	d1f3      	bne.n	8008ef0 <UART_RxISR_16BIT.part.0+0x14>
      huart->RxISR = NULL;

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;

      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8008f08:	4a1a      	ldr	r2, [pc, #104]	@ (8008f74 <UART_RxISR_16BIT.part.0+0x98>)
      huart->RxISR = NULL;
 8008f0a:	6741      	str	r1, [r0, #116]	@ 0x74
      huart->RxState = HAL_UART_STATE_READY;
 8008f0c:	2420      	movs	r4, #32
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8008f0e:	4293      	cmp	r3, r2
      huart->RxState = HAL_UART_STATE_READY;
 8008f10:	f8c0 408c 	str.w	r4, [r0, #140]	@ 0x8c
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 8008f14:	6701      	str	r1, [r0, #112]	@ 0x70
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8008f16:	d002      	beq.n	8008f1e <UART_RxISR_16BIT.part.0+0x42>
      {
        /* Check that USART RTOEN bit is set */
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8008f18:	685a      	ldr	r2, [r3, #4]
 8008f1a:	0211      	lsls	r1, r2, #8
 8008f1c:	d416      	bmi.n	8008f4c <UART_RxISR_16BIT.part.0+0x70>
        }
      }

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8008f1e:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
 8008f20:	2a01      	cmp	r2, #1
 8008f22:	d124      	bne.n	8008f6e <UART_RxISR_16BIT.part.0+0x92>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008f24:	2200      	movs	r2, #0
 8008f26:	66c2      	str	r2, [r0, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008f28:	e853 2f00 	ldrex	r2, [r3]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8008f2c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008f30:	e843 2100 	strex	r1, r2, [r3]
 8008f34:	2900      	cmp	r1, #0
 8008f36:	d1f7      	bne.n	8008f28 <UART_RxISR_16BIT.part.0+0x4c>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8008f38:	69da      	ldr	r2, [r3, #28]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8008f3a:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8008f3e:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8008f40:	bf44      	itt	mi
 8008f42:	2210      	movmi	r2, #16
 8008f44:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8008f46:	f7ff fe05 	bl	8008b54 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8008f4a:	bd10      	pop	{r4, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008f4c:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8008f50:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008f54:	e843 2100 	strex	r1, r2, [r3]
 8008f58:	2900      	cmp	r1, #0
 8008f5a:	d0e0      	beq.n	8008f1e <UART_RxISR_16BIT.part.0+0x42>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008f5c:	e853 2f00 	ldrex	r2, [r3]
 8008f60:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008f64:	e843 2100 	strex	r1, r2, [r3]
 8008f68:	2900      	cmp	r1, #0
 8008f6a:	d1ef      	bne.n	8008f4c <UART_RxISR_16BIT.part.0+0x70>
 8008f6c:	e7d7      	b.n	8008f1e <UART_RxISR_16BIT.part.0+0x42>
        HAL_UART_RxCpltCallback(huart);
 8008f6e:	f7f9 f93f 	bl	80021f0 <HAL_UART_RxCpltCallback>
}
 8008f72:	bd10      	pop	{r4, pc}
 8008f74:	40008000 	.word	0x40008000

08008f78 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 8008f78:	b410      	push	{r4}
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8008f7a:	f8d0 408c 	ldr.w	r4, [r0, #140]	@ 0x8c
  uint16_t uhMask = huart->Mask;
 8008f7e:	f8b0 1060 	ldrh.w	r1, [r0, #96]	@ 0x60
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8008f82:	6802      	ldr	r2, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8008f84:	2c22      	cmp	r4, #34	@ 0x22
 8008f86:	d005      	beq.n	8008f94 <UART_RxISR_16BIT+0x1c>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8008f88:	6993      	ldr	r3, [r2, #24]
 8008f8a:	f043 0308 	orr.w	r3, r3, #8
 8008f8e:	6193      	str	r3, [r2, #24]
  }
}
 8008f90:	bc10      	pop	{r4}
 8008f92:	4770      	bx	lr
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8008f94:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    *tmp = (uint16_t)(uhdata & uhMask);
 8008f96:	6d84      	ldr	r4, [r0, #88]	@ 0x58
 8008f98:	4011      	ands	r1, r2
 8008f9a:	f824 1b02 	strh.w	r1, [r4], #2
    huart->RxXferCount--;
 8008f9e:	f8b0 205e 	ldrh.w	r2, [r0, #94]	@ 0x5e
    huart->pRxBuffPtr += 2U;
 8008fa2:	6584      	str	r4, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 8008fa4:	3a01      	subs	r2, #1
 8008fa6:	b292      	uxth	r2, r2
 8008fa8:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
    if (huart->RxXferCount == 0U)
 8008fac:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
 8008fb0:	b29b      	uxth	r3, r3
 8008fb2:	2b00      	cmp	r3, #0
 8008fb4:	d1ec      	bne.n	8008f90 <UART_RxISR_16BIT+0x18>
}
 8008fb6:	bc10      	pop	{r4}
 8008fb8:	f7ff bf90 	b.w	8008edc <UART_RxISR_16BIT.part.0>

08008fbc <UART_RxISR_8BIT>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8008fbc:	f8d0 108c 	ldr.w	r1, [r0, #140]	@ 0x8c
  uint16_t uhMask = huart->Mask;
 8008fc0:	f8b0 c060 	ldrh.w	ip, [r0, #96]	@ 0x60
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8008fc4:	6802      	ldr	r2, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8008fc6:	2922      	cmp	r1, #34	@ 0x22
 8008fc8:	d004      	beq.n	8008fd4 <UART_RxISR_8BIT+0x18>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8008fca:	6993      	ldr	r3, [r2, #24]
 8008fcc:	f043 0308 	orr.w	r3, r3, #8
 8008fd0:	6193      	str	r3, [r2, #24]
}
 8008fd2:	4770      	bx	lr
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8008fd4:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8008fd6:	6d81      	ldr	r1, [r0, #88]	@ 0x58
 8008fd8:	ea02 020c 	and.w	r2, r2, ip
 8008fdc:	700a      	strb	r2, [r1, #0]
    huart->RxXferCount--;
 8008fde:	f8b0 205e 	ldrh.w	r2, [r0, #94]	@ 0x5e
    huart->pRxBuffPtr++;
 8008fe2:	6d81      	ldr	r1, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 8008fe4:	3a01      	subs	r2, #1
 8008fe6:	b292      	uxth	r2, r2
 8008fe8:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
    if (huart->RxXferCount == 0U)
 8008fec:	f8b0 205e 	ldrh.w	r2, [r0, #94]	@ 0x5e
    huart->pRxBuffPtr++;
 8008ff0:	3101      	adds	r1, #1
    if (huart->RxXferCount == 0U)
 8008ff2:	b292      	uxth	r2, r2
    huart->pRxBuffPtr++;
 8008ff4:	6581      	str	r1, [r0, #88]	@ 0x58
    if (huart->RxXferCount == 0U)
 8008ff6:	2a00      	cmp	r2, #0
 8008ff8:	d1eb      	bne.n	8008fd2 <UART_RxISR_8BIT+0x16>
 8008ffa:	f7ff bf6f 	b.w	8008edc <UART_RxISR_16BIT.part.0>
 8008ffe:	bf00      	nop

08009000 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8009000:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8009004:	6802      	ldr	r2, [r0, #0]
  uint16_t  uhMask = huart->Mask;
 8009006:	f8b0 b060 	ldrh.w	fp, [r0, #96]	@ 0x60
{
 800900a:	4604      	mov	r4, r0
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 800900c:	69d0      	ldr	r0, [r2, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 800900e:	6817      	ldr	r7, [r2, #0]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8009010:	6896      	ldr	r6, [r2, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8009012:	f8d4 108c 	ldr.w	r1, [r4, #140]	@ 0x8c
 8009016:	2922      	cmp	r1, #34	@ 0x22
 8009018:	d006      	beq.n	8009028 <UART_RxISR_8BIT_FIFOEN+0x28>
 800901a:	4613      	mov	r3, r2
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800901c:	6992      	ldr	r2, [r2, #24]
 800901e:	f042 0208 	orr.w	r2, r2, #8
 8009022:	619a      	str	r2, [r3, #24]
  }
}
 8009024:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8009028:	f8b4 3068 	ldrh.w	r3, [r4, #104]	@ 0x68
 800902c:	2b00      	cmp	r3, #0
 800902e:	f000 80cf 	beq.w	80091d0 <UART_RxISR_8BIT_FIFOEN+0x1d0>
 8009032:	0680      	lsls	r0, r0, #26
 8009034:	f140 8083 	bpl.w	800913e <UART_RxISR_8BIT_FIFOEN+0x13e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8009038:	f8df a19c 	ldr.w	sl, [pc, #412]	@ 80091d8 <UART_RxISR_8BIT_FIFOEN+0x1d8>
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800903c:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 80091dc <UART_RxISR_8BIT_FIFOEN+0x1dc>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8009040:	f407 7780 	and.w	r7, r7, #256	@ 0x100
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8009044:	f006 0601 	and.w	r6, r6, #1
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8009048:	fa5f fb8b 	uxtb.w	fp, fp
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 800904c:	f04f 0900 	mov.w	r9, #0
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8009050:	6a52      	ldr	r2, [r2, #36]	@ 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8009052:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8009054:	ea0b 0202 	and.w	r2, fp, r2
 8009058:	701a      	strb	r2, [r3, #0]
      huart->RxXferCount--;
 800905a:	f8b4 105e 	ldrh.w	r1, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 800905e:	6823      	ldr	r3, [r4, #0]
      huart->pRxBuffPtr++;
 8009060:	6da2      	ldr	r2, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 8009062:	3901      	subs	r1, #1
 8009064:	b289      	uxth	r1, r1
 8009066:	f8a4 105e 	strh.w	r1, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 800906a:	69dd      	ldr	r5, [r3, #28]
      huart->pRxBuffPtr++;
 800906c:	3201      	adds	r2, #1
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 800906e:	0769      	lsls	r1, r5, #29
      huart->pRxBuffPtr++;
 8009070:	65a2      	str	r2, [r4, #88]	@ 0x58
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 8009072:	d01b      	beq.n	80090ac <UART_RxISR_8BIT_FIFOEN+0xac>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8009074:	07ea      	lsls	r2, r5, #31
 8009076:	d508      	bpl.n	800908a <UART_RxISR_8BIT_FIFOEN+0x8a>
 8009078:	b13f      	cbz	r7, 800908a <UART_RxISR_8BIT_FIFOEN+0x8a>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800907a:	2201      	movs	r2, #1
 800907c:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 800907e:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 8009082:	f042 0201 	orr.w	r2, r2, #1
 8009086:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800908a:	07a8      	lsls	r0, r5, #30
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800908c:	f005 0204 	and.w	r2, r5, #4
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8009090:	d514      	bpl.n	80090bc <UART_RxISR_8BIT_FIFOEN+0xbc>
 8009092:	b146      	cbz	r6, 80090a6 <UART_RxISR_8BIT_FIFOEN+0xa6>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8009094:	2102      	movs	r1, #2
 8009096:	6219      	str	r1, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8009098:	f8d4 1090 	ldr.w	r1, [r4, #144]	@ 0x90
 800909c:	f041 0104 	orr.w	r1, r1, #4
 80090a0:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80090a4:	b972      	cbnz	r2, 80090c4 <UART_RxISR_8BIT_FIFOEN+0xc4>
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80090a6:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 80090aa:	b9bb      	cbnz	r3, 80090dc <UART_RxISR_8BIT_FIFOEN+0xdc>
      if (huart->RxXferCount == 0U)
 80090ac:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 80090b0:	b29b      	uxth	r3, r3
 80090b2:	b1eb      	cbz	r3, 80090f0 <UART_RxISR_8BIT_FIFOEN+0xf0>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 80090b4:	06ab      	lsls	r3, r5, #26
 80090b6:	d542      	bpl.n	800913e <UART_RxISR_8BIT_FIFOEN+0x13e>
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80090b8:	6822      	ldr	r2, [r4, #0]
 80090ba:	e7c9      	b.n	8009050 <UART_RxISR_8BIT_FIFOEN+0x50>
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80090bc:	2a00      	cmp	r2, #0
 80090be:	d0f2      	beq.n	80090a6 <UART_RxISR_8BIT_FIFOEN+0xa6>
 80090c0:	2e00      	cmp	r6, #0
 80090c2:	d0f0      	beq.n	80090a6 <UART_RxISR_8BIT_FIFOEN+0xa6>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80090c4:	2204      	movs	r2, #4
 80090c6:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 80090c8:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 80090cc:	f043 0302 	orr.w	r3, r3, #2
 80090d0:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80090d4:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 80090d8:	2b00      	cmp	r3, #0
 80090da:	d0e7      	beq.n	80090ac <UART_RxISR_8BIT_FIFOEN+0xac>
          HAL_UART_ErrorCallback(huart);
 80090dc:	4620      	mov	r0, r4
 80090de:	f7ff fcc3 	bl	8008a68 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80090e2:	f8c4 9090 	str.w	r9, [r4, #144]	@ 0x90
      if (huart->RxXferCount == 0U)
 80090e6:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 80090ea:	b29b      	uxth	r3, r3
 80090ec:	2b00      	cmp	r3, #0
 80090ee:	d1e1      	bne.n	80090b4 <UART_RxISR_8BIT_FIFOEN+0xb4>
 80090f0:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80090f2:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80090f6:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80090fa:	e843 2100 	strex	r1, r2, [r3]
 80090fe:	2900      	cmp	r1, #0
 8009100:	d1f7      	bne.n	80090f2 <UART_RxISR_8BIT_FIFOEN+0xf2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009102:	f103 0208 	add.w	r2, r3, #8
 8009106:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800910a:	ea02 020a 	and.w	r2, r2, sl
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800910e:	f103 0008 	add.w	r0, r3, #8
 8009112:	e840 2100 	strex	r1, r2, [r0]
 8009116:	2900      	cmp	r1, #0
 8009118:	d1f3      	bne.n	8009102 <UART_RxISR_8BIT_FIFOEN+0x102>
        huart->RxState = HAL_UART_STATE_READY;
 800911a:	2220      	movs	r2, #32
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800911c:	4543      	cmp	r3, r8
        huart->RxState = HAL_UART_STATE_READY;
 800911e:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        huart->RxISR = NULL;
 8009122:	6761      	str	r1, [r4, #116]	@ 0x74
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 8009124:	6721      	str	r1, [r4, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8009126:	d002      	beq.n	800912e <UART_RxISR_8BIT_FIFOEN+0x12e>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8009128:	685a      	ldr	r2, [r3, #4]
 800912a:	0211      	lsls	r1, r2, #8
 800912c:	d42a      	bmi.n	8009184 <UART_RxISR_8BIT_FIFOEN+0x184>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800912e:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8009130:	2a01      	cmp	r2, #1
 8009132:	d038      	beq.n	80091a6 <UART_RxISR_8BIT_FIFOEN+0x1a6>
          HAL_UART_RxCpltCallback(huart);
 8009134:	4620      	mov	r0, r4
 8009136:	f7f9 f85b 	bl	80021f0 <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 800913a:	06ab      	lsls	r3, r5, #26
 800913c:	d4bc      	bmi.n	80090b8 <UART_RxISR_8BIT_FIFOEN+0xb8>
    rxdatacount = huart->RxXferCount;
 800913e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 8009142:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 8009144:	2b00      	cmp	r3, #0
 8009146:	f43f af6d 	beq.w	8009024 <UART_RxISR_8BIT_FIFOEN+0x24>
 800914a:	f8b4 2068 	ldrh.w	r2, [r4, #104]	@ 0x68
 800914e:	429a      	cmp	r2, r3
 8009150:	f67f af68 	bls.w	8009024 <UART_RxISR_8BIT_FIFOEN+0x24>
 8009154:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009156:	f103 0208 	add.w	r2, r3, #8
 800915a:	e852 2f00 	ldrex	r2, [r2]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 800915e:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009162:	f103 0008 	add.w	r0, r3, #8
 8009166:	e840 2100 	strex	r1, r2, [r0]
 800916a:	2900      	cmp	r1, #0
 800916c:	d1f3      	bne.n	8009156 <UART_RxISR_8BIT_FIFOEN+0x156>
      huart->RxISR = UART_RxISR_8BIT;
 800916e:	4a1c      	ldr	r2, [pc, #112]	@ (80091e0 <UART_RxISR_8BIT_FIFOEN+0x1e0>)
 8009170:	6762      	str	r2, [r4, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009172:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8009176:	f042 0220 	orr.w	r2, r2, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800917a:	e843 2100 	strex	r1, r2, [r3]
 800917e:	2900      	cmp	r1, #0
 8009180:	d1f7      	bne.n	8009172 <UART_RxISR_8BIT_FIFOEN+0x172>
 8009182:	e74f      	b.n	8009024 <UART_RxISR_8BIT_FIFOEN+0x24>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009184:	e853 2f00 	ldrex	r2, [r3]
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8009188:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800918c:	e843 2100 	strex	r1, r2, [r3]
 8009190:	2900      	cmp	r1, #0
 8009192:	d0cc      	beq.n	800912e <UART_RxISR_8BIT_FIFOEN+0x12e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009194:	e853 2f00 	ldrex	r2, [r3]
 8009198:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800919c:	e843 2100 	strex	r1, r2, [r3]
 80091a0:	2900      	cmp	r1, #0
 80091a2:	d1ef      	bne.n	8009184 <UART_RxISR_8BIT_FIFOEN+0x184>
 80091a4:	e7c3      	b.n	800912e <UART_RxISR_8BIT_FIFOEN+0x12e>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80091a6:	2200      	movs	r2, #0
 80091a8:	66e2      	str	r2, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80091aa:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80091ae:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80091b2:	e843 2100 	strex	r1, r2, [r3]
 80091b6:	2900      	cmp	r1, #0
 80091b8:	d1f7      	bne.n	80091aa <UART_RxISR_8BIT_FIFOEN+0x1aa>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80091ba:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80091bc:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80091c0:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80091c2:	bf44      	itt	mi
 80091c4:	2210      	movmi	r2, #16
 80091c6:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80091c8:	4620      	mov	r0, r4
 80091ca:	f7ff fcc3 	bl	8008b54 <HAL_UARTEx_RxEventCallback>
 80091ce:	e771      	b.n	80090b4 <UART_RxISR_8BIT_FIFOEN+0xb4>
    rxdatacount = huart->RxXferCount;
 80091d0:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80091d4:	e726      	b.n	8009024 <UART_RxISR_8BIT_FIFOEN+0x24>
 80091d6:	bf00      	nop
 80091d8:	effffffe 	.word	0xeffffffe
 80091dc:	40008000 	.word	0x40008000
 80091e0:	08008fbd 	.word	0x08008fbd

080091e4 <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 80091e4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 80091e8:	6803      	ldr	r3, [r0, #0]
  uint16_t  uhMask = huart->Mask;
 80091ea:	f8b0 a060 	ldrh.w	sl, [r0, #96]	@ 0x60
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 80091ee:	69d9      	ldr	r1, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 80091f0:	681e      	ldr	r6, [r3, #0]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 80091f2:	689d      	ldr	r5, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80091f4:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
 80091f8:	2a22      	cmp	r2, #34	@ 0x22
 80091fa:	d005      	beq.n	8009208 <UART_RxISR_16BIT_FIFOEN+0x24>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80091fc:	699a      	ldr	r2, [r3, #24]
 80091fe:	f042 0208 	orr.w	r2, r2, #8
 8009202:	619a      	str	r2, [r3, #24]
  }
}
 8009204:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8009208:	f8b0 2068 	ldrh.w	r2, [r0, #104]	@ 0x68
 800920c:	4683      	mov	fp, r0
 800920e:	2a00      	cmp	r2, #0
 8009210:	f000 80d4 	beq.w	80093bc <UART_RxISR_16BIT_FIFOEN+0x1d8>
 8009214:	0688      	lsls	r0, r1, #26
 8009216:	f140 8085 	bpl.w	8009324 <UART_RxISR_16BIT_FIFOEN+0x140>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800921a:	f8df 91a8 	ldr.w	r9, [pc, #424]	@ 80093c4 <UART_RxISR_16BIT_FIFOEN+0x1e0>
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800921e:	4f6a      	ldr	r7, [pc, #424]	@ (80093c8 <UART_RxISR_16BIT_FIFOEN+0x1e4>)
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8009220:	f406 7680 	and.w	r6, r6, #256	@ 0x100
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8009224:	f005 0501 	and.w	r5, r5, #1
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009228:	f04f 0800 	mov.w	r8, #0
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800922c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 800922e:	f8db 1058 	ldr.w	r1, [fp, #88]	@ 0x58
 8009232:	ea0a 0202 	and.w	r2, sl, r2
 8009236:	f821 2b02 	strh.w	r2, [r1], #2
      huart->RxXferCount--;
 800923a:	f8bb 205e 	ldrh.w	r2, [fp, #94]	@ 0x5e
      huart->pRxBuffPtr += 2U;
 800923e:	f8cb 1058 	str.w	r1, [fp, #88]	@ 0x58
      huart->RxXferCount--;
 8009242:	3a01      	subs	r2, #1
 8009244:	b292      	uxth	r2, r2
 8009246:	f8ab 205e 	strh.w	r2, [fp, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 800924a:	69dc      	ldr	r4, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 800924c:	0761      	lsls	r1, r4, #29
 800924e:	d01b      	beq.n	8009288 <UART_RxISR_16BIT_FIFOEN+0xa4>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8009250:	07e2      	lsls	r2, r4, #31
 8009252:	d508      	bpl.n	8009266 <UART_RxISR_16BIT_FIFOEN+0x82>
 8009254:	b13e      	cbz	r6, 8009266 <UART_RxISR_16BIT_FIFOEN+0x82>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8009256:	2201      	movs	r2, #1
 8009258:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 800925a:	f8db 2090 	ldr.w	r2, [fp, #144]	@ 0x90
 800925e:	f042 0201 	orr.w	r2, r2, #1
 8009262:	f8cb 2090 	str.w	r2, [fp, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8009266:	07a0      	lsls	r0, r4, #30
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8009268:	f004 0204 	and.w	r2, r4, #4
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800926c:	d515      	bpl.n	800929a <UART_RxISR_16BIT_FIFOEN+0xb6>
 800926e:	b145      	cbz	r5, 8009282 <UART_RxISR_16BIT_FIFOEN+0x9e>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8009270:	2102      	movs	r1, #2
 8009272:	6219      	str	r1, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8009274:	f8db 1090 	ldr.w	r1, [fp, #144]	@ 0x90
 8009278:	f041 0104 	orr.w	r1, r1, #4
 800927c:	f8cb 1090 	str.w	r1, [fp, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8009280:	b97a      	cbnz	r2, 80092a2 <UART_RxISR_16BIT_FIFOEN+0xbe>
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8009282:	f8db 3090 	ldr.w	r3, [fp, #144]	@ 0x90
 8009286:	b9c3      	cbnz	r3, 80092ba <UART_RxISR_16BIT_FIFOEN+0xd6>
      if (huart->RxXferCount == 0U)
 8009288:	f8bb 305e 	ldrh.w	r3, [fp, #94]	@ 0x5e
 800928c:	b29b      	uxth	r3, r3
 800928e:	b1f3      	cbz	r3, 80092ce <UART_RxISR_16BIT_FIFOEN+0xea>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8009290:	06a3      	lsls	r3, r4, #26
 8009292:	d547      	bpl.n	8009324 <UART_RxISR_16BIT_FIFOEN+0x140>
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8009294:	f8db 3000 	ldr.w	r3, [fp]
 8009298:	e7c8      	b.n	800922c <UART_RxISR_16BIT_FIFOEN+0x48>
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800929a:	2a00      	cmp	r2, #0
 800929c:	d0f1      	beq.n	8009282 <UART_RxISR_16BIT_FIFOEN+0x9e>
 800929e:	2d00      	cmp	r5, #0
 80092a0:	d0ef      	beq.n	8009282 <UART_RxISR_16BIT_FIFOEN+0x9e>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80092a2:	2204      	movs	r2, #4
 80092a4:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 80092a6:	f8db 3090 	ldr.w	r3, [fp, #144]	@ 0x90
 80092aa:	f043 0302 	orr.w	r3, r3, #2
 80092ae:	f8cb 3090 	str.w	r3, [fp, #144]	@ 0x90
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80092b2:	f8db 3090 	ldr.w	r3, [fp, #144]	@ 0x90
 80092b6:	2b00      	cmp	r3, #0
 80092b8:	d0e6      	beq.n	8009288 <UART_RxISR_16BIT_FIFOEN+0xa4>
          HAL_UART_ErrorCallback(huart);
 80092ba:	4658      	mov	r0, fp
 80092bc:	f7ff fbd4 	bl	8008a68 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80092c0:	f8cb 8090 	str.w	r8, [fp, #144]	@ 0x90
      if (huart->RxXferCount == 0U)
 80092c4:	f8bb 305e 	ldrh.w	r3, [fp, #94]	@ 0x5e
 80092c8:	b29b      	uxth	r3, r3
 80092ca:	2b00      	cmp	r3, #0
 80092cc:	d1e0      	bne.n	8009290 <UART_RxISR_16BIT_FIFOEN+0xac>
 80092ce:	f8db 3000 	ldr.w	r3, [fp]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80092d2:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80092d6:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80092da:	e843 2100 	strex	r1, r2, [r3]
 80092de:	2900      	cmp	r1, #0
 80092e0:	d1f7      	bne.n	80092d2 <UART_RxISR_16BIT_FIFOEN+0xee>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80092e2:	f103 0208 	add.w	r2, r3, #8
 80092e6:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80092ea:	ea02 0209 	and.w	r2, r2, r9
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80092ee:	f103 0008 	add.w	r0, r3, #8
 80092f2:	e840 2100 	strex	r1, r2, [r0]
 80092f6:	2900      	cmp	r1, #0
 80092f8:	d1f3      	bne.n	80092e2 <UART_RxISR_16BIT_FIFOEN+0xfe>
        huart->RxState = HAL_UART_STATE_READY;
 80092fa:	2220      	movs	r2, #32
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 80092fc:	42bb      	cmp	r3, r7
        huart->RxState = HAL_UART_STATE_READY;
 80092fe:	f8cb 208c 	str.w	r2, [fp, #140]	@ 0x8c
        huart->RxISR = NULL;
 8009302:	f8cb 1074 	str.w	r1, [fp, #116]	@ 0x74
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 8009306:	f8cb 1070 	str.w	r1, [fp, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800930a:	d002      	beq.n	8009312 <UART_RxISR_16BIT_FIFOEN+0x12e>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800930c:	685a      	ldr	r2, [r3, #4]
 800930e:	0211      	lsls	r1, r2, #8
 8009310:	d42d      	bmi.n	800936e <UART_RxISR_16BIT_FIFOEN+0x18a>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8009312:	f8db 206c 	ldr.w	r2, [fp, #108]	@ 0x6c
 8009316:	2a01      	cmp	r2, #1
 8009318:	d03a      	beq.n	8009390 <UART_RxISR_16BIT_FIFOEN+0x1ac>
          HAL_UART_RxCpltCallback(huart);
 800931a:	4658      	mov	r0, fp
 800931c:	f7f8 ff68 	bl	80021f0 <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8009320:	06a3      	lsls	r3, r4, #26
 8009322:	d4b7      	bmi.n	8009294 <UART_RxISR_16BIT_FIFOEN+0xb0>
    rxdatacount = huart->RxXferCount;
 8009324:	f8bb 305e 	ldrh.w	r3, [fp, #94]	@ 0x5e
 8009328:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 800932a:	2b00      	cmp	r3, #0
 800932c:	f43f af6a 	beq.w	8009204 <UART_RxISR_16BIT_FIFOEN+0x20>
 8009330:	f8bb 2068 	ldrh.w	r2, [fp, #104]	@ 0x68
 8009334:	429a      	cmp	r2, r3
 8009336:	f67f af65 	bls.w	8009204 <UART_RxISR_16BIT_FIFOEN+0x20>
 800933a:	f8db 3000 	ldr.w	r3, [fp]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800933e:	f103 0208 	add.w	r2, r3, #8
 8009342:	e852 2f00 	ldrex	r2, [r2]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8009346:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800934a:	f103 0008 	add.w	r0, r3, #8
 800934e:	e840 2100 	strex	r1, r2, [r0]
 8009352:	2900      	cmp	r1, #0
 8009354:	d1f3      	bne.n	800933e <UART_RxISR_16BIT_FIFOEN+0x15a>
      huart->RxISR = UART_RxISR_16BIT;
 8009356:	4a1d      	ldr	r2, [pc, #116]	@ (80093cc <UART_RxISR_16BIT_FIFOEN+0x1e8>)
 8009358:	f8cb 2074 	str.w	r2, [fp, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800935c:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8009360:	f042 0220 	orr.w	r2, r2, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009364:	e843 2100 	strex	r1, r2, [r3]
 8009368:	2900      	cmp	r1, #0
 800936a:	d1f7      	bne.n	800935c <UART_RxISR_16BIT_FIFOEN+0x178>
 800936c:	e74a      	b.n	8009204 <UART_RxISR_16BIT_FIFOEN+0x20>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800936e:	e853 2f00 	ldrex	r2, [r3]
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8009372:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009376:	e843 2100 	strex	r1, r2, [r3]
 800937a:	2900      	cmp	r1, #0
 800937c:	d0c9      	beq.n	8009312 <UART_RxISR_16BIT_FIFOEN+0x12e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800937e:	e853 2f00 	ldrex	r2, [r3]
 8009382:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009386:	e843 2100 	strex	r1, r2, [r3]
 800938a:	2900      	cmp	r1, #0
 800938c:	d1ef      	bne.n	800936e <UART_RxISR_16BIT_FIFOEN+0x18a>
 800938e:	e7c0      	b.n	8009312 <UART_RxISR_16BIT_FIFOEN+0x12e>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009390:	2200      	movs	r2, #0
 8009392:	f8cb 206c 	str.w	r2, [fp, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009396:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800939a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800939e:	e843 2100 	strex	r1, r2, [r3]
 80093a2:	2900      	cmp	r1, #0
 80093a4:	d1f7      	bne.n	8009396 <UART_RxISR_16BIT_FIFOEN+0x1b2>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80093a6:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80093a8:	f8bb 105c 	ldrh.w	r1, [fp, #92]	@ 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80093ac:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80093ae:	bf44      	itt	mi
 80093b0:	2210      	movmi	r2, #16
 80093b2:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80093b4:	4658      	mov	r0, fp
 80093b6:	f7ff fbcd 	bl	8008b54 <HAL_UARTEx_RxEventCallback>
 80093ba:	e769      	b.n	8009290 <UART_RxISR_16BIT_FIFOEN+0xac>
    rxdatacount = huart->RxXferCount;
 80093bc:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80093c0:	e720      	b.n	8009204 <UART_RxISR_16BIT_FIFOEN+0x20>
 80093c2:	bf00      	nop
 80093c4:	effffffe 	.word	0xeffffffe
 80093c8:	40008000 	.word	0x40008000
 80093cc:	08008f79 	.word	0x08008f79

080093d0 <UART_SetConfig>:
{
 80093d0:	b570      	push	{r4, r5, r6, lr}
 80093d2:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 80093d4:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80093d6:	6882      	ldr	r2, [r0, #8]
 80093d8:	6900      	ldr	r0, [r0, #16]
 80093da:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80093dc:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80093de:	4302      	orrs	r2, r0
 80093e0:	430a      	orrs	r2, r1
 80093e2:	69e0      	ldr	r0, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80093e4:	4988      	ldr	r1, [pc, #544]	@ (8009608 <UART_SetConfig+0x238>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80093e6:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80093e8:	4029      	ands	r1, r5
 80093ea:	430a      	orrs	r2, r1
 80093ec:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80093ee:	685a      	ldr	r2, [r3, #4]
 80093f0:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80093f2:	6a65      	ldr	r5, [r4, #36]	@ 0x24
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80093f4:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 80093f8:	430a      	orrs	r2, r1
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80093fa:	4984      	ldr	r1, [pc, #528]	@ (800960c <UART_SetConfig+0x23c>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80093fc:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80093fe:	428b      	cmp	r3, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8009400:	6899      	ldr	r1, [r3, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8009402:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8009404:	f021 416e 	bic.w	r1, r1, #3992977408	@ 0xee000000
 8009408:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800940c:	f000 809b 	beq.w	8009546 <UART_SetConfig+0x176>
    tmpreg |= huart->Init.OneBitSampling;
 8009410:	6a26      	ldr	r6, [r4, #32]
 8009412:	4332      	orrs	r2, r6
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8009414:	430a      	orrs	r2, r1
 8009416:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8009418:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800941a:	f022 020f 	bic.w	r2, r2, #15
 800941e:	432a      	orrs	r2, r5
 8009420:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8009422:	4a7b      	ldr	r2, [pc, #492]	@ (8009610 <UART_SetConfig+0x240>)
 8009424:	4293      	cmp	r3, r2
 8009426:	d033      	beq.n	8009490 <UART_SetConfig+0xc0>
 8009428:	4a7a      	ldr	r2, [pc, #488]	@ (8009614 <UART_SetConfig+0x244>)
 800942a:	4293      	cmp	r3, r2
 800942c:	d007      	beq.n	800943e <UART_SetConfig+0x6e>
        ret = HAL_ERROR;
 800942e:	2001      	movs	r0, #1
  huart->RxISR = NULL;
 8009430:	2300      	movs	r3, #0
  huart->NbRxDataToProcess = 1;
 8009432:	f04f 1201 	mov.w	r2, #65537	@ 0x10001
  huart->TxISR = NULL;
 8009436:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
  huart->NbRxDataToProcess = 1;
 800943a:	66a2      	str	r2, [r4, #104]	@ 0x68
}
 800943c:	bd70      	pop	{r4, r5, r6, pc}
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 800943e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8009442:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8009446:	f003 030c 	and.w	r3, r3, #12
 800944a:	f443 2340 	orr.w	r3, r3, #786432	@ 0xc0000
  UART_GETCLOCKSOURCE(huart, clocksource);
 800944e:	f5a3 2340 	sub.w	r3, r3, #786432	@ 0xc0000
 8009452:	2b0c      	cmp	r3, #12
 8009454:	d8eb      	bhi.n	800942e <UART_SetConfig+0x5e>
 8009456:	a201      	add	r2, pc, #4	@ (adr r2, 800945c <UART_SetConfig+0x8c>)
 8009458:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800945c:	080095dd 	.word	0x080095dd
 8009460:	0800942f 	.word	0x0800942f
 8009464:	0800942f 	.word	0x0800942f
 8009468:	0800942f 	.word	0x0800942f
 800946c:	080094c5 	.word	0x080094c5
 8009470:	0800942f 	.word	0x0800942f
 8009474:	0800942f 	.word	0x0800942f
 8009478:	0800942f 	.word	0x0800942f
 800947c:	08009509 	.word	0x08009509
 8009480:	0800942f 	.word	0x0800942f
 8009484:	0800942f 	.word	0x0800942f
 8009488:	0800942f 	.word	0x0800942f
 800948c:	080094d9 	.word	0x080094d9
 8009490:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8009494:	4a60      	ldr	r2, [pc, #384]	@ (8009618 <UART_SetConfig+0x248>)
 8009496:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800949a:	f003 0303 	and.w	r3, r3, #3
 800949e:	f443 3340 	orr.w	r3, r3, #196608	@ 0x30000
 80094a2:	4293      	cmp	r3, r2
 80094a4:	d030      	beq.n	8009508 <UART_SetConfig+0x138>
 80094a6:	f1b3 1f03 	cmp.w	r3, #196611	@ 0x30003
 80094aa:	d015      	beq.n	80094d8 <UART_SetConfig+0x108>
 80094ac:	3a01      	subs	r2, #1
 80094ae:	4293      	cmp	r3, r2
 80094b0:	d008      	beq.n	80094c4 <UART_SetConfig+0xf4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80094b2:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 80094b6:	f000 8097 	beq.w	80095e8 <UART_SetConfig+0x218>
        pclk = HAL_RCC_GetPCLK2Freq();
 80094ba:	f7fe f8f7 	bl	80076ac <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 80094be:	b948      	cbnz	r0, 80094d4 <UART_SetConfig+0x104>
        pclk = (uint32_t) HSI_VALUE;
 80094c0:	2000      	movs	r0, #0
 80094c2:	e7b5      	b.n	8009430 <UART_SetConfig+0x60>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80094c4:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 80094c8:	f000 8095 	beq.w	80095f6 <UART_SetConfig+0x226>
        pclk = HAL_RCC_GetSysClockFreq();
 80094cc:	f7fd fb80 	bl	8006bd0 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 80094d0:	2800      	cmp	r0, #0
 80094d2:	d0f5      	beq.n	80094c0 <UART_SetConfig+0xf0>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80094d4:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 80094d6:	e004      	b.n	80094e2 <UART_SetConfig+0x112>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80094d8:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 80094dc:	d018      	beq.n	8009510 <UART_SetConfig+0x140>
        pclk = (uint32_t) LSE_VALUE;
 80094de:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80094e2:	6863      	ldr	r3, [r4, #4]
 80094e4:	4a4d      	ldr	r2, [pc, #308]	@ (800961c <UART_SetConfig+0x24c>)
 80094e6:	f832 1015 	ldrh.w	r1, [r2, r5, lsl #1]
 80094ea:	fbb0 f0f1 	udiv	r0, r0, r1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80094ee:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80094f2:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80094f6:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80094fa:	f1a0 0310 	sub.w	r3, r0, #16
 80094fe:	4293      	cmp	r3, r2
 8009500:	d895      	bhi.n	800942e <UART_SetConfig+0x5e>
        huart->Instance->BRR = (uint16_t)usartdiv;
 8009502:	6823      	ldr	r3, [r4, #0]
 8009504:	60d8      	str	r0, [r3, #12]
 8009506:	e7db      	b.n	80094c0 <UART_SetConfig+0xf0>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009508:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
        pclk = (uint32_t) HSI_VALUE;
 800950c:	4844      	ldr	r0, [pc, #272]	@ (8009620 <UART_SetConfig+0x250>)
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800950e:	d1e8      	bne.n	80094e2 <UART_SetConfig+0x112>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8009510:	6862      	ldr	r2, [r4, #4]
 8009512:	4b42      	ldr	r3, [pc, #264]	@ (800961c <UART_SetConfig+0x24c>)
 8009514:	f833 1015 	ldrh.w	r1, [r3, r5, lsl #1]
 8009518:	fbb0 f0f1 	udiv	r0, r0, r1
 800951c:	0853      	lsrs	r3, r2, #1
 800951e:	eb03 0340 	add.w	r3, r3, r0, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8009522:	f64f 71ef 	movw	r1, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8009526:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800952a:	f1a3 0210 	sub.w	r2, r3, #16
 800952e:	428a      	cmp	r2, r1
 8009530:	f63f af7d 	bhi.w	800942e <UART_SetConfig+0x5e>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8009534:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
 8009538:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800953a:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800953c:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8009540:	4313      	orrs	r3, r2
 8009542:	60cb      	str	r3, [r1, #12]
 8009544:	e7bc      	b.n	80094c0 <UART_SetConfig+0xf0>
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8009546:	4311      	orrs	r1, r2
 8009548:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800954a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800954c:	f022 020f 	bic.w	r2, r2, #15
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 8009550:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
 8009554:	432a      	orrs	r2, r5
 8009556:	62da      	str	r2, [r3, #44]	@ 0x2c
 8009558:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 800955c:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8009560:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8009564:	d04d      	beq.n	8009602 <UART_SetConfig+0x232>
 8009566:	d82f      	bhi.n	80095c8 <UART_SetConfig+0x1f8>
 8009568:	b3ab      	cbz	r3, 80095d6 <UART_SetConfig+0x206>
 800956a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800956e:	f47f af5e 	bne.w	800942e <UART_SetConfig+0x5e>
        pclk = HAL_RCC_GetSysClockFreq();
 8009572:	f7fd fb2d 	bl	8006bd0 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 8009576:	2800      	cmp	r0, #0
 8009578:	d0a2      	beq.n	80094c0 <UART_SetConfig+0xf0>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800957a:	6a65      	ldr	r5, [r4, #36]	@ 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800957c:	6866      	ldr	r6, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800957e:	4b27      	ldr	r3, [pc, #156]	@ (800961c <UART_SetConfig+0x24c>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8009580:	eb06 0146 	add.w	r1, r6, r6, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8009584:	f833 2015 	ldrh.w	r2, [r3, r5, lsl #1]
 8009588:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800958c:	4299      	cmp	r1, r3
 800958e:	f63f af4e 	bhi.w	800942e <UART_SetConfig+0x5e>
 8009592:	ebb3 3f06 	cmp.w	r3, r6, lsl #12
 8009596:	f63f af4a 	bhi.w	800942e <UART_SetConfig+0x5e>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800959a:	2300      	movs	r3, #0
 800959c:	4619      	mov	r1, r3
 800959e:	f7f7 f9e3 	bl	8000968 <__aeabi_uldivmod>
 80095a2:	0872      	lsrs	r2, r6, #1
 80095a4:	0203      	lsls	r3, r0, #8
 80095a6:	0209      	lsls	r1, r1, #8
 80095a8:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 80095ac:	1898      	adds	r0, r3, r2
 80095ae:	f141 0100 	adc.w	r1, r1, #0
 80095b2:	4632      	mov	r2, r6
 80095b4:	2300      	movs	r3, #0
 80095b6:	f7f7 f9d7 	bl	8000968 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80095ba:	4b1a      	ldr	r3, [pc, #104]	@ (8009624 <UART_SetConfig+0x254>)
 80095bc:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
 80095c0:	429a      	cmp	r2, r3
 80095c2:	f63f af34 	bhi.w	800942e <UART_SetConfig+0x5e>
 80095c6:	e79c      	b.n	8009502 <UART_SetConfig+0x132>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80095c8:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 80095cc:	f47f af2f 	bne.w	800942e <UART_SetConfig+0x5e>
        pclk = (uint32_t) LSE_VALUE;
 80095d0:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 80095d4:	e7d2      	b.n	800957c <UART_SetConfig+0x1ac>
        pclk = HAL_RCC_GetPCLK1Freq();
 80095d6:	f7fd ffdd 	bl	8007594 <HAL_RCC_GetPCLK1Freq>
        break;
 80095da:	e7cc      	b.n	8009576 <UART_SetConfig+0x1a6>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80095dc:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 80095e0:	d00c      	beq.n	80095fc <UART_SetConfig+0x22c>
        pclk = HAL_RCC_GetPCLK1Freq();
 80095e2:	f7fd ffd7 	bl	8007594 <HAL_RCC_GetPCLK1Freq>
        break;
 80095e6:	e76a      	b.n	80094be <UART_SetConfig+0xee>
        pclk = HAL_RCC_GetPCLK2Freq();
 80095e8:	f7fe f860 	bl	80076ac <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 80095ec:	2800      	cmp	r0, #0
 80095ee:	f43f af67 	beq.w	80094c0 <UART_SetConfig+0xf0>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80095f2:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 80095f4:	e78c      	b.n	8009510 <UART_SetConfig+0x140>
        pclk = HAL_RCC_GetSysClockFreq();
 80095f6:	f7fd faeb 	bl	8006bd0 <HAL_RCC_GetSysClockFreq>
        break;
 80095fa:	e7f7      	b.n	80095ec <UART_SetConfig+0x21c>
        pclk = HAL_RCC_GetPCLK1Freq();
 80095fc:	f7fd ffca 	bl	8007594 <HAL_RCC_GetPCLK1Freq>
        break;
 8009600:	e7f4      	b.n	80095ec <UART_SetConfig+0x21c>
        pclk = (uint32_t) HSI_VALUE;
 8009602:	4807      	ldr	r0, [pc, #28]	@ (8009620 <UART_SetConfig+0x250>)
 8009604:	e7ba      	b.n	800957c <UART_SetConfig+0x1ac>
 8009606:	bf00      	nop
 8009608:	cfff69f3 	.word	0xcfff69f3
 800960c:	40008000 	.word	0x40008000
 8009610:	40013800 	.word	0x40013800
 8009614:	40004400 	.word	0x40004400
 8009618:	00030002 	.word	0x00030002
 800961c:	08016b04 	.word	0x08016b04
 8009620:	00f42400 	.word	0x00f42400
 8009624:	000ffcff 	.word	0x000ffcff

08009628 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8009628:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800962a:	07da      	lsls	r2, r3, #31
{
 800962c:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800962e:	d506      	bpl.n	800963e <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8009630:	6801      	ldr	r1, [r0, #0]
 8009632:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 8009634:	684a      	ldr	r2, [r1, #4]
 8009636:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 800963a:	4322      	orrs	r2, r4
 800963c:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800963e:	079c      	lsls	r4, r3, #30
 8009640:	d506      	bpl.n	8009650 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8009642:	6801      	ldr	r1, [r0, #0]
 8009644:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 8009646:	684a      	ldr	r2, [r1, #4]
 8009648:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 800964c:	4322      	orrs	r2, r4
 800964e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8009650:	0759      	lsls	r1, r3, #29
 8009652:	d506      	bpl.n	8009662 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8009654:	6801      	ldr	r1, [r0, #0]
 8009656:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 8009658:	684a      	ldr	r2, [r1, #4]
 800965a:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 800965e:	4322      	orrs	r2, r4
 8009660:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8009662:	071a      	lsls	r2, r3, #28
 8009664:	d506      	bpl.n	8009674 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8009666:	6801      	ldr	r1, [r0, #0]
 8009668:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 800966a:	684a      	ldr	r2, [r1, #4]
 800966c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8009670:	4322      	orrs	r2, r4
 8009672:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8009674:	06dc      	lsls	r4, r3, #27
 8009676:	d506      	bpl.n	8009686 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8009678:	6801      	ldr	r1, [r0, #0]
 800967a:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 800967c:	688a      	ldr	r2, [r1, #8]
 800967e:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8009682:	4322      	orrs	r2, r4
 8009684:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8009686:	0699      	lsls	r1, r3, #26
 8009688:	d506      	bpl.n	8009698 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800968a:	6801      	ldr	r1, [r0, #0]
 800968c:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 800968e:	688a      	ldr	r2, [r1, #8]
 8009690:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8009694:	4322      	orrs	r2, r4
 8009696:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8009698:	065a      	lsls	r2, r3, #25
 800969a:	d509      	bpl.n	80096b0 <UART_AdvFeatureConfig+0x88>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800969c:	6801      	ldr	r1, [r0, #0]
 800969e:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 80096a0:	684a      	ldr	r2, [r1, #4]
 80096a2:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 80096a6:	4322      	orrs	r2, r4
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80096a8:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80096ac:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80096ae:	d00a      	beq.n	80096c6 <UART_AdvFeatureConfig+0x9e>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80096b0:	061b      	lsls	r3, r3, #24
 80096b2:	d506      	bpl.n	80096c2 <UART_AdvFeatureConfig+0x9a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80096b4:	6802      	ldr	r2, [r0, #0]
 80096b6:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 80096b8:	6853      	ldr	r3, [r2, #4]
 80096ba:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 80096be:	430b      	orrs	r3, r1
 80096c0:	6053      	str	r3, [r2, #4]
}
 80096c2:	bc10      	pop	{r4}
 80096c4:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80096c6:	684a      	ldr	r2, [r1, #4]
 80096c8:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 80096ca:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 80096ce:	4322      	orrs	r2, r4
 80096d0:	604a      	str	r2, [r1, #4]
 80096d2:	e7ed      	b.n	80096b0 <UART_AdvFeatureConfig+0x88>

080096d4 <UART_WaitOnFlagUntilTimeout>:
{
 80096d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80096d8:	f8dd 8020 	ldr.w	r8, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80096dc:	6804      	ldr	r4, [r0, #0]
 80096de:	f1b8 3fff 	cmp.w	r8, #4294967295
{
 80096e2:	460d      	mov	r5, r1
 80096e4:	4616      	mov	r6, r2
 80096e6:	d10a      	bne.n	80096fe <UART_WaitOnFlagUntilTimeout+0x2a>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80096e8:	69e3      	ldr	r3, [r4, #28]
 80096ea:	ea35 0303 	bics.w	r3, r5, r3
 80096ee:	bf0c      	ite	eq
 80096f0:	2301      	moveq	r3, #1
 80096f2:	2300      	movne	r3, #0
 80096f4:	429e      	cmp	r6, r3
 80096f6:	d0f7      	beq.n	80096e8 <UART_WaitOnFlagUntilTimeout+0x14>
  return HAL_OK;
 80096f8:	2000      	movs	r0, #0
}
 80096fa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80096fe:	4607      	mov	r7, r0
 8009700:	4699      	mov	r9, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8009702:	69e2      	ldr	r2, [r4, #28]
 8009704:	ea35 0202 	bics.w	r2, r5, r2
 8009708:	bf0c      	ite	eq
 800970a:	2301      	moveq	r3, #1
 800970c:	2300      	movne	r3, #0
 800970e:	42b3      	cmp	r3, r6
 8009710:	d1f2      	bne.n	80096f8 <UART_WaitOnFlagUntilTimeout+0x24>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8009712:	f7f8 fa59 	bl	8001bc8 <HAL_GetTick>
 8009716:	eba0 0009 	sub.w	r0, r0, r9
 800971a:	4540      	cmp	r0, r8
 800971c:	d830      	bhi.n	8009780 <UART_WaitOnFlagUntilTimeout+0xac>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800971e:	683c      	ldr	r4, [r7, #0]
 8009720:	4622      	mov	r2, r4
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8009722:	f1b8 0f00 	cmp.w	r8, #0
 8009726:	d02c      	beq.n	8009782 <UART_WaitOnFlagUntilTimeout+0xae>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8009728:	6823      	ldr	r3, [r4, #0]
 800972a:	0758      	lsls	r0, r3, #29
 800972c:	d5e9      	bpl.n	8009702 <UART_WaitOnFlagUntilTimeout+0x2e>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800972e:	69e3      	ldr	r3, [r4, #28]
 8009730:	0519      	lsls	r1, r3, #20
 8009732:	d5e6      	bpl.n	8009702 <UART_WaitOnFlagUntilTimeout+0x2e>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8009734:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8009738:	6223      	str	r3, [r4, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800973a:	e854 3f00 	ldrex	r3, [r4]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 800973e:	f423 73d0 	bic.w	r3, r3, #416	@ 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009742:	e844 3100 	strex	r1, r3, [r4]
 8009746:	b139      	cbz	r1, 8009758 <UART_WaitOnFlagUntilTimeout+0x84>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009748:	e852 3f00 	ldrex	r3, [r2]
 800974c:	f423 73d0 	bic.w	r3, r3, #416	@ 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009750:	e842 3100 	strex	r1, r3, [r2]
 8009754:	2900      	cmp	r1, #0
 8009756:	d1f7      	bne.n	8009748 <UART_WaitOnFlagUntilTimeout+0x74>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009758:	f102 0308 	add.w	r3, r2, #8
 800975c:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009760:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009764:	f102 0008 	add.w	r0, r2, #8
 8009768:	e840 3100 	strex	r1, r3, [r0]
 800976c:	2900      	cmp	r1, #0
 800976e:	d1f3      	bne.n	8009758 <UART_WaitOnFlagUntilTimeout+0x84>
          huart->gState = HAL_UART_STATE_READY;
 8009770:	2320      	movs	r3, #32
 8009772:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
          huart->RxState = HAL_UART_STATE_READY;
 8009776:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800977a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
          return HAL_TIMEOUT;
 800977e:	e019      	b.n	80097b4 <UART_WaitOnFlagUntilTimeout+0xe0>
 8009780:	683a      	ldr	r2, [r7, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009782:	e852 3f00 	ldrex	r3, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8009786:	f423 73d0 	bic.w	r3, r3, #416	@ 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800978a:	e842 3100 	strex	r1, r3, [r2]
 800978e:	2900      	cmp	r1, #0
 8009790:	d1f7      	bne.n	8009782 <UART_WaitOnFlagUntilTimeout+0xae>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009792:	f102 0308 	add.w	r3, r2, #8
 8009796:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800979a:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800979e:	f102 0008 	add.w	r0, r2, #8
 80097a2:	e840 3100 	strex	r1, r3, [r0]
 80097a6:	2900      	cmp	r1, #0
 80097a8:	d1f3      	bne.n	8009792 <UART_WaitOnFlagUntilTimeout+0xbe>
        huart->gState = HAL_UART_STATE_READY;
 80097aa:	2320      	movs	r3, #32
 80097ac:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        huart->RxState = HAL_UART_STATE_READY;
 80097b0:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
          __HAL_UNLOCK(huart);
 80097b4:	2300      	movs	r3, #0
 80097b6:	f887 3084 	strb.w	r3, [r7, #132]	@ 0x84
        return HAL_TIMEOUT;
 80097ba:	2003      	movs	r0, #3
 80097bc:	e79d      	b.n	80096fa <UART_WaitOnFlagUntilTimeout+0x26>
 80097be:	bf00      	nop

080097c0 <HAL_UART_Init>:
  if (huart == NULL)
 80097c0:	2800      	cmp	r0, #0
 80097c2:	d067      	beq.n	8009894 <HAL_UART_Init+0xd4>
{
 80097c4:	b570      	push	{r4, r5, r6, lr}
  if (huart->gState == HAL_UART_STATE_RESET)
 80097c6:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
 80097ca:	b082      	sub	sp, #8
 80097cc:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 80097ce:	2b00      	cmp	r3, #0
 80097d0:	d04d      	beq.n	800986e <HAL_UART_Init+0xae>
  __HAL_UART_DISABLE(huart);
 80097d2:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80097d4:	2324      	movs	r3, #36	@ 0x24
 80097d6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 80097da:	6813      	ldr	r3, [r2, #0]
 80097dc:	f023 0301 	bic.w	r3, r3, #1
  if (UART_SetConfig(huart) == HAL_ERROR)
 80097e0:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 80097e2:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 80097e4:	f7ff fdf4 	bl	80093d0 <UART_SetConfig>
 80097e8:	2801      	cmp	r0, #1
 80097ea:	d03d      	beq.n	8009868 <HAL_UART_Init+0xa8>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80097ec:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80097ee:	2b00      	cmp	r3, #0
 80097f0:	d136      	bne.n	8009860 <HAL_UART_Init+0xa0>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80097f2:	6823      	ldr	r3, [r4, #0]
 80097f4:	6859      	ldr	r1, [r3, #4]
 80097f6:	f421 4190 	bic.w	r1, r1, #18432	@ 0x4800
 80097fa:	6059      	str	r1, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80097fc:	6899      	ldr	r1, [r3, #8]
 80097fe:	f021 012a 	bic.w	r1, r1, #42	@ 0x2a
 8009802:	6099      	str	r1, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8009804:	6819      	ldr	r1, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009806:	2500      	movs	r5, #0
  __HAL_UART_ENABLE(huart);
 8009808:	f041 0101 	orr.w	r1, r1, #1
 800980c:	6019      	str	r1, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800980e:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
  tickstart = HAL_GetTick();
 8009812:	f7f8 f9d9 	bl	8001bc8 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8009816:	6823      	ldr	r3, [r4, #0]
 8009818:	681a      	ldr	r2, [r3, #0]
 800981a:	0712      	lsls	r2, r2, #28
  tickstart = HAL_GetTick();
 800981c:	4606      	mov	r6, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800981e:	d40f      	bmi.n	8009840 <HAL_UART_Init+0x80>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8009820:	681b      	ldr	r3, [r3, #0]
 8009822:	075b      	lsls	r3, r3, #29
 8009824:	d428      	bmi.n	8009878 <HAL_UART_Init+0xb8>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009826:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 8009828:	2220      	movs	r2, #32
 800982a:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 800982e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
  huart->RxState = HAL_UART_STATE_READY;
 8009832:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
  return HAL_OK;
 8009836:	4618      	mov	r0, r3
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009838:	66e3      	str	r3, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 800983a:	6723      	str	r3, [r4, #112]	@ 0x70
}
 800983c:	b002      	add	sp, #8
 800983e:	bd70      	pop	{r4, r5, r6, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009840:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 8009844:	9300      	str	r3, [sp, #0]
 8009846:	462a      	mov	r2, r5
 8009848:	4603      	mov	r3, r0
 800984a:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 800984e:	4620      	mov	r0, r4
 8009850:	f7ff ff40 	bl	80096d4 <UART_WaitOnFlagUntilTimeout>
 8009854:	b9e0      	cbnz	r0, 8009890 <HAL_UART_Init+0xd0>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8009856:	6823      	ldr	r3, [r4, #0]
 8009858:	681b      	ldr	r3, [r3, #0]
 800985a:	075b      	lsls	r3, r3, #29
 800985c:	d40c      	bmi.n	8009878 <HAL_UART_Init+0xb8>
 800985e:	e7e2      	b.n	8009826 <HAL_UART_Init+0x66>
    UART_AdvFeatureConfig(huart);
 8009860:	4620      	mov	r0, r4
 8009862:	f7ff fee1 	bl	8009628 <UART_AdvFeatureConfig>
 8009866:	e7c4      	b.n	80097f2 <HAL_UART_Init+0x32>
    return HAL_ERROR;
 8009868:	2001      	movs	r0, #1
}
 800986a:	b002      	add	sp, #8
 800986c:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 800986e:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 8009872:	f7f8 fbbd 	bl	8001ff0 <HAL_UART_MspInit>
 8009876:	e7ac      	b.n	80097d2 <HAL_UART_Init+0x12>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009878:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800987c:	9300      	str	r3, [sp, #0]
 800987e:	2200      	movs	r2, #0
 8009880:	4633      	mov	r3, r6
 8009882:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 8009886:	4620      	mov	r0, r4
 8009888:	f7ff ff24 	bl	80096d4 <UART_WaitOnFlagUntilTimeout>
 800988c:	2800      	cmp	r0, #0
 800988e:	d0ca      	beq.n	8009826 <HAL_UART_Init+0x66>
      return HAL_TIMEOUT;
 8009890:	2003      	movs	r0, #3
 8009892:	e7d3      	b.n	800983c <HAL_UART_Init+0x7c>
    return HAL_ERROR;
 8009894:	2001      	movs	r0, #1
}
 8009896:	4770      	bx	lr

08009898 <HAL_UARTEx_WakeupCallback>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8009898:	4770      	bx	lr
 800989a:	bf00      	nop

0800989c <HAL_UARTEx_RxFifoFullCallback>:
/**
  * @brief  UART RX Fifo full callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)
 800989c:	4770      	bx	lr
 800989e:	bf00      	nop

080098a0 <HAL_UARTEx_TxFifoEmptyCallback>:
/**
  * @brief  UART TX Fifo empty callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)
 80098a0:	4770      	bx	lr
 80098a2:	bf00      	nop

080098a4 <HAL_UARTEx_StopModeWakeUpSourceConfig>:
  *          @arg @ref UART_WAKEUP_ON_STARTBIT
  *          @arg @ref UART_WAKEUP_ON_READDATA_NONEMPTY
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
{
 80098a4:	b510      	push	{r4, lr}
 80098a6:	b084      	sub	sp, #16
 80098a8:	ab04      	add	r3, sp, #16
 80098aa:	e903 0006 	stmdb	r3, {r1, r2}
  assert_param(IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance));
  /* check the wake-up selection parameter */
  assert_param(IS_UART_WAKEUP_SELECTION(WakeUpSelection.WakeUpEvent));

  /* Process Locked */
  __HAL_LOCK(huart);
 80098ae:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 80098b2:	2b01      	cmp	r3, #1
 80098b4:	d03b      	beq.n	800992e <HAL_UARTEx_StopModeWakeUpSourceConfig+0x8a>
 80098b6:	4604      	mov	r4, r0

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 80098b8:	6803      	ldr	r3, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80098ba:	2224      	movs	r2, #36	@ 0x24
  __HAL_LOCK(huart);
 80098bc:	2001      	movs	r0, #1
 80098be:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 80098c2:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 80098c6:	681a      	ldr	r2, [r3, #0]
 80098c8:	f022 0201 	bic.w	r2, r2, #1
 80098cc:	601a      	str	r2, [r3, #0]

  /* Set the wake-up selection scheme */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
 80098ce:	689a      	ldr	r2, [r3, #8]
 80098d0:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 80098d4:	430a      	orrs	r2, r1
 80098d6:	609a      	str	r2, [r3, #8]

  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
 80098d8:	b971      	cbnz	r1, 80098f8 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x54>
static void UARTEx_Wakeup_AddressConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
{
  assert_param(IS_UART_ADDRESSLENGTH_DETECT(WakeUpSelection.AddressLength));

  /* Set the USART address length */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 80098da:	685a      	ldr	r2, [r3, #4]
 80098dc:	f8bd 100c 	ldrh.w	r1, [sp, #12]
 80098e0:	f022 0210 	bic.w	r2, r2, #16
 80098e4:	430a      	orrs	r2, r1
 80098e6:	605a      	str	r2, [r3, #4]

  /* Set the USART address node */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
 80098e8:	685a      	ldr	r2, [r3, #4]
 80098ea:	f89d 100e 	ldrb.w	r1, [sp, #14]
 80098ee:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
 80098f2:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 80098f6:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
 80098f8:	681a      	ldr	r2, [r3, #0]
 80098fa:	f042 0201 	orr.w	r2, r2, #1
 80098fe:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8009900:	f7f8 f962 	bl	8001bc8 <HAL_GetTick>
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009904:	f06f 427e 	mvn.w	r2, #4261412864	@ 0xfe000000
  tickstart = HAL_GetTick();
 8009908:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800990a:	9200      	str	r2, [sp, #0]
 800990c:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 8009910:	2200      	movs	r2, #0
 8009912:	4620      	mov	r0, r4
 8009914:	f7ff fede 	bl	80096d4 <UART_WaitOnFlagUntilTimeout>
 8009918:	b938      	cbnz	r0, 800992a <HAL_UARTEx_StopModeWakeUpSourceConfig+0x86>
    huart->gState = HAL_UART_STATE_READY;
 800991a:	2320      	movs	r3, #32
 800991c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 8009920:	2300      	movs	r3, #0
 8009922:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 8009926:	b004      	add	sp, #16
 8009928:	bd10      	pop	{r4, pc}
    status = HAL_TIMEOUT;
 800992a:	2003      	movs	r0, #3
 800992c:	e7f8      	b.n	8009920 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7c>
  __HAL_LOCK(huart);
 800992e:	2002      	movs	r0, #2
}
 8009930:	b004      	add	sp, #16
 8009932:	bd10      	pop	{r4, pc}

08009934 <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
 8009934:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8009938:	2b01      	cmp	r3, #1
 800993a:	d00f      	beq.n	800995c <HAL_UARTEx_EnableStopMode+0x28>
 800993c:	2301      	movs	r3, #1
 800993e:	6801      	ldr	r1, [r0, #0]
 8009940:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009944:	e851 3f00 	ldrex	r3, [r1]
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
 8009948:	f043 0302 	orr.w	r3, r3, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800994c:	e841 3200 	strex	r2, r3, [r1]
 8009950:	2a00      	cmp	r2, #0
 8009952:	d1f7      	bne.n	8009944 <HAL_UARTEx_EnableStopMode+0x10>
  __HAL_UNLOCK(huart);
 8009954:	f880 2084 	strb.w	r2, [r0, #132]	@ 0x84
  return HAL_OK;
 8009958:	4610      	mov	r0, r2
 800995a:	4770      	bx	lr
  __HAL_LOCK(huart);
 800995c:	2002      	movs	r0, #2
}
 800995e:	4770      	bx	lr

08009960 <HAL_UARTEx_DisableFifoMode>:
  __HAL_LOCK(huart);
 8009960:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8009964:	2b01      	cmp	r3, #1
 8009966:	d016      	beq.n	8009996 <HAL_UARTEx_DisableFifoMode+0x36>
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8009968:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800996a:	2324      	movs	r3, #36	@ 0x24
{
 800996c:	b410      	push	{r4}
  huart->gState = HAL_UART_STATE_BUSY;
 800996e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8009972:	6811      	ldr	r1, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8009974:	6814      	ldr	r4, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8009976:	2300      	movs	r3, #0
  __HAL_UART_DISABLE(huart);
 8009978:	f024 0401 	bic.w	r4, r4, #1
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 800997c:	f021 5100 	bic.w	r1, r1, #536870912	@ 0x20000000
  __HAL_UART_DISABLE(huart);
 8009980:	6014      	str	r4, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8009982:	6643      	str	r3, [r0, #100]	@ 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8009984:	6011      	str	r1, [r2, #0]
  __HAL_UNLOCK(huart);
 8009986:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_READY;
 800998a:	2220      	movs	r2, #32
 800998c:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
}
 8009990:	bc10      	pop	{r4}
  return HAL_OK;
 8009992:	4618      	mov	r0, r3
}
 8009994:	4770      	bx	lr
  __HAL_LOCK(huart);
 8009996:	2002      	movs	r0, #2
}
 8009998:	4770      	bx	lr
 800999a:	bf00      	nop

0800999c <HAL_UARTEx_SetTxFifoThreshold>:
  __HAL_LOCK(huart);
 800999c:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
 80099a0:	2a01      	cmp	r2, #1
 80099a2:	d037      	beq.n	8009a14 <HAL_UARTEx_SetTxFifoThreshold+0x78>
  huart->gState = HAL_UART_STATE_BUSY;
 80099a4:	4603      	mov	r3, r0
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80099a6:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80099a8:	2024      	movs	r0, #36	@ 0x24
{
 80099aa:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 80099ac:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80099b0:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 80099b2:	6810      	ldr	r0, [r2, #0]
 80099b4:	f020 0001 	bic.w	r0, r0, #1
 80099b8:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80099ba:	6890      	ldr	r0, [r2, #8]
 80099bc:	f020 4060 	bic.w	r0, r0, #3758096384	@ 0xe0000000
 80099c0:	4301      	orrs	r1, r0
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80099c2:	6e58      	ldr	r0, [r3, #100]	@ 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80099c4:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80099c6:	b310      	cbz	r0, 8009a0e <HAL_UARTEx_SetTxFifoThreshold+0x72>
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80099c8:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80099ca:	6890      	ldr	r0, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
 80099cc:	4d12      	ldr	r5, [pc, #72]	@ (8009a18 <HAL_UARTEx_SetTxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80099ce:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80099d2:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80099d6:	4911      	ldr	r1, [pc, #68]	@ (8009a1c <HAL_UARTEx_SetTxFifoThreshold+0x80>)
 80099d8:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80099dc:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 80099e0:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 80099e4:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80099e8:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80099ea:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80099ec:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80099f0:	fbb1 f1f5 	udiv	r1, r1, r5
 80099f4:	f8a3 1068 	strh.w	r1, [r3, #104]	@ 0x68
  __HAL_UNLOCK(huart);
 80099f8:	2100      	movs	r1, #0
 80099fa:	f8a3 006a 	strh.w	r0, [r3, #106]	@ 0x6a
  huart->gState = HAL_UART_STATE_READY;
 80099fe:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8009a00:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 8009a02:	f883 1084 	strb.w	r1, [r3, #132]	@ 0x84
  return HAL_OK;
 8009a06:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8009a08:	f8c3 5088 	str.w	r5, [r3, #136]	@ 0x88
}
 8009a0c:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8009a0e:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8009a10:	4608      	mov	r0, r1
 8009a12:	e7ef      	b.n	80099f4 <HAL_UARTEx_SetTxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8009a14:	2002      	movs	r0, #2
}
 8009a16:	4770      	bx	lr
 8009a18:	08016b1c 	.word	0x08016b1c
 8009a1c:	08016b24 	.word	0x08016b24

08009a20 <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
 8009a20:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
 8009a24:	2a01      	cmp	r2, #1
 8009a26:	d037      	beq.n	8009a98 <HAL_UARTEx_SetRxFifoThreshold+0x78>
  huart->gState = HAL_UART_STATE_BUSY;
 8009a28:	4603      	mov	r3, r0
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8009a2a:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8009a2c:	2024      	movs	r0, #36	@ 0x24
{
 8009a2e:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8009a30:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8009a34:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8009a36:	6810      	ldr	r0, [r2, #0]
 8009a38:	f020 0001 	bic.w	r0, r0, #1
 8009a3c:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8009a3e:	6890      	ldr	r0, [r2, #8]
 8009a40:	f020 6060 	bic.w	r0, r0, #234881024	@ 0xe000000
 8009a44:	4301      	orrs	r1, r0
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8009a46:	6e58      	ldr	r0, [r3, #100]	@ 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8009a48:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8009a4a:	b310      	cbz	r0, 8009a92 <HAL_UARTEx_SetRxFifoThreshold+0x72>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8009a4c:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8009a4e:	6890      	ldr	r0, [r2, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
 8009a50:	4d12      	ldr	r5, [pc, #72]	@ (8009a9c <HAL_UARTEx_SetRxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8009a52:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8009a56:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8009a5a:	4911      	ldr	r1, [pc, #68]	@ (8009aa0 <HAL_UARTEx_SetRxFifoThreshold+0x80>)
 8009a5c:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8009a60:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8009a64:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 8009a68:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8009a6c:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8009a6e:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8009a70:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8009a74:	fbb1 f1f5 	udiv	r1, r1, r5
 8009a78:	f8a3 1068 	strh.w	r1, [r3, #104]	@ 0x68
  __HAL_UNLOCK(huart);
 8009a7c:	2100      	movs	r1, #0
 8009a7e:	f8a3 006a 	strh.w	r0, [r3, #106]	@ 0x6a
  huart->gState = HAL_UART_STATE_READY;
 8009a82:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8009a84:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 8009a86:	f883 1084 	strb.w	r1, [r3, #132]	@ 0x84
  return HAL_OK;
 8009a8a:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8009a8c:	f8c3 5088 	str.w	r5, [r3, #136]	@ 0x88
}
 8009a90:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8009a92:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8009a94:	4608      	mov	r0, r1
 8009a96:	e7ef      	b.n	8009a78 <HAL_UARTEx_SetRxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8009a98:	2002      	movs	r0, #2
}
 8009a9a:	4770      	bx	lr
 8009a9c:	08016b1c 	.word	0x08016b1c
 8009aa0:	08016b24 	.word	0x08016b24

08009aa4 <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 8009aa4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 8009aa6:	f7f7 ffdf 	bl	8001a68 <SystemApp_Init>
  /* USER CODE END MX_LoRaWAN_Init_2 */
  LoRaWAN_Init();
  /* USER CODE BEGIN MX_LoRaWAN_Init_3 */

  /* USER CODE END MX_LoRaWAN_Init_3 */
}
 8009aaa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LoRaWAN_Init();
 8009aae:	f000 ba5f 	b.w	8009f70 <LoRaWAN_Init>
 8009ab2:	bf00      	nop

08009ab4 <MX_LoRaWAN_Process>:
void MX_LoRaWAN_Process(void)
{
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 8009ab4:	f04f 30ff 	mov.w	r0, #4294967295
 8009ab8:	f00b bcbc 	b.w	8015434 <UTIL_SEQ_Run>

08009abc <OnSysTimeUpdate>:
static void OnSysTimeUpdate(void)
{
  /* USER CODE BEGIN OnSysTimeUpdate_1 */

  /* USER CODE END OnSysTimeUpdate_1 */
}
 8009abc:	4770      	bx	lr
 8009abe:	bf00      	nop

08009ac0 <OnTxFrameCtrlChanged>:
static void OnTxFrameCtrlChanged(LmHandlerMsgTypes_t isTxConfirmed)
{
  /* USER CODE BEGIN OnTxFrameCtrlChanged_1 */

  /* USER CODE END OnTxFrameCtrlChanged_1 */
  LmHandlerParams.IsTxConfirmed = isTxConfirmed;
 8009ac0:	4b01      	ldr	r3, [pc, #4]	@ (8009ac8 <OnTxFrameCtrlChanged+0x8>)
 8009ac2:	70d8      	strb	r0, [r3, #3]
  /* USER CODE BEGIN OnTxFrameCtrlChanged_2 */

  /* USER CODE END OnTxFrameCtrlChanged_2 */
}
 8009ac4:	4770      	bx	lr
 8009ac6:	bf00      	nop
 8009ac8:	20000018 	.word	0x20000018

08009acc <OnPingSlotPeriodicityChanged>:
static void OnPingSlotPeriodicityChanged(uint8_t pingSlotPeriodicity)
{
  /* USER CODE BEGIN OnPingSlotPeriodicityChanged_1 */

  /* USER CODE END OnPingSlotPeriodicityChanged_1 */
  LmHandlerParams.PingSlotPeriodicity = pingSlotPeriodicity;
 8009acc:	4b01      	ldr	r3, [pc, #4]	@ (8009ad4 <OnPingSlotPeriodicityChanged+0x8>)
 8009ace:	7418      	strb	r0, [r3, #16]
  /* USER CODE BEGIN OnPingSlotPeriodicityChanged_2 */

  /* USER CODE END OnPingSlotPeriodicityChanged_2 */
}
 8009ad0:	4770      	bx	lr
 8009ad2:	bf00      	nop
 8009ad4:	20000018 	.word	0x20000018

08009ad8 <OnTxTimerEvent>:
{
 8009ad8:	b508      	push	{r3, lr}
  UpdateLoRaWANPayload(radio_payload_buffer);
 8009ada:	4807      	ldr	r0, [pc, #28]	@ (8009af8 <OnTxTimerEvent+0x20>)
 8009adc:	f7f7 fcd8 	bl	8001490 <UpdateLoRaWANPayload>
  printf("We have correctly update \r\n\n");
 8009ae0:	4806      	ldr	r0, [pc, #24]	@ (8009afc <OnTxTimerEvent+0x24>)
 8009ae2:	f00c fa11 	bl	8015f08 <puts>
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
 8009ae6:	2002      	movs	r0, #2
 8009ae8:	2100      	movs	r1, #0
 8009aea:	f00b fc8b 	bl	8015404 <UTIL_SEQ_SetTask>
}
 8009aee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UTIL_TIMER_Start(&TxTimer);
 8009af2:	4803      	ldr	r0, [pc, #12]	@ (8009b00 <OnTxTimerEvent+0x28>)
 8009af4:	f00b bde8 	b.w	80156c8 <UTIL_TIMER_Start>
 8009af8:	20000450 	.word	0x20000450
 8009afc:	08016b2c 	.word	0x08016b2c
 8009b00:	200004a8 	.word	0x200004a8

08009b04 <OnMacProcessNotify>:
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LmHandlerProcess), CFG_SEQ_Prio_0);
 8009b04:	2100      	movs	r1, #0
 8009b06:	2001      	movs	r0, #1
 8009b08:	f00b bc7c 	b.w	8015404 <UTIL_SEQ_SetTask>

08009b0c <OnTxPeriodicityChanged>:
{
 8009b0c:	b510      	push	{r4, lr}
 8009b0e:	f242 7310 	movw	r3, #10000	@ 0x2710
  TxPeriodicity = periodicity;
 8009b12:	4c08      	ldr	r4, [pc, #32]	@ (8009b34 <OnTxPeriodicityChanged+0x28>)
 8009b14:	2800      	cmp	r0, #0
 8009b16:	bf18      	it	ne
 8009b18:	4603      	movne	r3, r0
  UTIL_TIMER_Stop(&TxTimer);
 8009b1a:	4807      	ldr	r0, [pc, #28]	@ (8009b38 <OnTxPeriodicityChanged+0x2c>)
  TxPeriodicity = periodicity;
 8009b1c:	6023      	str	r3, [r4, #0]
  UTIL_TIMER_Stop(&TxTimer);
 8009b1e:	f00b fde5 	bl	80156ec <UTIL_TIMER_Stop>
  UTIL_TIMER_SetPeriod(&TxTimer, TxPeriodicity);
 8009b22:	6821      	ldr	r1, [r4, #0]
 8009b24:	4804      	ldr	r0, [pc, #16]	@ (8009b38 <OnTxPeriodicityChanged+0x2c>)
 8009b26:	f00b fe2b 	bl	8015780 <UTIL_TIMER_SetPeriod>
}
 8009b2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  UTIL_TIMER_Start(&TxTimer);
 8009b2e:	4802      	ldr	r0, [pc, #8]	@ (8009b38 <OnTxPeriodicityChanged+0x2c>)
 8009b30:	f00b bdca 	b.w	80156c8 <UTIL_TIMER_Start>
 8009b34:	20000014 	.word	0x20000014
 8009b38:	200004a8 	.word	0x200004a8

08009b3c <OnClassChange>:
{
 8009b3c:	b500      	push	{lr}
  APP_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8009b3e:	4b06      	ldr	r3, [pc, #24]	@ (8009b58 <OnClassChange+0x1c>)
{
 8009b40:	b083      	sub	sp, #12
  APP_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8009b42:	5c19      	ldrb	r1, [r3, r0]
 8009b44:	9100      	str	r1, [sp, #0]
 8009b46:	2200      	movs	r2, #0
 8009b48:	4b04      	ldr	r3, [pc, #16]	@ (8009b5c <OnClassChange+0x20>)
 8009b4a:	4611      	mov	r1, r2
 8009b4c:	2002      	movs	r0, #2
 8009b4e:	f00b ff51 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 8009b52:	b003      	add	sp, #12
 8009b54:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b58:	08016b64 	.word	0x08016b64
 8009b5c:	08016b48 	.word	0x08016b48

08009b60 <OnJoinRequest>:
  if (joinParams != NULL)
 8009b60:	b350      	cbz	r0, 8009bb8 <OnJoinRequest+0x58>
{
 8009b62:	b530      	push	{r4, r5, lr}
    if (joinParams->Status == LORAMAC_HANDLER_SUCCESS)
 8009b64:	f990 5006 	ldrsb.w	r5, [r0, #6]
{
 8009b68:	b083      	sub	sp, #12
 8009b6a:	4604      	mov	r4, r0
    if (joinParams->Status == LORAMAC_HANDLER_SUCCESS)
 8009b6c:	b19d      	cbz	r5, 8009b96 <OnJoinRequest+0x36>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 8009b6e:	2200      	movs	r2, #0
 8009b70:	4b12      	ldr	r3, [pc, #72]	@ (8009bbc <OnJoinRequest+0x5c>)
 8009b72:	4611      	mov	r1, r2
 8009b74:	2002      	movs	r0, #2
 8009b76:	f00b ff3d 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_H, "###### U/L FRAME:JOIN | DR:%d | PWR:%d\r\n", joinParams->Datarate, joinParams->TxPower);
 8009b7a:	f994 0005 	ldrsb.w	r0, [r4, #5]
 8009b7e:	f994 1004 	ldrsb.w	r1, [r4, #4]
 8009b82:	4b0f      	ldr	r3, [pc, #60]	@ (8009bc0 <OnJoinRequest+0x60>)
 8009b84:	2200      	movs	r2, #0
 8009b86:	e9cd 1000 	strd	r1, r0, [sp]
 8009b8a:	4611      	mov	r1, r2
 8009b8c:	2003      	movs	r0, #3
 8009b8e:	f00b ff31 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 8009b92:	b003      	add	sp, #12
 8009b94:	bd30      	pop	{r4, r5, pc}
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOINED = ");
 8009b96:	462a      	mov	r2, r5
 8009b98:	4629      	mov	r1, r5
 8009b9a:	4b0a      	ldr	r3, [pc, #40]	@ (8009bc4 <OnJoinRequest+0x64>)
 8009b9c:	2002      	movs	r0, #2
 8009b9e:	f00b ff29 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
      if (joinParams->Mode == ACTIVATION_TYPE_ABP)
 8009ba2:	79e3      	ldrb	r3, [r4, #7]
 8009ba4:	2b01      	cmp	r3, #1
        APP_LOG(TS_OFF, VLEVEL_M, "ABP ======================\r\n");
 8009ba6:	bf0c      	ite	eq
 8009ba8:	4b07      	ldreq	r3, [pc, #28]	@ (8009bc8 <OnJoinRequest+0x68>)
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 8009baa:	4b08      	ldrne	r3, [pc, #32]	@ (8009bcc <OnJoinRequest+0x6c>)
 8009bac:	462a      	mov	r2, r5
 8009bae:	4629      	mov	r1, r5
 8009bb0:	2002      	movs	r0, #2
 8009bb2:	f00b ff1f 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 8009bb6:	e7e0      	b.n	8009b7a <OnJoinRequest+0x1a>
 8009bb8:	4770      	bx	lr
 8009bba:	bf00      	nop
 8009bbc:	08016bc0 	.word	0x08016bc0
 8009bc0:	08016bdc 	.word	0x08016bdc
 8009bc4:	08016b68 	.word	0x08016b68
 8009bc8:	08016b80 	.word	0x08016b80
 8009bcc:	08016ba0 	.word	0x08016ba0

08009bd0 <OnRestoreContextRequest>:

  /* USER CODE END OnStoreContextRequest_Last */
}

static void OnRestoreContextRequest(void *nvm, uint32_t nvm_size)
{
 8009bd0:	460a      	mov	r2, r1
  /* USER CODE BEGIN OnRestoreContextRequest_1 */

  /* USER CODE END OnRestoreContextRequest_1 */
  FLASH_IF_Read(nvm, LORAWAN_NVM_BASE_ADDRESS, nvm_size);
 8009bd2:	4901      	ldr	r1, [pc, #4]	@ (8009bd8 <OnRestoreContextRequest+0x8>)
 8009bd4:	f7f7 baaa 	b.w	800112c <FLASH_IF_Read>
 8009bd8:	0803f000 	.word	0x0803f000

08009bdc <StopJoin>:
{
 8009bdc:	b538      	push	{r3, r4, r5, lr}
  UTIL_TIMER_Stop(&TxTimer);
 8009bde:	4818      	ldr	r0, [pc, #96]	@ (8009c40 <StopJoin+0x64>)
 8009be0:	f00b fd84 	bl	80156ec <UTIL_TIMER_Stop>
  if (LORAMAC_HANDLER_SUCCESS != LmHandlerStop())
 8009be4:	f002 fb82 	bl	800c2ec <LmHandlerStop>
 8009be8:	b150      	cbz	r0, 8009c00 <StopJoin+0x24>
    APP_LOG(TS_OFF, VLEVEL_M, "LmHandler Stop on going ...\r\n");
 8009bea:	2200      	movs	r2, #0
 8009bec:	4b15      	ldr	r3, [pc, #84]	@ (8009c44 <StopJoin+0x68>)
 8009bee:	4611      	mov	r1, r2
 8009bf0:	2002      	movs	r0, #2
 8009bf2:	f00b feff 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 8009bf6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  UTIL_TIMER_Start(&StopJoinTimer);
 8009bfa:	4813      	ldr	r0, [pc, #76]	@ (8009c48 <StopJoin+0x6c>)
 8009bfc:	f00b bd64 	b.w	80156c8 <UTIL_TIMER_Start>
    APP_LOG(TS_OFF, VLEVEL_M, "LmHandler Stopped\r\n");
 8009c00:	4604      	mov	r4, r0
 8009c02:	4602      	mov	r2, r0
 8009c04:	4601      	mov	r1, r0
 8009c06:	4b11      	ldr	r3, [pc, #68]	@ (8009c4c <StopJoin+0x70>)
      ActivationType = ACTIVATION_TYPE_ABP;
 8009c08:	4d11      	ldr	r5, [pc, #68]	@ (8009c50 <StopJoin+0x74>)
    APP_LOG(TS_OFF, VLEVEL_M, "LmHandler Stopped\r\n");
 8009c0a:	2002      	movs	r0, #2
 8009c0c:	f00b fef2 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_M, "LmHandler switch to ABP mode\r\n");
 8009c10:	4622      	mov	r2, r4
 8009c12:	4b10      	ldr	r3, [pc, #64]	@ (8009c54 <StopJoin+0x78>)
 8009c14:	4611      	mov	r1, r2
      ActivationType = ACTIVATION_TYPE_ABP;
 8009c16:	2401      	movs	r4, #1
      APP_LOG(TS_OFF, VLEVEL_M, "LmHandler switch to ABP mode\r\n");
 8009c18:	2002      	movs	r0, #2
      ActivationType = ACTIVATION_TYPE_ABP;
 8009c1a:	702c      	strb	r4, [r5, #0]
      APP_LOG(TS_OFF, VLEVEL_M, "LmHandler switch to ABP mode\r\n");
 8009c1c:	f00b feea 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
    LmHandlerConfigure(&LmHandlerParams);
 8009c20:	480d      	ldr	r0, [pc, #52]	@ (8009c58 <StopJoin+0x7c>)
 8009c22:	f002 fa4b 	bl	800c0bc <LmHandlerConfigure>
    LmHandlerJoin(ActivationType, true);
 8009c26:	7828      	ldrb	r0, [r5, #0]
 8009c28:	4621      	mov	r1, r4
 8009c2a:	f001 ff9f 	bl	800bb6c <LmHandlerJoin>
    UTIL_TIMER_Start(&TxTimer);
 8009c2e:	4804      	ldr	r0, [pc, #16]	@ (8009c40 <StopJoin+0x64>)
 8009c30:	f00b fd4a 	bl	80156c8 <UTIL_TIMER_Start>
}
 8009c34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  UTIL_TIMER_Start(&StopJoinTimer);
 8009c38:	4803      	ldr	r0, [pc, #12]	@ (8009c48 <StopJoin+0x6c>)
 8009c3a:	f00b bd45 	b.w	80156c8 <UTIL_TIMER_Start>
 8009c3e:	bf00      	nop
 8009c40:	200004a8 	.word	0x200004a8
 8009c44:	08016c08 	.word	0x08016c08
 8009c48:	20000490 	.word	0x20000490
 8009c4c:	08016c28 	.word	0x08016c28
 8009c50:	2000007c 	.word	0x2000007c
 8009c54:	08016c3c 	.word	0x08016c3c
 8009c58:	20000018 	.word	0x20000018

08009c5c <SendTxData>:
{
 8009c5c:	b530      	push	{r4, r5, lr}
	debug_print("SendTxData\r\n");
 8009c5e:	481e      	ldr	r0, [pc, #120]	@ (8009cd8 <SendTxData+0x7c>)
{
 8009c60:	b083      	sub	sp, #12
	debug_print("SendTxData\r\n");
 8009c62:	f7f7 fc13 	bl	800148c <debug_print>
	if (LmHandlerIsBusy() == false)
 8009c66:	f002 fab9 	bl	800c1dc <LmHandlerIsBusy>
 8009c6a:	b190      	cbz	r0, 8009c92 <SendTxData+0x36>
	UTIL_TIMER_Time_t nextTxIn = 0;
 8009c6c:	2500      	movs	r5, #0
	    UTIL_TIMER_Stop(&TxTimer);
 8009c6e:	481b      	ldr	r0, [pc, #108]	@ (8009cdc <SendTxData+0x80>)
 8009c70:	f00b fd3c 	bl	80156ec <UTIL_TIMER_Stop>
	    UTIL_TIMER_SetPeriod(&TxTimer, MAX(nextTxIn, TxPeriodicity));
 8009c74:	4b1a      	ldr	r3, [pc, #104]	@ (8009ce0 <SendTxData+0x84>)
 8009c76:	4819      	ldr	r0, [pc, #100]	@ (8009cdc <SendTxData+0x80>)
 8009c78:	681b      	ldr	r3, [r3, #0]
 8009c7a:	429d      	cmp	r5, r3
 8009c7c:	4629      	mov	r1, r5
 8009c7e:	bf38      	it	cc
 8009c80:	4619      	movcc	r1, r3
 8009c82:	f00b fd7d 	bl	8015780 <UTIL_TIMER_SetPeriod>
	    UTIL_TIMER_Start(&TxTimer);
 8009c86:	4815      	ldr	r0, [pc, #84]	@ (8009cdc <SendTxData+0x80>)
}
 8009c88:	b003      	add	sp, #12
 8009c8a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	    UTIL_TIMER_Start(&TxTimer);
 8009c8e:	f00b bd1b 	b.w	80156c8 <UTIL_TIMER_Start>
		status = LmHandlerSend(&AppData, LmHandlerParams.IsTxConfirmed, false);
 8009c92:	4b14      	ldr	r3, [pc, #80]	@ (8009ce4 <SendTxData+0x88>)
 8009c94:	4604      	mov	r4, r0
 8009c96:	78d9      	ldrb	r1, [r3, #3]
 8009c98:	4813      	ldr	r0, [pc, #76]	@ (8009ce8 <SendTxData+0x8c>)
 8009c9a:	4622      	mov	r2, r4
 8009c9c:	f001 ffe2 	bl	800bc64 <LmHandlerSend>
		if (LORAMAC_HANDLER_SUCCESS == status)
 8009ca0:	b190      	cbz	r0, 8009cc8 <SendTxData+0x6c>
		else if (LORAMAC_HANDLER_DUTYCYCLE_RESTRICTED == status)
 8009ca2:	3006      	adds	r0, #6
 8009ca4:	d1e2      	bne.n	8009c6c <SendTxData+0x10>
			nextTxIn = LmHandlerGetDutyCycleWaitTime();
 8009ca6:	f002 fb05 	bl	800c2b4 <LmHandlerGetDutyCycleWaitTime>
			if (nextTxIn > 0)
 8009caa:	4605      	mov	r5, r0
 8009cac:	2800      	cmp	r0, #0
 8009cae:	d0dd      	beq.n	8009c6c <SendTxData+0x10>
				APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 8009cb0:	490e      	ldr	r1, [pc, #56]	@ (8009cec <SendTxData+0x90>)
 8009cb2:	fba1 3100 	umull	r3, r1, r1, r0
 8009cb6:	2201      	movs	r2, #1
 8009cb8:	0989      	lsrs	r1, r1, #6
 8009cba:	9100      	str	r1, [sp, #0]
 8009cbc:	4b0c      	ldr	r3, [pc, #48]	@ (8009cf0 <SendTxData+0x94>)
 8009cbe:	4621      	mov	r1, r4
 8009cc0:	4610      	mov	r0, r2
 8009cc2:	f00b fe97 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 8009cc6:	e7d2      	b.n	8009c6e <SendTxData+0x12>
			APP_LOG(TS_ON, VLEVEL_L, "SEND REQUEST\r\n");
 8009cc8:	2201      	movs	r2, #1
 8009cca:	4601      	mov	r1, r0
 8009ccc:	4b09      	ldr	r3, [pc, #36]	@ (8009cf4 <SendTxData+0x98>)
 8009cce:	4610      	mov	r0, r2
 8009cd0:	f00b fe90 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 8009cd4:	e7ca      	b.n	8009c6c <SendTxData+0x10>
 8009cd6:	bf00      	nop
 8009cd8:	08016c5c 	.word	0x08016c5c
 8009cdc:	200004a8 	.word	0x200004a8
 8009ce0:	20000014 	.word	0x20000014
 8009ce4:	20000018 	.word	0x20000018
 8009ce8:	2000000c 	.word	0x2000000c
 8009cec:	10624dd3 	.word	0x10624dd3
 8009cf0:	08016c7c 	.word	0x08016c7c
 8009cf4:	08016c6c 	.word	0x08016c6c

08009cf8 <OnStopJoinTimerEvent>:
  if (ActivationType == LORAWAN_DEFAULT_ACTIVATION_TYPE)
 8009cf8:	4b04      	ldr	r3, [pc, #16]	@ (8009d0c <OnStopJoinTimerEvent+0x14>)
 8009cfa:	781b      	ldrb	r3, [r3, #0]
 8009cfc:	2b02      	cmp	r3, #2
 8009cfe:	d000      	beq.n	8009d02 <OnStopJoinTimerEvent+0xa>
}
 8009d00:	4770      	bx	lr
    UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaStopJoinEvent), CFG_SEQ_Prio_0);
 8009d02:	2100      	movs	r1, #0
 8009d04:	2008      	movs	r0, #8
 8009d06:	f00b bb7d 	b.w	8015404 <UTIL_SEQ_SetTask>
 8009d0a:	bf00      	nop
 8009d0c:	2000007c 	.word	0x2000007c

08009d10 <OnSystemReset>:
{
 8009d10:	b508      	push	{r3, lr}
  if ((LORAMAC_HANDLER_SUCCESS == LmHandlerHalt()) && (LmHandlerJoinStatus() == LORAMAC_HANDLER_SET))
 8009d12:	f002 faf5 	bl	800c300 <LmHandlerHalt>
 8009d16:	b100      	cbz	r0, 8009d1a <OnSystemReset+0xa>
}
 8009d18:	bd08      	pop	{r3, pc}
  if ((LORAMAC_HANDLER_SUCCESS == LmHandlerHalt()) && (LmHandlerJoinStatus() == LORAMAC_HANDLER_SET))
 8009d1a:	f002 fad1 	bl	800c2c0 <LmHandlerJoinStatus>
 8009d1e:	2801      	cmp	r0, #1
 8009d20:	d1fa      	bne.n	8009d18 <OnSystemReset+0x8>
  __ASM volatile ("dsb 0xF":::"memory");
 8009d22:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009d26:	4905      	ldr	r1, [pc, #20]	@ (8009d3c <OnSystemReset+0x2c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009d28:	4b05      	ldr	r3, [pc, #20]	@ (8009d40 <OnSystemReset+0x30>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009d2a:	68ca      	ldr	r2, [r1, #12]
 8009d2c:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009d30:	4313      	orrs	r3, r2
 8009d32:	60cb      	str	r3, [r1, #12]
 8009d34:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8009d38:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8009d3a:	e7fd      	b.n	8009d38 <OnSystemReset+0x28>
 8009d3c:	e000ed00 	.word	0xe000ed00
 8009d40:	05fa0004 	.word	0x05fa0004

08009d44 <OnBeaconStatusChange>:
  if (params != NULL)
 8009d44:	2800      	cmp	r0, #0
 8009d46:	d034      	beq.n	8009db2 <OnBeaconStatusChange+0x6e>
 8009d48:	4601      	mov	r1, r0
    switch (params->State)
 8009d4a:	7840      	ldrb	r0, [r0, #1]
 8009d4c:	2802      	cmp	r0, #2
 8009d4e:	d00d      	beq.n	8009d6c <OnBeaconStatusChange+0x28>
 8009d50:	2803      	cmp	r0, #3
        APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### BEACON LOST\r\n");
 8009d52:	f04f 0200 	mov.w	r2, #0
    switch (params->State)
 8009d56:	d004      	beq.n	8009d62 <OnBeaconStatusChange+0x1e>
        APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### BEACON LOST\r\n");
 8009d58:	4b16      	ldr	r3, [pc, #88]	@ (8009db4 <OnBeaconStatusChange+0x70>)
 8009d5a:	4611      	mov	r1, r2
 8009d5c:	2002      	movs	r0, #2
 8009d5e:	f00b be49 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
        APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### BEACON NOT RECEIVED\r\n");
 8009d62:	4b15      	ldr	r3, [pc, #84]	@ (8009db8 <OnBeaconStatusChange+0x74>)
 8009d64:	4611      	mov	r1, r2
 8009d66:	2002      	movs	r0, #2
 8009d68:	f00b be44 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
{
 8009d6c:	b530      	push	{r4, r5, lr}
 8009d6e:	b08d      	sub	sp, #52	@ 0x34
        APP_LOG(TS_OFF, VLEVEL_M,
 8009d70:	7dcd      	ldrb	r5, [r1, #23]
 8009d72:	7ecc      	ldrb	r4, [r1, #27]
 8009d74:	7d8b      	ldrb	r3, [r1, #22]
 8009d76:	7d4a      	ldrb	r2, [r1, #21]
 8009d78:	9507      	str	r5, [sp, #28]
 8009d7a:	940b      	str	r4, [sp, #44]	@ 0x2c
 8009d7c:	7e8c      	ldrb	r4, [r1, #26]
 8009d7e:	9306      	str	r3, [sp, #24]
 8009d80:	684b      	ldr	r3, [r1, #4]
 8009d82:	e9cd 3204 	strd	r3, r2, [sp, #16]
 8009d86:	68ca      	ldr	r2, [r1, #12]
 8009d88:	f991 3014 	ldrsb.w	r3, [r1, #20]
 8009d8c:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8009d90:	f9b1 2012 	ldrsh.w	r2, [r1, #18]
 8009d94:	7c0b      	ldrb	r3, [r1, #16]
 8009d96:	940a      	str	r4, [sp, #40]	@ 0x28
 8009d98:	e9cd 3200 	strd	r3, r2, [sp]
 8009d9c:	7e4c      	ldrb	r4, [r1, #25]
 8009d9e:	7e09      	ldrb	r1, [r1, #24]
 8009da0:	4b06      	ldr	r3, [pc, #24]	@ (8009dbc <OnBeaconStatusChange+0x78>)
 8009da2:	2200      	movs	r2, #0
 8009da4:	e9cd 1408 	strd	r1, r4, [sp, #32]
 8009da8:	4611      	mov	r1, r2
 8009daa:	f00b fe23 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 8009dae:	b00d      	add	sp, #52	@ 0x34
 8009db0:	bd30      	pop	{r4, r5, pc}
 8009db2:	4770      	bx	lr
 8009db4:	08016c9c 	.word	0x08016c9c
 8009db8:	08016d28 	.word	0x08016d28
 8009dbc:	08016cb4 	.word	0x08016cb4

08009dc0 <OnNvmDataChange>:
  if (state == LORAMAC_HANDLER_NVM_STORE)
 8009dc0:	2801      	cmp	r0, #1
    APP_LOG(TS_OFF, VLEVEL_M, "NVM DATA STORED\r\n");
 8009dc2:	f04f 0200 	mov.w	r2, #0
  if (state == LORAMAC_HANDLER_NVM_STORE)
 8009dc6:	d004      	beq.n	8009dd2 <OnNvmDataChange+0x12>
    APP_LOG(TS_OFF, VLEVEL_M, "NVM DATA RESTORED\r\n");
 8009dc8:	4b04      	ldr	r3, [pc, #16]	@ (8009ddc <OnNvmDataChange+0x1c>)
 8009dca:	4611      	mov	r1, r2
 8009dcc:	2002      	movs	r0, #2
 8009dce:	f00b be11 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_M, "NVM DATA STORED\r\n");
 8009dd2:	4b03      	ldr	r3, [pc, #12]	@ (8009de0 <OnNvmDataChange+0x20>)
 8009dd4:	4611      	mov	r1, r2
 8009dd6:	2002      	movs	r0, #2
 8009dd8:	f00b be0c 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 8009ddc:	08016d5c 	.word	0x08016d5c
 8009de0:	08016d48 	.word	0x08016d48

08009de4 <OnStoreContextRequest>:
{
 8009de4:	b538      	push	{r3, r4, r5, lr}
 8009de6:	4604      	mov	r4, r0
 8009de8:	460d      	mov	r5, r1
  if (FLASH_IF_Erase(LORAWAN_NVM_BASE_ADDRESS, FLASH_PAGE_SIZE) == FLASH_IF_OK)
 8009dea:	4807      	ldr	r0, [pc, #28]	@ (8009e08 <OnStoreContextRequest+0x24>)
 8009dec:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8009df0:	f7f7 f9be 	bl	8001170 <FLASH_IF_Erase>
 8009df4:	b100      	cbz	r0, 8009df8 <OnStoreContextRequest+0x14>
}
 8009df6:	bd38      	pop	{r3, r4, r5, pc}
    FLASH_IF_Write(LORAWAN_NVM_BASE_ADDRESS, (const void *)nvm, nvm_size);
 8009df8:	462a      	mov	r2, r5
 8009dfa:	4621      	mov	r1, r4
 8009dfc:	4802      	ldr	r0, [pc, #8]	@ (8009e08 <OnStoreContextRequest+0x24>)
}
 8009dfe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    FLASH_IF_Write(LORAWAN_NVM_BASE_ADDRESS, (const void *)nvm, nvm_size);
 8009e02:	f7f7 b869 	b.w	8000ed8 <FLASH_IF_Write>
 8009e06:	bf00      	nop
 8009e08:	0803f000 	.word	0x0803f000

08009e0c <StoreContext>:
{
 8009e0c:	b510      	push	{r4, lr}
  status = LmHandlerNvmDataStore();
 8009e0e:	f002 fa81 	bl	800c314 <LmHandlerNvmDataStore>
  if (status == LORAMAC_HANDLER_NVM_DATA_UP_TO_DATE)
 8009e12:	f110 0f08 	cmn.w	r0, #8
 8009e16:	d002      	beq.n	8009e1e <StoreContext+0x12>
  else if (status == LORAMAC_HANDLER_ERROR)
 8009e18:	3001      	adds	r0, #1
 8009e1a:	d008      	beq.n	8009e2e <StoreContext+0x22>
}
 8009e1c:	bd10      	pop	{r4, pc}
    APP_LOG(TS_OFF, VLEVEL_M, "NVM DATA UP TO DATE\r\n");
 8009e1e:	2200      	movs	r2, #0
}
 8009e20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    APP_LOG(TS_OFF, VLEVEL_M, "NVM DATA UP TO DATE\r\n");
 8009e24:	4b06      	ldr	r3, [pc, #24]	@ (8009e40 <StoreContext+0x34>)
 8009e26:	4611      	mov	r1, r2
 8009e28:	2002      	movs	r0, #2
 8009e2a:	f00b bde3 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_M, "NVM DATA STORE FAILED\r\n");
 8009e2e:	2200      	movs	r2, #0
}
 8009e30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    APP_LOG(TS_OFF, VLEVEL_M, "NVM DATA STORE FAILED\r\n");
 8009e34:	4b03      	ldr	r3, [pc, #12]	@ (8009e44 <StoreContext+0x38>)
 8009e36:	4611      	mov	r1, r2
 8009e38:	2002      	movs	r0, #2
 8009e3a:	f00b bddb 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 8009e3e:	bf00      	nop
 8009e40:	08016d70 	.word	0x08016d70
 8009e44:	08016d88 	.word	0x08016d88

08009e48 <OnRxData>:
	  if (params != NULL)
 8009e48:	b111      	cbz	r1, 8009e50 <OnRxData+0x8>
	    if (params->RxSlot < RX_SLOT_NONE)
 8009e4a:	7c0b      	ldrb	r3, [r1, #16]
 8009e4c:	2b05      	cmp	r3, #5
 8009e4e:	d900      	bls.n	8009e52 <OnRxData+0xa>
 8009e50:	4770      	bx	lr
{
 8009e52:	b530      	push	{r4, r5, lr}
 8009e54:	4604      	mov	r4, r0
	      APP_LOG(TS_OFF, VLEVEL_H, "###### D/L FRAME:%04d | PORT:%d | DR:%d | SLOT:%d | RSSI:%d | SNR:%d\r\n",
 8009e56:	f991 2009 	ldrsb.w	r2, [r1, #9]
 8009e5a:	f991 000a 	ldrsb.w	r0, [r1, #10]
{
 8009e5e:	b087      	sub	sp, #28
	      APP_LOG(TS_OFF, VLEVEL_H, "###### D/L FRAME:%04d | PORT:%d | DR:%d | SLOT:%d | RSSI:%d | SNR:%d\r\n",
 8009e60:	e9cd 2004 	strd	r2, r0, [sp, #16]
 8009e64:	f991 2008 	ldrsb.w	r2, [r1, #8]
 8009e68:	7820      	ldrb	r0, [r4, #0]
 8009e6a:	68c9      	ldr	r1, [r1, #12]
 8009e6c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8009e70:	2200      	movs	r2, #0
 8009e72:	e9cd 1000 	strd	r1, r0, [sp]
 8009e76:	4b13      	ldr	r3, [pc, #76]	@ (8009ec4 <OnRxData+0x7c>)
 8009e78:	4611      	mov	r1, r2
 8009e7a:	2003      	movs	r0, #3
 8009e7c:	f00b fdba 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
	      if(appData->BufferSize == 2) {
 8009e80:	7860      	ldrb	r0, [r4, #1]
 8009e82:	2802      	cmp	r0, #2
 8009e84:	d009      	beq.n	8009e9a <OnRxData+0x52>
	    	  APP_LOG(TS_OFF, VLEVEL_M, "Rx message -- Port:%d | Payload length != 2\r\n", appData->Port);
 8009e86:	7821      	ldrb	r1, [r4, #0]
 8009e88:	9100      	str	r1, [sp, #0]
 8009e8a:	2200      	movs	r2, #0
 8009e8c:	4b0e      	ldr	r3, [pc, #56]	@ (8009ec8 <OnRxData+0x80>)
 8009e8e:	4611      	mov	r1, r2
 8009e90:	2002      	movs	r0, #2
 8009e92:	f00b fdaf 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 8009e96:	b007      	add	sp, #28
 8009e98:	bd30      	pop	{r4, r5, pc}
 8009e9a:	6863      	ldr	r3, [r4, #4]
	    	  APP_LOG(TS_OFF, VLEVEL_M, "Rx message -- Port:%d | Payload = %x%x\r\n", appData->Port,
 8009e9c:	7859      	ldrb	r1, [r3, #1]
 8009e9e:	9102      	str	r1, [sp, #8]
 8009ea0:	781d      	ldrb	r5, [r3, #0]
 8009ea2:	7824      	ldrb	r4, [r4, #0]
 8009ea4:	4b09      	ldr	r3, [pc, #36]	@ (8009ecc <OnRxData+0x84>)
 8009ea6:	2200      	movs	r2, #0
 8009ea8:	4611      	mov	r1, r2
 8009eaa:	e9cd 4500 	strd	r4, r5, [sp]
 8009eae:	f00b fda1 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
	    	  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
 8009eb2:	2201      	movs	r2, #1
 8009eb4:	2120      	movs	r1, #32
 8009eb6:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
}
 8009eba:	b007      	add	sp, #28
 8009ebc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	    	  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
 8009ec0:	f7fc b922 	b.w	8006108 <HAL_GPIO_WritePin>
 8009ec4:	08016da0 	.word	0x08016da0
 8009ec8:	08016e14 	.word	0x08016e14
 8009ecc:	08016de8 	.word	0x08016de8

08009ed0 <OnTxData>:
  if ((params != NULL))
 8009ed0:	2800      	cmp	r0, #0
 8009ed2:	d034      	beq.n	8009f3e <OnTxData+0x6e>
{
 8009ed4:	b530      	push	{r4, r5, lr}
    if (params->IsMcpsConfirm != 0)
 8009ed6:	7803      	ldrb	r3, [r0, #0]
{
 8009ed8:	b085      	sub	sp, #20
 8009eda:	4604      	mov	r4, r0
    if (params->IsMcpsConfirm != 0)
 8009edc:	b90b      	cbnz	r3, 8009ee2 <OnTxData+0x12>
}
 8009ede:	b005      	add	sp, #20
 8009ee0:	bd30      	pop	{r4, r5, pc}
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Confirm =============\r\n");
 8009ee2:	2200      	movs	r2, #0
 8009ee4:	4611      	mov	r1, r2
 8009ee6:	4b1b      	ldr	r3, [pc, #108]	@ (8009f54 <OnTxData+0x84>)
 8009ee8:	2002      	movs	r0, #2
 8009eea:	f00b fd83 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, "###### U/L FRAME:%04d | PORT:%d | DR:%d | PWR:%d", params->UplinkCounter,
 8009eee:	f994 1018 	ldrsb.w	r1, [r4, #24]
 8009ef2:	f994 300a 	ldrsb.w	r3, [r4, #10]
 8009ef6:	7c25      	ldrb	r5, [r4, #16]
 8009ef8:	e9cd 3102 	strd	r3, r1, [sp, #8]
 8009efc:	68e0      	ldr	r0, [r4, #12]
 8009efe:	4b16      	ldr	r3, [pc, #88]	@ (8009f58 <OnTxData+0x88>)
 8009f00:	2200      	movs	r2, #0
 8009f02:	4611      	mov	r1, r2
 8009f04:	e9cd 0500 	strd	r0, r5, [sp]
 8009f08:	2003      	movs	r0, #3
 8009f0a:	f00b fd73 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, " | MSG TYPE:");
 8009f0e:	2200      	movs	r2, #0
 8009f10:	4b12      	ldr	r3, [pc, #72]	@ (8009f5c <OnTxData+0x8c>)
 8009f12:	4611      	mov	r1, r2
 8009f14:	2003      	movs	r0, #3
 8009f16:	f00b fd6d 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
      if (params->MsgType == LORAMAC_HANDLER_CONFIRMED_MSG)
 8009f1a:	7a23      	ldrb	r3, [r4, #8]
 8009f1c:	2b01      	cmp	r3, #1
 8009f1e:	d10f      	bne.n	8009f40 <OnTxData+0x70>
        APP_LOG(TS_OFF, VLEVEL_H, "CONFIRMED [%s]\r\n", (params->AckReceived != 0) ? "ACK" : "NACK");
 8009f20:	7a60      	ldrb	r0, [r4, #9]
 8009f22:	4b0f      	ldr	r3, [pc, #60]	@ (8009f60 <OnTxData+0x90>)
 8009f24:	490f      	ldr	r1, [pc, #60]	@ (8009f64 <OnTxData+0x94>)
 8009f26:	2200      	movs	r2, #0
 8009f28:	4290      	cmp	r0, r2
 8009f2a:	bf18      	it	ne
 8009f2c:	4619      	movne	r1, r3
 8009f2e:	9100      	str	r1, [sp, #0]
 8009f30:	4b0d      	ldr	r3, [pc, #52]	@ (8009f68 <OnTxData+0x98>)
 8009f32:	4611      	mov	r1, r2
 8009f34:	2003      	movs	r0, #3
 8009f36:	f00b fd5d 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 8009f3a:	b005      	add	sp, #20
 8009f3c:	bd30      	pop	{r4, r5, pc}
 8009f3e:	4770      	bx	lr
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 8009f40:	2200      	movs	r2, #0
 8009f42:	4b0a      	ldr	r3, [pc, #40]	@ (8009f6c <OnTxData+0x9c>)
 8009f44:	4611      	mov	r1, r2
 8009f46:	2003      	movs	r0, #3
}
 8009f48:	b005      	add	sp, #20
 8009f4a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 8009f4e:	f00b bd51 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 8009f52:	bf00      	nop
 8009f54:	08016e50 	.word	0x08016e50
 8009f58:	08016e84 	.word	0x08016e84
 8009f5c:	08016eb8 	.word	0x08016eb8
 8009f60:	08016e44 	.word	0x08016e44
 8009f64:	08016e48 	.word	0x08016e48
 8009f68:	08016ec8 	.word	0x08016ec8
 8009f6c:	08016edc 	.word	0x08016edc

08009f70 <LoRaWAN_Init>:
		radio_payload_buffer[i] = i;
 8009f70:	a14f      	add	r1, pc, #316	@ (adr r1, 800a0b0 <LoRaWAN_Init+0x140>)
 8009f72:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009f76:	4a40      	ldr	r2, [pc, #256]	@ (800a078 <LoRaWAN_Init+0x108>)
  UTIL_TIMER_Create(&StopJoinTimer, JOIN_TIME, UTIL_TIMER_ONESHOT, OnStopJoinTimerEvent, NULL);
 8009f78:	4b40      	ldr	r3, [pc, #256]	@ (800a07c <LoRaWAN_Init+0x10c>)
{
 8009f7a:	b530      	push	{r4, r5, lr}
		radio_payload_buffer[i] = i;
 8009f7c:	e9c2 0100 	strd	r0, r1, [r2]
 8009f80:	a12f      	add	r1, pc, #188	@ (adr r1, 800a040 <LoRaWAN_Init+0xd0>)
 8009f82:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009f86:	a530      	add	r5, pc, #192	@ (adr r5, 800a048 <LoRaWAN_Init+0xd8>)
 8009f88:	e9d5 4500 	ldrd	r4, r5, [r5]
 8009f8c:	e9c2 0104 	strd	r0, r1, [r2, #16]
 8009f90:	a12f      	add	r1, pc, #188	@ (adr r1, 800a050 <LoRaWAN_Init+0xe0>)
 8009f92:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009f96:	e9c2 4502 	strd	r4, r5, [r2, #8]
 8009f9a:	a52f      	add	r5, pc, #188	@ (adr r5, 800a058 <LoRaWAN_Init+0xe8>)
 8009f9c:	e9d5 4500 	ldrd	r4, r5, [r5]
 8009fa0:	e9c2 0108 	strd	r0, r1, [r2, #32]
 8009fa4:	a12e      	add	r1, pc, #184	@ (adr r1, 800a060 <LoRaWAN_Init+0xf0>)
 8009fa6:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009faa:	e9c2 4506 	strd	r4, r5, [r2, #24]
 8009fae:	a52e      	add	r5, pc, #184	@ (adr r5, 800a068 <LoRaWAN_Init+0xf8>)
 8009fb0:	e9d5 4500 	ldrd	r4, r5, [r5]
 8009fb4:	e9c2 010c 	strd	r0, r1, [r2, #48]	@ 0x30
 8009fb8:	a12d      	add	r1, pc, #180	@ (adr r1, 800a070 <LoRaWAN_Init+0x100>)
 8009fba:	e9d1 0100 	ldrd	r0, r1, [r1]
{
 8009fbe:	b083      	sub	sp, #12
		radio_payload_buffer[i] = i;
 8009fc0:	e9c2 450a 	strd	r4, r5, [r2, #40]	@ 0x28
  UTIL_TIMER_Create(&StopJoinTimer, JOIN_TIME, UTIL_TIMER_ONESHOT, OnStopJoinTimerEvent, NULL);
 8009fc4:	2400      	movs	r4, #0
 8009fc6:	9400      	str	r4, [sp, #0]
		radio_payload_buffer[i] = i;
 8009fc8:	e9c2 010e 	strd	r0, r1, [r2, #56]	@ 0x38
  UTIL_TIMER_Create(&StopJoinTimer, JOIN_TIME, UTIL_TIMER_ONESHOT, OnStopJoinTimerEvent, NULL);
 8009fcc:	4622      	mov	r2, r4
 8009fce:	f44f 61fa 	mov.w	r1, #2000	@ 0x7d0
 8009fd2:	482b      	ldr	r0, [pc, #172]	@ (800a080 <LoRaWAN_Init+0x110>)
    UTIL_TIMER_Create(&TxTimer, TxPeriodicity, UTIL_TIMER_ONESHOT, OnTxTimerEvent, NULL);
 8009fd4:	4d2b      	ldr	r5, [pc, #172]	@ (800a084 <LoRaWAN_Init+0x114>)
  UTIL_TIMER_Create(&StopJoinTimer, JOIN_TIME, UTIL_TIMER_ONESHOT, OnStopJoinTimerEvent, NULL);
 8009fd6:	f00b fb5d 	bl	8015694 <UTIL_TIMER_Create>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 8009fda:	4621      	mov	r1, r4
 8009fdc:	4a2a      	ldr	r2, [pc, #168]	@ (800a088 <LoRaWAN_Init+0x118>)
 8009fde:	2001      	movs	r0, #1
 8009fe0:	f00b f9e6 	bl	80153b0 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), UTIL_SEQ_RFU, SendTxData);
 8009fe4:	4621      	mov	r1, r4
 8009fe6:	4a29      	ldr	r2, [pc, #164]	@ (800a08c <LoRaWAN_Init+0x11c>)
 8009fe8:	2002      	movs	r0, #2
 8009fea:	f00b f9e1 	bl	80153b0 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaStoreContextEvent), UTIL_SEQ_RFU, StoreContext);
 8009fee:	4621      	mov	r1, r4
 8009ff0:	4a27      	ldr	r2, [pc, #156]	@ (800a090 <LoRaWAN_Init+0x120>)
 8009ff2:	2004      	movs	r0, #4
 8009ff4:	f00b f9dc 	bl	80153b0 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaStopJoinEvent), UTIL_SEQ_RFU, StopJoin);
 8009ff8:	4a26      	ldr	r2, [pc, #152]	@ (800a094 <LoRaWAN_Init+0x124>)
 8009ffa:	4621      	mov	r1, r4
 8009ffc:	2008      	movs	r0, #8
 8009ffe:	f00b f9d7 	bl	80153b0 <UTIL_SEQ_RegTask>
  LoraInfo_Init();
 800a002:	f000 f879 	bl	800a0f8 <LoraInfo_Init>
  LmHandlerInit(&LmHandlerCallbacks, APP_VERSION);
 800a006:	4924      	ldr	r1, [pc, #144]	@ (800a098 <LoRaWAN_Init+0x128>)
 800a008:	4824      	ldr	r0, [pc, #144]	@ (800a09c <LoRaWAN_Init+0x12c>)
 800a00a:	f002 f801 	bl	800c010 <LmHandlerInit>
  LmHandlerConfigure(&LmHandlerParams);
 800a00e:	4824      	ldr	r0, [pc, #144]	@ (800a0a0 <LoRaWAN_Init+0x130>)
 800a010:	f002 f854 	bl	800c0bc <LmHandlerConfigure>
  LmHandlerJoin(ActivationType, ForceRejoin);
 800a014:	4b23      	ldr	r3, [pc, #140]	@ (800a0a4 <LoRaWAN_Init+0x134>)
 800a016:	2101      	movs	r1, #1
 800a018:	7818      	ldrb	r0, [r3, #0]
 800a01a:	f001 fda7 	bl	800bb6c <LmHandlerJoin>
    UTIL_TIMER_Create(&TxTimer, TxPeriodicity, UTIL_TIMER_ONESHOT, OnTxTimerEvent, NULL);
 800a01e:	4a22      	ldr	r2, [pc, #136]	@ (800a0a8 <LoRaWAN_Init+0x138>)
 800a020:	4b22      	ldr	r3, [pc, #136]	@ (800a0ac <LoRaWAN_Init+0x13c>)
 800a022:	6811      	ldr	r1, [r2, #0]
 800a024:	9400      	str	r4, [sp, #0]
 800a026:	4622      	mov	r2, r4
 800a028:	4628      	mov	r0, r5
 800a02a:	f00b fb33 	bl	8015694 <UTIL_TIMER_Create>
    UTIL_TIMER_Start(&TxTimer);
 800a02e:	4628      	mov	r0, r5
}
 800a030:	b003      	add	sp, #12
 800a032:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    UTIL_TIMER_Start(&TxTimer);
 800a036:	f00b bb47 	b.w	80156c8 <UTIL_TIMER_Start>
 800a03a:	bf00      	nop
 800a03c:	f3af 8000 	nop.w
 800a040:	13121110 	.word	0x13121110
 800a044:	17161514 	.word	0x17161514
 800a048:	0b0a0908 	.word	0x0b0a0908
 800a04c:	0f0e0d0c 	.word	0x0f0e0d0c
 800a050:	23222120 	.word	0x23222120
 800a054:	27262524 	.word	0x27262524
 800a058:	1b1a1918 	.word	0x1b1a1918
 800a05c:	1f1e1d1c 	.word	0x1f1e1d1c
 800a060:	33323130 	.word	0x33323130
 800a064:	37363534 	.word	0x37363534
 800a068:	2b2a2928 	.word	0x2b2a2928
 800a06c:	2f2e2d2c 	.word	0x2f2e2d2c
 800a070:	3b3a3938 	.word	0x3b3a3938
 800a074:	3f3e3d3c 	.word	0x3f3e3d3c
 800a078:	20000450 	.word	0x20000450
 800a07c:	08009cf9 	.word	0x08009cf9
 800a080:	20000490 	.word	0x20000490
 800a084:	200004a8 	.word	0x200004a8
 800a088:	0800c259 	.word	0x0800c259
 800a08c:	08009c5d 	.word	0x08009c5d
 800a090:	08009e0d 	.word	0x08009e0d
 800a094:	08009bdd 	.word	0x08009bdd
 800a098:	01030000 	.word	0x01030000
 800a09c:	20000030 	.word	0x20000030
 800a0a0:	20000018 	.word	0x20000018
 800a0a4:	2000007c 	.word	0x2000007c
 800a0a8:	20000014 	.word	0x20000014
 800a0ac:	08009ad9 	.word	0x08009ad9
 800a0b0:	03020100 	.word	0x03020100
 800a0b4:	07060504 	.word	0x07060504

0800a0b8 <HAL_GPIO_EXTI_Callback>:
{
 800a0b8:	b510      	push	{r4, lr}
 800a0ba:	4604      	mov	r4, r0
	debug_print("GPIO EXTI callback - ");
 800a0bc:	480a      	ldr	r0, [pc, #40]	@ (800a0e8 <HAL_GPIO_EXTI_Callback+0x30>)
 800a0be:	f7f7 f9e5 	bl	800148c <debug_print>
	switch (GPIO_Pin)
 800a0c2:	2c40      	cmp	r4, #64	@ 0x40
 800a0c4:	d006      	beq.n	800a0d4 <HAL_GPIO_EXTI_Callback+0x1c>
 800a0c6:	2c80      	cmp	r4, #128	@ 0x80
 800a0c8:	d009      	beq.n	800a0de <HAL_GPIO_EXTI_Callback+0x26>
}
 800a0ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		debug_print("other pin?\r\n");
 800a0ce:	4807      	ldr	r0, [pc, #28]	@ (800a0ec <HAL_GPIO_EXTI_Callback+0x34>)
 800a0d0:	f7f7 b9dc 	b.w	800148c <debug_print>
}
 800a0d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		debug_print("pin 6\r\n");
 800a0d8:	4805      	ldr	r0, [pc, #20]	@ (800a0f0 <HAL_GPIO_EXTI_Callback+0x38>)
 800a0da:	f7f7 b9d7 	b.w	800148c <debug_print>
}
 800a0de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		debug_print("pin 7\r\n");
 800a0e2:	4804      	ldr	r0, [pc, #16]	@ (800a0f4 <HAL_GPIO_EXTI_Callback+0x3c>)
 800a0e4:	f7f7 b9d2 	b.w	800148c <debug_print>
 800a0e8:	08016eec 	.word	0x08016eec
 800a0ec:	08016f14 	.word	0x08016f14
 800a0f0:	08016f04 	.word	0x08016f04
 800a0f4:	08016f0c 	.word	0x08016f0c

0800a0f8 <LoraInfo_Init>:

/* USER CODE END EV */

/* Exported functions --------------------------------------------------------*/
void LoraInfo_Init(void)
{
 800a0f8:	b430      	push	{r4, r5}
  loraInfo.ContextManagement = 0;
 800a0fa:	4b05      	ldr	r3, [pc, #20]	@ (800a110 <LoraInfo_Init+0x18>)
 800a0fc:	2400      	movs	r4, #0
 800a0fe:	2520      	movs	r5, #32
 800a100:	2000      	movs	r0, #0
 800a102:	2100      	movs	r1, #0
 800a104:	e9c3 4500 	strd	r4, r5, [r3]
 800a108:	e9c3 0102 	strd	r0, r1, [r3, #8]
#endif /* CONTEXT_MANAGEMENT_ENABLED */

  /* USER CODE BEGIN LoraInfo_Init_2 */

  /* USER CODE END LoraInfo_Init_2 */
}
 800a10c:	bc30      	pop	{r4, r5}
 800a10e:	4770      	bx	lr
 800a110:	200004c0 	.word	0x200004c0

0800a114 <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 800a114:	4800      	ldr	r0, [pc, #0]	@ (800a118 <LoraInfo_GetPtr+0x4>)
 800a116:	4770      	bx	lr
 800a118:	200004c0 	.word	0x200004c0

0800a11c <RBI_Init>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t RBI_Init(void)
{
 800a11c:	b530      	push	{r4, r5, lr}
#else
  /* 2/ Or implement RBI_Init here */
  int32_t retcode = 0;
  /* USER CODE BEGIN RBI_Init_2 */
  //#warning user to provide its board code or to call his board driver functions
  GPIO_InitTypeDef gpio_init_structure = {0};
 800a11e:	2400      	movs	r4, #0
{
 800a120:	b089      	sub	sp, #36	@ 0x24
  GPIO_InitTypeDef gpio_init_structure = {0};
 800a122:	e9cd 4404 	strd	r4, r4, [sp, #16]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800a126:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800a12a:	9406      	str	r4, [sp, #24]
 800a12c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  //Configure the Radio Switch pin
  gpio_init_structure.Pin   = RFIO_SEL_PIN;
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(RFIO_SEL_GPIO_PORT, &gpio_init_structure);
 800a12e:	4d0e      	ldr	r5, [pc, #56]	@ (800a168 <RBI_Init+0x4c>)
 800a130:	f042 0204 	orr.w	r2, r2, #4
 800a134:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800a136:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800a138:	f003 0304 	and.w	r3, r3, #4
 800a13c:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pin   = RFIO_SEL_PIN;
 800a13e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800a142:	2301      	movs	r3, #1
 800a144:	e9cd 2302 	strd	r2, r3, [sp, #8]
  HAL_GPIO_Init(RFIO_SEL_GPIO_PORT, &gpio_init_structure);
 800a148:	a902      	add	r1, sp, #8
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a14a:	2303      	movs	r3, #3
  HAL_GPIO_Init(RFIO_SEL_GPIO_PORT, &gpio_init_structure);
 800a14c:	4628      	mov	r0, r5
  (void)tmpreg;
 800a14e:	9a01      	ldr	r2, [sp, #4]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a150:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(RFIO_SEL_GPIO_PORT, &gpio_init_structure);
 800a152:	f7fb fe77 	bl	8005e44 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RFIO_SEL_GPIO_PORT, RFIO_SEL_PIN, GPIO_PIN_RESET);
 800a156:	4628      	mov	r0, r5
 800a158:	4622      	mov	r2, r4
 800a15a:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800a15e:	f7fb ffd3 	bl	8006108 <HAL_GPIO_WritePin>
  /* USER CODE END RBI_Init_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 800a162:	4620      	mov	r0, r4
 800a164:	b009      	add	sp, #36	@ 0x24
 800a166:	bd30      	pop	{r4, r5, pc}
 800a168:	48000800 	.word	0x48000800

0800a16c <RBI_ConfigRFSwitch>:
  /* USER CODE BEGIN RBI_ConfigRFSwitch_2 */
//#warning user to provide its board code or to call his board driver functions

  // notes from brock : with one switch, only RX or TX => OFF=RX, HP=LP
  // quand RFIO_SEL = 0, RX ; si RFIO_SEL = 1, TX
  switch (Config)
 800a16c:	2801      	cmp	r0, #1
{
 800a16e:	b508      	push	{r3, lr}
  switch (Config)
 800a170:	d90a      	bls.n	800a188 <RBI_ConfigRFSwitch+0x1c>
 800a172:	3802      	subs	r0, #2
 800a174:	2801      	cmp	r0, #1
 800a176:	d805      	bhi.n	800a184 <RBI_ConfigRFSwitch+0x18>
	  break;
	}
	case RBI_SWITCH_RFO_LP:
	{
	  /*Turns On in Tx Low Power the RF Switch */
		  HAL_GPIO_WritePin(RFIO_SEL_GPIO_PORT, RFIO_SEL_PIN, GPIO_PIN_SET);
 800a178:	4807      	ldr	r0, [pc, #28]	@ (800a198 <RBI_ConfigRFSwitch+0x2c>)
 800a17a:	2201      	movs	r2, #1
 800a17c:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800a180:	f7fb ffc2 	bl	8006108 <HAL_GPIO_WritePin>
	  break;
  }
  /* USER CODE END RBI_ConfigRFSwitch_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 800a184:	2000      	movs	r0, #0
 800a186:	bd08      	pop	{r3, pc}
		  HAL_GPIO_WritePin(RFIO_SEL_GPIO_PORT, RFIO_SEL_PIN, GPIO_PIN_RESET);
 800a188:	4803      	ldr	r0, [pc, #12]	@ (800a198 <RBI_ConfigRFSwitch+0x2c>)
 800a18a:	2200      	movs	r2, #0
 800a18c:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800a190:	f7fb ffba 	bl	8006108 <HAL_GPIO_WritePin>
}
 800a194:	2000      	movs	r0, #0
 800a196:	bd08      	pop	{r3, pc}
 800a198:	48000800 	.word	0x48000800

0800a19c <RBI_GetTxConfig>:
  /* USER CODE BEGIN RBI_GetTxConfig_2 */
//#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_GetTxConfig_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 800a19c:	2001      	movs	r0, #1
 800a19e:	4770      	bx	lr

0800a1a0 <RBI_IsTCXO>:
  /* USER CODE BEGIN RBI_IsTCXO_2 */
//#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_IsTCXO_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 800a1a0:	2000      	movs	r0, #0
 800a1a2:	4770      	bx	lr

0800a1a4 <RBI_IsDCDC>:

int32_t RBI_IsDCDC(void)
 800a1a4:	2001      	movs	r0, #1
 800a1a6:	4770      	bx	lr

0800a1a8 <RBI_GetRFOMaxPowerConfig>:
  int32_t ret = 0;
  /* USER CODE BEGIN RBI_GetRFOMaxPowerConfig_2 */
//#warning user to provide its board code or to call his board driver functions
  if (Config == RBI_RFO_LP_MAXPOWER)
  {
    ret = 15; /*dBm*/
 800a1a8:	2800      	cmp	r0, #0
    ret = 22; /*dBm*/
  }
  /* USER CODE END RBI_GetRFOMaxPowerConfig_2 */
  return ret;
#endif  /* USE_BSP_DRIVER  */
}
 800a1aa:	bf14      	ite	ne
 800a1ac:	2016      	movne	r0, #22
 800a1ae:	200f      	moveq	r0, #15
 800a1b0:	4770      	bx	lr
 800a1b2:	bf00      	nop

0800a1b4 <AES_CMAC_Init>:
            ( r )[i] = ( r )[i] ^ ( v )[i]; \
        }                                   \
    } while( 0 )

void AES_CMAC_Init( AES_CMAC_CTX* ctx )
{
 800a1b4:	b510      	push	{r4, lr}
    memset1( ctx->X, 0, sizeof ctx->X );
 800a1b6:	2210      	movs	r2, #16
{
 800a1b8:	4604      	mov	r4, r0
    memset1( ctx->X, 0, sizeof ctx->X );
 800a1ba:	2100      	movs	r1, #0
 800a1bc:	30f1      	adds	r0, #241	@ 0xf1
 800a1be:	f008 f8bd 	bl	801233c <memset1>
    ctx->M_n = 0;
 800a1c2:	2100      	movs	r1, #0
 800a1c4:	f8c4 1114 	str.w	r1, [r4, #276]	@ 0x114
    memset1( ctx->rijndael.ksch, '\0', 240 );
 800a1c8:	4620      	mov	r0, r4
 800a1ca:	22f0      	movs	r2, #240	@ 0xf0
}
 800a1cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memset1( ctx->rijndael.ksch, '\0', 240 );
 800a1d0:	f008 b8b4 	b.w	801233c <memset1>

0800a1d4 <AES_CMAC_SetKey>:

void AES_CMAC_SetKey( AES_CMAC_CTX* ctx, const uint8_t key[AES_CMAC_KEY_LENGTH] )
{
 800a1d4:	4602      	mov	r2, r0
 800a1d6:	4608      	mov	r0, r1
    lorawan_aes_set_key( key, AES_CMAC_KEY_LENGTH, &ctx->rijndael );
 800a1d8:	2110      	movs	r1, #16
 800a1da:	f000 bbb7 	b.w	800a94c <lorawan_aes_set_key>
 800a1de:	bf00      	nop

0800a1e0 <AES_CMAC_Update>:
}

void AES_CMAC_Update( AES_CMAC_CTX* ctx, const uint8_t* data, uint32_t len )
{
 800a1e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a1e4:	4604      	mov	r4, r0
    uint32_t mlen;
    uint8_t  in[16];

    if( ctx->M_n > 0 )
 800a1e6:	f8d0 0114 	ldr.w	r0, [r0, #276]	@ 0x114
{
 800a1ea:	b087      	sub	sp, #28
 800a1ec:	468b      	mov	fp, r1
 800a1ee:	4690      	mov	r8, r2
    {
        mlen = MIN( 16 - ctx->M_n, len );
        memcpy1( ctx->M_last + ctx->M_n, data, mlen );
 800a1f0:	f204 1a01 	addw	sl, r4, #257	@ 0x101
    if( ctx->M_n > 0 )
 800a1f4:	2800      	cmp	r0, #0
 800a1f6:	f040 80aa 	bne.w	800a34e <AES_CMAC_Update+0x16e>
        memcpy1( &ctx->X[0], in, 16 );

        data += mlen;
        len -= mlen;
    }
    while( len > 16 )
 800a1fa:	f1b8 0f10 	cmp.w	r8, #16
 800a1fe:	f240 809b 	bls.w	800a338 <AES_CMAC_Update+0x158>
 800a202:	f1a8 0211 	sub.w	r2, r8, #17
 800a206:	f022 010f 	bic.w	r1, r2, #15
 800a20a:	0912      	lsrs	r2, r2, #4
 800a20c:	e9cd 2100 	strd	r2, r1, [sp]
 800a210:	f10b 0920 	add.w	r9, fp, #32
        memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800a214:	f104 07f1 	add.w	r7, r4, #241	@ 0xf1
 800a218:	4489      	add	r9, r1
 800a21a:	f10b 0510 	add.w	r5, fp, #16
 800a21e:	ae02      	add	r6, sp, #8
    { /* not last block */

        XOR( data, ctx->X );
 800a220:	f815 1c10 	ldrb.w	r1, [r5, #-16]
 800a224:	f894 20f1 	ldrb.w	r2, [r4, #241]	@ 0xf1
 800a228:	404a      	eors	r2, r1
 800a22a:	f884 20f1 	strb.w	r2, [r4, #241]	@ 0xf1
 800a22e:	f815 1c0f 	ldrb.w	r1, [r5, #-15]
 800a232:	f894 20f2 	ldrb.w	r2, [r4, #242]	@ 0xf2
 800a236:	404a      	eors	r2, r1
 800a238:	f884 20f2 	strb.w	r2, [r4, #242]	@ 0xf2
 800a23c:	f815 1c0e 	ldrb.w	r1, [r5, #-14]
 800a240:	f894 20f3 	ldrb.w	r2, [r4, #243]	@ 0xf3
 800a244:	404a      	eors	r2, r1
 800a246:	f884 20f3 	strb.w	r2, [r4, #243]	@ 0xf3
 800a24a:	f815 1c0d 	ldrb.w	r1, [r5, #-13]
 800a24e:	f894 20f4 	ldrb.w	r2, [r4, #244]	@ 0xf4
 800a252:	404a      	eors	r2, r1
 800a254:	f884 20f4 	strb.w	r2, [r4, #244]	@ 0xf4
 800a258:	f815 1c0c 	ldrb.w	r1, [r5, #-12]
 800a25c:	f894 20f5 	ldrb.w	r2, [r4, #245]	@ 0xf5
 800a260:	404a      	eors	r2, r1
 800a262:	f884 20f5 	strb.w	r2, [r4, #245]	@ 0xf5
 800a266:	f815 1c0b 	ldrb.w	r1, [r5, #-11]
 800a26a:	f894 20f6 	ldrb.w	r2, [r4, #246]	@ 0xf6
 800a26e:	404a      	eors	r2, r1
 800a270:	f884 20f6 	strb.w	r2, [r4, #246]	@ 0xf6
 800a274:	f815 1c0a 	ldrb.w	r1, [r5, #-10]
 800a278:	f894 20f7 	ldrb.w	r2, [r4, #247]	@ 0xf7
 800a27c:	404a      	eors	r2, r1
 800a27e:	f884 20f7 	strb.w	r2, [r4, #247]	@ 0xf7
 800a282:	f815 1c09 	ldrb.w	r1, [r5, #-9]
 800a286:	f894 20f8 	ldrb.w	r2, [r4, #248]	@ 0xf8
 800a28a:	404a      	eors	r2, r1
 800a28c:	f884 20f8 	strb.w	r2, [r4, #248]	@ 0xf8
 800a290:	f815 1c08 	ldrb.w	r1, [r5, #-8]
 800a294:	f894 20f9 	ldrb.w	r2, [r4, #249]	@ 0xf9
 800a298:	404a      	eors	r2, r1
 800a29a:	f884 20f9 	strb.w	r2, [r4, #249]	@ 0xf9
 800a29e:	f815 1c07 	ldrb.w	r1, [r5, #-7]
 800a2a2:	f894 20fa 	ldrb.w	r2, [r4, #250]	@ 0xfa
 800a2a6:	404a      	eors	r2, r1
 800a2a8:	f884 20fa 	strb.w	r2, [r4, #250]	@ 0xfa
 800a2ac:	f815 1c06 	ldrb.w	r1, [r5, #-6]
 800a2b0:	f894 20fb 	ldrb.w	r2, [r4, #251]	@ 0xfb
 800a2b4:	404a      	eors	r2, r1
 800a2b6:	f884 20fb 	strb.w	r2, [r4, #251]	@ 0xfb
 800a2ba:	f815 1c05 	ldrb.w	r1, [r5, #-5]
 800a2be:	f894 20fc 	ldrb.w	r2, [r4, #252]	@ 0xfc
 800a2c2:	404a      	eors	r2, r1
 800a2c4:	f884 20fc 	strb.w	r2, [r4, #252]	@ 0xfc
 800a2c8:	f815 1c04 	ldrb.w	r1, [r5, #-4]
 800a2cc:	f894 20fd 	ldrb.w	r2, [r4, #253]	@ 0xfd
 800a2d0:	404a      	eors	r2, r1
 800a2d2:	f884 20fd 	strb.w	r2, [r4, #253]	@ 0xfd
 800a2d6:	f815 1c03 	ldrb.w	r1, [r5, #-3]
 800a2da:	f894 20fe 	ldrb.w	r2, [r4, #254]	@ 0xfe
 800a2de:	404a      	eors	r2, r1
 800a2e0:	f884 20fe 	strb.w	r2, [r4, #254]	@ 0xfe
 800a2e4:	f815 1c02 	ldrb.w	r1, [r5, #-2]
 800a2e8:	f894 20ff 	ldrb.w	r2, [r4, #255]	@ 0xff
 800a2ec:	404a      	eors	r2, r1
 800a2ee:	f884 20ff 	strb.w	r2, [r4, #255]	@ 0xff
 800a2f2:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 800a2f6:	f894 2100 	ldrb.w	r2, [r4, #256]	@ 0x100
 800a2fa:	404a      	eors	r2, r1
 800a2fc:	f884 2100 	strb.w	r2, [r4, #256]	@ 0x100

        memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800a300:	4639      	mov	r1, r7
 800a302:	2210      	movs	r2, #16
 800a304:	4630      	mov	r0, r6
 800a306:	f007 ffbd 	bl	8012284 <memcpy1>
        lorawan_aes_encrypt( in, in, &ctx->rijndael );
 800a30a:	4622      	mov	r2, r4
 800a30c:	4631      	mov	r1, r6
 800a30e:	4630      	mov	r0, r6
 800a310:	f000 fc22 	bl	800ab58 <lorawan_aes_encrypt>
    while( len > 16 )
 800a314:	3510      	adds	r5, #16
        memcpy1( &ctx->X[0], in, 16 );
 800a316:	2210      	movs	r2, #16
 800a318:	4631      	mov	r1, r6
 800a31a:	4638      	mov	r0, r7
 800a31c:	f007 ffb2 	bl	8012284 <memcpy1>
    while( len > 16 )
 800a320:	45a9      	cmp	r9, r5
 800a322:	f47f af7d 	bne.w	800a220 <AES_CMAC_Update+0x40>

        data += 16;
 800a326:	e9dd 2100 	ldrd	r2, r1, [sp]
 800a32a:	f1a8 0810 	sub.w	r8, r8, #16
 800a32e:	3201      	adds	r2, #1
 800a330:	eb0b 1b02 	add.w	fp, fp, r2, lsl #4
 800a334:	eba8 0801 	sub.w	r8, r8, r1
        len -= 16;
    }
    /* potential last block, save it */
    memcpy1( ctx->M_last, data, len );
 800a338:	fa1f f288 	uxth.w	r2, r8
 800a33c:	4659      	mov	r1, fp
 800a33e:	4650      	mov	r0, sl
 800a340:	f007 ffa0 	bl	8012284 <memcpy1>
    ctx->M_n = len;
 800a344:	f8c4 8114 	str.w	r8, [r4, #276]	@ 0x114
}
 800a348:	b007      	add	sp, #28
 800a34a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        mlen = MIN( 16 - ctx->M_n, len );
 800a34e:	f1c0 0610 	rsb	r6, r0, #16
 800a352:	4296      	cmp	r6, r2
 800a354:	4635      	mov	r5, r6
 800a356:	bf28      	it	cs
 800a358:	4615      	movcs	r5, r2
        memcpy1( ctx->M_last + ctx->M_n, data, mlen );
 800a35a:	4450      	add	r0, sl
 800a35c:	b2aa      	uxth	r2, r5
 800a35e:	f007 ff91 	bl	8012284 <memcpy1>
        ctx->M_n += mlen;
 800a362:	f8d4 3114 	ldr.w	r3, [r4, #276]	@ 0x114
 800a366:	442b      	add	r3, r5
        if( ctx->M_n < 16 || len == mlen )
 800a368:	2b0f      	cmp	r3, #15
        ctx->M_n += mlen;
 800a36a:	f8c4 3114 	str.w	r3, [r4, #276]	@ 0x114
        if( ctx->M_n < 16 || len == mlen )
 800a36e:	d9eb      	bls.n	800a348 <AES_CMAC_Update+0x168>
 800a370:	4546      	cmp	r6, r8
 800a372:	d2e9      	bcs.n	800a348 <AES_CMAC_Update+0x168>
        XOR( ctx->M_last, ctx->X );
 800a374:	f8d4 10f1 	ldr.w	r1, [r4, #241]	@ 0xf1
 800a378:	f8d4 00f5 	ldr.w	r0, [r4, #245]	@ 0xf5
 800a37c:	f8d4 20f9 	ldr.w	r2, [r4, #249]	@ 0xf9
 800a380:	f8d4 30fd 	ldr.w	r3, [r4, #253]	@ 0xfd
        data += mlen;
 800a384:	44ab      	add	fp, r5
        len -= mlen;
 800a386:	eba8 0805 	sub.w	r8, r8, r5
        XOR( ctx->M_last, ctx->X );
 800a38a:	f8d4 5101 	ldr.w	r5, [r4, #257]	@ 0x101
 800a38e:	4069      	eors	r1, r5
 800a390:	f8c4 10f1 	str.w	r1, [r4, #241]	@ 0xf1
 800a394:	f8d4 1105 	ldr.w	r1, [r4, #261]	@ 0x105
 800a398:	4041      	eors	r1, r0
 800a39a:	f8c4 10f5 	str.w	r1, [r4, #245]	@ 0xf5
 800a39e:	f8d4 1109 	ldr.w	r1, [r4, #265]	@ 0x109
 800a3a2:	404a      	eors	r2, r1
 800a3a4:	f8c4 20f9 	str.w	r2, [r4, #249]	@ 0xf9
 800a3a8:	f8d4 210d 	ldr.w	r2, [r4, #269]	@ 0x10d
        memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800a3ac:	ae02      	add	r6, sp, #8
        XOR( ctx->M_last, ctx->X );
 800a3ae:	4053      	eors	r3, r2
        memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800a3b0:	f104 05f1 	add.w	r5, r4, #241	@ 0xf1
        XOR( ctx->M_last, ctx->X );
 800a3b4:	f8c4 30fd 	str.w	r3, [r4, #253]	@ 0xfd
        memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800a3b8:	4629      	mov	r1, r5
 800a3ba:	4630      	mov	r0, r6
 800a3bc:	2210      	movs	r2, #16
 800a3be:	f007 ff61 	bl	8012284 <memcpy1>
        lorawan_aes_encrypt( in, in, &ctx->rijndael );
 800a3c2:	4622      	mov	r2, r4
 800a3c4:	4631      	mov	r1, r6
 800a3c6:	4630      	mov	r0, r6
 800a3c8:	f000 fbc6 	bl	800ab58 <lorawan_aes_encrypt>
        memcpy1( &ctx->X[0], in, 16 );
 800a3cc:	4631      	mov	r1, r6
 800a3ce:	4628      	mov	r0, r5
 800a3d0:	2210      	movs	r2, #16
 800a3d2:	f007 ff57 	bl	8012284 <memcpy1>
        len -= mlen;
 800a3d6:	e710      	b.n	800a1fa <AES_CMAC_Update+0x1a>

0800a3d8 <AES_CMAC_Final>:

void AES_CMAC_Final( uint8_t digest[AES_CMAC_DIGEST_LENGTH], AES_CMAC_CTX* ctx )
{
 800a3d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a3dc:	b08f      	sub	sp, #60	@ 0x3c
 800a3de:	460c      	mov	r4, r1
    uint8_t K[16];
    uint8_t in[16];
    /* generate subkey K1 */
    memset1( K, '\0', 16 );
 800a3e0:	2210      	movs	r2, #16
 800a3e2:	2100      	movs	r1, #0
{
 800a3e4:	9001      	str	r0, [sp, #4]
    memset1( K, '\0', 16 );
 800a3e6:	a806      	add	r0, sp, #24
 800a3e8:	f007 ffa8 	bl	801233c <memset1>

    lorawan_aes_encrypt( K, K, &ctx->rijndael );
 800a3ec:	a906      	add	r1, sp, #24
 800a3ee:	4622      	mov	r2, r4
 800a3f0:	4608      	mov	r0, r1
 800a3f2:	f000 fbb1 	bl	800ab58 <lorawan_aes_encrypt>

    if( K[0] & 0x80 )
 800a3f6:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 800a3fa:	f89d c018 	ldrb.w	ip, [sp, #24]
 800a3fe:	2b00      	cmp	r3, #0
 800a400:	f2c0 81b2 	blt.w	800a768 <AES_CMAC_Final+0x390>
    {
        LSHIFT( K, K );
        K[15] ^= 0x87;
    }
    else
        LSHIFT( K, K );
 800a404:	2300      	movs	r3, #0
 800a406:	f89d 6019 	ldrb.w	r6, [sp, #25]
 800a40a:	f89d 901d 	ldrb.w	r9, [sp, #29]
 800a40e:	f89d b01c 	ldrb.w	fp, [sp, #28]
 800a412:	f89d 201f 	ldrb.w	r2, [sp, #31]
 800a416:	9203      	str	r2, [sp, #12]
 800a418:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800a41c:	4619      	mov	r1, r3
 800a41e:	f36c 0107 	bfi	r1, ip, #0, #8
 800a422:	ea4f 1cd6 	mov.w	ip, r6, lsr #7
 800a426:	0076      	lsls	r6, r6, #1
 800a428:	461a      	mov	r2, r3
 800a42a:	f366 210f 	bfi	r1, r6, #8, #8
 800a42e:	ea4f 16d9 	mov.w	r6, r9, lsr #7
 800a432:	f89d a020 	ldrb.w	sl, [sp, #32]
 800a436:	f89d 801a 	ldrb.w	r8, [sp, #26]
 800a43a:	f89d 701e 	ldrb.w	r7, [sp, #30]
 800a43e:	f89d e021 	ldrb.w	lr, [sp, #33]	@ 0x21
 800a442:	f89d 001b 	ldrb.w	r0, [sp, #27]
 800a446:	9002      	str	r0, [sp, #8]
 800a448:	461d      	mov	r5, r3
 800a44a:	f366 0207 	bfi	r2, r6, #0, #8
 800a44e:	ea4f 064b 	mov.w	r6, fp, lsl #1
 800a452:	ea4f 0949 	mov.w	r9, r9, lsl #1
 800a456:	f366 0507 	bfi	r5, r6, #0, #8
 800a45a:	f89d 0022 	ldrb.w	r0, [sp, #34]	@ 0x22
 800a45e:	f369 250f 	bfi	r5, r9, #8, #8
 800a462:	ea4f 16db 	mov.w	r6, fp, lsr #7
 800a466:	ea4f 094a 	mov.w	r9, sl, lsl #1
 800a46a:	ea4f 1bd8 	mov.w	fp, r8, lsr #7
 800a46e:	ea4f 0848 	mov.w	r8, r8, lsl #1
 800a472:	ea49 19de 	orr.w	r9, r9, lr, lsr #7
 800a476:	f368 4117 	bfi	r1, r8, #16, #8
 800a47a:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800a47e:	ea4f 18d7 	mov.w	r8, r7, lsr #7
 800a482:	007f      	lsls	r7, r7, #1
 800a484:	f36c 0307 	bfi	r3, ip, #0, #8
 800a488:	ea4e 1ed0 	orr.w	lr, lr, r0, lsr #7
 800a48c:	ea4f 0c40 	mov.w	ip, r0, lsl #1
 800a490:	f367 4517 	bfi	r5, r7, #16, #8
 800a494:	f89d 0023 	ldrb.w	r0, [sp, #35]	@ 0x23
 800a498:	2700      	movs	r7, #0
 800a49a:	f369 0707 	bfi	r7, r9, #0, #8
 800a49e:	ea4c 1cd0 	orr.w	ip, ip, r0, lsr #7
 800a4a2:	f36e 270f 	bfi	r7, lr, #8, #8
 800a4a6:	f36c 4717 	bfi	r7, ip, #16, #8
 800a4aa:	f89d c024 	ldrb.w	ip, [sp, #36]	@ 0x24
 800a4ae:	0040      	lsls	r0, r0, #1
 800a4b0:	ea40 10dc 	orr.w	r0, r0, ip, lsr #7
 800a4b4:	f360 671f 	bfi	r7, r0, #24, #8
 800a4b8:	f89d 0025 	ldrb.w	r0, [sp, #37]	@ 0x25
 800a4bc:	9708      	str	r7, [sp, #32]
 800a4be:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800a4c2:	f89d 7026 	ldrb.w	r7, [sp, #38]	@ 0x26
 800a4c6:	ea4c 1cd0 	orr.w	ip, ip, r0, lsr #7
 800a4ca:	0040      	lsls	r0, r0, #1
 800a4cc:	ea40 10d7 	orr.w	r0, r0, r7, lsr #7
 800a4d0:	f88d 0025 	strb.w	r0, [sp, #37]	@ 0x25
 800a4d4:	9802      	ldr	r0, [sp, #8]
 800a4d6:	f88d c024 	strb.w	ip, [sp, #36]	@ 0x24
 800a4da:	09c0      	lsrs	r0, r0, #7
 800a4dc:	f36b 230f 	bfi	r3, fp, #8, #8
 800a4e0:	f360 4317 	bfi	r3, r0, #16, #8
 800a4e4:	9802      	ldr	r0, [sp, #8]
 800a4e6:	0040      	lsls	r0, r0, #1
 800a4e8:	f360 611f 	bfi	r1, r0, #24, #8
 800a4ec:	f366 631f 	bfi	r3, r6, #24, #8
 800a4f0:	430b      	orrs	r3, r1
 800a4f2:	9903      	ldr	r1, [sp, #12]
 800a4f4:	9306      	str	r3, [sp, #24]
 800a4f6:	f368 220f 	bfi	r2, r8, #8, #8
 800a4fa:	09cb      	lsrs	r3, r1, #7
 800a4fc:	f89d 0027 	ldrb.w	r0, [sp, #39]	@ 0x27
 800a500:	f363 4217 	bfi	r2, r3, #16, #8
 800a504:	ea4f 1ada 	mov.w	sl, sl, lsr #7
 800a508:	004b      	lsls	r3, r1, #1
 800a50a:	f363 651f 	bfi	r5, r3, #24, #8
 800a50e:	007f      	lsls	r7, r7, #1
 800a510:	f36a 621f 	bfi	r2, sl, #24, #8
 800a514:	432a      	orrs	r2, r5
 800a516:	ea47 15d0 	orr.w	r5, r7, r0, lsr #7
 800a51a:	0040      	lsls	r0, r0, #1
 800a51c:	9207      	str	r2, [sp, #28]
 800a51e:	b2ed      	uxtb	r5, r5
 800a520:	b2c0      	uxtb	r0, r0

    if( ctx->M_n == 16 )
 800a522:	f8d4 2114 	ldr.w	r2, [r4, #276]	@ 0x114
        XOR( K, ctx->M_last );
    }
    else
    {
        /* generate subkey K2 */
        if( K[0] & 0x80 )
 800a526:	f89d 3018 	ldrb.w	r3, [sp, #24]
        LSHIFT( K, K );
 800a52a:	f88d 5026 	strb.w	r5, [sp, #38]	@ 0x26
    if( ctx->M_n == 16 )
 800a52e:	2a10      	cmp	r2, #16
        K[15] ^= 0x87;
 800a530:	f88d 0027 	strb.w	r0, [sp, #39]	@ 0x27
    if( ctx->M_n == 16 )
 800a534:	f000 80bd 	beq.w	800a6b2 <AES_CMAC_Final+0x2da>
        {
            LSHIFT( K, K );
 800a538:	f89d 101a 	ldrb.w	r1, [sp, #26]
 800a53c:	9102      	str	r1, [sp, #8]
 800a53e:	f89d a019 	ldrb.w	sl, [sp, #25]
 800a542:	f89d 501e 	ldrb.w	r5, [sp, #30]
 800a546:	f89d e01f 	ldrb.w	lr, [sp, #31]
 800a54a:	9503      	str	r5, [sp, #12]
 800a54c:	2100      	movs	r1, #0
 800a54e:	460e      	mov	r6, r1
        if( K[0] & 0x80 )
 800a550:	f013 0f80 	tst.w	r3, #128	@ 0x80
            LSHIFT( K, K );
 800a554:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800a558:	f363 0607 	bfi	r6, r3, #0, #8
 800a55c:	ea4f 13da 	mov.w	r3, sl, lsr #7
 800a560:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
 800a564:	f36a 260f 	bfi	r6, sl, #8, #8
 800a568:	f8dd a008 	ldr.w	sl, [sp, #8]
 800a56c:	f8cd e014 	str.w	lr, [sp, #20]
 800a570:	460d      	mov	r5, r1
 800a572:	468e      	mov	lr, r1
 800a574:	ea4f 1ada 	mov.w	sl, sl, lsr #7
 800a578:	f363 0107 	bfi	r1, r3, #0, #8
 800a57c:	f36a 210f 	bfi	r1, sl, #8, #8
 800a580:	f8dd a008 	ldr.w	sl, [sp, #8]
 800a584:	f89d 901d 	ldrb.w	r9, [sp, #29]
 800a588:	f89d b01c 	ldrb.w	fp, [sp, #28]
 800a58c:	f89d 8020 	ldrb.w	r8, [sp, #32]
 800a590:	f89d c021 	ldrb.w	ip, [sp, #33]	@ 0x21
 800a594:	f89d 701b 	ldrb.w	r7, [sp, #27]
 800a598:	9704      	str	r7, [sp, #16]
 800a59a:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
 800a59e:	f36a 4617 	bfi	r6, sl, #16, #8
 800a5a2:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800a5a6:	f89d 7022 	ldrb.w	r7, [sp, #34]	@ 0x22
 800a5aa:	ea4f 13d9 	mov.w	r3, r9, lsr #7
 800a5ae:	f363 0507 	bfi	r5, r3, #0, #8
 800a5b2:	ea4f 1ada 	mov.w	sl, sl, lsr #7
 800a5b6:	ea4f 034b 	mov.w	r3, fp, lsl #1
 800a5ba:	f36a 250f 	bfi	r5, sl, #8, #8
 800a5be:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800a5c2:	ea4f 0949 	mov.w	r9, r9, lsl #1
 800a5c6:	f363 0e07 	bfi	lr, r3, #0, #8
 800a5ca:	f369 2e0f 	bfi	lr, r9, #8, #8
 800a5ce:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
 800a5d2:	ea4f 0948 	mov.w	r9, r8, lsl #1
 800a5d6:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
 800a5da:	ea49 19dc 	orr.w	r9, r9, ip, lsr #7
 800a5de:	f36a 4e17 	bfi	lr, sl, #16, #8
 800a5e2:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800a5e6:	f04f 0a00 	mov.w	sl, #0
 800a5ea:	ea4c 1cd7 	orr.w	ip, ip, r7, lsr #7
 800a5ee:	f369 0a07 	bfi	sl, r9, #0, #8
 800a5f2:	ea4f 0747 	mov.w	r7, r7, lsl #1
 800a5f6:	ea47 17d3 	orr.w	r7, r7, r3, lsr #7
 800a5fa:	f36c 2a0f 	bfi	sl, ip, #8, #8
 800a5fe:	f367 4a17 	bfi	sl, r7, #16, #8
 800a602:	f89d 7024 	ldrb.w	r7, [sp, #36]	@ 0x24
 800a606:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800a60a:	ea43 13d7 	orr.w	r3, r3, r7, lsr #7
 800a60e:	f363 6a1f 	bfi	sl, r3, #24, #8
 800a612:	ea4f 1bdb 	mov.w	fp, fp, lsr #7
 800a616:	ea4f 18d8 	mov.w	r8, r8, lsr #7
 800a61a:	f8cd a020 	str.w	sl, [sp, #32]
        if( K[0] & 0x80 )
 800a61e:	f040 808f 	bne.w	800a740 <AES_CMAC_Final+0x368>
            K[15] ^= 0x87;
        }
        else
            LSHIFT( K, K );
 800a622:	f89d c025 	ldrb.w	ip, [sp, #37]	@ 0x25
 800a626:	007f      	lsls	r7, r7, #1
 800a628:	ea47 13dc 	orr.w	r3, r7, ip, lsr #7
 800a62c:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
 800a630:	f89d 3026 	ldrb.w	r3, [sp, #38]	@ 0x26
 800a634:	ea4f 074c 	mov.w	r7, ip, lsl #1
 800a638:	ea47 17d3 	orr.w	r7, r7, r3, lsr #7
 800a63c:	005b      	lsls	r3, r3, #1
 800a63e:	ea43 13d0 	orr.w	r3, r3, r0, lsr #7
 800a642:	0040      	lsls	r0, r0, #1
 800a644:	f8dd 9010 	ldr.w	r9, [sp, #16]
 800a648:	ea4f 1cd9 	mov.w	ip, r9, lsr #7
 800a64c:	f36c 4117 	bfi	r1, ip, #16, #8
 800a650:	ea4f 0c49 	mov.w	ip, r9, lsl #1
 800a654:	f36c 661f 	bfi	r6, ip, #24, #8
 800a658:	f36b 611f 	bfi	r1, fp, #24, #8
 800a65c:	4331      	orrs	r1, r6
 800a65e:	9e05      	ldr	r6, [sp, #20]
 800a660:	9106      	str	r1, [sp, #24]
 800a662:	b2db      	uxtb	r3, r3
 800a664:	09f1      	lsrs	r1, r6, #7
 800a666:	f361 4517 	bfi	r5, r1, #16, #8
            LSHIFT( K, K );
 800a66a:	f88d 3026 	strb.w	r3, [sp, #38]	@ 0x26
            LSHIFT( K, K );
 800a66e:	0071      	lsls	r1, r6, #1

        /* padding(M_last) */
        ctx->M_last[ctx->M_n] = 0x80;
 800a670:	18a3      	adds	r3, r4, r2
 800a672:	f361 6e1f 	bfi	lr, r1, #24, #8
 800a676:	2180      	movs	r1, #128	@ 0x80
 800a678:	f883 1101 	strb.w	r1, [r3, #257]	@ 0x101
 800a67c:	f368 651f 	bfi	r5, r8, #24, #8
        while( ++ctx->M_n < 16 )
 800a680:	1c53      	adds	r3, r2, #1
            LSHIFT( K, K );
 800a682:	b2ff      	uxtb	r7, r7
 800a684:	b2c0      	uxtb	r0, r0
 800a686:	ea45 050e 	orr.w	r5, r5, lr
        while( ++ctx->M_n < 16 )
 800a68a:	2b0f      	cmp	r3, #15
            LSHIFT( K, K );
 800a68c:	9507      	str	r5, [sp, #28]
            LSHIFT( K, K );
 800a68e:	f88d 7025 	strb.w	r7, [sp, #37]	@ 0x25
            K[15] ^= 0x87;
 800a692:	f88d 0027 	strb.w	r0, [sp, #39]	@ 0x27
        while( ++ctx->M_n < 16 )
 800a696:	f8c4 3114 	str.w	r3, [r4, #276]	@ 0x114
 800a69a:	d80a      	bhi.n	800a6b2 <AES_CMAC_Final+0x2da>
            ctx->M_last[ctx->M_n] = 0;
 800a69c:	f502 7081 	add.w	r0, r2, #258	@ 0x102
 800a6a0:	4420      	add	r0, r4
 800a6a2:	f1c2 020f 	rsb	r2, r2, #15
 800a6a6:	2100      	movs	r1, #0
 800a6a8:	f00b fd0e 	bl	80160c8 <memset>
 800a6ac:	2310      	movs	r3, #16
 800a6ae:	f8c4 3114 	str.w	r3, [r4, #276]	@ 0x114
        XOR( K, ctx->M_last );
 800a6b2:	f8d4 2101 	ldr.w	r2, [r4, #257]	@ 0x101
 800a6b6:	9b06      	ldr	r3, [sp, #24]
 800a6b8:	9907      	ldr	r1, [sp, #28]
 800a6ba:	405a      	eors	r2, r3
 800a6bc:	f8d4 3105 	ldr.w	r3, [r4, #261]	@ 0x105
 800a6c0:	f8c4 2101 	str.w	r2, [r4, #257]	@ 0x101
 800a6c4:	404b      	eors	r3, r1
 800a6c6:	f8d4 2109 	ldr.w	r2, [r4, #265]	@ 0x109
 800a6ca:	f8c4 3105 	str.w	r3, [r4, #261]	@ 0x105
 800a6ce:	9b08      	ldr	r3, [sp, #32]

        XOR( K, ctx->M_last );
    }
    XOR( ctx->M_last, ctx->X );
 800a6d0:	f8d4 10f5 	ldr.w	r1, [r4, #245]	@ 0xf5
 800a6d4:	f8d4 0105 	ldr.w	r0, [r4, #261]	@ 0x105
        XOR( K, ctx->M_last );
 800a6d8:	405a      	eors	r2, r3
 800a6da:	f8c4 2109 	str.w	r2, [r4, #265]	@ 0x109
 800a6de:	f8d4 310d 	ldr.w	r3, [r4, #269]	@ 0x10d
 800a6e2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800a6e4:	4053      	eors	r3, r2
 800a6e6:	f8c4 310d 	str.w	r3, [r4, #269]	@ 0x10d
    XOR( ctx->M_last, ctx->X );
 800a6ea:	f8d4 2101 	ldr.w	r2, [r4, #257]	@ 0x101
 800a6ee:	f8d4 30f1 	ldr.w	r3, [r4, #241]	@ 0xf1
 800a6f2:	4041      	eors	r1, r0
 800a6f4:	4053      	eors	r3, r2
 800a6f6:	f8c4 10f5 	str.w	r1, [r4, #245]	@ 0xf5
 800a6fa:	f8d4 20f9 	ldr.w	r2, [r4, #249]	@ 0xf9
 800a6fe:	f8d4 1109 	ldr.w	r1, [r4, #265]	@ 0x109
 800a702:	f8c4 30f1 	str.w	r3, [r4, #241]	@ 0xf1
 800a706:	404a      	eors	r2, r1
 800a708:	f8d4 30fd 	ldr.w	r3, [r4, #253]	@ 0xfd
 800a70c:	f8c4 20f9 	str.w	r2, [r4, #249]	@ 0xf9
 800a710:	f8d4 210d 	ldr.w	r2, [r4, #269]	@ 0x10d
 800a714:	4053      	eors	r3, r2
 800a716:	f8c4 30fd 	str.w	r3, [r4, #253]	@ 0xfd

    memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800a71a:	f104 01f1 	add.w	r1, r4, #241	@ 0xf1
 800a71e:	a80a      	add	r0, sp, #40	@ 0x28
 800a720:	2210      	movs	r2, #16
 800a722:	f007 fdaf 	bl	8012284 <memcpy1>
    lorawan_aes_encrypt( in, digest, &ctx->rijndael );
 800a726:	9901      	ldr	r1, [sp, #4]
 800a728:	4622      	mov	r2, r4
 800a72a:	a80a      	add	r0, sp, #40	@ 0x28
 800a72c:	f000 fa14 	bl	800ab58 <lorawan_aes_encrypt>
    memset1( K, 0, sizeof K );
 800a730:	2210      	movs	r2, #16
 800a732:	2100      	movs	r1, #0
 800a734:	a806      	add	r0, sp, #24
 800a736:	f007 fe01 	bl	801233c <memset1>
}
 800a73a:	b00f      	add	sp, #60	@ 0x3c
 800a73c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            LSHIFT( K, K );
 800a740:	f89d c025 	ldrb.w	ip, [sp, #37]	@ 0x25
 800a744:	007b      	lsls	r3, r7, #1
 800a746:	ea43 13dc 	orr.w	r3, r3, ip, lsr #7
 800a74a:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
 800a74e:	f89d 3026 	ldrb.w	r3, [sp, #38]	@ 0x26
 800a752:	ea4f 074c 	mov.w	r7, ip, lsl #1
 800a756:	ea47 17d3 	orr.w	r7, r7, r3, lsr #7
 800a75a:	005b      	lsls	r3, r3, #1
 800a75c:	ea43 13d0 	orr.w	r3, r3, r0, lsr #7
 800a760:	0040      	lsls	r0, r0, #1
            K[15] ^= 0x87;
 800a762:	f080 0087 	eor.w	r0, r0, #135	@ 0x87
 800a766:	e76d      	b.n	800a644 <AES_CMAC_Final+0x26c>
        LSHIFT( K, K );
 800a768:	2300      	movs	r3, #0
 800a76a:	f89d 9019 	ldrb.w	r9, [sp, #25]
 800a76e:	f89d 501d 	ldrb.w	r5, [sp, #29]
 800a772:	f89d b01c 	ldrb.w	fp, [sp, #28]
 800a776:	f89d 201b 	ldrb.w	r2, [sp, #27]
 800a77a:	f89d a020 	ldrb.w	sl, [sp, #32]
 800a77e:	f89d 801a 	ldrb.w	r8, [sp, #26]
 800a782:	9202      	str	r2, [sp, #8]
 800a784:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800a788:	4619      	mov	r1, r3
 800a78a:	f36c 0107 	bfi	r1, ip, #0, #8
 800a78e:	ea4f 1cd9 	mov.w	ip, r9, lsr #7
 800a792:	461a      	mov	r2, r3
 800a794:	461f      	mov	r7, r3
 800a796:	f36c 0307 	bfi	r3, ip, #0, #8
 800a79a:	ea4f 1cd5 	mov.w	ip, r5, lsr #7
 800a79e:	f89d e01e 	ldrb.w	lr, [sp, #30]
 800a7a2:	f89d 6021 	ldrb.w	r6, [sp, #33]	@ 0x21
 800a7a6:	f89d 001f 	ldrb.w	r0, [sp, #31]
 800a7aa:	9003      	str	r0, [sp, #12]
 800a7ac:	ea4f 0949 	mov.w	r9, r9, lsl #1
 800a7b0:	f36c 0207 	bfi	r2, ip, #0, #8
 800a7b4:	ea4f 0c4b 	mov.w	ip, fp, lsl #1
 800a7b8:	f89d 0022 	ldrb.w	r0, [sp, #34]	@ 0x22
 800a7bc:	f369 210f 	bfi	r1, r9, #8, #8
 800a7c0:	006d      	lsls	r5, r5, #1
 800a7c2:	f36c 0707 	bfi	r7, ip, #0, #8
 800a7c6:	ea4f 094a 	mov.w	r9, sl, lsl #1
 800a7ca:	ea4f 1cdb 	mov.w	ip, fp, lsr #7
 800a7ce:	ea4f 1bd8 	mov.w	fp, r8, lsr #7
 800a7d2:	ea4f 0848 	mov.w	r8, r8, lsl #1
 800a7d6:	f365 270f 	bfi	r7, r5, #8, #8
 800a7da:	ea49 19d6 	orr.w	r9, r9, r6, lsr #7
 800a7de:	f368 4117 	bfi	r1, r8, #16, #8
 800a7e2:	0076      	lsls	r6, r6, #1
 800a7e4:	ea4f 18de 	mov.w	r8, lr, lsr #7
 800a7e8:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800a7ec:	ea46 16d0 	orr.w	r6, r6, r0, lsr #7
 800a7f0:	0045      	lsls	r5, r0, #1
 800a7f2:	f36e 4717 	bfi	r7, lr, #16, #8
 800a7f6:	f89d 0023 	ldrb.w	r0, [sp, #35]	@ 0x23
 800a7fa:	f04f 0e00 	mov.w	lr, #0
 800a7fe:	f369 0e07 	bfi	lr, r9, #0, #8
 800a802:	ea45 15d0 	orr.w	r5, r5, r0, lsr #7
 800a806:	f366 2e0f 	bfi	lr, r6, #8, #8
 800a80a:	f365 4e17 	bfi	lr, r5, #16, #8
 800a80e:	9e02      	ldr	r6, [sp, #8]
 800a810:	f89d 5024 	ldrb.w	r5, [sp, #36]	@ 0x24
 800a814:	0040      	lsls	r0, r0, #1
 800a816:	ea40 10d5 	orr.w	r0, r0, r5, lsr #7
 800a81a:	09f6      	lsrs	r6, r6, #7
 800a81c:	f36b 230f 	bfi	r3, fp, #8, #8
 800a820:	f360 6e1f 	bfi	lr, r0, #24, #8
 800a824:	f366 4317 	bfi	r3, r6, #16, #8
 800a828:	f89d 0025 	ldrb.w	r0, [sp, #37]	@ 0x25
 800a82c:	9e02      	ldr	r6, [sp, #8]
 800a82e:	f8cd e020 	str.w	lr, [sp, #32]
 800a832:	006d      	lsls	r5, r5, #1
 800a834:	ea45 15d0 	orr.w	r5, r5, r0, lsr #7
 800a838:	0076      	lsls	r6, r6, #1
 800a83a:	f366 611f 	bfi	r1, r6, #24, #8
 800a83e:	f88d 5024 	strb.w	r5, [sp, #36]	@ 0x24
 800a842:	f36c 631f 	bfi	r3, ip, #24, #8
 800a846:	0045      	lsls	r5, r0, #1
 800a848:	f89d 0026 	ldrb.w	r0, [sp, #38]	@ 0x26
 800a84c:	430b      	orrs	r3, r1
 800a84e:	9903      	ldr	r1, [sp, #12]
 800a850:	9306      	str	r3, [sp, #24]
 800a852:	ea45 15d0 	orr.w	r5, r5, r0, lsr #7
 800a856:	09cb      	lsrs	r3, r1, #7
 800a858:	f368 220f 	bfi	r2, r8, #8, #8
 800a85c:	f88d 5025 	strb.w	r5, [sp, #37]	@ 0x25
 800a860:	0045      	lsls	r5, r0, #1
 800a862:	f89d 0027 	ldrb.w	r0, [sp, #39]	@ 0x27
 800a866:	f363 4217 	bfi	r2, r3, #16, #8
 800a86a:	ea4f 1ada 	mov.w	sl, sl, lsr #7
 800a86e:	004b      	lsls	r3, r1, #1
 800a870:	ea45 15d0 	orr.w	r5, r5, r0, lsr #7
 800a874:	f36a 621f 	bfi	r2, sl, #24, #8
 800a878:	0040      	lsls	r0, r0, #1
 800a87a:	f363 671f 	bfi	r7, r3, #24, #8
        K[15] ^= 0x87;
 800a87e:	f080 0087 	eor.w	r0, r0, #135	@ 0x87
        LSHIFT( K, K );
 800a882:	433a      	orrs	r2, r7
 800a884:	b2ed      	uxtb	r5, r5
        K[15] ^= 0x87;
 800a886:	b2c0      	uxtb	r0, r0
        LSHIFT( K, K );
 800a888:	9207      	str	r2, [sp, #28]
        K[15] ^= 0x87;
 800a88a:	e64a      	b.n	800a522 <AES_CMAC_Final+0x14a>

0800a88c <copy_and_key>:
    ((uint32_t*)d)[ 0] = ((uint32_t*)s)[ 0] ^ ((uint32_t*)k)[ 0];
    ((uint32_t*)d)[ 1] = ((uint32_t*)s)[ 1] ^ ((uint32_t*)k)[ 1];
    ((uint32_t*)d)[ 2] = ((uint32_t*)s)[ 2] ^ ((uint32_t*)k)[ 2];
    ((uint32_t*)d)[ 3] = ((uint32_t*)s)[ 3] ^ ((uint32_t*)k)[ 3];
#elif 1
    ((uint8_t*)d)[ 0] = ((uint8_t*)s)[ 0] ^ ((uint8_t*)k)[ 0];
 800a88c:	f892 c000 	ldrb.w	ip, [r2]
 800a890:	780b      	ldrb	r3, [r1, #0]
 800a892:	ea83 030c 	eor.w	r3, r3, ip
 800a896:	7003      	strb	r3, [r0, #0]
    ((uint8_t*)d)[ 1] = ((uint8_t*)s)[ 1] ^ ((uint8_t*)k)[ 1];
 800a898:	f892 c001 	ldrb.w	ip, [r2, #1]
 800a89c:	784b      	ldrb	r3, [r1, #1]
 800a89e:	ea83 030c 	eor.w	r3, r3, ip
 800a8a2:	7043      	strb	r3, [r0, #1]
    ((uint8_t*)d)[ 2] = ((uint8_t*)s)[ 2] ^ ((uint8_t*)k)[ 2];
 800a8a4:	f892 c002 	ldrb.w	ip, [r2, #2]
 800a8a8:	788b      	ldrb	r3, [r1, #2]
 800a8aa:	ea83 030c 	eor.w	r3, r3, ip
 800a8ae:	7083      	strb	r3, [r0, #2]
    ((uint8_t*)d)[ 3] = ((uint8_t*)s)[ 3] ^ ((uint8_t*)k)[ 3];
 800a8b0:	f892 c003 	ldrb.w	ip, [r2, #3]
 800a8b4:	78cb      	ldrb	r3, [r1, #3]
 800a8b6:	ea83 030c 	eor.w	r3, r3, ip
 800a8ba:	70c3      	strb	r3, [r0, #3]
    ((uint8_t*)d)[ 4] = ((uint8_t*)s)[ 4] ^ ((uint8_t*)k)[ 4];
 800a8bc:	f892 c004 	ldrb.w	ip, [r2, #4]
 800a8c0:	790b      	ldrb	r3, [r1, #4]
 800a8c2:	ea83 030c 	eor.w	r3, r3, ip
 800a8c6:	7103      	strb	r3, [r0, #4]
    ((uint8_t*)d)[ 5] = ((uint8_t*)s)[ 5] ^ ((uint8_t*)k)[ 5];
 800a8c8:	f892 c005 	ldrb.w	ip, [r2, #5]
 800a8cc:	794b      	ldrb	r3, [r1, #5]
 800a8ce:	ea83 030c 	eor.w	r3, r3, ip
 800a8d2:	7143      	strb	r3, [r0, #5]
    ((uint8_t*)d)[ 6] = ((uint8_t*)s)[ 6] ^ ((uint8_t*)k)[ 6];
 800a8d4:	f892 c006 	ldrb.w	ip, [r2, #6]
 800a8d8:	798b      	ldrb	r3, [r1, #6]
 800a8da:	ea83 030c 	eor.w	r3, r3, ip
 800a8de:	7183      	strb	r3, [r0, #6]
    ((uint8_t*)d)[ 7] = ((uint8_t*)s)[ 7] ^ ((uint8_t*)k)[ 7];
 800a8e0:	f892 c007 	ldrb.w	ip, [r2, #7]
 800a8e4:	79cb      	ldrb	r3, [r1, #7]
 800a8e6:	ea83 030c 	eor.w	r3, r3, ip
 800a8ea:	71c3      	strb	r3, [r0, #7]
    ((uint8_t*)d)[ 8] = ((uint8_t*)s)[ 8] ^ ((uint8_t*)k)[ 8];
 800a8ec:	f892 c008 	ldrb.w	ip, [r2, #8]
 800a8f0:	7a0b      	ldrb	r3, [r1, #8]
 800a8f2:	ea83 030c 	eor.w	r3, r3, ip
 800a8f6:	7203      	strb	r3, [r0, #8]
    ((uint8_t*)d)[ 9] = ((uint8_t*)s)[ 9] ^ ((uint8_t*)k)[ 9];
 800a8f8:	f892 c009 	ldrb.w	ip, [r2, #9]
 800a8fc:	7a4b      	ldrb	r3, [r1, #9]
 800a8fe:	ea83 030c 	eor.w	r3, r3, ip
 800a902:	7243      	strb	r3, [r0, #9]
    ((uint8_t*)d)[10] = ((uint8_t*)s)[10] ^ ((uint8_t*)k)[10];
 800a904:	f892 c00a 	ldrb.w	ip, [r2, #10]
 800a908:	7a8b      	ldrb	r3, [r1, #10]
 800a90a:	ea83 030c 	eor.w	r3, r3, ip
 800a90e:	7283      	strb	r3, [r0, #10]
    ((uint8_t*)d)[11] = ((uint8_t*)s)[11] ^ ((uint8_t*)k)[11];
 800a910:	f892 c00b 	ldrb.w	ip, [r2, #11]
 800a914:	7acb      	ldrb	r3, [r1, #11]
 800a916:	ea83 030c 	eor.w	r3, r3, ip
 800a91a:	72c3      	strb	r3, [r0, #11]
    ((uint8_t*)d)[12] = ((uint8_t*)s)[12] ^ ((uint8_t*)k)[12];
 800a91c:	f892 c00c 	ldrb.w	ip, [r2, #12]
 800a920:	7b0b      	ldrb	r3, [r1, #12]
 800a922:	ea83 030c 	eor.w	r3, r3, ip
 800a926:	7303      	strb	r3, [r0, #12]
    ((uint8_t*)d)[13] = ((uint8_t*)s)[13] ^ ((uint8_t*)k)[13];
 800a928:	f892 c00d 	ldrb.w	ip, [r2, #13]
 800a92c:	7b4b      	ldrb	r3, [r1, #13]
 800a92e:	ea83 030c 	eor.w	r3, r3, ip
 800a932:	7343      	strb	r3, [r0, #13]
    ((uint8_t*)d)[14] = ((uint8_t*)s)[14] ^ ((uint8_t*)k)[14];
 800a934:	f892 c00e 	ldrb.w	ip, [r2, #14]
 800a938:	7b8b      	ldrb	r3, [r1, #14]
 800a93a:	ea83 030c 	eor.w	r3, r3, ip
 800a93e:	7383      	strb	r3, [r0, #14]
    ((uint8_t*)d)[15] = ((uint8_t*)s)[15] ^ ((uint8_t*)k)[15];
 800a940:	7bcb      	ldrb	r3, [r1, #15]
 800a942:	7bd2      	ldrb	r2, [r2, #15]
 800a944:	4053      	eors	r3, r2
 800a946:	73c3      	strb	r3, [r0, #15]
#else
    block_copy(d, s);
    xor_block(d, k);
#endif
}
 800a948:	4770      	bx	lr
 800a94a:	bf00      	nop

0800a94c <lorawan_aes_set_key>:

return_type lorawan_aes_set_key( const uint8_t key[], length_type keylen, lorawan_aes_context ctx[1] )
{
    uint8_t cc, rc, hi;

    switch( keylen )
 800a94c:	f1a1 0310 	sub.w	r3, r1, #16
 800a950:	b2db      	uxtb	r3, r3
 800a952:	2b10      	cmp	r3, #16
 800a954:	f200 80f7 	bhi.w	800ab46 <lorawan_aes_set_key+0x1fa>
{
 800a958:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    switch( keylen )
 800a95c:	4c7c      	ldr	r4, [pc, #496]	@ (800ab50 <lorawan_aes_set_key+0x204>)
 800a95e:	fa24 f303 	lsr.w	r3, r4, r3
 800a962:	07db      	lsls	r3, r3, #31
 800a964:	d405      	bmi.n	800a972 <lorawan_aes_set_key+0x26>
    case 16:
    case 24:
    case 32:
        break;
    default:
        ctx->rnd = 0;
 800a966:	2300      	movs	r3, #0
 800a968:	f882 30f0 	strb.w	r3, [r2, #240]	@ 0xf0
        return ( uint8_t )-1;
 800a96c:	20ff      	movs	r0, #255	@ 0xff
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
    }
    return 0;
}
 800a96e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while( nn-- )
 800a972:	1c43      	adds	r3, r0, #1
 800a974:	1ad4      	subs	r4, r2, r3
 800a976:	2c02      	cmp	r4, #2
 800a978:	d85a      	bhi.n	800aa30 <lorawan_aes_set_key+0xe4>
 800a97a:	1e54      	subs	r4, r2, #1
 800a97c:	4408      	add	r0, r1
 800a97e:	e000      	b.n	800a982 <lorawan_aes_set_key+0x36>
 800a980:	3301      	adds	r3, #1
        *d++ = *s++;
 800a982:	f813 5c01 	ldrb.w	r5, [r3, #-1]
 800a986:	f804 5f01 	strb.w	r5, [r4, #1]!
    while( nn-- )
 800a98a:	4283      	cmp	r3, r0
 800a98c:	d1f8      	bne.n	800a980 <lorawan_aes_set_key+0x34>
    hi = (keylen + 28) << 2;
 800a98e:	f101 071c 	add.w	r7, r1, #28
 800a992:	00bf      	lsls	r7, r7, #2
    ctx->rnd = (hi >> 4) - 1;
 800a994:	f3c7 1303 	ubfx	r3, r7, #4, #4
 800a998:	3b01      	subs	r3, #1
 800a99a:	2918      	cmp	r1, #24
 800a99c:	f882 30f0 	strb.w	r3, [r2, #240]	@ 0xf0
    hi = (keylen + 28) << 2;
 800a9a0:	b2ff      	uxtb	r7, r7
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800a9a2:	d862      	bhi.n	800aa6a <lorawan_aes_set_key+0x11e>
 800a9a4:	1850      	adds	r0, r2, r1
            t0 = s_box(t1) ^ rc;
 800a9a6:	f8df 91ac 	ldr.w	r9, [pc, #428]	@ 800ab54 <lorawan_aes_set_key+0x208>
 800a9aa:	f810 8c01 	ldrb.w	r8, [r0, #-1]
 800a9ae:	f810 ec02 	ldrb.w	lr, [r0, #-2]
 800a9b2:	f810 cc03 	ldrb.w	ip, [r0, #-3]
 800a9b6:	f810 6c04 	ldrb.w	r6, [r0, #-4]
    ctx->rnd = (hi >> 4) - 1;
 800a9ba:	460b      	mov	r3, r1
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800a9bc:	2501      	movs	r5, #1
        if( cc % keylen == 0 )
 800a9be:	fbb3 f4f1 	udiv	r4, r3, r1
 800a9c2:	fb01 3414 	mls	r4, r1, r4, r3
 800a9c6:	b2e4      	uxtb	r4, r4
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800a9c8:	3304      	adds	r3, #4
 800a9ca:	b2db      	uxtb	r3, r3
            rc = f2(rc);
 800a9cc:	ea4f 1ad5 	mov.w	sl, r5, lsr #7
        if( cc % keylen == 0 )
 800a9d0:	b99c      	cbnz	r4, 800a9fa <lorawan_aes_set_key+0xae>
            t0 = s_box(t1) ^ rc;
 800a9d2:	f819 400c 	ldrb.w	r4, [r9, ip]
            t1 = s_box(t2);
 800a9d6:	f819 c00e 	ldrb.w	ip, [r9, lr]
            t2 = s_box(t3);
 800a9da:	f819 e008 	ldrb.w	lr, [r9, r8]
            t3 = s_box(tt);
 800a9de:	f819 8006 	ldrb.w	r8, [r9, r6]
            rc = f2(rc);
 800a9e2:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
            t0 = s_box(t1) ^ rc;
 800a9e6:	406c      	eors	r4, r5
            rc = f2(rc);
 800a9e8:	eb0a 0aca 	add.w	sl, sl, sl, lsl #3
 800a9ec:	006d      	lsls	r5, r5, #1
 800a9ee:	fa5f fa8a 	uxtb.w	sl, sl
 800a9f2:	b2ed      	uxtb	r5, r5
 800a9f4:	ea8a 0505 	eor.w	r5, sl, r5
            t0 = s_box(t1) ^ rc;
 800a9f8:	4626      	mov	r6, r4
        ctx->ksch[cc + 0] = ctx->ksch[tt + 0] ^ t0;
 800a9fa:	7814      	ldrb	r4, [r2, #0]
 800a9fc:	4066      	eors	r6, r4
 800a9fe:	7006      	strb	r6, [r0, #0]
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
 800aa00:	7854      	ldrb	r4, [r2, #1]
 800aa02:	ea8c 0c04 	eor.w	ip, ip, r4
 800aa06:	f880 c001 	strb.w	ip, [r0, #1]
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
 800aa0a:	7894      	ldrb	r4, [r2, #2]
 800aa0c:	ea8e 0e04 	eor.w	lr, lr, r4
 800aa10:	f880 e002 	strb.w	lr, [r0, #2]
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800aa14:	78d4      	ldrb	r4, [r2, #3]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800aa16:	429f      	cmp	r7, r3
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800aa18:	ea88 0804 	eor.w	r8, r8, r4
 800aa1c:	f880 8003 	strb.w	r8, [r0, #3]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800aa20:	f102 0204 	add.w	r2, r2, #4
 800aa24:	f100 0004 	add.w	r0, r0, #4
 800aa28:	d8c9      	bhi.n	800a9be <lorawan_aes_set_key+0x72>
    return 0;
 800aa2a:	2000      	movs	r0, #0
}
 800aa2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        *d++ = *s++;
 800aa30:	6803      	ldr	r3, [r0, #0]
 800aa32:	6013      	str	r3, [r2, #0]
 800aa34:	6843      	ldr	r3, [r0, #4]
 800aa36:	6053      	str	r3, [r2, #4]
 800aa38:	6883      	ldr	r3, [r0, #8]
 800aa3a:	6093      	str	r3, [r2, #8]
 800aa3c:	088b      	lsrs	r3, r1, #2
 800aa3e:	68c4      	ldr	r4, [r0, #12]
 800aa40:	60d4      	str	r4, [r2, #12]
    while( nn-- )
 800aa42:	2b04      	cmp	r3, #4
 800aa44:	d05f      	beq.n	800ab06 <lorawan_aes_set_key+0x1ba>
        *d++ = *s++;
 800aa46:	6904      	ldr	r4, [r0, #16]
 800aa48:	6114      	str	r4, [r2, #16]
    while( nn-- )
 800aa4a:	2b05      	cmp	r3, #5
 800aa4c:	d05b      	beq.n	800ab06 <lorawan_aes_set_key+0x1ba>
        *d++ = *s++;
 800aa4e:	6944      	ldr	r4, [r0, #20]
 800aa50:	6154      	str	r4, [r2, #20]
    while( nn-- )
 800aa52:	2b06      	cmp	r3, #6
 800aa54:	d057      	beq.n	800ab06 <lorawan_aes_set_key+0x1ba>
        *d++ = *s++;
 800aa56:	6984      	ldr	r4, [r0, #24]
 800aa58:	6194      	str	r4, [r2, #24]
    while( nn-- )
 800aa5a:	2b08      	cmp	r3, #8
 800aa5c:	d153      	bne.n	800ab06 <lorawan_aes_set_key+0x1ba>
        *d++ = *s++;
 800aa5e:	69c0      	ldr	r0, [r0, #28]
 800aa60:	61d0      	str	r0, [r2, #28]
    ctx->rnd = (hi >> 4) - 1;
 800aa62:	230e      	movs	r3, #14
 800aa64:	f882 30f0 	strb.w	r3, [r2, #240]	@ 0xf0
    hi = (keylen + 28) << 2;
 800aa68:	27f0      	movs	r7, #240	@ 0xf0
 800aa6a:	eb02 0c01 	add.w	ip, r2, r1
            t0 = s_box(t1) ^ rc;
 800aa6e:	f8df 90e4 	ldr.w	r9, [pc, #228]	@ 800ab54 <lorawan_aes_set_key+0x208>
 800aa72:	f81c 6c01 	ldrb.w	r6, [ip, #-1]
 800aa76:	f81c 5c02 	ldrb.w	r5, [ip, #-2]
 800aa7a:	f81c 4c03 	ldrb.w	r4, [ip, #-3]
 800aa7e:	f81c 8c04 	ldrb.w	r8, [ip, #-4]
    hi = (keylen + 28) << 2;
 800aa82:	4608      	mov	r0, r1
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800aa84:	f04f 0e01 	mov.w	lr, #1
 800aa88:	e01e      	b.n	800aac8 <lorawan_aes_set_key+0x17c>
        else if( keylen > 24 && cc % keylen == 16 )
 800aa8a:	f1ba 0f10 	cmp.w	sl, #16
 800aa8e:	d053      	beq.n	800ab38 <lorawan_aes_set_key+0x1ec>
        t0 = ctx->ksch[cc - 4];
 800aa90:	46c2      	mov	sl, r8
        ctx->ksch[cc + 0] = ctx->ksch[tt + 0] ^ t0;
 800aa92:	7813      	ldrb	r3, [r2, #0]
 800aa94:	ea8a 0303 	eor.w	r3, sl, r3
 800aa98:	fa5f f883 	uxtb.w	r8, r3
 800aa9c:	f88c 8000 	strb.w	r8, [ip]
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
 800aaa0:	7853      	ldrb	r3, [r2, #1]
 800aaa2:	405c      	eors	r4, r3
 800aaa4:	f88c 4001 	strb.w	r4, [ip, #1]
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
 800aaa8:	7893      	ldrb	r3, [r2, #2]
 800aaaa:	405d      	eors	r5, r3
 800aaac:	f88c 5002 	strb.w	r5, [ip, #2]
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800aab0:	78d3      	ldrb	r3, [r2, #3]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800aab2:	3004      	adds	r0, #4
 800aab4:	b2c0      	uxtb	r0, r0
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800aab6:	405e      	eors	r6, r3
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800aab8:	42b8      	cmp	r0, r7
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800aaba:	f88c 6003 	strb.w	r6, [ip, #3]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800aabe:	f102 0204 	add.w	r2, r2, #4
 800aac2:	f10c 0c04 	add.w	ip, ip, #4
 800aac6:	d2b0      	bcs.n	800aa2a <lorawan_aes_set_key+0xde>
        if( cc % keylen == 0 )
 800aac8:	fbb0 faf1 	udiv	sl, r0, r1
            rc = f2(rc);
 800aacc:	ea4f 13de 	mov.w	r3, lr, lsr #7
 800aad0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
        if( cc % keylen == 0 )
 800aad4:	fb01 0a1a 	mls	sl, r1, sl, r0
            rc = f2(rc);
 800aad8:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
        if( cc % keylen == 0 )
 800aadc:	f01a 0aff 	ands.w	sl, sl, #255	@ 0xff
            rc = f2(rc);
 800aae0:	b2db      	uxtb	r3, r3
        if( cc % keylen == 0 )
 800aae2:	d1d2      	bne.n	800aa8a <lorawan_aes_set_key+0x13e>
            t0 = s_box(t1) ^ rc;
 800aae4:	f819 a004 	ldrb.w	sl, [r9, r4]
            t1 = s_box(t2);
 800aae8:	f819 4005 	ldrb.w	r4, [r9, r5]
            t2 = s_box(t3);
 800aaec:	f819 5006 	ldrb.w	r5, [r9, r6]
            t3 = s_box(tt);
 800aaf0:	f819 6008 	ldrb.w	r6, [r9, r8]
            t0 = s_box(t1) ^ rc;
 800aaf4:	ea8e 0a0a 	eor.w	sl, lr, sl
            rc = f2(rc);
 800aaf8:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800aafc:	fa5f fe8e 	uxtb.w	lr, lr
 800ab00:	ea83 0e0e 	eor.w	lr, r3, lr
 800ab04:	e7c5      	b.n	800aa92 <lorawan_aes_set_key+0x146>
 800ab06:	f001 04fc 	and.w	r4, r1, #252	@ 0xfc
    while( nn-- )
 800ab0a:	1e4b      	subs	r3, r1, #1
 800ab0c:	1b1b      	subs	r3, r3, r4
 800ab0e:	078f      	lsls	r7, r1, #30
 800ab10:	eb00 0604 	add.w	r6, r0, r4
 800ab14:	b2db      	uxtb	r3, r3
 800ab16:	eb02 0504 	add.w	r5, r2, r4
 800ab1a:	f43f af38 	beq.w	800a98e <lorawan_aes_set_key+0x42>
        *d++ = *s++;
 800ab1e:	5d00      	ldrb	r0, [r0, r4]
 800ab20:	5510      	strb	r0, [r2, r4]
    while( nn-- )
 800ab22:	2b00      	cmp	r3, #0
 800ab24:	f43f af33 	beq.w	800a98e <lorawan_aes_set_key+0x42>
        *d++ = *s++;
 800ab28:	7870      	ldrb	r0, [r6, #1]
 800ab2a:	7068      	strb	r0, [r5, #1]
    while( nn-- )
 800ab2c:	2b01      	cmp	r3, #1
 800ab2e:	f43f af2e 	beq.w	800a98e <lorawan_aes_set_key+0x42>
        *d++ = *s++;
 800ab32:	78b3      	ldrb	r3, [r6, #2]
 800ab34:	70ab      	strb	r3, [r5, #2]
    while( nn-- )
 800ab36:	e72a      	b.n	800a98e <lorawan_aes_set_key+0x42>
            t0 = s_box(t0);
 800ab38:	4b06      	ldr	r3, [pc, #24]	@ (800ab54 <lorawan_aes_set_key+0x208>)
 800ab3a:	f813 a008 	ldrb.w	sl, [r3, r8]
            t1 = s_box(t1);
 800ab3e:	5d1c      	ldrb	r4, [r3, r4]
            t2 = s_box(t2);
 800ab40:	5d5d      	ldrb	r5, [r3, r5]
            t3 = s_box(t3);
 800ab42:	5d9e      	ldrb	r6, [r3, r6]
 800ab44:	e7a5      	b.n	800aa92 <lorawan_aes_set_key+0x146>
        ctx->rnd = 0;
 800ab46:	2300      	movs	r3, #0
 800ab48:	f882 30f0 	strb.w	r3, [r2, #240]	@ 0xf0
        return ( uint8_t )-1;
 800ab4c:	20ff      	movs	r0, #255	@ 0xff
}
 800ab4e:	4770      	bx	lr
 800ab50:	00010101 	.word	0x00010101
 800ab54:	08017124 	.word	0x08017124

0800ab58 <lorawan_aes_encrypt>:
#if defined( AES_ENC_PREKEYED )

/*  Encrypt a single block of 16 bytes */

return_type lorawan_aes_encrypt( const uint8_t in[N_BLOCK], uint8_t  out[N_BLOCK], const lorawan_aes_context ctx[1] )
{
 800ab58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ab5c:	b0a7      	sub	sp, #156	@ 0x9c
    if( ctx->rnd )
 800ab5e:	f892 40f0 	ldrb.w	r4, [r2, #240]	@ 0xf0
{
 800ab62:	911f      	str	r1, [sp, #124]	@ 0x7c
    if( ctx->rnd )
 800ab64:	2c00      	cmp	r4, #0
 800ab66:	f000 8200 	beq.w	800af6a <lorawan_aes_encrypt+0x412>
    {
        uint8_t s1[N_BLOCK], r;
        copy_and_key( s1, in, ctx->ksch );
 800ab6a:	4601      	mov	r1, r0
 800ab6c:	a822      	add	r0, sp, #136	@ 0x88
 800ab6e:	4615      	mov	r5, r2
 800ab70:	f7ff fe8c 	bl	800a88c <copy_and_key>

        for( r = 1 ; r < ctx->rnd ; ++r )
 800ab74:	f89d 3088 	ldrb.w	r3, [sp, #136]	@ 0x88
 800ab78:	9308      	str	r3, [sp, #32]
 800ab7a:	2c01      	cmp	r4, #1
 800ab7c:	f000 81f9 	beq.w	800af72 <lorawan_aes_encrypt+0x41a>
 800ab80:	1ea3      	subs	r3, r4, #2
 800ab82:	f105 0210 	add.w	r2, r5, #16
 800ab86:	b2db      	uxtb	r3, r3
 800ab88:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800ab8c:	931e      	str	r3, [sp, #120]	@ 0x78
 800ab8e:	f89d 3089 	ldrb.w	r3, [sp, #137]	@ 0x89
 800ab92:	9309      	str	r3, [sp, #36]	@ 0x24
 800ab94:	f89d 308a 	ldrb.w	r3, [sp, #138]	@ 0x8a
 800ab98:	930a      	str	r3, [sp, #40]	@ 0x28
 800ab9a:	f89d 308b 	ldrb.w	r3, [sp, #139]	@ 0x8b
 800ab9e:	930b      	str	r3, [sp, #44]	@ 0x2c
 800aba0:	f89d 308c 	ldrb.w	r3, [sp, #140]	@ 0x8c
 800aba4:	930c      	str	r3, [sp, #48]	@ 0x30
 800aba6:	f89d 308d 	ldrb.w	r3, [sp, #141]	@ 0x8d
 800abaa:	9302      	str	r3, [sp, #8]
 800abac:	f89d 308f 	ldrb.w	r3, [sp, #143]	@ 0x8f
 800abb0:	f89d 6095 	ldrb.w	r6, [sp, #149]	@ 0x95
 800abb4:	f89d 2096 	ldrb.w	r2, [sp, #150]	@ 0x96
 800abb8:	f89d 7091 	ldrb.w	r7, [sp, #145]	@ 0x91
 800abbc:	9307      	str	r3, [sp, #28]
 800abbe:	f89d 3092 	ldrb.w	r3, [sp, #146]	@ 0x92
 800abc2:	9203      	str	r2, [sp, #12]
 800abc4:	f89d c08e 	ldrb.w	ip, [sp, #142]	@ 0x8e
 800abc8:	f89d 2097 	ldrb.w	r2, [sp, #151]	@ 0x97
 800abcc:	f89d 0090 	ldrb.w	r0, [sp, #144]	@ 0x90
 800abd0:	f89d b093 	ldrb.w	fp, [sp, #147]	@ 0x93
 800abd4:	f89d 1094 	ldrb.w	r1, [sp, #148]	@ 0x94
 800abd8:	f8df e2a0 	ldr.w	lr, [pc, #672]	@ 800ae7c <lorawan_aes_encrypt+0x324>
 800abdc:	f8df a2a0 	ldr.w	sl, [pc, #672]	@ 800ae80 <lorawan_aes_encrypt+0x328>
 800abe0:	f8df 92a0 	ldr.w	r9, [pc, #672]	@ 800ae84 <lorawan_aes_encrypt+0x32c>
 800abe4:	9201      	str	r2, [sp, #4]
 800abe6:	e9cd 7604 	strd	r7, r6, [sp, #16]
 800abea:	46a8      	mov	r8, r5
 800abec:	9420      	str	r4, [sp, #128]	@ 0x80
 800abee:	461e      	mov	r6, r3
 800abf0:	9521      	str	r5, [sp, #132]	@ 0x84
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800abf2:	9a08      	ldr	r2, [sp, #32]
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800abf4:	9d09      	ldr	r5, [sp, #36]	@ 0x24
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800abf6:	f819 4002 	ldrb.w	r4, [r9, r2]
 800abfa:	9409      	str	r4, [sp, #36]	@ 0x24
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800abfc:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800abfe:	f81e 3005 	ldrb.w	r3, [lr, r5]
 800ac02:	9517      	str	r5, [sp, #92]	@ 0x5c
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ac04:	9006      	str	r0, [sp, #24]
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac06:	f81a 5002 	ldrb.w	r5, [sl, r2]
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800ac0a:	f81e 0002 	ldrb.w	r0, [lr, r2]
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800ac0e:	9a02      	ldr	r2, [sp, #8]
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ac10:	f81e 7004 	ldrb.w	r7, [lr, r4]
 800ac14:	9712      	str	r7, [sp, #72]	@ 0x48
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800ac16:	f81e 7002 	ldrb.w	r7, [lr, r2]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ac1a:	9a03      	ldr	r2, [sp, #12]
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800ac1c:	9708      	str	r7, [sp, #32]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ac1e:	f81e 7002 	ldrb.w	r7, [lr, r2]
 800ac22:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ac24:	f8cd c060 	str.w	ip, [sp, #96]	@ 0x60
 800ac28:	f81e c00c 	ldrb.w	ip, [lr, ip]
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800ac2c:	931c      	str	r3, [sp, #112]	@ 0x70
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ac2e:	f8cd c064 	str.w	ip, [sp, #100]	@ 0x64
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ac32:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac34:	f8dd c004 	ldr.w	ip, [sp, #4]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ac38:	970c      	str	r7, [sp, #48]	@ 0x30
 800ac3a:	f81e 7002 	ldrb.w	r7, [lr, r2]
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac3e:	f81e c00c 	ldrb.w	ip, [lr, ip]
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ac42:	9411      	str	r4, [sp, #68]	@ 0x44
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ac44:	e9cd 270e 	strd	r2, r7, [sp, #56]	@ 0x38
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ac48:	460c      	mov	r4, r1
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800ac4a:	f81e 2003 	ldrb.w	r2, [lr, r3]
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac4e:	f81e 1006 	ldrb.w	r1, [lr, r6]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ac52:	930d      	str	r3, [sp, #52]	@ 0x34
 800ac54:	f81a 7003 	ldrb.w	r7, [sl, r3]
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800ac58:	9b04      	ldr	r3, [sp, #16]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ac5a:	971d      	str	r7, [sp, #116]	@ 0x74
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800ac5c:	f81e 3003 	ldrb.w	r3, [lr, r3]
 800ac60:	9310      	str	r3, [sp, #64]	@ 0x40
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ac62:	9b07      	ldr	r3, [sp, #28]
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ac64:	f8cd b068 	str.w	fp, [sp, #104]	@ 0x68
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ac68:	f81e 7003 	ldrb.w	r7, [lr, r3]
 800ac6c:	e9cd 3713 	strd	r3, r7, [sp, #76]	@ 0x4c
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800ac70:	9b06      	ldr	r3, [sp, #24]
 800ac72:	f81e 7003 	ldrb.w	r7, [lr, r3]
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800ac76:	9b05      	ldr	r3, [sp, #20]
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800ac78:	9715      	str	r7, [sp, #84]	@ 0x54
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800ac7a:	f81e 7003 	ldrb.w	r7, [lr, r3]
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac7e:	9b02      	ldr	r3, [sp, #8]
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800ac80:	9716      	str	r7, [sp, #88]	@ 0x58
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ac82:	f81e 700b 	ldrb.w	r7, [lr, fp]
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac86:	f819 b003 	ldrb.w	fp, [r9, r3]
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ac8a:	9707      	str	r7, [sp, #28]
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
 800ac8c:	f81e 7004 	ldrb.w	r7, [lr, r4]
 800ac90:	971b      	str	r7, [sp, #108]	@ 0x6c
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac92:	ea85 050b 	eor.w	r5, r5, fp
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800ac96:	9f08      	ldr	r7, [sp, #32]
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800ac98:	f81a b003 	ldrb.w	fp, [sl, r3]
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800ac9c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800ac9e:	404d      	eors	r5, r1
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800aca0:	4079      	eors	r1, r7
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800aca2:	4047      	eors	r7, r0
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800aca4:	ea8c 0000 	eor.w	r0, ip, r0
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800aca8:	ea8c 0c05 	eor.w	ip, ip, r5
    ((uint8_t*)d)[ 0] ^= ((uint8_t*)s)[ 0];
 800acac:	f898 5010 	ldrb.w	r5, [r8, #16]
 800acb0:	ea8c 0c05 	eor.w	ip, ip, r5
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800acb4:	f819 5006 	ldrb.w	r5, [r9, r6]
    ((uint8_t*)d)[ 0] ^= ((uint8_t*)s)[ 0];
 800acb8:	f8cd c020 	str.w	ip, [sp, #32]
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800acbc:	ea8b 0000 	eor.w	r0, fp, r0
 800acc0:	4045      	eors	r5, r0
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800acc2:	f81a 0006 	ldrb.w	r0, [sl, r6]
 800acc6:	4078      	eors	r0, r7
    ((uint8_t*)d)[ 1] ^= ((uint8_t*)s)[ 1];
 800acc8:	f898 7011 	ldrb.w	r7, [r8, #17]
 800accc:	ea85 0607 	eor.w	r6, r5, r7
 800acd0:	9609      	str	r6, [sp, #36]	@ 0x24
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800acd2:	9e01      	ldr	r6, [sp, #4]
 800acd4:	f819 5006 	ldrb.w	r5, [r9, r6]
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800acd8:	f8dd c040 	ldr.w	ip, [sp, #64]	@ 0x40
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800acdc:	9f06      	ldr	r7, [sp, #24]
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800acde:	f8dd b058 	ldr.w	fp, [sp, #88]	@ 0x58
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800ace2:	4045      	eors	r5, r0
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800ace4:	f81a 0006 	ldrb.w	r0, [sl, r6]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ace8:	9e04      	ldr	r6, [sp, #16]
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800acea:	4059      	eors	r1, r3
 800acec:	4041      	eors	r1, r0
    ((uint8_t*)d)[ 2] ^= ((uint8_t*)s)[ 2];
 800acee:	f898 0012 	ldrb.w	r0, [r8, #18]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800acf2:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
    ((uint8_t*)d)[ 2] ^= ((uint8_t*)s)[ 2];
 800acf4:	4068      	eors	r0, r5
 800acf6:	900a      	str	r0, [sp, #40]	@ 0x28
    ((uint8_t*)d)[ 3] ^= ((uint8_t*)s)[ 3];
 800acf8:	f898 0013 	ldrb.w	r0, [r8, #19]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800acfc:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
    ((uint8_t*)d)[ 3] ^= ((uint8_t*)s)[ 3];
 800acfe:	4048      	eors	r0, r1
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ad00:	f819 1006 	ldrb.w	r1, [r9, r6]
    ((uint8_t*)d)[ 3] ^= ((uint8_t*)s)[ 3];
 800ad04:	900b      	str	r0, [sp, #44]	@ 0x2c
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ad06:	4059      	eors	r1, r3
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800ad08:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800ad0a:	f81a 0006 	ldrb.w	r0, [sl, r6]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ad0e:	4069      	eors	r1, r5
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800ad10:	ea85 060c 	eor.w	r6, r5, ip
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800ad14:	ea82 0c0c 	eor.w	ip, r2, ip
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800ad18:	405a      	eors	r2, r3
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800ad1a:	404b      	eors	r3, r1
    ((uint8_t*)d)[ 4] ^= ((uint8_t*)s)[ 4];
 800ad1c:	f898 1014 	ldrb.w	r1, [r8, #20]
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800ad20:	f819 5007 	ldrb.w	r5, [r9, r7]
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800ad24:	4042      	eors	r2, r0
    ((uint8_t*)d)[ 4] ^= ((uint8_t*)s)[ 4];
 800ad26:	ea83 0001 	eor.w	r0, r3, r1
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800ad2a:	9903      	ldr	r1, [sp, #12]
    ((uint8_t*)d)[ 4] ^= ((uint8_t*)s)[ 4];
 800ad2c:	900c      	str	r0, [sp, #48]	@ 0x30
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800ad2e:	f819 3001 	ldrb.w	r3, [r9, r1]
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800ad32:	f81a 1001 	ldrb.w	r1, [sl, r1]
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800ad36:	ea82 0003 	eor.w	r0, r2, r3
 800ad3a:	9001      	str	r0, [sp, #4]
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800ad3c:	980d      	ldr	r0, [sp, #52]	@ 0x34
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ad3e:	f81a 2007 	ldrb.w	r2, [sl, r7]
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800ad42:	f819 0000 	ldrb.w	r0, [r9, r0]
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ad46:	f81a 3004 	ldrb.w	r3, [sl, r4]
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800ad4a:	f819 4004 	ldrb.w	r4, [r9, r4]
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800ad4e:	4070      	eors	r0, r6
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ad50:	9e05      	ldr	r6, [sp, #20]
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800ad52:	ea8c 0c01 	eor.w	ip, ip, r1
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ad56:	f819 1006 	ldrb.w	r1, [r9, r6]
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800ad5a:	f81a 7006 	ldrb.w	r7, [sl, r6]
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ad5e:	404a      	eors	r2, r1
 800ad60:	9912      	ldr	r1, [sp, #72]	@ 0x48
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800ad62:	465e      	mov	r6, fp
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ad64:	404a      	eors	r2, r1
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800ad66:	4071      	eors	r1, r6
 800ad68:	4069      	eors	r1, r5
 800ad6a:	9102      	str	r1, [sp, #8]
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800ad6c:	9d15      	ldr	r5, [sp, #84]	@ 0x54
 800ad6e:	ea85 060b 	eor.w	r6, r5, fp
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800ad72:	f8dd b050 	ldr.w	fp, [sp, #80]	@ 0x50
 800ad76:	ea8b 0505 	eor.w	r5, fp, r5
 800ad7a:	406f      	eors	r7, r5
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ad7c:	9d17      	ldr	r5, [sp, #92]	@ 0x5c
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ad7e:	ea8b 0102 	eor.w	r1, fp, r2
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ad82:	f819 2005 	ldrb.w	r2, [r9, r5]
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
 800ad86:	f81a b005 	ldrb.w	fp, [sl, r5]
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800ad8a:	9d1c      	ldr	r5, [sp, #112]	@ 0x70
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800ad8c:	9103      	str	r1, [sp, #12]
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ad8e:	4053      	eors	r3, r2
 800ad90:	9a19      	ldr	r2, [sp, #100]	@ 0x64
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800ad92:	991b      	ldr	r1, [sp, #108]	@ 0x6c
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ad94:	4053      	eors	r3, r2
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800ad96:	406a      	eors	r2, r5
 800ad98:	4062      	eors	r2, r4
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
 800ad9a:	9c07      	ldr	r4, [sp, #28]
 800ad9c:	404c      	eors	r4, r1
 800ad9e:	ea84 040b 	eor.w	r4, r4, fp
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ada2:	f8dd b01c 	ldr.w	fp, [sp, #28]
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800ada6:	404d      	eors	r5, r1
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800ada8:	ea8b 0103 	eor.w	r1, fp, r3
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800adac:	f8dd b044 	ldr.w	fp, [sp, #68]	@ 0x44
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800adb0:	9105      	str	r1, [sp, #20]
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800adb2:	f81a 300b 	ldrb.w	r3, [sl, fp]
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800adb6:	9902      	ldr	r1, [sp, #8]
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800adb8:	405e      	eors	r6, r3
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800adba:	f819 300b 	ldrb.w	r3, [r9, fp]
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800adbe:	f8dd b060 	ldr.w	fp, [sp, #96]	@ 0x60
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800adc2:	405f      	eors	r7, r3
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800adc4:	f81a 300b 	ldrb.w	r3, [sl, fp]
 800adc8:	405d      	eors	r5, r3
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
 800adca:	f819 300b 	ldrb.w	r3, [r9, fp]
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800adce:	f8dd b038 	ldr.w	fp, [sp, #56]	@ 0x38
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
 800add2:	405c      	eors	r4, r3
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800add4:	f819 300b 	ldrb.w	r3, [r9, fp]
 800add8:	ea8c 0c03 	eor.w	ip, ip, r3
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800addc:	f81a 300b 	ldrb.w	r3, [sl, fp]
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800ade0:	f8dd b04c 	ldr.w	fp, [sp, #76]	@ 0x4c
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800ade4:	4058      	eors	r0, r3
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800ade6:	f819 300b 	ldrb.w	r3, [r9, fp]
 800adea:	405e      	eors	r6, r3
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800adec:	f81a 300b 	ldrb.w	r3, [sl, fp]
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800adf0:	f8dd b068 	ldr.w	fp, [sp, #104]	@ 0x68
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800adf4:	4059      	eors	r1, r3
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800adf6:	f819 300b 	ldrb.w	r3, [r9, fp]
 800adfa:	405d      	eors	r5, r3
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800adfc:	f81a 300b 	ldrb.w	r3, [sl, fp]
    ((uint8_t*)d)[ 5] ^= ((uint8_t*)s)[ 5];
 800ae00:	f8dd b004 	ldr.w	fp, [sp, #4]
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800ae04:	405a      	eors	r2, r3
    ((uint8_t*)d)[ 5] ^= ((uint8_t*)s)[ 5];
 800ae06:	f898 3015 	ldrb.w	r3, [r8, #21]
 800ae0a:	ea8b 0b03 	eor.w	fp, fp, r3
    ((uint8_t*)d)[ 6] ^= ((uint8_t*)s)[ 6];
 800ae0e:	f898 3016 	ldrb.w	r3, [r8, #22]
    ((uint8_t*)d)[ 5] ^= ((uint8_t*)s)[ 5];
 800ae12:	f8cd b008 	str.w	fp, [sp, #8]
    ((uint8_t*)d)[ 6] ^= ((uint8_t*)s)[ 6];
 800ae16:	ea8c 0c03 	eor.w	ip, ip, r3
    ((uint8_t*)d)[ 7] ^= ((uint8_t*)s)[ 7];
 800ae1a:	f898 3017 	ldrb.w	r3, [r8, #23]
    ((uint8_t*)d)[11] ^= ((uint8_t*)s)[11];
 800ae1e:	f898 b01b 	ldrb.w	fp, [r8, #27]
    ((uint8_t*)d)[ 7] ^= ((uint8_t*)s)[ 7];
 800ae22:	4058      	eors	r0, r3
 800ae24:	9007      	str	r0, [sp, #28]
    ((uint8_t*)d)[ 8] ^= ((uint8_t*)s)[ 8];
 800ae26:	9b03      	ldr	r3, [sp, #12]
 800ae28:	f898 0018 	ldrb.w	r0, [r8, #24]
 800ae2c:	4058      	eors	r0, r3
    ((uint8_t*)d)[ 9] ^= ((uint8_t*)s)[ 9];
 800ae2e:	f898 3019 	ldrb.w	r3, [r8, #25]
 800ae32:	405f      	eors	r7, r3
    ((uint8_t*)d)[10] ^= ((uint8_t*)s)[10];
 800ae34:	f898 301a 	ldrb.w	r3, [r8, #26]
    ((uint8_t*)d)[ 9] ^= ((uint8_t*)s)[ 9];
 800ae38:	9704      	str	r7, [sp, #16]
    ((uint8_t*)d)[10] ^= ((uint8_t*)s)[10];
 800ae3a:	405e      	eors	r6, r3
    ((uint8_t*)d)[11] ^= ((uint8_t*)s)[11];
 800ae3c:	ea81 0b0b 	eor.w	fp, r1, fp
    ((uint8_t*)d)[12] ^= ((uint8_t*)s)[12];
 800ae40:	9b05      	ldr	r3, [sp, #20]
 800ae42:	f898 101c 	ldrb.w	r1, [r8, #28]
 800ae46:	4059      	eors	r1, r3
    ((uint8_t*)d)[13] ^= ((uint8_t*)s)[13];
 800ae48:	f898 301d 	ldrb.w	r3, [r8, #29]
 800ae4c:	4063      	eors	r3, r4
 800ae4e:	9305      	str	r3, [sp, #20]
    ((uint8_t*)d)[14] ^= ((uint8_t*)s)[14];
 800ae50:	f898 301e 	ldrb.w	r3, [r8, #30]
    ((uint8_t*)d)[15] ^= ((uint8_t*)s)[15];
 800ae54:	f898 401f 	ldrb.w	r4, [r8, #31]
    ((uint8_t*)d)[14] ^= ((uint8_t*)s)[14];
 800ae58:	406b      	eors	r3, r5
 800ae5a:	9303      	str	r3, [sp, #12]
    ((uint8_t*)d)[15] ^= ((uint8_t*)s)[15];
 800ae5c:	ea82 0304 	eor.w	r3, r2, r4
 800ae60:	9301      	str	r3, [sp, #4]
        for( r = 1 ; r < ctx->rnd ; ++r )
 800ae62:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 800ae64:	f108 0810 	add.w	r8, r8, #16
 800ae68:	4598      	cmp	r8, r3
 800ae6a:	f47f aec2 	bne.w	800abf2 <lorawan_aes_encrypt+0x9a>
            mix_sub_columns( s2, s1 );
            copy_and_key( s1, s2, ctx->ksch + r * N_BLOCK);
        }
#endif
        shift_sub_rows( s1 );
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800ae6e:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 800ae70:	9d21      	ldr	r5, [sp, #132]	@ 0x84
 800ae72:	46b0      	mov	r8, r6
 800ae74:	9e05      	ldr	r6, [sp, #20]
 800ae76:	0122      	lsls	r2, r4, #4
 800ae78:	e006      	b.n	800ae88 <lorawan_aes_encrypt+0x330>
 800ae7a:	bf00      	nop
 800ae7c:	08017124 	.word	0x08017124
 800ae80:	08017024 	.word	0x08017024
 800ae84:	08016f24 	.word	0x08016f24
 800ae88:	442a      	add	r2, r5
 800ae8a:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 800ae8c:	f81e 3000 	ldrb.w	r3, [lr, r0]
 800ae90:	9304      	str	r3, [sp, #16]
 800ae92:	f81e 3005 	ldrb.w	r3, [lr, r5]
 800ae96:	f81e 5006 	ldrb.w	r5, [lr, r6]
 800ae9a:	9505      	str	r5, [sp, #20]
 800ae9c:	f81e 500c 	ldrb.w	r5, [lr, ip]
 800aea0:	f8dd c028 	ldr.w	ip, [sp, #40]	@ 0x28
 800aea4:	f81e 6007 	ldrb.w	r6, [lr, r7]
    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
 800aea8:	9f02      	ldr	r7, [sp, #8]
 800aeaa:	9808      	ldr	r0, [sp, #32]
 800aeac:	9608      	str	r6, [sp, #32]
 800aeae:	f81e 600c 	ldrb.w	r6, [lr, ip]
 800aeb2:	f8dd c00c 	ldr.w	ip, [sp, #12]
 800aeb6:	f81e 7007 	ldrb.w	r7, [lr, r7]
 800aeba:	f8dd 901c 	ldr.w	r9, [sp, #28]
 800aebe:	f8dd a004 	ldr.w	sl, [sp, #4]
 800aec2:	f81e 4001 	ldrb.w	r4, [lr, r1]
 800aec6:	9709      	str	r7, [sp, #36]	@ 0x24
 800aec8:	990c      	ldr	r1, [sp, #48]	@ 0x30
 800aeca:	f81e 700c 	ldrb.w	r7, [lr, ip]
 800aece:	f81e c008 	ldrb.w	ip, [lr, r8]
 800aed2:	f81e 800b 	ldrb.w	r8, [lr, fp]
 800aed6:	f8cd 8008 	str.w	r8, [sp, #8]
 800aeda:	f81e b00a 	ldrb.w	fp, [lr, sl]
 800aede:	f81e 8009 	ldrb.w	r8, [lr, r9]
 800aee2:	f8dd 902c 	ldr.w	r9, [sp, #44]	@ 0x2c
 800aee6:	f81e 1001 	ldrb.w	r1, [lr, r1]
 800aeea:	f81e 0000 	ldrb.w	r0, [lr, r0]
 800aeee:	f81e 9009 	ldrb.w	r9, [lr, r9]
 800aef2:	9106      	str	r1, [sp, #24]
 800aef4:	f04f 0a00 	mov.w	sl, #0
 800aef8:	f364 0a07 	bfi	sl, r4, #0, #8
 800aefc:	900c      	str	r0, [sp, #48]	@ 0x30
 800aefe:	f363 2a0f 	bfi	sl, r3, #8, #8
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800af02:	981f      	ldr	r0, [sp, #124]	@ 0x7c
 800af04:	9c04      	ldr	r4, [sp, #16]
 800af06:	f8dd e008 	ldr.w	lr, [sp, #8]
 800af0a:	f365 4a17 	bfi	sl, r5, #16, #8
 800af0e:	2300      	movs	r3, #0
 800af10:	9d05      	ldr	r5, [sp, #20]
 800af12:	f364 0307 	bfi	r3, r4, #0, #8
 800af16:	f365 230f 	bfi	r3, r5, #8, #8
 800af1a:	f366 4317 	bfi	r3, r6, #16, #8
 800af1e:	9c06      	ldr	r4, [sp, #24]
 800af20:	9e08      	ldr	r6, [sp, #32]
 800af22:	f368 631f 	bfi	r3, r8, #24, #8
    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
 800af26:	9324      	str	r3, [sp, #144]	@ 0x90
 800af28:	2300      	movs	r3, #0
 800af2a:	f364 0307 	bfi	r3, r4, #0, #8
 800af2e:	f366 230f 	bfi	r3, r6, #8, #8
 800af32:	f367 4317 	bfi	r3, r7, #16, #8
 800af36:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 800af38:	9f09      	ldr	r7, [sp, #36]	@ 0x24
 800af3a:	f369 631f 	bfi	r3, r9, #24, #8
 800af3e:	9323      	str	r3, [sp, #140]	@ 0x8c
 800af40:	2300      	movs	r3, #0
 800af42:	f364 0307 	bfi	r3, r4, #0, #8
 800af46:	f367 230f 	bfi	r3, r7, #8, #8
 800af4a:	f36c 4317 	bfi	r3, ip, #16, #8
 800af4e:	f36e 6a1f 	bfi	sl, lr, #24, #8
 800af52:	f36b 631f 	bfi	r3, fp, #24, #8
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800af56:	a922      	add	r1, sp, #136	@ 0x88
    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
 800af58:	f8cd a094 	str.w	sl, [sp, #148]	@ 0x94
 800af5c:	9322      	str	r3, [sp, #136]	@ 0x88
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800af5e:	f7ff fc95 	bl	800a88c <copy_and_key>
    }
    else
        return ( uint8_t )-1;
    return 0;
 800af62:	2000      	movs	r0, #0
}
 800af64:	b027      	add	sp, #156	@ 0x9c
 800af66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return ( uint8_t )-1;
 800af6a:	20ff      	movs	r0, #255	@ 0xff
}
 800af6c:	b027      	add	sp, #156	@ 0x9c
 800af6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800af72:	f89d 308c 	ldrb.w	r3, [sp, #140]	@ 0x8c
 800af76:	930c      	str	r3, [sp, #48]	@ 0x30
 800af78:	f89d 3089 	ldrb.w	r3, [sp, #137]	@ 0x89
 800af7c:	9309      	str	r3, [sp, #36]	@ 0x24
 800af7e:	f89d 308d 	ldrb.w	r3, [sp, #141]	@ 0x8d
 800af82:	9302      	str	r3, [sp, #8]
 800af84:	f89d 308a 	ldrb.w	r3, [sp, #138]	@ 0x8a
 800af88:	930a      	str	r3, [sp, #40]	@ 0x28
 800af8a:	f89d 3092 	ldrb.w	r3, [sp, #146]	@ 0x92
 800af8e:	f89d 0090 	ldrb.w	r0, [sp, #144]	@ 0x90
 800af92:	f89d 1094 	ldrb.w	r1, [sp, #148]	@ 0x94
 800af96:	f89d 7091 	ldrb.w	r7, [sp, #145]	@ 0x91
 800af9a:	f89d 6095 	ldrb.w	r6, [sp, #149]	@ 0x95
 800af9e:	f89d c08e 	ldrb.w	ip, [sp, #142]	@ 0x8e
 800afa2:	f89d b093 	ldrb.w	fp, [sp, #147]	@ 0x93
 800afa6:	f8df e020 	ldr.w	lr, [pc, #32]	@ 800afc8 <lorawan_aes_encrypt+0x470>
 800afaa:	4698      	mov	r8, r3
 800afac:	f89d 3096 	ldrb.w	r3, [sp, #150]	@ 0x96
 800afb0:	9303      	str	r3, [sp, #12]
 800afb2:	f89d 3097 	ldrb.w	r3, [sp, #151]	@ 0x97
 800afb6:	9301      	str	r3, [sp, #4]
 800afb8:	f89d 308f 	ldrb.w	r3, [sp, #143]	@ 0x8f
 800afbc:	9307      	str	r3, [sp, #28]
 800afbe:	f89d 308b 	ldrb.w	r3, [sp, #139]	@ 0x8b
 800afc2:	930b      	str	r3, [sp, #44]	@ 0x2c
        for( r = 1 ; r < ctx->rnd ; ++r )
 800afc4:	2210      	movs	r2, #16
 800afc6:	e75f      	b.n	800ae88 <lorawan_aes_encrypt+0x330>
 800afc8:	08017124 	.word	0x08017124

0800afcc <PrintKey>:
SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem )
{
#if (KEY_EXTRACTABLE == 1)
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
    {
        if( SeNvm->KeyList[i].KeyID == keyID )
 800afcc:	4b54      	ldr	r3, [pc, #336]	@ (800b120 <PrintKey+0x154>)
 800afce:	681b      	ldr	r3, [r3, #0]
 800afd0:	7e1a      	ldrb	r2, [r3, #24]
 800afd2:	4282      	cmp	r2, r0
 800afd4:	d02a      	beq.n	800b02c <PrintKey+0x60>
 800afd6:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 800afda:	4282      	cmp	r2, r0
 800afdc:	d074      	beq.n	800b0c8 <PrintKey+0xfc>
 800afde:	f893 203a 	ldrb.w	r2, [r3, #58]	@ 0x3a
 800afe2:	4282      	cmp	r2, r0
 800afe4:	d074      	beq.n	800b0d0 <PrintKey+0x104>
 800afe6:	f893 204b 	ldrb.w	r2, [r3, #75]	@ 0x4b
 800afea:	4282      	cmp	r2, r0
 800afec:	d074      	beq.n	800b0d8 <PrintKey+0x10c>
 800afee:	f893 205c 	ldrb.w	r2, [r3, #92]	@ 0x5c
 800aff2:	4282      	cmp	r2, r0
 800aff4:	d074      	beq.n	800b0e0 <PrintKey+0x114>
 800aff6:	f893 206d 	ldrb.w	r2, [r3, #109]	@ 0x6d
 800affa:	4282      	cmp	r2, r0
 800affc:	d074      	beq.n	800b0e8 <PrintKey+0x11c>
 800affe:	f893 207e 	ldrb.w	r2, [r3, #126]	@ 0x7e
 800b002:	4282      	cmp	r2, r0
 800b004:	d074      	beq.n	800b0f0 <PrintKey+0x124>
 800b006:	f893 208f 	ldrb.w	r2, [r3, #143]	@ 0x8f
 800b00a:	4282      	cmp	r2, r0
 800b00c:	d074      	beq.n	800b0f8 <PrintKey+0x12c>
 800b00e:	f893 20a0 	ldrb.w	r2, [r3, #160]	@ 0xa0
 800b012:	4282      	cmp	r2, r0
 800b014:	d074      	beq.n	800b100 <PrintKey+0x134>
 800b016:	f893 20b1 	ldrb.w	r2, [r3, #177]	@ 0xb1
 800b01a:	4282      	cmp	r2, r0
 800b01c:	d074      	beq.n	800b108 <PrintKey+0x13c>
 800b01e:	f893 20c2 	ldrb.w	r2, [r3, #194]	@ 0xc2
 800b022:	4282      	cmp	r2, r0
 800b024:	bf08      	it	eq
 800b026:	220a      	moveq	r2, #10
 800b028:	d001      	beq.n	800b02e <PrintKey+0x62>
 800b02a:	4770      	bx	lr
 800b02c:	2200      	movs	r2, #0
            if( KeyLabel[i].keyID == keyID )
 800b02e:	b168      	cbz	r0, 800b04c <PrintKey+0x80>
 800b030:	2801      	cmp	r0, #1
 800b032:	d00b      	beq.n	800b04c <PrintKey+0x80>
 800b034:	2808      	cmp	r0, #8
 800b036:	d06b      	beq.n	800b110 <PrintKey+0x144>
 800b038:	2809      	cmp	r0, #9
 800b03a:	d06b      	beq.n	800b114 <PrintKey+0x148>
 800b03c:	280a      	cmp	r0, #10
 800b03e:	d06b      	beq.n	800b118 <PrintKey+0x14c>
 800b040:	280b      	cmp	r0, #11
 800b042:	d06b      	beq.n	800b11c <PrintKey+0x150>
 800b044:	280c      	cmp	r0, #12
 800b046:	bf08      	it	eq
 800b048:	2006      	moveq	r0, #6
 800b04a:	d1ee      	bne.n	800b02a <PrintKey+0x5e>
{
 800b04c:	b500      	push	{lr}
                MW_LOG( TS_OFF, VLEVEL_M,
 800b04e:	eb02 1202 	add.w	r2, r2, r2, lsl #4
 800b052:	4413      	add	r3, r2
{
 800b054:	b093      	sub	sp, #76	@ 0x4c
                MW_LOG( TS_OFF, VLEVEL_M,
 800b056:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 800b05a:	9210      	str	r2, [sp, #64]	@ 0x40
 800b05c:	f893 2027 	ldrb.w	r2, [r3, #39]	@ 0x27
 800b060:	920f      	str	r2, [sp, #60]	@ 0x3c
 800b062:	f893 2026 	ldrb.w	r2, [r3, #38]	@ 0x26
 800b066:	920e      	str	r2, [sp, #56]	@ 0x38
 800b068:	f893 2025 	ldrb.w	r2, [r3, #37]	@ 0x25
 800b06c:	920d      	str	r2, [sp, #52]	@ 0x34
 800b06e:	f893 2024 	ldrb.w	r2, [r3, #36]	@ 0x24
 800b072:	920c      	str	r2, [sp, #48]	@ 0x30
 800b074:	f893 2023 	ldrb.w	r2, [r3, #35]	@ 0x23
 800b078:	920b      	str	r2, [sp, #44]	@ 0x2c
 800b07a:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
 800b07e:	920a      	str	r2, [sp, #40]	@ 0x28
 800b080:	f893 2021 	ldrb.w	r2, [r3, #33]	@ 0x21
 800b084:	9209      	str	r2, [sp, #36]	@ 0x24
 800b086:	f893 2020 	ldrb.w	r2, [r3, #32]
 800b08a:	9208      	str	r2, [sp, #32]
 800b08c:	7fda      	ldrb	r2, [r3, #31]
 800b08e:	9207      	str	r2, [sp, #28]
 800b090:	7f9a      	ldrb	r2, [r3, #30]
 800b092:	9206      	str	r2, [sp, #24]
 800b094:	7f5a      	ldrb	r2, [r3, #29]
 800b096:	9205      	str	r2, [sp, #20]
 800b098:	7f1a      	ldrb	r2, [r3, #28]
 800b09a:	9204      	str	r2, [sp, #16]
 800b09c:	7eda      	ldrb	r2, [r3, #27]
 800b09e:	9203      	str	r2, [sp, #12]
 800b0a0:	4920      	ldr	r1, [pc, #128]	@ (800b124 <PrintKey+0x158>)
 800b0a2:	7e9a      	ldrb	r2, [r3, #26]
 800b0a4:	9202      	str	r2, [sp, #8]
 800b0a6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800b0aa:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 800b0ae:	7e5b      	ldrb	r3, [r3, #25]
 800b0b0:	9301      	str	r3, [sp, #4]
 800b0b2:	2200      	movs	r2, #0
 800b0b4:	6889      	ldr	r1, [r1, #8]
 800b0b6:	9100      	str	r1, [sp, #0]
 800b0b8:	4b1b      	ldr	r3, [pc, #108]	@ (800b128 <PrintKey+0x15c>)
 800b0ba:	4611      	mov	r1, r2
 800b0bc:	2002      	movs	r0, #2
 800b0be:	f00a fc99 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 800b0c2:	b013      	add	sp, #76	@ 0x4c
 800b0c4:	f85d fb04 	ldr.w	pc, [sp], #4
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b0c8:	2201      	movs	r2, #1
            if( KeyLabel[i].keyID == keyID )
 800b0ca:	2800      	cmp	r0, #0
 800b0cc:	d1b0      	bne.n	800b030 <PrintKey+0x64>
 800b0ce:	e7bd      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b0d0:	2202      	movs	r2, #2
            if( KeyLabel[i].keyID == keyID )
 800b0d2:	2800      	cmp	r0, #0
 800b0d4:	d1ac      	bne.n	800b030 <PrintKey+0x64>
 800b0d6:	e7b9      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b0d8:	2203      	movs	r2, #3
            if( KeyLabel[i].keyID == keyID )
 800b0da:	2800      	cmp	r0, #0
 800b0dc:	d1a8      	bne.n	800b030 <PrintKey+0x64>
 800b0de:	e7b5      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b0e0:	2204      	movs	r2, #4
            if( KeyLabel[i].keyID == keyID )
 800b0e2:	2800      	cmp	r0, #0
 800b0e4:	d1a4      	bne.n	800b030 <PrintKey+0x64>
 800b0e6:	e7b1      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b0e8:	2205      	movs	r2, #5
            if( KeyLabel[i].keyID == keyID )
 800b0ea:	2800      	cmp	r0, #0
 800b0ec:	d1a0      	bne.n	800b030 <PrintKey+0x64>
 800b0ee:	e7ad      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b0f0:	2206      	movs	r2, #6
            if( KeyLabel[i].keyID == keyID )
 800b0f2:	2800      	cmp	r0, #0
 800b0f4:	d19c      	bne.n	800b030 <PrintKey+0x64>
 800b0f6:	e7a9      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b0f8:	2207      	movs	r2, #7
            if( KeyLabel[i].keyID == keyID )
 800b0fa:	2800      	cmp	r0, #0
 800b0fc:	d198      	bne.n	800b030 <PrintKey+0x64>
 800b0fe:	e7a5      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b100:	2208      	movs	r2, #8
            if( KeyLabel[i].keyID == keyID )
 800b102:	2800      	cmp	r0, #0
 800b104:	d194      	bne.n	800b030 <PrintKey+0x64>
 800b106:	e7a1      	b.n	800b04c <PrintKey+0x80>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b108:	2209      	movs	r2, #9
            if( KeyLabel[i].keyID == keyID )
 800b10a:	2800      	cmp	r0, #0
 800b10c:	d190      	bne.n	800b030 <PrintKey+0x64>
 800b10e:	e79d      	b.n	800b04c <PrintKey+0x80>
 800b110:	2002      	movs	r0, #2
 800b112:	e79b      	b.n	800b04c <PrintKey+0x80>
 800b114:	2003      	movs	r0, #3
 800b116:	e799      	b.n	800b04c <PrintKey+0x80>
 800b118:	2004      	movs	r0, #4
 800b11a:	e797      	b.n	800b04c <PrintKey+0x80>
 800b11c:	2005      	movs	r0, #5
 800b11e:	e795      	b.n	800b04c <PrintKey+0x80>
 800b120:	200004d0 	.word	0x200004d0
 800b124:	080173bc 	.word	0x080173bc
 800b128:	08017224 	.word	0x08017224

0800b12c <PrintIds>:
{
 800b12c:	b530      	push	{r4, r5, lr}
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

#if (LORAWAN_KMS == 0)
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b12e:	4c30      	ldr	r4, [pc, #192]	@ (800b1f0 <PrintIds+0xc4>)
{
 800b130:	b08d      	sub	sp, #52	@ 0x34
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b132:	6821      	ldr	r1, [r4, #0]
{
 800b134:	4605      	mov	r5, r0
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b136:	2208      	movs	r2, #8
 800b138:	a80a      	add	r0, sp, #40	@ 0x28
 800b13a:	f007 f8a3 	bl	8012284 <memcpy1>
    MW_LOG( TS_OFF, VLEVEL_M, "###### DevEUI:      %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n", HEX8( devEui ) );
 800b13e:	f89d 102f 	ldrb.w	r1, [sp, #47]	@ 0x2f
 800b142:	f89d 302e 	ldrb.w	r3, [sp, #46]	@ 0x2e
 800b146:	e9cd 3106 	strd	r3, r1, [sp, #24]
 800b14a:	f89d 102d 	ldrb.w	r1, [sp, #45]	@ 0x2d
 800b14e:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 800b152:	e9cd 3104 	strd	r3, r1, [sp, #16]
 800b156:	f89d 102b 	ldrb.w	r1, [sp, #43]	@ 0x2b
 800b15a:	f89d 302a 	ldrb.w	r3, [sp, #42]	@ 0x2a
 800b15e:	e9cd 3102 	strd	r3, r1, [sp, #8]
 800b162:	f89d 1029 	ldrb.w	r1, [sp, #41]	@ 0x29
 800b166:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 800b16a:	2200      	movs	r2, #0
 800b16c:	e9cd 3100 	strd	r3, r1, [sp]
 800b170:	2002      	movs	r0, #2
 800b172:	4b20      	ldr	r3, [pc, #128]	@ (800b1f4 <PrintIds+0xc8>)
 800b174:	4611      	mov	r1, r2
 800b176:	f00a fc3d 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

#if (LORAWAN_KMS == 0)
    memcpy1( joinEui, SeNvm->SeNvmDevJoinKey.JoinEui, SE_EUI_SIZE );
 800b17a:	6821      	ldr	r1, [r4, #0]
 800b17c:	2208      	movs	r2, #8
 800b17e:	4411      	add	r1, r2
 800b180:	a808      	add	r0, sp, #32
 800b182:	f007 f87f 	bl	8012284 <memcpy1>
    MW_LOG( TS_OFF, VLEVEL_M, "###### AppEUI:      %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n", HEX8( joinEui ) );
 800b186:	f89d 2027 	ldrb.w	r2, [sp, #39]	@ 0x27
 800b18a:	f89d 3026 	ldrb.w	r3, [sp, #38]	@ 0x26
 800b18e:	f89d 1025 	ldrb.w	r1, [sp, #37]	@ 0x25
 800b192:	f89d 0021 	ldrb.w	r0, [sp, #33]	@ 0x21
 800b196:	e9cd 3206 	strd	r3, r2, [sp, #24]
 800b19a:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 800b19e:	f89d 2023 	ldrb.w	r2, [sp, #35]	@ 0x23
 800b1a2:	e9cd 3104 	strd	r3, r1, [sp, #16]
 800b1a6:	f89d 3022 	ldrb.w	r3, [sp, #34]	@ 0x22
 800b1aa:	f89d 1020 	ldrb.w	r1, [sp, #32]
 800b1ae:	e9cd 3202 	strd	r3, r2, [sp, #8]
 800b1b2:	2200      	movs	r2, #0
 800b1b4:	e9cd 1000 	strd	r1, r0, [sp]
 800b1b8:	4b0f      	ldr	r3, [pc, #60]	@ (800b1f8 <PrintIds+0xcc>)
 800b1ba:	4611      	mov	r1, r2
 800b1bc:	2002      	movs	r0, #2
 800b1be:	f00a fc19 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
    }
#if (LORAWAN_KMS == 0)
    /* Recover DevAddrABP or DevAddrOTAA depending on mode */
    if( mode == ACTIVATION_TYPE_OTAA )
    {
        *devAddr = SeNvm->SeNvmDevJoinKey.DevAddrOTAA;
 800b1c2:	6823      	ldr	r3, [r4, #0]
    if( mode == ACTIVATION_TYPE_OTAA )
 800b1c4:	2d02      	cmp	r5, #2
        *devAddr = SeNvm->SeNvmDevJoinKey.DevAddrOTAA;
 800b1c6:	bf0c      	ite	eq
 800b1c8:	6919      	ldreq	r1, [r3, #16]
    }
    else
    {
        *devAddr = SeNvm->SeNvmDevJoinKey.DevAddrABP;
 800b1ca:	6959      	ldrne	r1, [r3, #20]
    MW_LOG( TS_OFF, VLEVEL_M, "###### DevAddr:     %02X:%02X:%02X:%02X\r\n",
 800b1cc:	4b0b      	ldr	r3, [pc, #44]	@ (800b1fc <PrintIds+0xd0>)
 800b1ce:	b2cd      	uxtb	r5, r1
 800b1d0:	f3c1 2407 	ubfx	r4, r1, #8, #8
 800b1d4:	f3c1 4007 	ubfx	r0, r1, #16, #8
 800b1d8:	2200      	movs	r2, #0
 800b1da:	0e09      	lsrs	r1, r1, #24
 800b1dc:	e9cd 1000 	strd	r1, r0, [sp]
 800b1e0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 800b1e4:	4611      	mov	r1, r2
 800b1e6:	2002      	movs	r0, #2
 800b1e8:	f00a fc04 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 800b1ec:	b00d      	add	sp, #52	@ 0x34
 800b1ee:	bd30      	pop	{r4, r5, pc}
 800b1f0:	200004d0 	.word	0x200004d0
 800b1f4:	08017280 	.word	0x08017280
 800b1f8:	080172c0 	.word	0x080172c0
 800b1fc:	08017300 	.word	0x08017300

0800b200 <ComputeCmac>:
{
 800b200:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b204:	b0ca      	sub	sp, #296	@ 0x128
 800b206:	9d50      	ldr	r5, [sp, #320]	@ 0x140
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 800b208:	2900      	cmp	r1, #0
 800b20a:	d03a      	beq.n	800b282 <ComputeCmac+0x82>
 800b20c:	b3cd      	cbz	r5, 800b282 <ComputeCmac+0x82>
 800b20e:	4607      	mov	r7, r0
    AES_CMAC_Init( aesCmacCtx );
 800b210:	a804      	add	r0, sp, #16
 800b212:	461c      	mov	r4, r3
 800b214:	4690      	mov	r8, r2
 800b216:	460e      	mov	r6, r1
 800b218:	f7fe ffcc 	bl	800a1b4 <AES_CMAC_Init>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b21c:	4b33      	ldr	r3, [pc, #204]	@ (800b2ec <ComputeCmac+0xec>)
 800b21e:	681b      	ldr	r3, [r3, #0]
 800b220:	7e1a      	ldrb	r2, [r3, #24]
 800b222:	42a2      	cmp	r2, r4
 800b224:	d031      	beq.n	800b28a <ComputeCmac+0x8a>
 800b226:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 800b22a:	42a2      	cmp	r2, r4
 800b22c:	d04d      	beq.n	800b2ca <ComputeCmac+0xca>
 800b22e:	f893 203a 	ldrb.w	r2, [r3, #58]	@ 0x3a
 800b232:	42a2      	cmp	r2, r4
 800b234:	d04b      	beq.n	800b2ce <ComputeCmac+0xce>
 800b236:	f893 204b 	ldrb.w	r2, [r3, #75]	@ 0x4b
 800b23a:	42a2      	cmp	r2, r4
 800b23c:	d049      	beq.n	800b2d2 <ComputeCmac+0xd2>
 800b23e:	f893 205c 	ldrb.w	r2, [r3, #92]	@ 0x5c
 800b242:	42a2      	cmp	r2, r4
 800b244:	d047      	beq.n	800b2d6 <ComputeCmac+0xd6>
 800b246:	f893 206d 	ldrb.w	r2, [r3, #109]	@ 0x6d
 800b24a:	42a2      	cmp	r2, r4
 800b24c:	d045      	beq.n	800b2da <ComputeCmac+0xda>
 800b24e:	f893 207e 	ldrb.w	r2, [r3, #126]	@ 0x7e
 800b252:	42a2      	cmp	r2, r4
 800b254:	d037      	beq.n	800b2c6 <ComputeCmac+0xc6>
 800b256:	f893 208f 	ldrb.w	r2, [r3, #143]	@ 0x8f
 800b25a:	42a2      	cmp	r2, r4
 800b25c:	d03f      	beq.n	800b2de <ComputeCmac+0xde>
 800b25e:	f893 20a0 	ldrb.w	r2, [r3, #160]	@ 0xa0
 800b262:	42a2      	cmp	r2, r4
 800b264:	d03d      	beq.n	800b2e2 <ComputeCmac+0xe2>
 800b266:	f893 20b1 	ldrb.w	r2, [r3, #177]	@ 0xb1
 800b26a:	42a2      	cmp	r2, r4
 800b26c:	d03b      	beq.n	800b2e6 <ComputeCmac+0xe6>
 800b26e:	f893 20c2 	ldrb.w	r2, [r3, #194]	@ 0xc2
 800b272:	42a2      	cmp	r2, r4
 800b274:	bf08      	it	eq
 800b276:	210a      	moveq	r1, #10
 800b278:	d008      	beq.n	800b28c <ComputeCmac+0x8c>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800b27a:	2003      	movs	r0, #3
}
 800b27c:	b04a      	add	sp, #296	@ 0x128
 800b27e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b282:	2002      	movs	r0, #2
}
 800b284:	b04a      	add	sp, #296	@ 0x128
 800b286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b28a:	2100      	movs	r1, #0
        AES_CMAC_SetKey( aesCmacCtx, keyItem->KeyValue );
 800b28c:	eb01 1101 	add.w	r1, r1, r1, lsl #4
 800b290:	3119      	adds	r1, #25
 800b292:	4419      	add	r1, r3
 800b294:	a804      	add	r0, sp, #16
 800b296:	f7fe ff9d 	bl	800a1d4 <AES_CMAC_SetKey>
        if( micBxBuffer != NULL )
 800b29a:	b12f      	cbz	r7, 800b2a8 <ComputeCmac+0xa8>
            AES_CMAC_Update( aesCmacCtx, micBxBuffer, MIC_BLOCK_BX_SIZE );
 800b29c:	2210      	movs	r2, #16
 800b29e:	4639      	mov	r1, r7
 800b2a0:	eb0d 0002 	add.w	r0, sp, r2
 800b2a4:	f7fe ff9c 	bl	800a1e0 <AES_CMAC_Update>
        AES_CMAC_Update( aesCmacCtx, buffer, size );
 800b2a8:	4642      	mov	r2, r8
 800b2aa:	4631      	mov	r1, r6
 800b2ac:	a804      	add	r0, sp, #16
 800b2ae:	f7fe ff97 	bl	800a1e0 <AES_CMAC_Update>
        AES_CMAC_Final( Cmac, aesCmacCtx );
 800b2b2:	4668      	mov	r0, sp
 800b2b4:	a904      	add	r1, sp, #16
 800b2b6:	f7ff f88f 	bl	800a3d8 <AES_CMAC_Final>
        *cmac = GET_UINT32_LE( Cmac, 0 );
 800b2ba:	9b00      	ldr	r3, [sp, #0]
 800b2bc:	602b      	str	r3, [r5, #0]
 800b2be:	2000      	movs	r0, #0
}
 800b2c0:	b04a      	add	sp, #296	@ 0x128
 800b2c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b2c6:	2106      	movs	r1, #6
 800b2c8:	e7e0      	b.n	800b28c <ComputeCmac+0x8c>
 800b2ca:	2101      	movs	r1, #1
 800b2cc:	e7de      	b.n	800b28c <ComputeCmac+0x8c>
 800b2ce:	2102      	movs	r1, #2
 800b2d0:	e7dc      	b.n	800b28c <ComputeCmac+0x8c>
 800b2d2:	2103      	movs	r1, #3
 800b2d4:	e7da      	b.n	800b28c <ComputeCmac+0x8c>
 800b2d6:	2104      	movs	r1, #4
 800b2d8:	e7d8      	b.n	800b28c <ComputeCmac+0x8c>
 800b2da:	2105      	movs	r1, #5
 800b2dc:	e7d6      	b.n	800b28c <ComputeCmac+0x8c>
 800b2de:	2107      	movs	r1, #7
 800b2e0:	e7d4      	b.n	800b28c <ComputeCmac+0x8c>
 800b2e2:	2108      	movs	r1, #8
 800b2e4:	e7d2      	b.n	800b28c <ComputeCmac+0x8c>
 800b2e6:	2109      	movs	r1, #9
 800b2e8:	e7d0      	b.n	800b28c <ComputeCmac+0x8c>
 800b2ea:	bf00      	nop
 800b2ec:	200004d0 	.word	0x200004d0

0800b2f0 <SecureElementAesEncrypt.part.0>:
SecureElementStatus_t SecureElementAesEncrypt( uint8_t *buffer, uint32_t size, KeyIdentifier_t keyID,
 800b2f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b2f2:	b0bf      	sub	sp, #252	@ 0xfc
 800b2f4:	4614      	mov	r4, r2
 800b2f6:	4606      	mov	r6, r0
    memset1( aesContext.ksch, '\0', 240 );
 800b2f8:	22f0      	movs	r2, #240	@ 0xf0
SecureElementStatus_t SecureElementAesEncrypt( uint8_t *buffer, uint32_t size, KeyIdentifier_t keyID,
 800b2fa:	460d      	mov	r5, r1
    memset1( aesContext.ksch, '\0', 240 );
 800b2fc:	a801      	add	r0, sp, #4
 800b2fe:	2100      	movs	r1, #0
SecureElementStatus_t SecureElementAesEncrypt( uint8_t *buffer, uint32_t size, KeyIdentifier_t keyID,
 800b300:	461f      	mov	r7, r3
    memset1( aesContext.ksch, '\0', 240 );
 800b302:	f007 f81b 	bl	801233c <memset1>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b306:	4b2d      	ldr	r3, [pc, #180]	@ (800b3bc <SecureElementAesEncrypt.part.0+0xcc>)
 800b308:	681a      	ldr	r2, [r3, #0]
 800b30a:	7e13      	ldrb	r3, [r2, #24]
 800b30c:	42a3      	cmp	r3, r4
 800b30e:	d02c      	beq.n	800b36a <SecureElementAesEncrypt.part.0+0x7a>
 800b310:	f892 3029 	ldrb.w	r3, [r2, #41]	@ 0x29
 800b314:	42a3      	cmp	r3, r4
 800b316:	d03f      	beq.n	800b398 <SecureElementAesEncrypt.part.0+0xa8>
 800b318:	f892 303a 	ldrb.w	r3, [r2, #58]	@ 0x3a
 800b31c:	42a3      	cmp	r3, r4
 800b31e:	d03d      	beq.n	800b39c <SecureElementAesEncrypt.part.0+0xac>
 800b320:	f892 304b 	ldrb.w	r3, [r2, #75]	@ 0x4b
 800b324:	42a3      	cmp	r3, r4
 800b326:	d03b      	beq.n	800b3a0 <SecureElementAesEncrypt.part.0+0xb0>
 800b328:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 800b32c:	42a3      	cmp	r3, r4
 800b32e:	d039      	beq.n	800b3a4 <SecureElementAesEncrypt.part.0+0xb4>
 800b330:	f892 306d 	ldrb.w	r3, [r2, #109]	@ 0x6d
 800b334:	42a3      	cmp	r3, r4
 800b336:	d037      	beq.n	800b3a8 <SecureElementAesEncrypt.part.0+0xb8>
 800b338:	f892 307e 	ldrb.w	r3, [r2, #126]	@ 0x7e
 800b33c:	42a3      	cmp	r3, r4
 800b33e:	d035      	beq.n	800b3ac <SecureElementAesEncrypt.part.0+0xbc>
 800b340:	f892 308f 	ldrb.w	r3, [r2, #143]	@ 0x8f
 800b344:	42a3      	cmp	r3, r4
 800b346:	d033      	beq.n	800b3b0 <SecureElementAesEncrypt.part.0+0xc0>
 800b348:	f892 30a0 	ldrb.w	r3, [r2, #160]	@ 0xa0
 800b34c:	42a3      	cmp	r3, r4
 800b34e:	d031      	beq.n	800b3b4 <SecureElementAesEncrypt.part.0+0xc4>
 800b350:	f892 30b1 	ldrb.w	r3, [r2, #177]	@ 0xb1
 800b354:	42a3      	cmp	r3, r4
 800b356:	d02f      	beq.n	800b3b8 <SecureElementAesEncrypt.part.0+0xc8>
 800b358:	f892 30c2 	ldrb.w	r3, [r2, #194]	@ 0xc2
 800b35c:	42a3      	cmp	r3, r4
 800b35e:	bf08      	it	eq
 800b360:	200a      	moveq	r0, #10
 800b362:	d003      	beq.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800b364:	2003      	movs	r0, #3
}
 800b366:	b03f      	add	sp, #252	@ 0xfc
 800b368:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b36a:	2000      	movs	r0, #0
        lorawan_aes_set_key( pItem->KeyValue, SE_KEY_SIZE, &aesContext );
 800b36c:	eb00 1000 	add.w	r0, r0, r0, lsl #4
 800b370:	3019      	adds	r0, #25
 800b372:	4410      	add	r0, r2
 800b374:	2110      	movs	r1, #16
 800b376:	aa01      	add	r2, sp, #4
 800b378:	f7ff fae8 	bl	800a94c <lorawan_aes_set_key>
        while( size != 0 )
 800b37c:	b14d      	cbz	r5, 800b392 <SecureElementAesEncrypt.part.0+0xa2>
 800b37e:	462c      	mov	r4, r5
            lorawan_aes_encrypt( &buffer[block], &encBuffer[block], &aesContext );
 800b380:	1b28      	subs	r0, r5, r4
 800b382:	b2c0      	uxtb	r0, r0
 800b384:	1839      	adds	r1, r7, r0
 800b386:	aa01      	add	r2, sp, #4
 800b388:	4430      	add	r0, r6
 800b38a:	f7ff fbe5 	bl	800ab58 <lorawan_aes_encrypt>
        while( size != 0 )
 800b38e:	3c10      	subs	r4, #16
 800b390:	d1f6      	bne.n	800b380 <SecureElementAesEncrypt.part.0+0x90>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800b392:	2000      	movs	r0, #0
}
 800b394:	b03f      	add	sp, #252	@ 0xfc
 800b396:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b398:	2001      	movs	r0, #1
 800b39a:	e7e7      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b39c:	2002      	movs	r0, #2
 800b39e:	e7e5      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3a0:	2003      	movs	r0, #3
 800b3a2:	e7e3      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3a4:	2004      	movs	r0, #4
 800b3a6:	e7e1      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3a8:	2005      	movs	r0, #5
 800b3aa:	e7df      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3ac:	2006      	movs	r0, #6
 800b3ae:	e7dd      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3b0:	2007      	movs	r0, #7
 800b3b2:	e7db      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3b4:	2008      	movs	r0, #8
 800b3b6:	e7d9      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3b8:	2009      	movs	r0, #9
 800b3ba:	e7d7      	b.n	800b36c <SecureElementAesEncrypt.part.0+0x7c>
 800b3bc:	200004d0 	.word	0x200004d0

0800b3c0 <SecureElementInit>:
    if( nvm == NULL )
 800b3c0:	b140      	cbz	r0, 800b3d4 <SecureElementInit+0x14>
{
 800b3c2:	b510      	push	{r4, lr}
    SeNvm = nvm;
 800b3c4:	4c04      	ldr	r4, [pc, #16]	@ (800b3d8 <SecureElementInit+0x18>)
    memcpy1( ( uint8_t * )SeNvm, ( uint8_t * )&seNvmInit, sizeof( seNvmInit ) );
 800b3c6:	4905      	ldr	r1, [pc, #20]	@ (800b3dc <SecureElementInit+0x1c>)
    SeNvm = nvm;
 800b3c8:	6020      	str	r0, [r4, #0]
    memcpy1( ( uint8_t * )SeNvm, ( uint8_t * )&seNvmInit, sizeof( seNvmInit ) );
 800b3ca:	22d8      	movs	r2, #216	@ 0xd8
 800b3cc:	f006 ff5a 	bl	8012284 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 800b3d0:	2000      	movs	r0, #0
}
 800b3d2:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b3d4:	2002      	movs	r0, #2
}
 800b3d6:	4770      	bx	lr
 800b3d8:	200004d0 	.word	0x200004d0
 800b3dc:	080177fc 	.word	0x080177fc

0800b3e0 <SecureElementInitMcuID>:
{
 800b3e0:	b570      	push	{r4, r5, r6, lr}
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b3e2:	4e1d      	ldr	r6, [pc, #116]	@ (800b458 <SecureElementInitMcuID+0x78>)
{
 800b3e4:	b084      	sub	sp, #16
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b3e6:	2208      	movs	r2, #8
    uint32_t devAddrABP = 0;
 800b3e8:	2300      	movs	r3, #0
{
 800b3ea:	4604      	mov	r4, r0
 800b3ec:	460d      	mov	r5, r1
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b3ee:	eb0d 0002 	add.w	r0, sp, r2
 800b3f2:	6831      	ldr	r1, [r6, #0]
    uint32_t devAddrABP = 0;
 800b3f4:	9301      	str	r3, [sp, #4]
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b3f6:	f006 ff45 	bl	8012284 <memcpy1>
        *devAddr = SeNvm->SeNvmDevJoinKey.DevAddrABP;
 800b3fa:	6833      	ldr	r3, [r6, #0]
 800b3fc:	695b      	ldr	r3, [r3, #20]
 800b3fe:	9301      	str	r3, [sp, #4]
    if( seGetUniqueId != NULL )
 800b400:	b1fc      	cbz	r4, 800b442 <SecureElementInitMcuID+0x62>
            if( devEui[index] != 0 )
 800b402:	f89d 2009 	ldrb.w	r2, [sp, #9]
 800b406:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800b40a:	4313      	orrs	r3, r2
 800b40c:	f89d 200a 	ldrb.w	r2, [sp, #10]
 800b410:	4313      	orrs	r3, r2
 800b412:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800b416:	4313      	orrs	r3, r2
 800b418:	f89d 200c 	ldrb.w	r2, [sp, #12]
 800b41c:	4313      	orrs	r3, r2
 800b41e:	f89d 200d 	ldrb.w	r2, [sp, #13]
 800b422:	4313      	orrs	r3, r2
 800b424:	f89d 200e 	ldrb.w	r2, [sp, #14]
 800b428:	4313      	orrs	r3, r2
 800b42a:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800b42e:	4313      	orrs	r3, r2
 800b430:	d107      	bne.n	800b442 <SecureElementInitMcuID+0x62>
            seGetUniqueId( devEui );
 800b432:	a802      	add	r0, sp, #8
 800b434:	47a0      	blx	r4
    memcpy1( SeNvm->SeNvmDevJoinKey.DevEui, devEui, SE_EUI_SIZE );
 800b436:	2208      	movs	r2, #8
 800b438:	6830      	ldr	r0, [r6, #0]
 800b43a:	eb0d 0102 	add.w	r1, sp, r2
 800b43e:	f006 ff21 	bl	8012284 <memcpy1>
    if( ( seGetDevAddr != NULL ) && ( devAddrABP == 0 ) )
 800b442:	b135      	cbz	r5, 800b452 <SecureElementInitMcuID+0x72>
 800b444:	9b01      	ldr	r3, [sp, #4]
 800b446:	b923      	cbnz	r3, 800b452 <SecureElementInitMcuID+0x72>
        seGetDevAddr( &devAddrABP );
 800b448:	a801      	add	r0, sp, #4
 800b44a:	47a8      	blx	r5
        SeNvm->SeNvmDevJoinKey.DevAddrABP = devAddr;
 800b44c:	6833      	ldr	r3, [r6, #0]
 800b44e:	9a01      	ldr	r2, [sp, #4]
 800b450:	615a      	str	r2, [r3, #20]
}
 800b452:	2000      	movs	r0, #0
 800b454:	b004      	add	sp, #16
 800b456:	bd70      	pop	{r4, r5, r6, pc}
 800b458:	200004d0 	.word	0x200004d0

0800b45c <SecureElementPrintKeys>:
{
 800b45c:	b508      	push	{r3, lr}
    PrintKey( APP_KEY );
 800b45e:	2000      	movs	r0, #0
 800b460:	f7ff fdb4 	bl	800afcc <PrintKey>
    PrintKey( NWK_KEY );
 800b464:	2001      	movs	r0, #1
 800b466:	f7ff fdb1 	bl	800afcc <PrintKey>
    PrintKey( APP_S_KEY );
 800b46a:	2009      	movs	r0, #9
 800b46c:	f7ff fdae 	bl	800afcc <PrintKey>
    PrintKey( NWK_S_KEY );
 800b470:	2008      	movs	r0, #8
 800b472:	f7ff fdab 	bl	800afcc <PrintKey>
    PrintIds( ACTIVATION_TYPE_NONE );
 800b476:	2000      	movs	r0, #0
 800b478:	f7ff fe58 	bl	800b12c <PrintIds>
}
 800b47c:	2000      	movs	r0, #0
 800b47e:	bd08      	pop	{r3, pc}

0800b480 <SecureElementPrintSessionKeys>:
{
 800b480:	b510      	push	{r4, lr}
 800b482:	4604      	mov	r4, r0
    PrintKey( MC_ROOT_KEY );
 800b484:	200b      	movs	r0, #11
 800b486:	f7ff fda1 	bl	800afcc <PrintKey>
    PrintKey( MC_KE_KEY );
 800b48a:	200c      	movs	r0, #12
 800b48c:	f7ff fd9e 	bl	800afcc <PrintKey>
    PrintKey( APP_S_KEY );
 800b490:	2009      	movs	r0, #9
 800b492:	f7ff fd9b 	bl	800afcc <PrintKey>
    PrintKey( NWK_S_KEY );
 800b496:	2008      	movs	r0, #8
 800b498:	f7ff fd98 	bl	800afcc <PrintKey>
    PrintKey( DATABLOCK_INT_KEY );
 800b49c:	200a      	movs	r0, #10
 800b49e:	f7ff fd95 	bl	800afcc <PrintKey>
    PrintIds( mode );
 800b4a2:	4620      	mov	r0, r4
 800b4a4:	f7ff fe42 	bl	800b12c <PrintIds>
}
 800b4a8:	2000      	movs	r0, #0
 800b4aa:	bd10      	pop	{r4, pc}

0800b4ac <SecureElementSetKey>:
{
 800b4ac:	b530      	push	{r4, r5, lr}
 800b4ae:	b085      	sub	sp, #20
    if( key == NULL )
 800b4b0:	2900      	cmp	r1, #0
 800b4b2:	d058      	beq.n	800b566 <SecureElementSetKey+0xba>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b4b4:	4d37      	ldr	r5, [pc, #220]	@ (800b594 <SecureElementSetKey+0xe8>)
 800b4b6:	4603      	mov	r3, r0
 800b4b8:	6828      	ldr	r0, [r5, #0]
 800b4ba:	7e02      	ldrb	r2, [r0, #24]
 800b4bc:	429a      	cmp	r2, r3
 800b4be:	d02d      	beq.n	800b51c <SecureElementSetKey+0x70>
 800b4c0:	f890 2029 	ldrb.w	r2, [r0, #41]	@ 0x29
 800b4c4:	429a      	cmp	r2, r3
 800b4c6:	d052      	beq.n	800b56e <SecureElementSetKey+0xc2>
 800b4c8:	f890 203a 	ldrb.w	r2, [r0, #58]	@ 0x3a
 800b4cc:	429a      	cmp	r2, r3
 800b4ce:	d050      	beq.n	800b572 <SecureElementSetKey+0xc6>
 800b4d0:	f890 204b 	ldrb.w	r2, [r0, #75]	@ 0x4b
 800b4d4:	429a      	cmp	r2, r3
 800b4d6:	d04e      	beq.n	800b576 <SecureElementSetKey+0xca>
 800b4d8:	f890 205c 	ldrb.w	r2, [r0, #92]	@ 0x5c
 800b4dc:	429a      	cmp	r2, r3
 800b4de:	d04c      	beq.n	800b57a <SecureElementSetKey+0xce>
 800b4e0:	f890 206d 	ldrb.w	r2, [r0, #109]	@ 0x6d
 800b4e4:	429a      	cmp	r2, r3
 800b4e6:	d04a      	beq.n	800b57e <SecureElementSetKey+0xd2>
 800b4e8:	f890 207e 	ldrb.w	r2, [r0, #126]	@ 0x7e
 800b4ec:	429a      	cmp	r2, r3
 800b4ee:	d048      	beq.n	800b582 <SecureElementSetKey+0xd6>
 800b4f0:	f890 208f 	ldrb.w	r2, [r0, #143]	@ 0x8f
 800b4f4:	429a      	cmp	r2, r3
 800b4f6:	d046      	beq.n	800b586 <SecureElementSetKey+0xda>
 800b4f8:	f890 20a0 	ldrb.w	r2, [r0, #160]	@ 0xa0
 800b4fc:	429a      	cmp	r2, r3
 800b4fe:	d044      	beq.n	800b58a <SecureElementSetKey+0xde>
 800b500:	f890 20b1 	ldrb.w	r2, [r0, #177]	@ 0xb1
 800b504:	429a      	cmp	r2, r3
 800b506:	d042      	beq.n	800b58e <SecureElementSetKey+0xe2>
 800b508:	f890 20c2 	ldrb.w	r2, [r0, #194]	@ 0xc2
 800b50c:	429a      	cmp	r2, r3
 800b50e:	bf08      	it	eq
 800b510:	220a      	moveq	r2, #10
 800b512:	d004      	beq.n	800b51e <SecureElementSetKey+0x72>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800b514:	2403      	movs	r4, #3
}
 800b516:	4620      	mov	r0, r4
 800b518:	b005      	add	sp, #20
 800b51a:	bd30      	pop	{r4, r5, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b51c:	2200      	movs	r2, #0
            if( keyID == MC_KEY_0 )
 800b51e:	eb02 1202 	add.w	r2, r2, r2, lsl #4
 800b522:	2b0d      	cmp	r3, #13
 800b524:	f102 0419 	add.w	r4, r2, #25
 800b528:	d007      	beq.n	800b53a <SecureElementSetKey+0x8e>
                memcpy1( SeNvm->KeyList[i].KeyValue, key, SE_KEY_SIZE );
 800b52a:	4420      	add	r0, r4
 800b52c:	2210      	movs	r2, #16
 800b52e:	f006 fea9 	bl	8012284 <memcpy1>
                return SECURE_ELEMENT_SUCCESS;
 800b532:	2400      	movs	r4, #0
}
 800b534:	4620      	mov	r0, r4
 800b536:	b005      	add	sp, #20
 800b538:	bd30      	pop	{r4, r5, pc}
                uint8_t decryptedKey[SE_KEY_SIZE] = { 0 };
 800b53a:	2300      	movs	r3, #0
 800b53c:	e9cd 3300 	strd	r3, r3, [sp]
 800b540:	e9cd 3302 	strd	r3, r3, [sp, #8]
    if( ( size % 16 ) != 0 )
 800b544:	4608      	mov	r0, r1
 800b546:	466b      	mov	r3, sp
 800b548:	220c      	movs	r2, #12
 800b54a:	2110      	movs	r1, #16
 800b54c:	f7ff fed0 	bl	800b2f0 <SecureElementAesEncrypt.part.0>
 800b550:	4603      	mov	r3, r0
                memcpy1( SeNvm->KeyList[i].KeyValue, decryptedKey, SE_KEY_SIZE );
 800b552:	6828      	ldr	r0, [r5, #0]
 800b554:	2210      	movs	r2, #16
 800b556:	4420      	add	r0, r4
 800b558:	4669      	mov	r1, sp
 800b55a:	461c      	mov	r4, r3
 800b55c:	f006 fe92 	bl	8012284 <memcpy1>
}
 800b560:	4620      	mov	r0, r4
 800b562:	b005      	add	sp, #20
 800b564:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b566:	2402      	movs	r4, #2
}
 800b568:	4620      	mov	r0, r4
 800b56a:	b005      	add	sp, #20
 800b56c:	bd30      	pop	{r4, r5, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b56e:	2201      	movs	r2, #1
 800b570:	e7d5      	b.n	800b51e <SecureElementSetKey+0x72>
 800b572:	2202      	movs	r2, #2
 800b574:	e7d3      	b.n	800b51e <SecureElementSetKey+0x72>
 800b576:	2203      	movs	r2, #3
 800b578:	e7d1      	b.n	800b51e <SecureElementSetKey+0x72>
 800b57a:	2204      	movs	r2, #4
 800b57c:	e7cf      	b.n	800b51e <SecureElementSetKey+0x72>
 800b57e:	2205      	movs	r2, #5
 800b580:	e7cd      	b.n	800b51e <SecureElementSetKey+0x72>
 800b582:	2206      	movs	r2, #6
 800b584:	e7cb      	b.n	800b51e <SecureElementSetKey+0x72>
 800b586:	2207      	movs	r2, #7
 800b588:	e7c9      	b.n	800b51e <SecureElementSetKey+0x72>
 800b58a:	2208      	movs	r2, #8
 800b58c:	e7c7      	b.n	800b51e <SecureElementSetKey+0x72>
 800b58e:	2209      	movs	r2, #9
 800b590:	e7c5      	b.n	800b51e <SecureElementSetKey+0x72>
 800b592:	bf00      	nop
 800b594:	200004d0 	.word	0x200004d0

0800b598 <SecureElementComputeAesCmac>:
{
 800b598:	b410      	push	{r4}
    if( keyID >= MC_KE_KEY )
 800b59a:	2b0b      	cmp	r3, #11
{
 800b59c:	9c01      	ldr	r4, [sp, #4]
    if( keyID >= MC_KE_KEY )
 800b59e:	d803      	bhi.n	800b5a8 <SecureElementComputeAesCmac+0x10>
    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 800b5a0:	9401      	str	r4, [sp, #4]
}
 800b5a2:	bc10      	pop	{r4}
    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 800b5a4:	f7ff be2c 	b.w	800b200 <ComputeCmac>
}
 800b5a8:	2003      	movs	r0, #3
 800b5aa:	bc10      	pop	{r4}
 800b5ac:	4770      	bx	lr
 800b5ae:	bf00      	nop

0800b5b0 <SecureElementVerifyAesCmac>:
    if( buffer == NULL )
 800b5b0:	b190      	cbz	r0, 800b5d8 <SecureElementVerifyAesCmac+0x28>
{
 800b5b2:	b530      	push	{r4, r5, lr}
 800b5b4:	b085      	sub	sp, #20
 800b5b6:	468c      	mov	ip, r1
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800b5b8:	ad03      	add	r5, sp, #12
 800b5ba:	4614      	mov	r4, r2
 800b5bc:	4601      	mov	r1, r0
 800b5be:	4662      	mov	r2, ip
    uint32_t              compCmac = 0;
 800b5c0:	2000      	movs	r0, #0
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800b5c2:	9500      	str	r5, [sp, #0]
    uint32_t              compCmac = 0;
 800b5c4:	9003      	str	r0, [sp, #12]
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800b5c6:	f7ff fe1b 	bl	800b200 <ComputeCmac>
    if( retval != SECURE_ELEMENT_SUCCESS )
 800b5ca:	b918      	cbnz	r0, 800b5d4 <SecureElementVerifyAesCmac+0x24>
    if( expectedCmac != compCmac )
 800b5cc:	9803      	ldr	r0, [sp, #12]
 800b5ce:	1b00      	subs	r0, r0, r4
 800b5d0:	bf18      	it	ne
 800b5d2:	2001      	movne	r0, #1
}
 800b5d4:	b005      	add	sp, #20
 800b5d6:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b5d8:	2002      	movs	r0, #2
}
 800b5da:	4770      	bx	lr

0800b5dc <SecureElementAesEncrypt>:
    if( ( buffer == NULL ) || ( encBuffer == NULL ) )
 800b5dc:	2800      	cmp	r0, #0
 800b5de:	d066      	beq.n	800b6ae <SecureElementAesEncrypt+0xd2>
{
 800b5e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b5e4:	461f      	mov	r7, r3
 800b5e6:	b0be      	sub	sp, #248	@ 0xf8
    if( ( buffer == NULL ) || ( encBuffer == NULL ) )
 800b5e8:	2b00      	cmp	r3, #0
 800b5ea:	d062      	beq.n	800b6b2 <SecureElementAesEncrypt+0xd6>
    if( ( size % 16 ) != 0 )
 800b5ec:	f011 080f 	ands.w	r8, r1, #15
 800b5f0:	460d      	mov	r5, r1
 800b5f2:	d13a      	bne.n	800b66a <SecureElementAesEncrypt+0x8e>
 800b5f4:	4614      	mov	r4, r2
 800b5f6:	4606      	mov	r6, r0
    memset1( aesContext.ksch, '\0', 240 );
 800b5f8:	22f0      	movs	r2, #240	@ 0xf0
 800b5fa:	4641      	mov	r1, r8
 800b5fc:	a801      	add	r0, sp, #4
 800b5fe:	f006 fe9d 	bl	801233c <memset1>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b602:	4b39      	ldr	r3, [pc, #228]	@ (800b6e8 <SecureElementAesEncrypt+0x10c>)
 800b604:	681b      	ldr	r3, [r3, #0]
 800b606:	7e1a      	ldrb	r2, [r3, #24]
 800b608:	42a2      	cmp	r2, r4
 800b60a:	d034      	beq.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b60c:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 800b610:	42a2      	cmp	r2, r4
 800b612:	d02e      	beq.n	800b672 <SecureElementAesEncrypt+0x96>
 800b614:	f893 203a 	ldrb.w	r2, [r3, #58]	@ 0x3a
 800b618:	42a2      	cmp	r2, r4
 800b61a:	d04c      	beq.n	800b6b6 <SecureElementAesEncrypt+0xda>
 800b61c:	f893 204b 	ldrb.w	r2, [r3, #75]	@ 0x4b
 800b620:	42a2      	cmp	r2, r4
 800b622:	d04b      	beq.n	800b6bc <SecureElementAesEncrypt+0xe0>
 800b624:	f893 205c 	ldrb.w	r2, [r3, #92]	@ 0x5c
 800b628:	42a2      	cmp	r2, r4
 800b62a:	d04a      	beq.n	800b6c2 <SecureElementAesEncrypt+0xe6>
 800b62c:	f893 206d 	ldrb.w	r2, [r3, #109]	@ 0x6d
 800b630:	42a2      	cmp	r2, r4
 800b632:	d049      	beq.n	800b6c8 <SecureElementAesEncrypt+0xec>
 800b634:	f893 207e 	ldrb.w	r2, [r3, #126]	@ 0x7e
 800b638:	42a2      	cmp	r2, r4
 800b63a:	d048      	beq.n	800b6ce <SecureElementAesEncrypt+0xf2>
 800b63c:	f893 208f 	ldrb.w	r2, [r3, #143]	@ 0x8f
 800b640:	42a2      	cmp	r2, r4
 800b642:	d047      	beq.n	800b6d4 <SecureElementAesEncrypt+0xf8>
 800b644:	f893 20a0 	ldrb.w	r2, [r3, #160]	@ 0xa0
 800b648:	42a2      	cmp	r2, r4
 800b64a:	d046      	beq.n	800b6da <SecureElementAesEncrypt+0xfe>
 800b64c:	f893 20b1 	ldrb.w	r2, [r3, #177]	@ 0xb1
 800b650:	42a2      	cmp	r2, r4
 800b652:	d045      	beq.n	800b6e0 <SecureElementAesEncrypt+0x104>
 800b654:	f893 20c2 	ldrb.w	r2, [r3, #194]	@ 0xc2
 800b658:	42a2      	cmp	r2, r4
 800b65a:	bf08      	it	eq
 800b65c:	f04f 080a 	moveq.w	r8, #10
 800b660:	d009      	beq.n	800b676 <SecureElementAesEncrypt+0x9a>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800b662:	2003      	movs	r0, #3
}
 800b664:	b03e      	add	sp, #248	@ 0xf8
 800b666:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 800b66a:	2005      	movs	r0, #5
}
 800b66c:	b03e      	add	sp, #248	@ 0xf8
 800b66e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b672:	f04f 0801 	mov.w	r8, #1
        lorawan_aes_set_key( pItem->KeyValue, SE_KEY_SIZE, &aesContext );
 800b676:	eb08 1808 	add.w	r8, r8, r8, lsl #4
 800b67a:	f108 0019 	add.w	r0, r8, #25
 800b67e:	4418      	add	r0, r3
 800b680:	aa01      	add	r2, sp, #4
 800b682:	2110      	movs	r1, #16
 800b684:	f7ff f962 	bl	800a94c <lorawan_aes_set_key>
        while( size != 0 )
 800b688:	b16d      	cbz	r5, 800b6a6 <SecureElementAesEncrypt+0xca>
 800b68a:	462c      	mov	r4, r5
            lorawan_aes_encrypt( &buffer[block], &encBuffer[block], &aesContext );
 800b68c:	eba5 0c04 	sub.w	ip, r5, r4
 800b690:	fa5f fc8c 	uxtb.w	ip, ip
 800b694:	aa01      	add	r2, sp, #4
 800b696:	eb07 010c 	add.w	r1, r7, ip
 800b69a:	eb06 000c 	add.w	r0, r6, ip
 800b69e:	f7ff fa5b 	bl	800ab58 <lorawan_aes_encrypt>
        while( size != 0 )
 800b6a2:	3c10      	subs	r4, #16
 800b6a4:	d1f2      	bne.n	800b68c <SecureElementAesEncrypt+0xb0>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800b6a6:	2000      	movs	r0, #0
}
 800b6a8:	b03e      	add	sp, #248	@ 0xf8
 800b6aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b6ae:	2002      	movs	r0, #2
}
 800b6b0:	4770      	bx	lr
        return SECURE_ELEMENT_ERROR_NPE;
 800b6b2:	2002      	movs	r0, #2
 800b6b4:	e7d6      	b.n	800b664 <SecureElementAesEncrypt+0x88>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b6b6:	f04f 0802 	mov.w	r8, #2
 800b6ba:	e7dc      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6bc:	f04f 0803 	mov.w	r8, #3
 800b6c0:	e7d9      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6c2:	f04f 0804 	mov.w	r8, #4
 800b6c6:	e7d6      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6c8:	f04f 0805 	mov.w	r8, #5
 800b6cc:	e7d3      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6ce:	f04f 0806 	mov.w	r8, #6
 800b6d2:	e7d0      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6d4:	f04f 0807 	mov.w	r8, #7
 800b6d8:	e7cd      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6da:	f04f 0808 	mov.w	r8, #8
 800b6de:	e7ca      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6e0:	f04f 0809 	mov.w	r8, #9
 800b6e4:	e7c7      	b.n	800b676 <SecureElementAesEncrypt+0x9a>
 800b6e6:	bf00      	nop
 800b6e8:	200004d0 	.word	0x200004d0

0800b6ec <SecureElementDeriveAndStoreKey>:
{
 800b6ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b6ee:	b089      	sub	sp, #36	@ 0x24
    if( input == NULL )
 800b6f0:	2800      	cmp	r0, #0
 800b6f2:	d053      	beq.n	800b79c <SecureElementDeriveAndStoreKey+0xb0>
    if( targetKeyID == MC_KE_KEY )
 800b6f4:	2a0c      	cmp	r2, #12
 800b6f6:	4614      	mov	r4, r2
 800b6f8:	d101      	bne.n	800b6fe <SecureElementDeriveAndStoreKey+0x12>
        if( rootKeyID != MC_ROOT_KEY )
 800b6fa:	290b      	cmp	r1, #11
 800b6fc:	d13d      	bne.n	800b77a <SecureElementDeriveAndStoreKey+0x8e>
    uint8_t key[SE_KEY_SIZE] = { 0 };
 800b6fe:	2300      	movs	r3, #0
 800b700:	e9cd 3300 	strd	r3, r3, [sp]
 800b704:	e9cd 3302 	strd	r3, r3, [sp, #8]
 800b708:	460a      	mov	r2, r1
    if( ( size % 16 ) != 0 )
 800b70a:	466b      	mov	r3, sp
 800b70c:	2110      	movs	r1, #16
 800b70e:	f7ff fdef 	bl	800b2f0 <SecureElementAesEncrypt.part.0>
    if( retval != SECURE_ELEMENT_SUCCESS )
 800b712:	4605      	mov	r5, r0
 800b714:	b110      	cbz	r0, 800b71c <SecureElementDeriveAndStoreKey+0x30>
}
 800b716:	4628      	mov	r0, r5
 800b718:	b009      	add	sp, #36	@ 0x24
 800b71a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b71c:	4f34      	ldr	r7, [pc, #208]	@ (800b7f0 <SecureElementDeriveAndStoreKey+0x104>)
 800b71e:	6838      	ldr	r0, [r7, #0]
 800b720:	7e03      	ldrb	r3, [r0, #24]
 800b722:	42a3      	cmp	r3, r4
 800b724:	d02d      	beq.n	800b782 <SecureElementDeriveAndStoreKey+0x96>
 800b726:	f890 3029 	ldrb.w	r3, [r0, #41]	@ 0x29
 800b72a:	42a3      	cmp	r3, r4
 800b72c:	d04e      	beq.n	800b7cc <SecureElementDeriveAndStoreKey+0xe0>
 800b72e:	f890 303a 	ldrb.w	r3, [r0, #58]	@ 0x3a
 800b732:	42a3      	cmp	r3, r4
 800b734:	d04c      	beq.n	800b7d0 <SecureElementDeriveAndStoreKey+0xe4>
 800b736:	f890 304b 	ldrb.w	r3, [r0, #75]	@ 0x4b
 800b73a:	42a3      	cmp	r3, r4
 800b73c:	d04a      	beq.n	800b7d4 <SecureElementDeriveAndStoreKey+0xe8>
 800b73e:	f890 305c 	ldrb.w	r3, [r0, #92]	@ 0x5c
 800b742:	42a3      	cmp	r3, r4
 800b744:	d048      	beq.n	800b7d8 <SecureElementDeriveAndStoreKey+0xec>
 800b746:	f890 306d 	ldrb.w	r3, [r0, #109]	@ 0x6d
 800b74a:	42a3      	cmp	r3, r4
 800b74c:	d046      	beq.n	800b7dc <SecureElementDeriveAndStoreKey+0xf0>
 800b74e:	f890 307e 	ldrb.w	r3, [r0, #126]	@ 0x7e
 800b752:	42a3      	cmp	r3, r4
 800b754:	d044      	beq.n	800b7e0 <SecureElementDeriveAndStoreKey+0xf4>
 800b756:	f890 308f 	ldrb.w	r3, [r0, #143]	@ 0x8f
 800b75a:	42a3      	cmp	r3, r4
 800b75c:	d042      	beq.n	800b7e4 <SecureElementDeriveAndStoreKey+0xf8>
 800b75e:	f890 30a0 	ldrb.w	r3, [r0, #160]	@ 0xa0
 800b762:	42a3      	cmp	r3, r4
 800b764:	d040      	beq.n	800b7e8 <SecureElementDeriveAndStoreKey+0xfc>
 800b766:	f890 30b1 	ldrb.w	r3, [r0, #177]	@ 0xb1
 800b76a:	42a3      	cmp	r3, r4
 800b76c:	d03e      	beq.n	800b7ec <SecureElementDeriveAndStoreKey+0x100>
 800b76e:	f890 30c2 	ldrb.w	r3, [r0, #194]	@ 0xc2
 800b772:	42a3      	cmp	r3, r4
 800b774:	bf08      	it	eq
 800b776:	230a      	moveq	r3, #10
 800b778:	d004      	beq.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800b77a:	2503      	movs	r5, #3
}
 800b77c:	4628      	mov	r0, r5
 800b77e:	b009      	add	sp, #36	@ 0x24
 800b780:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b782:	462b      	mov	r3, r5
            if( keyID == MC_KEY_0 )
 800b784:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 800b788:	2c0d      	cmp	r4, #13
 800b78a:	f103 0619 	add.w	r6, r3, #25
 800b78e:	d009      	beq.n	800b7a4 <SecureElementDeriveAndStoreKey+0xb8>
                memcpy1( SeNvm->KeyList[i].KeyValue, key, SE_KEY_SIZE );
 800b790:	2210      	movs	r2, #16
 800b792:	4669      	mov	r1, sp
 800b794:	4430      	add	r0, r6
 800b796:	f006 fd75 	bl	8012284 <memcpy1>
                return SECURE_ELEMENT_SUCCESS;
 800b79a:	e7bc      	b.n	800b716 <SecureElementDeriveAndStoreKey+0x2a>
        return SECURE_ELEMENT_ERROR_NPE;
 800b79c:	2502      	movs	r5, #2
}
 800b79e:	4628      	mov	r0, r5
 800b7a0:	b009      	add	sp, #36	@ 0x24
 800b7a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                uint8_t decryptedKey[SE_KEY_SIZE] = { 0 };
 800b7a4:	2300      	movs	r3, #0
 800b7a6:	e9cd 3304 	strd	r3, r3, [sp, #16]
 800b7aa:	e9cd 3306 	strd	r3, r3, [sp, #24]
    if( ( size % 16 ) != 0 )
 800b7ae:	4668      	mov	r0, sp
 800b7b0:	ab04      	add	r3, sp, #16
 800b7b2:	220c      	movs	r2, #12
 800b7b4:	2110      	movs	r1, #16
 800b7b6:	f7ff fd9b 	bl	800b2f0 <SecureElementAesEncrypt.part.0>
 800b7ba:	4605      	mov	r5, r0
                memcpy1( SeNvm->KeyList[i].KeyValue, decryptedKey, SE_KEY_SIZE );
 800b7bc:	6838      	ldr	r0, [r7, #0]
 800b7be:	2210      	movs	r2, #16
 800b7c0:	eb0d 0102 	add.w	r1, sp, r2
 800b7c4:	4430      	add	r0, r6
 800b7c6:	f006 fd5d 	bl	8012284 <memcpy1>
                return retval;
 800b7ca:	e7a4      	b.n	800b716 <SecureElementDeriveAndStoreKey+0x2a>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b7cc:	2301      	movs	r3, #1
 800b7ce:	e7d9      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7d0:	2302      	movs	r3, #2
 800b7d2:	e7d7      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7d4:	2303      	movs	r3, #3
 800b7d6:	e7d5      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7d8:	2304      	movs	r3, #4
 800b7da:	e7d3      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7dc:	2305      	movs	r3, #5
 800b7de:	e7d1      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7e0:	2306      	movs	r3, #6
 800b7e2:	e7cf      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7e4:	2307      	movs	r3, #7
 800b7e6:	e7cd      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7e8:	2308      	movs	r3, #8
 800b7ea:	e7cb      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7ec:	2309      	movs	r3, #9
 800b7ee:	e7c9      	b.n	800b784 <SecureElementDeriveAndStoreKey+0x98>
 800b7f0:	200004d0 	.word	0x200004d0

0800b7f4 <SecureElementProcessJoinAccept>:
{
 800b7f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b7f8:	b0c1      	sub	sp, #260	@ 0x104
 800b7fa:	e9dd 6449 	ldrd	r6, r4, [sp, #292]	@ 0x124
 800b7fe:	f89d 7120 	ldrb.w	r7, [sp, #288]	@ 0x120
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 800b802:	2b00      	cmp	r3, #0
 800b804:	d04e      	beq.n	800b8a4 <SecureElementProcessJoinAccept+0xb0>
 800b806:	2e00      	cmp	r6, #0
 800b808:	d04c      	beq.n	800b8a4 <SecureElementProcessJoinAccept+0xb0>
 800b80a:	2c00      	cmp	r4, #0
 800b80c:	d04a      	beq.n	800b8a4 <SecureElementProcessJoinAccept+0xb0>
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 800b80e:	2f21      	cmp	r7, #33	@ 0x21
 800b810:	d844      	bhi.n	800b89c <SecureElementProcessJoinAccept+0xa8>
    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 800b812:	463a      	mov	r2, r7
 800b814:	4619      	mov	r1, r3
 800b816:	4630      	mov	r0, r6
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 800b818:	f107 38ff 	add.w	r8, r7, #4294967295
 800b81c:	461d      	mov	r5, r3
    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 800b81e:	f006 fd31 	bl	8012284 <memcpy1>
    if( ( size % 16 ) != 0 )
 800b822:	f018 090f 	ands.w	r9, r8, #15
 800b826:	d135      	bne.n	800b894 <SecureElementProcessJoinAccept+0xa0>
    memset1( aesContext.ksch, '\0', 240 );
 800b828:	22f0      	movs	r2, #240	@ 0xf0
 800b82a:	4649      	mov	r1, r9
 800b82c:	a803      	add	r0, sp, #12
 800b82e:	f006 fd85 	bl	801233c <memset1>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b832:	4b49      	ldr	r3, [pc, #292]	@ (800b958 <SecureElementProcessJoinAccept+0x164>)
 800b834:	681b      	ldr	r3, [r3, #0]
 800b836:	7e1a      	ldrb	r2, [r3, #24]
 800b838:	2a01      	cmp	r2, #1
 800b83a:	d039      	beq.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b83c:	f893 9029 	ldrb.w	r9, [r3, #41]	@ 0x29
 800b840:	f1b9 0f01 	cmp.w	r9, #1
 800b844:	d034      	beq.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b846:	f893 203a 	ldrb.w	r2, [r3, #58]	@ 0x3a
 800b84a:	2a01      	cmp	r2, #1
 800b84c:	d02e      	beq.n	800b8ac <SecureElementProcessJoinAccept+0xb8>
 800b84e:	f893 204b 	ldrb.w	r2, [r3, #75]	@ 0x4b
 800b852:	2a01      	cmp	r2, #1
 800b854:	d06d      	beq.n	800b932 <SecureElementProcessJoinAccept+0x13e>
 800b856:	f893 205c 	ldrb.w	r2, [r3, #92]	@ 0x5c
 800b85a:	2a01      	cmp	r2, #1
 800b85c:	d06c      	beq.n	800b938 <SecureElementProcessJoinAccept+0x144>
 800b85e:	f893 206d 	ldrb.w	r2, [r3, #109]	@ 0x6d
 800b862:	2a01      	cmp	r2, #1
 800b864:	d06b      	beq.n	800b93e <SecureElementProcessJoinAccept+0x14a>
 800b866:	f893 207e 	ldrb.w	r2, [r3, #126]	@ 0x7e
 800b86a:	2a01      	cmp	r2, #1
 800b86c:	d05e      	beq.n	800b92c <SecureElementProcessJoinAccept+0x138>
 800b86e:	f893 208f 	ldrb.w	r2, [r3, #143]	@ 0x8f
 800b872:	2a01      	cmp	r2, #1
 800b874:	d066      	beq.n	800b944 <SecureElementProcessJoinAccept+0x150>
 800b876:	f893 20a0 	ldrb.w	r2, [r3, #160]	@ 0xa0
 800b87a:	2a01      	cmp	r2, #1
 800b87c:	d065      	beq.n	800b94a <SecureElementProcessJoinAccept+0x156>
 800b87e:	f893 20b1 	ldrb.w	r2, [r3, #177]	@ 0xb1
 800b882:	2a01      	cmp	r2, #1
 800b884:	d064      	beq.n	800b950 <SecureElementProcessJoinAccept+0x15c>
 800b886:	f893 20c2 	ldrb.w	r2, [r3, #194]	@ 0xc2
 800b88a:	2a01      	cmp	r2, #1
 800b88c:	bf08      	it	eq
 800b88e:	f04f 090a 	moveq.w	r9, #10
 800b892:	d00d      	beq.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 800b894:	2007      	movs	r0, #7
}
 800b896:	b041      	add	sp, #260	@ 0x104
 800b898:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 800b89c:	2005      	movs	r0, #5
}
 800b89e:	b041      	add	sp, #260	@ 0x104
 800b8a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b8a4:	2002      	movs	r0, #2
}
 800b8a6:	b041      	add	sp, #260	@ 0x104
 800b8a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b8ac:	f04f 0902 	mov.w	r9, #2
        lorawan_aes_set_key( pItem->KeyValue, SE_KEY_SIZE, &aesContext );
 800b8b0:	eb09 1909 	add.w	r9, r9, r9, lsl #4
 800b8b4:	f109 0019 	add.w	r0, r9, #25
 800b8b8:	4418      	add	r0, r3
 800b8ba:	aa03      	add	r2, sp, #12
 800b8bc:	2110      	movs	r1, #16
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 800b8be:	46c1      	mov	r9, r8
        lorawan_aes_set_key( pItem->KeyValue, SE_KEY_SIZE, &aesContext );
 800b8c0:	f7ff f844 	bl	800a94c <lorawan_aes_set_key>
        while( size != 0 )
 800b8c4:	f1b8 0f00 	cmp.w	r8, #0
 800b8c8:	d00b      	beq.n	800b8e2 <SecureElementProcessJoinAccept+0xee>
            lorawan_aes_encrypt( &buffer[block], &encBuffer[block], &aesContext );
 800b8ca:	eba8 0009 	sub.w	r0, r8, r9
 800b8ce:	b2c0      	uxtb	r0, r0
 800b8d0:	3001      	adds	r0, #1
 800b8d2:	1831      	adds	r1, r6, r0
 800b8d4:	aa03      	add	r2, sp, #12
 800b8d6:	4428      	add	r0, r5
 800b8d8:	f7ff f93e 	bl	800ab58 <lorawan_aes_encrypt>
        while( size != 0 )
 800b8dc:	f1b9 0910 	subs.w	r9, r9, #16
 800b8e0:	d1f3      	bne.n	800b8ca <SecureElementProcessJoinAccept+0xd6>
    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 800b8e2:	7af0      	ldrb	r0, [r6, #11]
 800b8e4:	09c0      	lsrs	r0, r0, #7
 800b8e6:	7020      	strb	r0, [r4, #0]
    if( *versionMinor == 0 )
 800b8e8:	b9f0      	cbnz	r0, 800b928 <SecureElementProcessJoinAccept+0x134>
    uint32_t mic = GET_UINT32_LE( decJoinAccept, encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE );
 800b8ea:	19f4      	adds	r4, r6, r7
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800b8ec:	ab03      	add	r3, sp, #12
 800b8ee:	9300      	str	r3, [sp, #0]
 800b8f0:	1f3a      	subs	r2, r7, #4
 800b8f2:	4631      	mov	r1, r6
 800b8f4:	2301      	movs	r3, #1
    uint32_t mic = GET_UINT32_LE( decJoinAccept, encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE );
 800b8f6:	f814 6c04 	ldrb.w	r6, [r4, #-4]
 800b8fa:	f814 5c03 	ldrb.w	r5, [r4, #-3]
 800b8fe:	f814 7c02 	ldrb.w	r7, [r4, #-2]
    uint32_t              compCmac = 0;
 800b902:	9003      	str	r0, [sp, #12]
    uint32_t mic = GET_UINT32_LE( decJoinAccept, encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE );
 800b904:	f814 4c01 	ldrb.w	r4, [r4, #-1]
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800b908:	f7ff fc7a 	bl	800b200 <ComputeCmac>
    if( retval != SECURE_ELEMENT_SUCCESS )
 800b90c:	b940      	cbnz	r0, 800b920 <SecureElementProcessJoinAccept+0x12c>
    uint32_t mic = GET_UINT32_LE( decJoinAccept, encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE );
 800b90e:	0623      	lsls	r3, r4, #24
 800b910:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
    if( expectedCmac != compCmac )
 800b914:	9a03      	ldr	r2, [sp, #12]
    uint32_t mic = GET_UINT32_LE( decJoinAccept, encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE );
 800b916:	4333      	orrs	r3, r6
 800b918:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    if( expectedCmac != compCmac )
 800b91c:	4293      	cmp	r3, r2
 800b91e:	d0be      	beq.n	800b89e <SecureElementProcessJoinAccept+0xaa>
            return SECURE_ELEMENT_FAIL_CMAC;
 800b920:	2001      	movs	r0, #1
}
 800b922:	b041      	add	sp, #260	@ 0x104
 800b924:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 800b928:	2004      	movs	r0, #4
 800b92a:	e7b8      	b.n	800b89e <SecureElementProcessJoinAccept+0xaa>
        if( SeNvm->KeyList[i].KeyID == keyID )
 800b92c:	f04f 0906 	mov.w	r9, #6
 800b930:	e7be      	b.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b932:	f04f 0903 	mov.w	r9, #3
 800b936:	e7bb      	b.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b938:	f04f 0904 	mov.w	r9, #4
 800b93c:	e7b8      	b.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b93e:	f04f 0905 	mov.w	r9, #5
 800b942:	e7b5      	b.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b944:	f04f 0907 	mov.w	r9, #7
 800b948:	e7b2      	b.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b94a:	f04f 0908 	mov.w	r9, #8
 800b94e:	e7af      	b.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b950:	f04f 0909 	mov.w	r9, #9
 800b954:	e7ac      	b.n	800b8b0 <SecureElementProcessJoinAccept+0xbc>
 800b956:	bf00      	nop
 800b958:	200004d0 	.word	0x200004d0

0800b95c <SecureElementRandomNumber>:
    if( randomNum == NULL )
 800b95c:	b138      	cbz	r0, 800b96e <SecureElementRandomNumber+0x12>
    *randomNum = Radio.Random();
 800b95e:	4b05      	ldr	r3, [pc, #20]	@ (800b974 <SecureElementRandomNumber+0x18>)
{
 800b960:	b510      	push	{r4, lr}
    *randomNum = Radio.Random();
 800b962:	695b      	ldr	r3, [r3, #20]
 800b964:	4604      	mov	r4, r0
 800b966:	4798      	blx	r3
 800b968:	6020      	str	r0, [r4, #0]
    return SECURE_ELEMENT_SUCCESS;
 800b96a:	2000      	movs	r0, #0
}
 800b96c:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b96e:	2002      	movs	r0, #2
}
 800b970:	4770      	bx	lr
 800b972:	bf00      	nop
 800b974:	08017658 	.word	0x08017658

0800b978 <SecureElementSetDevEui>:
    if( devEui == NULL )
 800b978:	b140      	cbz	r0, 800b98c <SecureElementSetDevEui+0x14>
{
 800b97a:	b508      	push	{r3, lr}
    memcpy1( SeNvm->SeNvmDevJoinKey.DevEui, devEui, SE_EUI_SIZE );
 800b97c:	4b04      	ldr	r3, [pc, #16]	@ (800b990 <SecureElementSetDevEui+0x18>)
 800b97e:	4601      	mov	r1, r0
 800b980:	2208      	movs	r2, #8
 800b982:	6818      	ldr	r0, [r3, #0]
 800b984:	f006 fc7e 	bl	8012284 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 800b988:	2000      	movs	r0, #0
}
 800b98a:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b98c:	2002      	movs	r0, #2
}
 800b98e:	4770      	bx	lr
 800b990:	200004d0 	.word	0x200004d0

0800b994 <SecureElementGetDevEui>:
    if( devEui == NULL )
 800b994:	b138      	cbz	r0, 800b9a6 <SecureElementGetDevEui+0x12>
{
 800b996:	b508      	push	{r3, lr}
    memcpy1( devEui, SeNvm->SeNvmDevJoinKey.DevEui, SE_EUI_SIZE );
 800b998:	4b04      	ldr	r3, [pc, #16]	@ (800b9ac <SecureElementGetDevEui+0x18>)
 800b99a:	2208      	movs	r2, #8
 800b99c:	6819      	ldr	r1, [r3, #0]
 800b99e:	f006 fc71 	bl	8012284 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 800b9a2:	2000      	movs	r0, #0
}
 800b9a4:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b9a6:	2002      	movs	r0, #2
}
 800b9a8:	4770      	bx	lr
 800b9aa:	bf00      	nop
 800b9ac:	200004d0 	.word	0x200004d0

0800b9b0 <SecureElementSetJoinEui>:
    if( joinEui == NULL )
 800b9b0:	b148      	cbz	r0, 800b9c6 <SecureElementSetJoinEui+0x16>
{
 800b9b2:	b508      	push	{r3, lr}
    memcpy1( SeNvm->SeNvmDevJoinKey.JoinEui, joinEui, SE_EUI_SIZE );
 800b9b4:	4b05      	ldr	r3, [pc, #20]	@ (800b9cc <SecureElementSetJoinEui+0x1c>)
 800b9b6:	4601      	mov	r1, r0
 800b9b8:	6818      	ldr	r0, [r3, #0]
 800b9ba:	2208      	movs	r2, #8
 800b9bc:	4410      	add	r0, r2
 800b9be:	f006 fc61 	bl	8012284 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 800b9c2:	2000      	movs	r0, #0
}
 800b9c4:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b9c6:	2002      	movs	r0, #2
}
 800b9c8:	4770      	bx	lr
 800b9ca:	bf00      	nop
 800b9cc:	200004d0 	.word	0x200004d0

0800b9d0 <SecureElementGetJoinEui>:
    if( joinEui == NULL )
 800b9d0:	b140      	cbz	r0, 800b9e4 <SecureElementGetJoinEui+0x14>
{
 800b9d2:	b508      	push	{r3, lr}
    memcpy1( joinEui, SeNvm->SeNvmDevJoinKey.JoinEui, SE_EUI_SIZE );
 800b9d4:	4b04      	ldr	r3, [pc, #16]	@ (800b9e8 <SecureElementGetJoinEui+0x18>)
 800b9d6:	6819      	ldr	r1, [r3, #0]
 800b9d8:	2208      	movs	r2, #8
 800b9da:	4411      	add	r1, r2
 800b9dc:	f006 fc52 	bl	8012284 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 800b9e0:	2000      	movs	r0, #0
}
 800b9e2:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800b9e4:	2002      	movs	r0, #2
}
 800b9e6:	4770      	bx	lr
 800b9e8:	200004d0 	.word	0x200004d0

0800b9ec <SecureElementSetDevAddr>:
        SeNvm->SeNvmDevJoinKey.DevAddrOTAA = devAddr;
 800b9ec:	4b03      	ldr	r3, [pc, #12]	@ (800b9fc <SecureElementSetDevAddr+0x10>)
 800b9ee:	681b      	ldr	r3, [r3, #0]
    if( mode == ACTIVATION_TYPE_OTAA )
 800b9f0:	2802      	cmp	r0, #2
        SeNvm->SeNvmDevJoinKey.DevAddrOTAA = devAddr;
 800b9f2:	bf0c      	ite	eq
 800b9f4:	6119      	streq	r1, [r3, #16]
        SeNvm->SeNvmDevJoinKey.DevAddrABP = devAddr;
 800b9f6:	6159      	strne	r1, [r3, #20]
}
 800b9f8:	2000      	movs	r0, #0
 800b9fa:	4770      	bx	lr
 800b9fc:	200004d0 	.word	0x200004d0

0800ba00 <SecureElementGetDevAddr>:
    if( devAddr == NULL )
 800ba00:	b149      	cbz	r1, 800ba16 <SecureElementGetDevAddr+0x16>
        *devAddr = SeNvm->SeNvmDevJoinKey.DevAddrOTAA;
 800ba02:	4b06      	ldr	r3, [pc, #24]	@ (800ba1c <SecureElementGetDevAddr+0x1c>)
 800ba04:	681b      	ldr	r3, [r3, #0]
        *devAddr = SeNvm->SeNvmDevJoinKey.DevAddrABP;
 800ba06:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
    if( mode == ACTIVATION_TYPE_OTAA )
 800ba0a:	2802      	cmp	r0, #2
 800ba0c:	bf08      	it	eq
 800ba0e:	4613      	moveq	r3, r2
        *devAddr = SeNvm->SeNvmDevJoinKey.DevAddrOTAA;
 800ba10:	600b      	str	r3, [r1, #0]
    }
    return SECURE_ELEMENT_SUCCESS;
 800ba12:	2000      	movs	r0, #0
 800ba14:	4770      	bx	lr
        return SECURE_ELEMENT_ERROR_NPE;
 800ba16:	2002      	movs	r0, #2
        }
    }

    return status;
#endif /* LORAWAN_KMS */
}
 800ba18:	4770      	bx	lr
 800ba1a:	bf00      	nop
 800ba1c:	200004d0 	.word	0x200004d0

0800ba20 <McpsConfirm>:
 * LORAMAC NOTIFICATIONS HANDLING
 *=============================================================================
 */

static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
 800ba20:	b570      	push	{r4, r5, r6, lr}
 800ba22:	4605      	mov	r5, r0
    TxParams.IsMcpsConfirm = 1;
 800ba24:	4810      	ldr	r0, [pc, #64]	@ (800ba68 <McpsConfirm+0x48>)
    TxParams.Status = mcpsConfirm->Status;
    TxParams.Datarate = mcpsConfirm->Datarate;
 800ba26:	78ab      	ldrb	r3, [r5, #2]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 800ba28:	68ea      	ldr	r2, [r5, #12]
    TxParams.Status = mcpsConfirm->Status;
 800ba2a:	7869      	ldrb	r1, [r5, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 800ba2c:	7283      	strb	r3, [r0, #10]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 800ba2e:	60c2      	str	r2, [r0, #12]
    TxParams.TxPower = mcpsConfirm->TxPower;
    TxParams.Channel = mcpsConfirm->Channel;
    TxParams.AckReceived = mcpsConfirm->AckReceived;

    if( LmHandlerCallbacks->OnTxData != NULL )
 800ba30:	4b0e      	ldr	r3, [pc, #56]	@ (800ba6c <McpsConfirm+0x4c>)
    TxParams.TxPower = mcpsConfirm->TxPower;
 800ba32:	78ea      	ldrb	r2, [r5, #3]
 800ba34:	7602      	strb	r2, [r0, #24]
    if( LmHandlerCallbacks->OnTxData != NULL )
 800ba36:	681b      	ldr	r3, [r3, #0]
    TxParams.Channel = mcpsConfirm->Channel;
 800ba38:	692a      	ldr	r2, [r5, #16]
 800ba3a:	7642      	strb	r2, [r0, #25]
    if( LmHandlerCallbacks->OnTxData != NULL )
 800ba3c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 800ba3e:	792a      	ldrb	r2, [r5, #4]
    TxParams.Status = mcpsConfirm->Status;
 800ba40:	7041      	strb	r1, [r0, #1]
    TxParams.IsMcpsConfirm = 1;
 800ba42:	2401      	movs	r4, #1
 800ba44:	7004      	strb	r4, [r0, #0]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 800ba46:	7242      	strb	r2, [r0, #9]
    if( LmHandlerCallbacks->OnTxData != NULL )
 800ba48:	b103      	cbz	r3, 800ba4c <McpsConfirm+0x2c>
    {
        LmHandlerCallbacks->OnTxData( &TxParams );
 800ba4a:	4798      	blx	r3
    }
}

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800ba4c:	4c08      	ldr	r4, [pc, #32]	@ (800ba70 <McpsConfirm+0x50>)
 800ba4e:	f104 0614 	add.w	r6, r4, #20
    {
        if( LmHandlerPackages[i] != NULL )
 800ba52:	f854 3b04 	ldr.w	r3, [r4], #4
            {
                case PACKAGE_MCPS_CONFIRM:
                    {
                        if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
                        {
                            LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t * ) params );
 800ba56:	4628      	mov	r0, r5
        if( LmHandlerPackages[i] != NULL )
 800ba58:	b113      	cbz	r3, 800ba60 <McpsConfirm+0x40>
                        if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 800ba5a:	69db      	ldr	r3, [r3, #28]
 800ba5c:	b103      	cbz	r3, 800ba60 <McpsConfirm+0x40>
                            LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t * ) params );
 800ba5e:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800ba60:	42b4      	cmp	r4, r6
 800ba62:	d1f6      	bne.n	800ba52 <McpsConfirm+0x32>
}
 800ba64:	bd70      	pop	{r4, r5, r6, pc}
 800ba66:	bf00      	nop
 800ba68:	20000094 	.word	0x20000094
 800ba6c:	200005f4 	.word	0x200005f4
 800ba70:	20000610 	.word	0x20000610

0800ba74 <MlmeIndication>:
{
 800ba74:	b570      	push	{r4, r5, r6, lr}
    RxParams.IsMcpsIndication = 0;
 800ba76:	4b14      	ldr	r3, [pc, #80]	@ (800bac8 <MlmeIndication+0x54>)
    RxParams.Status = mlmeIndication->Status;
 800ba78:	7842      	ldrb	r2, [r0, #1]
    RxParams.Datarate = mlmeIndication->RxDatarate;
 800ba7a:	7884      	ldrb	r4, [r0, #2]
 800ba7c:	721c      	strb	r4, [r3, #8]
{
 800ba7e:	4605      	mov	r5, r0
    RxParams.IsMcpsIndication = 0;
 800ba80:	2000      	movs	r0, #0
    RxParams.Status = mlmeIndication->Status;
 800ba82:	705a      	strb	r2, [r3, #1]
    RxParams.IsMcpsIndication = 0;
 800ba84:	7018      	strb	r0, [r3, #0]
    RxParams.Rssi = rxStatus->Rssi;
 800ba86:	880a      	ldrh	r2, [r1, #0]
 800ba88:	725a      	strb	r2, [r3, #9]
    RxParams.Snr = rxStatus->Snr;
 800ba8a:	788a      	ldrb	r2, [r1, #2]
 800ba8c:	729a      	strb	r2, [r3, #10]
    if( ( LmHandlerCallbacks->OnRxData != NULL ) && ( mlmeIndication->MlmeIndication != MLME_BEACON ) && ( mlmeIndication->MlmeIndication != MLME_BEACON_LOST ) )
 800ba8e:	4a0f      	ldr	r2, [pc, #60]	@ (800bacc <MlmeIndication+0x58>)
    RxParams.RxSlot = rxStatus->RxSlot;
 800ba90:	78c9      	ldrb	r1, [r1, #3]
    if( ( LmHandlerCallbacks->OnRxData != NULL ) && ( mlmeIndication->MlmeIndication != MLME_BEACON ) && ( mlmeIndication->MlmeIndication != MLME_BEACON_LOST ) )
 800ba92:	6812      	ldr	r2, [r2, #0]
    RxParams.RxSlot = rxStatus->RxSlot;
 800ba94:	7419      	strb	r1, [r3, #16]
    if( ( LmHandlerCallbacks->OnRxData != NULL ) && ( mlmeIndication->MlmeIndication != MLME_BEACON ) && ( mlmeIndication->MlmeIndication != MLME_BEACON_LOST ) )
 800ba96:	6ad4      	ldr	r4, [r2, #44]	@ 0x2c
    RxParams.DownlinkCounter = mlmeIndication->DownLinkCounter;
 800ba98:	686a      	ldr	r2, [r5, #4]
 800ba9a:	60da      	str	r2, [r3, #12]
    if( ( LmHandlerCallbacks->OnRxData != NULL ) && ( mlmeIndication->MlmeIndication != MLME_BEACON ) && ( mlmeIndication->MlmeIndication != MLME_BEACON_LOST ) )
 800ba9c:	b134      	cbz	r4, 800baac <MlmeIndication+0x38>
 800ba9e:	782a      	ldrb	r2, [r5, #0]
 800baa0:	f002 02fb 	and.w	r2, r2, #251	@ 0xfb
 800baa4:	2a0b      	cmp	r2, #11
 800baa6:	d001      	beq.n	800baac <MlmeIndication+0x38>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 800baa8:	4619      	mov	r1, r3
 800baaa:	47a0      	blx	r4
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800baac:	4c08      	ldr	r4, [pc, #32]	@ (800bad0 <MlmeIndication+0x5c>)
 800baae:	f104 0614 	add.w	r6, r4, #20
        if( LmHandlerPackages[i] != NULL )
 800bab2:	f854 3b04 	ldr.w	r3, [r4], #4
                    }
                case PACKAGE_MLME_INDICATION:
                    {
                        if( LmHandlerPackages[i]->OnMlmeIndicationProcess != NULL )
                        {
                            LmHandlerPackages[i]->OnMlmeIndicationProcess( params );
 800bab6:	4628      	mov	r0, r5
        if( LmHandlerPackages[i] != NULL )
 800bab8:	b113      	cbz	r3, 800bac0 <MlmeIndication+0x4c>
                        if( LmHandlerPackages[i]->OnMlmeIndicationProcess != NULL )
 800baba:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800babc:	b103      	cbz	r3, 800bac0 <MlmeIndication+0x4c>
                            LmHandlerPackages[i]->OnMlmeIndicationProcess( params );
 800babe:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800bac0:	42b4      	cmp	r4, r6
 800bac2:	d1f6      	bne.n	800bab2 <MlmeIndication+0x3e>
}
 800bac4:	bd70      	pop	{r4, r5, r6, pc}
 800bac6:	bf00      	nop
 800bac8:	20000080 	.word	0x20000080
 800bacc:	200005f4 	.word	0x200005f4
 800bad0:	20000610 	.word	0x20000610

0800bad4 <LmHandlerDeviceTimeReq>:
{
 800bad4:	b500      	push	{lr}
 800bad6:	b087      	sub	sp, #28
    mlmeReq.Type = MLME_DEVICE_TIME;
 800bad8:	230a      	movs	r3, #10
    status = LoRaMacMlmeRequest( &mlmeReq );
 800bada:	a801      	add	r0, sp, #4
    mlmeReq.Type = MLME_DEVICE_TIME;
 800badc:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMlmeRequest( &mlmeReq );
 800bae0:	f003 fb3e 	bl	800f160 <LoRaMacMlmeRequest>
    if( status == LORAMAC_STATUS_OK )
 800bae4:	3800      	subs	r0, #0
    DutyCycleWaitTime = mlmeReq.ReqReturn.DutyCycleWaitTime;
 800bae6:	4b04      	ldr	r3, [pc, #16]	@ (800baf8 <LmHandlerDeviceTimeReq+0x24>)
 800bae8:	9a05      	ldr	r2, [sp, #20]
 800baea:	601a      	str	r2, [r3, #0]
    if( status == LORAMAC_STATUS_OK )
 800baec:	bf18      	it	ne
 800baee:	2001      	movne	r0, #1
}
 800baf0:	4240      	negs	r0, r0
 800baf2:	b007      	add	sp, #28
 800baf4:	f85d fb04 	ldr.w	pc, [sp], #4
 800baf8:	200005c8 	.word	0x200005c8

0800bafc <LmHandlerRequestClass.part.0>:
LmHandlerErrorStatus_t LmHandlerRequestClass( DeviceClass_t newClass )
 800bafc:	b510      	push	{r4, lr}
 800bafe:	b08a      	sub	sp, #40	@ 0x28
 800bb00:	4604      	mov	r4, r0
    mibReq.Type = MIB_DEVICE_CLASS;
 800bb02:	2300      	movs	r3, #0
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800bb04:	4668      	mov	r0, sp
    mibReq.Type = MIB_DEVICE_CLASS;
 800bb06:	f88d 3000 	strb.w	r3, [sp]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800bb0a:	f002 ff27 	bl	800e95c <LoRaMacMibGetRequestConfirm>
 800bb0e:	bb38      	cbnz	r0, 800bb60 <LmHandlerRequestClass.part.0+0x64>
    currentClass = mibReq.Param.Class;
 800bb10:	f89d 3004 	ldrb.w	r3, [sp, #4]
    if( currentClass != newClass )
 800bb14:	42a3      	cmp	r3, r4
 800bb16:	d004      	beq.n	800bb22 <LmHandlerRequestClass.part.0+0x26>
        switch( newClass )
 800bb18:	2c01      	cmp	r4, #1
 800bb1a:	d021      	beq.n	800bb60 <LmHandlerRequestClass.part.0+0x64>
 800bb1c:	2c02      	cmp	r4, #2
 800bb1e:	d010      	beq.n	800bb42 <LmHandlerRequestClass.part.0+0x46>
 800bb20:	b114      	cbz	r4, 800bb28 <LmHandlerRequestClass.part.0+0x2c>
LmHandlerErrorStatus_t LmHandlerRequestClass( DeviceClass_t newClass )
 800bb22:	2000      	movs	r0, #0
}
 800bb24:	b00a      	add	sp, #40	@ 0x28
 800bb26:	bd10      	pop	{r4, pc}
                    if( currentClass != CLASS_A )
 800bb28:	2b00      	cmp	r3, #0
 800bb2a:	d0fa      	beq.n	800bb22 <LmHandlerRequestClass.part.0+0x26>
                        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 800bb2c:	4668      	mov	r0, sp
                        mibReq.Param.Class = newClass;
 800bb2e:	f88d 4004 	strb.w	r4, [sp, #4]
                        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 800bb32:	f003 f833 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
 800bb36:	b998      	cbnz	r0, 800bb60 <LmHandlerRequestClass.part.0+0x64>
                            if( LmHandlerCallbacks->OnClassChange != NULL )
 800bb38:	4b0b      	ldr	r3, [pc, #44]	@ (800bb68 <LmHandlerRequestClass.part.0+0x6c>)
 800bb3a:	681b      	ldr	r3, [r3, #0]
 800bb3c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800bb3e:	b96b      	cbnz	r3, 800bb5c <LmHandlerRequestClass.part.0+0x60>
 800bb40:	e7ef      	b.n	800bb22 <LmHandlerRequestClass.part.0+0x26>
                    if( currentClass != CLASS_A )
 800bb42:	b96b      	cbnz	r3, 800bb60 <LmHandlerRequestClass.part.0+0x64>
                        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 800bb44:	4668      	mov	r0, sp
                        mibReq.Param.Class = newClass;
 800bb46:	f88d 4004 	strb.w	r4, [sp, #4]
                        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 800bb4a:	f003 f827 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
 800bb4e:	b938      	cbnz	r0, 800bb60 <LmHandlerRequestClass.part.0+0x64>
                            if( LmHandlerCallbacks->OnClassChange != NULL )
 800bb50:	4b05      	ldr	r3, [pc, #20]	@ (800bb68 <LmHandlerRequestClass.part.0+0x6c>)
 800bb52:	681b      	ldr	r3, [r3, #0]
 800bb54:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800bb56:	2b00      	cmp	r3, #0
 800bb58:	d0e3      	beq.n	800bb22 <LmHandlerRequestClass.part.0+0x26>
                                LmHandlerCallbacks->OnClassChange( newClass );
 800bb5a:	4620      	mov	r0, r4
 800bb5c:	4798      	blx	r3
 800bb5e:	e7e0      	b.n	800bb22 <LmHandlerRequestClass.part.0+0x26>
        return LORAMAC_HANDLER_ERROR;
 800bb60:	f04f 30ff 	mov.w	r0, #4294967295
}
 800bb64:	b00a      	add	sp, #40	@ 0x28
 800bb66:	bd10      	pop	{r4, pc}
 800bb68:	200005f4 	.word	0x200005f4

0800bb6c <LmHandlerJoin>:
{
 800bb6c:	b570      	push	{r4, r5, r6, lr}
    mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 800bb6e:	4c39      	ldr	r4, [pc, #228]	@ (800bc54 <LmHandlerJoin+0xe8>)
{
 800bb70:	b09a      	sub	sp, #104	@ 0x68
    mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 800bb72:	f994 3004 	ldrsb.w	r3, [r4, #4]
    mlmeReq.Req.Join.TxPower = LmHandlerParams.TxPower;
 800bb76:	f994 2005 	ldrsb.w	r2, [r4, #5]
    mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 800bb7a:	f88d 3009 	strb.w	r3, [sp, #9]
    mlmeReq.Type = MLME_JOIN;
 800bb7e:	2601      	movs	r6, #1
    if( mode == ACTIVATION_TYPE_OTAA )
 800bb80:	2802      	cmp	r0, #2
    mlmeReq.Type = MLME_JOIN;
 800bb82:	f88d 6004 	strb.w	r6, [sp, #4]
    mlmeReq.Req.Join.TxPower = LmHandlerParams.TxPower;
 800bb86:	f88d 200a 	strb.w	r2, [sp, #10]
    if( mode == ACTIVATION_TYPE_OTAA )
 800bb8a:	d057      	beq.n	800bc3c <LmHandlerJoin+0xd0>
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 800bb8c:	4d32      	ldr	r5, [pc, #200]	@ (800bc58 <LmHandlerJoin+0xec>)
            mibReq.Param.ChannelsDefaultDatarate = LmHandlerParams.TxDatarate;
 800bb8e:	f88d 301c 	strb.w	r3, [sp, #28]
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 800bb92:	712b      	strb	r3, [r5, #4]
            mibReq.Type = MIB_CHANNELS_DEFAULT_DATARATE;
 800bb94:	231e      	movs	r3, #30
 800bb96:	f88d 3018 	strb.w	r3, [sp, #24]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bb9a:	a806      	add	r0, sp, #24
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 800bb9c:	f44f 7380 	mov.w	r3, #256	@ 0x100
        JoinParams.TxPower = LmHandlerParams.TxPower;
 800bba0:	716a      	strb	r2, [r5, #5]
        JoinParams.forceRejoin = forceRejoin;
 800bba2:	7229      	strb	r1, [r5, #8]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 800bba4:	80eb      	strh	r3, [r5, #6]
        mlmeReq.Req.Join.NetworkActivation = ACTIVATION_TYPE_ABP;
 800bba6:	f88d 6008 	strb.w	r6, [sp, #8]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbaa:	f002 fff7 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_CHANNELS_DATARATE;
 800bbae:	231f      	movs	r3, #31
 800bbb0:	f88d 3018 	strb.w	r3, [sp, #24]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbb4:	a806      	add	r0, sp, #24
            mibReq.Param.ChannelsDatarate = LmHandlerParams.TxDatarate;
 800bbb6:	7923      	ldrb	r3, [r4, #4]
 800bbb8:	f88d 301c 	strb.w	r3, [sp, #28]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbbc:	f002 ffee 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_CHANNELS_DEFAULT_TX_POWER;
 800bbc0:	2321      	movs	r3, #33	@ 0x21
 800bbc2:	f88d 3018 	strb.w	r3, [sp, #24]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbc6:	a806      	add	r0, sp, #24
            mibReq.Param.ChannelsDefaultTxPower = LmHandlerParams.TxPower;
 800bbc8:	7963      	ldrb	r3, [r4, #5]
 800bbca:	f88d 301c 	strb.w	r3, [sp, #28]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbce:	f002 ffe5 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_CHANNELS_TX_POWER;
 800bbd2:	2320      	movs	r3, #32
 800bbd4:	f88d 3018 	strb.w	r3, [sp, #24]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbd8:	a806      	add	r0, sp, #24
            mibReq.Param.ChannelsTxPower = LmHandlerParams.TxPower;
 800bbda:	7963      	ldrb	r3, [r4, #5]
 800bbdc:	f88d 301c 	strb.w	r3, [sp, #28]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbe0:	f002 ffdc 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 800bbe4:	2328      	movs	r3, #40	@ 0x28
 800bbe6:	f88d 3018 	strb.w	r3, [sp, #24]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbea:	a806      	add	r0, sp, #24
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 800bbec:	4b1b      	ldr	r3, [pc, #108]	@ (800bc5c <LmHandlerJoin+0xf0>)
 800bbee:	9307      	str	r3, [sp, #28]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800bbf0:	f002 ffd4 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
        LoRaMacStart();
 800bbf4:	f002 fe18 	bl	800e828 <LoRaMacStart>
        LoRaMacMibSetRequestConfirm( &mibReq );
 800bbf8:	a806      	add	r0, sp, #24
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 800bbfa:	f88d 6018 	strb.w	r6, [sp, #24]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 800bbfe:	f88d 601c 	strb.w	r6, [sp, #28]
        LoRaMacMibSetRequestConfirm( &mibReq );
 800bc02:	f002 ffcb 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
        if( LmHandlerCallbacks->OnJoinRequest != NULL )
 800bc06:	4b16      	ldr	r3, [pc, #88]	@ (800bc60 <LmHandlerJoin+0xf4>)
 800bc08:	681b      	ldr	r3, [r3, #0]
 800bc0a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bc0c:	b10b      	cbz	r3, 800bc12 <LmHandlerJoin+0xa6>
            LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 800bc0e:	4628      	mov	r0, r5
 800bc10:	4798      	blx	r3
        LmHandlerRequestClass( LmHandlerParams.DefaultClass );
 800bc12:	7864      	ldrb	r4, [r4, #1]
    if( LoRaMacIsBusy() == true )
 800bc14:	f001 fcca 	bl	800d5ac <LoRaMacIsBusy>
 800bc18:	b948      	cbnz	r0, 800bc2e <LmHandlerJoin+0xc2>
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800bc1a:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800bc1c:	a810      	add	r0, sp, #64	@ 0x40
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800bc1e:	f88d 3040 	strb.w	r3, [sp, #64]	@ 0x40
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800bc22:	f002 fe9b 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 800bc26:	b910      	cbnz	r0, 800bc2e <LmHandlerJoin+0xc2>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 800bc28:	f89d 3044 	ldrb.w	r3, [sp, #68]	@ 0x44
 800bc2c:	b90b      	cbnz	r3, 800bc32 <LmHandlerJoin+0xc6>
}
 800bc2e:	b01a      	add	sp, #104	@ 0x68
 800bc30:	bd70      	pop	{r4, r5, r6, pc}
 800bc32:	4620      	mov	r0, r4
 800bc34:	f7ff ff62 	bl	800bafc <LmHandlerRequestClass.part.0>
 800bc38:	b01a      	add	sp, #104	@ 0x68
 800bc3a:	bd70      	pop	{r4, r5, r6, pc}
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 800bc3c:	4b06      	ldr	r3, [pc, #24]	@ (800bc58 <LmHandlerJoin+0xec>)
        mlmeReq.Req.Join.NetworkActivation = ACTIVATION_TYPE_OTAA;
 800bc3e:	f88d 0008 	strb.w	r0, [sp, #8]
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 800bc42:	71d8      	strb	r0, [r3, #7]
        JoinParams.forceRejoin = forceRejoin;
 800bc44:	7219      	strb	r1, [r3, #8]
        LoRaMacStart();
 800bc46:	f002 fdef 	bl	800e828 <LoRaMacStart>
        LoRaMacMlmeRequest( &mlmeReq );
 800bc4a:	a801      	add	r0, sp, #4
 800bc4c:	f003 fa88 	bl	800f160 <LoRaMacMlmeRequest>
}
 800bc50:	b01a      	add	sp, #104	@ 0x68
 800bc52:	bd70      	pop	{r4, r5, r6, pc}
 800bc54:	200005f8 	.word	0x200005f8
 800bc58:	200000b0 	.word	0x200000b0
 800bc5c:	01000300 	.word	0x01000300
 800bc60:	200005f4 	.word	0x200005f4

0800bc64 <LmHandlerSend>:
{
 800bc64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bc68:	b08c      	sub	sp, #48	@ 0x30
 800bc6a:	4604      	mov	r4, r0
 800bc6c:	460d      	mov	r5, r1
 800bc6e:	4616      	mov	r6, r2
    if( LoRaMacIsBusy() == true )
 800bc70:	f001 fc9c 	bl	800d5ac <LoRaMacIsBusy>
 800bc74:	2800      	cmp	r0, #0
 800bc76:	f040 8083 	bne.w	800bd80 <LmHandlerSend+0x11c>
    if( LoRaMacIsStopped() == true )
 800bc7a:	f001 fca9 	bl	800d5d0 <LoRaMacIsStopped>
 800bc7e:	b970      	cbnz	r0, 800bc9e <LmHandlerSend+0x3a>
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800bc80:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800bc82:	a802      	add	r0, sp, #8
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800bc84:	f88d 3008 	strb.w	r3, [sp, #8]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800bc88:	f002 fe68 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 800bc8c:	b910      	cbnz	r0, 800bc94 <LmHandlerSend+0x30>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 800bc8e:	f89d 300c 	ldrb.w	r3, [sp, #12]
 800bc92:	b953      	cbnz	r3, 800bcaa <LmHandlerSend+0x46>
        LmHandlerJoin( JoinParams.Mode, JoinParams.forceRejoin );
 800bc94:	4b42      	ldr	r3, [pc, #264]	@ (800bda0 <LmHandlerSend+0x13c>)
 800bc96:	7a19      	ldrb	r1, [r3, #8]
 800bc98:	79d8      	ldrb	r0, [r3, #7]
 800bc9a:	f7ff ff67 	bl	800bb6c <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 800bc9e:	f06f 0502 	mvn.w	r5, #2
}
 800bca2:	4628      	mov	r0, r5
 800bca4:	b00c      	add	sp, #48	@ 0x30
 800bca6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 800bcaa:	4f3e      	ldr	r7, [pc, #248]	@ (800bda4 <LmHandlerSend+0x140>)
 800bcac:	683b      	ldr	r3, [r7, #0]
 800bcae:	68db      	ldr	r3, [r3, #12]
 800bcb0:	4798      	blx	r3
 800bcb2:	b130      	cbz	r0, 800bcc2 <LmHandlerSend+0x5e>
        && ( appData->Port != LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->Port ) && ( appData->Port != 0 ) )
 800bcb4:	683b      	ldr	r3, [r7, #0]
 800bcb6:	781a      	ldrb	r2, [r3, #0]
 800bcb8:	7823      	ldrb	r3, [r4, #0]
 800bcba:	429a      	cmp	r2, r3
 800bcbc:	d001      	beq.n	800bcc2 <LmHandlerSend+0x5e>
 800bcbe:	2b00      	cmp	r3, #0
 800bcc0:	d16b      	bne.n	800bd9a <LmHandlerSend+0x136>
    TxParams.MsgType = isTxConfirmed;
 800bcc2:	4f39      	ldr	r7, [pc, #228]	@ (800bda8 <LmHandlerSend+0x144>)
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 800bcc4:	f8df 80e4 	ldr.w	r8, [pc, #228]	@ 800bdac <LmHandlerSend+0x148>
    TxParams.MsgType = isTxConfirmed;
 800bcc8:	723d      	strb	r5, [r7, #8]
    mcpsReq.Type = ( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG ) ? MCPS_UNCONFIRMED : MCPS_CONFIRMED;
 800bcca:	1e29      	subs	r1, r5, #0
 800bccc:	bf18      	it	ne
 800bcce:	2101      	movne	r1, #1
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 800bcd0:	f898 3004 	ldrb.w	r3, [r8, #4]
    mcpsReq.Type = ( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG ) ? MCPS_UNCONFIRMED : MCPS_CONFIRMED;
 800bcd4:	f88d 1008 	strb.w	r1, [sp, #8]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 800bcd8:	7860      	ldrb	r0, [r4, #1]
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 800bcda:	f88d 3016 	strb.w	r3, [sp, #22]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 800bcde:	a901      	add	r1, sp, #4
 800bce0:	f002 fdd4 	bl	800e88c <LoRaMacQueryTxPossible>
 800bce4:	2800      	cmp	r0, #0
 800bce6:	d141      	bne.n	800bd6c <LmHandlerSend+0x108>
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 800bce8:	7823      	ldrb	r3, [r4, #0]
 800bcea:	f88d 300c 	strb.w	r3, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 800bcee:	6862      	ldr	r2, [r4, #4]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 800bcf0:	7863      	ldrb	r3, [r4, #1]
    LmHandlerErrorStatus_t lmhStatus = LORAMAC_HANDLER_ERROR;
 800bcf2:	f04f 35ff 	mov.w	r5, #4294967295
    TxParams.AppData = *appData;
 800bcf6:	e894 0003 	ldmia.w	r4, {r0, r1}
 800bcfa:	f8ad 3014 	strh.w	r3, [sp, #20]
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 800bcfe:	f898 3004 	ldrb.w	r3, [r8, #4]
 800bd02:	72bb      	strb	r3, [r7, #10]
    TxParams.AppData = *appData;
 800bd04:	4b2a      	ldr	r3, [pc, #168]	@ (800bdb0 <LmHandlerSend+0x14c>)
 800bd06:	9204      	str	r2, [sp, #16]
 800bd08:	e883 0003 	stmia.w	r3, {r0, r1}
    status = LoRaMacMcpsRequest( &mcpsReq, allowDelayedTx );
 800bd0c:	4631      	mov	r1, r6
 800bd0e:	a802      	add	r0, sp, #8
 800bd10:	f003 fb72 	bl	800f3f8 <LoRaMacMcpsRequest>
    DutyCycleWaitTime = mcpsReq.ReqReturn.DutyCycleWaitTime;
 800bd14:	4b27      	ldr	r3, [pc, #156]	@ (800bdb4 <LmHandlerSend+0x150>)
 800bd16:	9a06      	ldr	r2, [sp, #24]
 800bd18:	601a      	str	r2, [r3, #0]
    switch( status )
 800bd1a:	2811      	cmp	r0, #17
 800bd1c:	d82d      	bhi.n	800bd7a <LmHandlerSend+0x116>
 800bd1e:	a301      	add	r3, pc, #4	@ (adr r3, 800bd24 <LmHandlerSend+0xc0>)
 800bd20:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 800bd24:	0800bd87 	.word	0x0800bd87
 800bd28:	0800bd81 	.word	0x0800bd81
 800bd2c:	0800bd7b 	.word	0x0800bd7b
 800bd30:	0800bd7b 	.word	0x0800bd7b
 800bd34:	0800bd7b 	.word	0x0800bd7b
 800bd38:	0800bd7b 	.word	0x0800bd7b
 800bd3c:	0800bd7b 	.word	0x0800bd7b
 800bd40:	0800bc9f 	.word	0x0800bc9f
 800bd44:	0800bd7b 	.word	0x0800bd7b
 800bd48:	0800bd7b 	.word	0x0800bd7b
 800bd4c:	0800bd7b 	.word	0x0800bd7b
 800bd50:	0800bd95 	.word	0x0800bd95
 800bd54:	0800bd7b 	.word	0x0800bd7b
 800bd58:	0800bd7b 	.word	0x0800bd7b
 800bd5c:	0800bd81 	.word	0x0800bd81
 800bd60:	0800bd81 	.word	0x0800bd81
 800bd64:	0800bd81 	.word	0x0800bd81
 800bd68:	0800bd8f 	.word	0x0800bd8f
        mcpsReq.Type = MCPS_UNCONFIRMED;
 800bd6c:	2300      	movs	r3, #0
 800bd6e:	f88d 3008 	strb.w	r3, [sp, #8]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 800bd72:	461a      	mov	r2, r3
        lmhStatus = LORAMAC_HANDLER_PAYLOAD_LENGTH_RESTRICTED;
 800bd74:	f06f 0506 	mvn.w	r5, #6
 800bd78:	e7bd      	b.n	800bcf6 <LmHandlerSend+0x92>
            lmhStatus = LORAMAC_HANDLER_ERROR;
 800bd7a:	f04f 35ff 	mov.w	r5, #4294967295
            break;
 800bd7e:	e790      	b.n	800bca2 <LmHandlerSend+0x3e>
    LmHandlerErrorStatus_t lmhStatus = LORAMAC_HANDLER_ERROR;
 800bd80:	f06f 0501 	mvn.w	r5, #1
 800bd84:	e78d      	b.n	800bca2 <LmHandlerSend+0x3e>
                lmhStatus = LORAMAC_HANDLER_SUCCESS;
 800bd86:	1deb      	adds	r3, r5, #7
 800bd88:	bf18      	it	ne
 800bd8a:	2500      	movne	r5, #0
 800bd8c:	e789      	b.n	800bca2 <LmHandlerSend+0x3e>
            lmhStatus = LORAMAC_HANDLER_CRYPTO_ERROR;
 800bd8e:	f06f 0504 	mvn.w	r5, #4
 800bd92:	e786      	b.n	800bca2 <LmHandlerSend+0x3e>
            lmhStatus = LORAMAC_HANDLER_DUTYCYCLE_RESTRICTED;
 800bd94:	f06f 0505 	mvn.w	r5, #5
 800bd98:	e783      	b.n	800bca2 <LmHandlerSend+0x3e>
        return LORAMAC_HANDLER_COMPLIANCE_RUNNING;
 800bd9a:	f06f 0503 	mvn.w	r5, #3
 800bd9e:	e780      	b.n	800bca2 <LmHandlerSend+0x3e>
 800bda0:	200000b0 	.word	0x200000b0
 800bda4:	20000610 	.word	0x20000610
 800bda8:	20000094 	.word	0x20000094
 800bdac:	200005f8 	.word	0x200005f8
 800bdb0:	200000a4 	.word	0x200000a4
 800bdb4:	200005c8 	.word	0x200005c8

0800bdb8 <McpsIndication>:
{
 800bdb8:	b570      	push	{r4, r5, r6, lr}
    RxParams.IsMcpsIndication = 1;
 800bdba:	4b41      	ldr	r3, [pc, #260]	@ (800bec0 <McpsIndication+0x108>)
    RxParams.Status = mcpsIndication->Status;
 800bdbc:	7842      	ldrb	r2, [r0, #1]
 800bdbe:	705a      	strb	r2, [r3, #1]
{
 800bdc0:	4604      	mov	r4, r0
    RxParams.IsMcpsIndication = 1;
 800bdc2:	2001      	movs	r0, #1
{
 800bdc4:	b08c      	sub	sp, #48	@ 0x30
    RxParams.IsMcpsIndication = 1;
 800bdc6:	7018      	strb	r0, [r3, #0]
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 800bdc8:	2a00      	cmp	r2, #0
 800bdca:	d158      	bne.n	800be7e <McpsIndication+0xc6>
 800bdcc:	78ce      	ldrb	r6, [r1, #3]
    RxParams.Datarate = mcpsIndication->RxDatarate;
 800bdce:	f9b1 2000 	ldrsh.w	r2, [r1]
 800bdd2:	f991 0002 	ldrsb.w	r0, [r1, #2]
    if( LmHandlerCallbacks->OnRxData != NULL )
 800bdd6:	4d3b      	ldr	r5, [pc, #236]	@ (800bec4 <McpsIndication+0x10c>)
    RxParams.Datarate = mcpsIndication->RxDatarate;
 800bdd8:	7921      	ldrb	r1, [r4, #4]
    RxParams.RxSlot = rxStatus->RxSlot;
 800bdda:	741e      	strb	r6, [r3, #16]
    RxParams.Datarate = mcpsIndication->RxDatarate;
 800bddc:	7219      	strb	r1, [r3, #8]
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 800bdde:	6921      	ldr	r1, [r4, #16]
    RxParams.Rssi = rxStatus->Rssi;
 800bde0:	725a      	strb	r2, [r3, #9]
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 800bde2:	60d9      	str	r1, [r3, #12]
    RxParams.Snr = rxStatus->Snr;
 800bde4:	7298      	strb	r0, [r3, #10]
    if( LmHandlerCallbacks->OnRxData != NULL )
 800bde6:	682a      	ldr	r2, [r5, #0]
    appData.Port = mcpsIndication->Port;
 800bde8:	78e1      	ldrb	r1, [r4, #3]
 800bdea:	f88d 1000 	strb.w	r1, [sp]
    if( LmHandlerCallbacks->OnRxData != NULL )
 800bdee:	6ad6      	ldr	r6, [r2, #44]	@ 0x2c
    appData.BufferSize = mcpsIndication->BufferSize;
 800bdf0:	7b21      	ldrb	r1, [r4, #12]
 800bdf2:	f88d 1001 	strb.w	r1, [sp, #1]
    appData.Buffer = mcpsIndication->Buffer;
 800bdf6:	68a1      	ldr	r1, [r4, #8]
 800bdf8:	9101      	str	r1, [sp, #4]
    if( LmHandlerCallbacks->OnRxData != NULL )
 800bdfa:	b11e      	cbz	r6, 800be04 <McpsIndication+0x4c>
        LmHandlerCallbacks->OnRxData( &appData, &RxParams );
 800bdfc:	4619      	mov	r1, r3
 800bdfe:	4668      	mov	r0, sp
 800be00:	47b0      	blx	r6
    if( ( LmHandlerCallbacks->OnSysTimeUpdate != NULL ) && ( mcpsIndication->DeviceTimeAnsReceived == true ) )
 800be02:	682a      	ldr	r2, [r5, #0]
 800be04:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 800be06:	b113      	cbz	r3, 800be0e <McpsIndication+0x56>
 800be08:	7e22      	ldrb	r2, [r4, #24]
 800be0a:	b102      	cbz	r2, 800be0e <McpsIndication+0x56>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 800be0c:	4798      	blx	r3
        if( LmHandlerPackages[i] != NULL )
 800be0e:	4d2e      	ldr	r5, [pc, #184]	@ (800bec8 <McpsIndication+0x110>)
 800be10:	682b      	ldr	r3, [r5, #0]
 800be12:	b163      	cbz	r3, 800be2e <McpsIndication+0x76>
                        if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 800be14:	6a1a      	ldr	r2, [r3, #32]
 800be16:	b152      	cbz	r2, 800be2e <McpsIndication+0x76>
 800be18:	7818      	ldrb	r0, [r3, #0]
 800be1a:	78e1      	ldrb	r1, [r4, #3]
 800be1c:	4288      	cmp	r0, r1
 800be1e:	d004      	beq.n	800be2a <McpsIndication+0x72>
                              ( ( i == PACKAGE_ID_COMPLIANCE ) && ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning() ) ) ) )
 800be20:	68db      	ldr	r3, [r3, #12]
 800be22:	4798      	blx	r3
 800be24:	b118      	cbz	r0, 800be2e <McpsIndication+0x76>
                            LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t * )params );
 800be26:	682b      	ldr	r3, [r5, #0]
 800be28:	6a1a      	ldr	r2, [r3, #32]
 800be2a:	4620      	mov	r0, r4
 800be2c:	4790      	blx	r2
        if( LmHandlerPackages[i] != NULL )
 800be2e:	686b      	ldr	r3, [r5, #4]
 800be30:	b12b      	cbz	r3, 800be3e <McpsIndication+0x86>
                        if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 800be32:	6a1a      	ldr	r2, [r3, #32]
 800be34:	b11a      	cbz	r2, 800be3e <McpsIndication+0x86>
 800be36:	7819      	ldrb	r1, [r3, #0]
 800be38:	78e3      	ldrb	r3, [r4, #3]
 800be3a:	4299      	cmp	r1, r3
 800be3c:	d02b      	beq.n	800be96 <McpsIndication+0xde>
        if( LmHandlerPackages[i] != NULL )
 800be3e:	68ab      	ldr	r3, [r5, #8]
 800be40:	b12b      	cbz	r3, 800be4e <McpsIndication+0x96>
                        if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 800be42:	6a1a      	ldr	r2, [r3, #32]
 800be44:	b11a      	cbz	r2, 800be4e <McpsIndication+0x96>
 800be46:	7819      	ldrb	r1, [r3, #0]
 800be48:	78e3      	ldrb	r3, [r4, #3]
 800be4a:	4299      	cmp	r1, r3
 800be4c:	d029      	beq.n	800bea2 <McpsIndication+0xea>
        if( LmHandlerPackages[i] != NULL )
 800be4e:	68eb      	ldr	r3, [r5, #12]
 800be50:	b12b      	cbz	r3, 800be5e <McpsIndication+0xa6>
                        if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 800be52:	6a1a      	ldr	r2, [r3, #32]
 800be54:	b11a      	cbz	r2, 800be5e <McpsIndication+0xa6>
 800be56:	7819      	ldrb	r1, [r3, #0]
 800be58:	78e3      	ldrb	r3, [r4, #3]
 800be5a:	4299      	cmp	r1, r3
 800be5c:	d027      	beq.n	800beae <McpsIndication+0xf6>
        if( LmHandlerPackages[i] != NULL )
 800be5e:	692b      	ldr	r3, [r5, #16]
 800be60:	b12b      	cbz	r3, 800be6e <McpsIndication+0xb6>
                        if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 800be62:	6a1a      	ldr	r2, [r3, #32]
 800be64:	b11a      	cbz	r2, 800be6e <McpsIndication+0xb6>
 800be66:	7819      	ldrb	r1, [r3, #0]
 800be68:	78e3      	ldrb	r3, [r4, #3]
 800be6a:	4299      	cmp	r1, r3
 800be6c:	d025      	beq.n	800beba <McpsIndication+0x102>
    mibReq.Type = MIB_DEVICE_CLASS;
 800be6e:	2500      	movs	r5, #0
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800be70:	a802      	add	r0, sp, #8
    mibReq.Type = MIB_DEVICE_CLASS;
 800be72:	f88d 5008 	strb.w	r5, [sp, #8]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800be76:	f002 fd71 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    if( mcpsIndication->IsUplinkTxPending != 0 )
 800be7a:	7963      	ldrb	r3, [r4, #5]
 800be7c:	b90b      	cbnz	r3, 800be82 <McpsIndication+0xca>
}
 800be7e:	b00c      	add	sp, #48	@ 0x30
 800be80:	bd70      	pop	{r4, r5, r6, pc}
        LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, true );
 800be82:	2201      	movs	r2, #1
 800be84:	4629      	mov	r1, r5
 800be86:	a802      	add	r0, sp, #8
        LmHandlerAppData_t appData =
 800be88:	f8ad 5008 	strh.w	r5, [sp, #8]
 800be8c:	9503      	str	r5, [sp, #12]
        LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, true );
 800be8e:	f7ff fee9 	bl	800bc64 <LmHandlerSend>
}
 800be92:	b00c      	add	sp, #48	@ 0x30
 800be94:	bd70      	pop	{r4, r5, r6, pc}
                            LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t * )params );
 800be96:	4620      	mov	r0, r4
 800be98:	4790      	blx	r2
        if( LmHandlerPackages[i] != NULL )
 800be9a:	68ab      	ldr	r3, [r5, #8]
 800be9c:	2b00      	cmp	r3, #0
 800be9e:	d1d0      	bne.n	800be42 <McpsIndication+0x8a>
 800bea0:	e7d5      	b.n	800be4e <McpsIndication+0x96>
                            LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t * )params );
 800bea2:	4620      	mov	r0, r4
 800bea4:	4790      	blx	r2
        if( LmHandlerPackages[i] != NULL )
 800bea6:	68eb      	ldr	r3, [r5, #12]
 800bea8:	2b00      	cmp	r3, #0
 800beaa:	d1d2      	bne.n	800be52 <McpsIndication+0x9a>
 800beac:	e7d7      	b.n	800be5e <McpsIndication+0xa6>
                            LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t * )params );
 800beae:	4620      	mov	r0, r4
 800beb0:	4790      	blx	r2
        if( LmHandlerPackages[i] != NULL )
 800beb2:	692b      	ldr	r3, [r5, #16]
 800beb4:	2b00      	cmp	r3, #0
 800beb6:	d1d4      	bne.n	800be62 <McpsIndication+0xaa>
 800beb8:	e7d9      	b.n	800be6e <McpsIndication+0xb6>
                            LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t * )params );
 800beba:	4620      	mov	r0, r4
 800bebc:	4790      	blx	r2
 800bebe:	e7d6      	b.n	800be6e <McpsIndication+0xb6>
 800bec0:	20000080 	.word	0x20000080
 800bec4:	200005f4 	.word	0x200005f4
 800bec8:	20000610 	.word	0x20000610

0800becc <MlmeConfirm>:
{
 800becc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( LmHandlerCallbacks->OnTxData != NULL )
 800bed0:	f8df 811c 	ldr.w	r8, [pc, #284]	@ 800bff0 <MlmeConfirm+0x124>
    TxParams.IsMcpsConfirm = 0;
 800bed4:	4f47      	ldr	r7, [pc, #284]	@ (800bff4 <MlmeConfirm+0x128>)
    if( LmHandlerCallbacks->OnTxData != NULL )
 800bed6:	f8d8 3000 	ldr.w	r3, [r8]
    TxParams.IsMcpsConfirm = 0;
 800beda:	2200      	movs	r2, #0
    if( LmHandlerCallbacks->OnTxData != NULL )
 800bedc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
    TxParams.IsMcpsConfirm = 0;
 800bede:	703a      	strb	r2, [r7, #0]
    TxParams.Status = mlmeConfirm->Status;
 800bee0:	7842      	ldrb	r2, [r0, #1]
 800bee2:	707a      	strb	r2, [r7, #1]
{
 800bee4:	b094      	sub	sp, #80	@ 0x50
 800bee6:	4605      	mov	r5, r0
    if( LmHandlerCallbacks->OnTxData != NULL )
 800bee8:	b10b      	cbz	r3, 800beee <MlmeConfirm+0x22>
        LmHandlerCallbacks->OnTxData( &TxParams );
 800beea:	4638      	mov	r0, r7
 800beec:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800beee:	4c42      	ldr	r4, [pc, #264]	@ (800bff8 <MlmeConfirm+0x12c>)
 800bef0:	f104 0614 	add.w	r6, r4, #20
        if( LmHandlerPackages[i] != NULL )
 800bef4:	f854 3b04 	ldr.w	r3, [r4], #4
                            LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t * )params );
 800bef8:	4628      	mov	r0, r5
        if( LmHandlerPackages[i] != NULL )
 800befa:	b113      	cbz	r3, 800bf02 <MlmeConfirm+0x36>
                        if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 800befc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800befe:	b103      	cbz	r3, 800bf02 <MlmeConfirm+0x36>
                            LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t * )params );
 800bf00:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800bf02:	42b4      	cmp	r4, r6
 800bf04:	d1f6      	bne.n	800bef4 <MlmeConfirm+0x28>
    switch( mlmeConfirm->MlmeRequest )
 800bf06:	782b      	ldrb	r3, [r5, #0]
 800bf08:	2b05      	cmp	r3, #5
 800bf0a:	d006      	beq.n	800bf1a <MlmeConfirm+0x4e>
 800bf0c:	2b0c      	cmp	r3, #12
 800bf0e:	d043      	beq.n	800bf98 <MlmeConfirm+0xcc>
 800bf10:	2b01      	cmp	r3, #1
 800bf12:	d00a      	beq.n	800bf2a <MlmeConfirm+0x5e>
}
 800bf14:	b014      	add	sp, #80	@ 0x50
 800bf16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                RxParams.LinkCheck = true;
 800bf1a:	4b38      	ldr	r3, [pc, #224]	@ (800bffc <MlmeConfirm+0x130>)
 800bf1c:	2201      	movs	r2, #1
 800bf1e:	745a      	strb	r2, [r3, #17]
                RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 800bf20:	892a      	ldrh	r2, [r5, #8]
 800bf22:	825a      	strh	r2, [r3, #18]
}
 800bf24:	b014      	add	sp, #80	@ 0x50
 800bf26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                if( SecureElementSetDevAddr( JoinParams.Mode, mibReq.Param.DevAddr ) == SECURE_ELEMENT_SUCCESS )
 800bf2a:	4c35      	ldr	r4, [pc, #212]	@ (800c000 <MlmeConfirm+0x134>)
                mibReq.Type = MIB_DEV_ADDR;
 800bf2c:	2306      	movs	r3, #6
                LoRaMacMibGetRequestConfirm( &mibReq );
 800bf2e:	4668      	mov	r0, sp
                mibReq.Type = MIB_DEV_ADDR;
 800bf30:	f88d 3000 	strb.w	r3, [sp]
                LoRaMacMibGetRequestConfirm( &mibReq );
 800bf34:	f002 fd12 	bl	800e95c <LoRaMacMibGetRequestConfirm>
                if( SecureElementSetDevAddr( JoinParams.Mode, mibReq.Param.DevAddr ) == SECURE_ELEMENT_SUCCESS )
 800bf38:	9901      	ldr	r1, [sp, #4]
 800bf3a:	79e0      	ldrb	r0, [r4, #7]
 800bf3c:	f7ff fd56 	bl	800b9ec <SecureElementSetDevAddr>
 800bf40:	2800      	cmp	r0, #0
 800bf42:	d036      	beq.n	800bfb2 <MlmeConfirm+0xe6>
    mibGet.Type = MIB_CHANNELS_DATARATE;
 800bf44:	231f      	movs	r3, #31
    if( LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK )
 800bf46:	a80a      	add	r0, sp, #40	@ 0x28
    mibGet.Type = MIB_CHANNELS_DATARATE;
 800bf48:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
    if( LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK )
 800bf4c:	f002 fd06 	bl	800e95c <LoRaMacMibGetRequestConfirm>
 800bf50:	b920      	cbnz	r0, 800bf5c <MlmeConfirm+0x90>
    LmHandlerParams.TxDatarate = *txDatarate;
 800bf52:	4a2c      	ldr	r2, [pc, #176]	@ (800c004 <MlmeConfirm+0x138>)
    *txDatarate = mibGet.Param.ChannelsDatarate;
 800bf54:	f99d 302c 	ldrsb.w	r3, [sp, #44]	@ 0x2c
 800bf58:	7123      	strb	r3, [r4, #4]
    LmHandlerParams.TxDatarate = *txDatarate;
 800bf5a:	7113      	strb	r3, [r2, #4]
    if( txPower == NULL )
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_CHANNELS_TX_POWER;
 800bf5c:	2320      	movs	r3, #32
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800bf5e:	a80a      	add	r0, sp, #40	@ 0x28
    mibReq.Type = MIB_CHANNELS_TX_POWER;
 800bf60:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800bf64:	f002 fcfa 	bl	800e95c <LoRaMacMibGetRequestConfirm>
 800bf68:	b920      	cbnz	r0, 800bf74 <MlmeConfirm+0xa8>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *txPower = mibReq.Param.ChannelsTxPower;
    LmHandlerParams.TxPower = *txPower;
 800bf6a:	4a26      	ldr	r2, [pc, #152]	@ (800c004 <MlmeConfirm+0x138>)
    *txPower = mibReq.Param.ChannelsTxPower;
 800bf6c:	f99d 302c 	ldrsb.w	r3, [sp, #44]	@ 0x2c
 800bf70:	7163      	strb	r3, [r4, #5]
    LmHandlerParams.TxPower = *txPower;
 800bf72:	7153      	strb	r3, [r2, #5]
                if( TxParams.Status == LORAMAC_EVENT_INFO_STATUS_OK )
 800bf74:	787b      	ldrb	r3, [r7, #1]
 800bf76:	b303      	cbz	r3, 800bfba <MlmeConfirm+0xee>
                if( LmHandlerCallbacks->OnJoinRequest != NULL )
 800bf78:	f8d8 3000 	ldr.w	r3, [r8]
 800bf7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                    JoinParams.Status = LORAMAC_HANDLER_ERROR;
 800bf7e:	22ff      	movs	r2, #255	@ 0xff
 800bf80:	71a2      	strb	r2, [r4, #6]
                if( LmHandlerCallbacks->OnJoinRequest != NULL )
 800bf82:	2b00      	cmp	r3, #0
 800bf84:	d0c6      	beq.n	800bf14 <MlmeConfirm+0x48>
                    LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 800bf86:	481e      	ldr	r0, [pc, #120]	@ (800c000 <MlmeConfirm+0x134>)
 800bf88:	4798      	blx	r3
                if( TxParams.Status == LORAMAC_EVENT_INFO_STATUS_OK )
 800bf8a:	787b      	ldrb	r3, [r7, #1]
 800bf8c:	2b00      	cmp	r3, #0
 800bf8e:	d1c1      	bne.n	800bf14 <MlmeConfirm+0x48>
                    SecureElementPrintSessionKeys( JoinParams.Mode );
 800bf90:	79e0      	ldrb	r0, [r4, #7]
 800bf92:	f7ff fa75 	bl	800b480 <SecureElementPrintSessionKeys>
            break;
 800bf96:	e7bd      	b.n	800bf14 <MlmeConfirm+0x48>
                if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 800bf98:	786b      	ldrb	r3, [r5, #1]
 800bf9a:	2b00      	cmp	r3, #0
 800bf9c:	d0ba      	beq.n	800bf14 <MlmeConfirm+0x48>
    mlmeReq.Type = MLME_DEVICE_TIME;
 800bf9e:	230a      	movs	r3, #10
    status = LoRaMacMlmeRequest( &mlmeReq );
 800bfa0:	a80a      	add	r0, sp, #40	@ 0x28
    mlmeReq.Type = MLME_DEVICE_TIME;
 800bfa2:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
    status = LoRaMacMlmeRequest( &mlmeReq );
 800bfa6:	f003 f8db 	bl	800f160 <LoRaMacMlmeRequest>
    DutyCycleWaitTime = mlmeReq.ReqReturn.DutyCycleWaitTime;
 800bfaa:	4b17      	ldr	r3, [pc, #92]	@ (800c008 <MlmeConfirm+0x13c>)
 800bfac:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 800bfae:	601a      	str	r2, [r3, #0]
}
 800bfb0:	e7b0      	b.n	800bf14 <MlmeConfirm+0x48>
                    CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 800bfb2:	4b16      	ldr	r3, [pc, #88]	@ (800c00c <MlmeConfirm+0x140>)
 800bfb4:	9a01      	ldr	r2, [sp, #4]
 800bfb6:	615a      	str	r2, [r3, #20]
 800bfb8:	e7c4      	b.n	800bf44 <MlmeConfirm+0x78>
                    JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 800bfba:	71a3      	strb	r3, [r4, #6]
                    LmHandlerRequestClass( LmHandlerParams.DefaultClass );
 800bfbc:	4b11      	ldr	r3, [pc, #68]	@ (800c004 <MlmeConfirm+0x138>)
 800bfbe:	785d      	ldrb	r5, [r3, #1]
    if( LoRaMacIsBusy() == true )
 800bfc0:	f001 faf4 	bl	800d5ac <LoRaMacIsBusy>
 800bfc4:	b948      	cbnz	r0, 800bfda <MlmeConfirm+0x10e>
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800bfc6:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800bfc8:	a80a      	add	r0, sp, #40	@ 0x28
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800bfca:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800bfce:	f002 fcc5 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 800bfd2:	b910      	cbnz	r0, 800bfda <MlmeConfirm+0x10e>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 800bfd4:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 800bfd8:	b92b      	cbnz	r3, 800bfe6 <MlmeConfirm+0x11a>
                if( LmHandlerCallbacks->OnJoinRequest != NULL )
 800bfda:	f8d8 3000 	ldr.w	r3, [r8]
 800bfde:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bfe0:	2b00      	cmp	r3, #0
 800bfe2:	d1d0      	bne.n	800bf86 <MlmeConfirm+0xba>
 800bfe4:	e7d1      	b.n	800bf8a <MlmeConfirm+0xbe>
 800bfe6:	4628      	mov	r0, r5
 800bfe8:	f7ff fd88 	bl	800bafc <LmHandlerRequestClass.part.0>
 800bfec:	e7f5      	b.n	800bfda <MlmeConfirm+0x10e>
 800bfee:	bf00      	nop
 800bff0:	200005f4 	.word	0x200005f4
 800bff4:	20000094 	.word	0x20000094
 800bff8:	20000610 	.word	0x20000610
 800bffc:	20000080 	.word	0x20000080
 800c000:	200000b0 	.word	0x200000b0
 800c004:	200005f8 	.word	0x200005f8
 800c008:	200005c8 	.word	0x200005c8
 800c00c:	20000624 	.word	0x20000624

0800c010 <LmHandlerInit>:
{
 800c010:	b570      	push	{r4, r5, r6, lr}
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 800c012:	4b1c      	ldr	r3, [pc, #112]	@ (800c084 <LmHandlerInit+0x74>)
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 800c014:	4c1c      	ldr	r4, [pc, #112]	@ (800c088 <LmHandlerInit+0x78>)
 800c016:	605c      	str	r4, [r3, #4]
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 800c018:	4c1c      	ldr	r4, [pc, #112]	@ (800c08c <LmHandlerInit+0x7c>)
 800c01a:	609c      	str	r4, [r3, #8]
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 800c01c:	4a1c      	ldr	r2, [pc, #112]	@ (800c090 <LmHandlerInit+0x80>)
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 800c01e:	4c1d      	ldr	r4, [pc, #116]	@ (800c094 <LmHandlerInit+0x84>)
 800c020:	60dc      	str	r4, [r3, #12]
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 800c022:	601a      	str	r2, [r3, #0]
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 800c024:	4b1c      	ldr	r3, [pc, #112]	@ (800c098 <LmHandlerInit+0x88>)
 800c026:	6805      	ldr	r5, [r0, #0]
    LmHandlerCallbacks = handlerCallbacks;
 800c028:	4c1c      	ldr	r4, [pc, #112]	@ (800c09c <LmHandlerInit+0x8c>)
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 800c02a:	601d      	str	r5, [r3, #0]
{
 800c02c:	b082      	sub	sp, #8
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 800c02e:	6845      	ldr	r5, [r0, #4]
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 800c030:	6982      	ldr	r2, [r0, #24]
{
 800c032:	9101      	str	r1, [sp, #4]
    LmHandlerCallbacks = handlerCallbacks;
 800c034:	6020      	str	r0, [r4, #0]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 800c036:	491a      	ldr	r1, [pc, #104]	@ (800c0a0 <LmHandlerInit+0x90>)
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 800c038:	605d      	str	r5, [r3, #4]
 800c03a:	6885      	ldr	r5, [r0, #8]
 800c03c:	68c0      	ldr	r0, [r0, #12]
 800c03e:	609d      	str	r5, [r3, #8]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 800c040:	e9c3 0103 	strd	r0, r1, [r3, #12]
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 800c044:	615a      	str	r2, [r3, #20]
                package = LmhpCompliancePackageFactory( );
 800c046:	f000 fb4b 	bl	800c6e0 <LmhpCompliancePackageFactory>
    if( package != NULL )
 800c04a:	b1c0      	cbz	r0, 800c07e <LmHandlerInit+0x6e>
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 800c04c:	6823      	ldr	r3, [r4, #0]
        LmHandlerPackages[id] = package;
 800c04e:	4a15      	ldr	r2, [pc, #84]	@ (800c0a4 <LmHandlerInit+0x94>)
        LmHandlerPackages[id]->OnSendRequest = LmHandlerSend;
 800c050:	4e15      	ldr	r6, [pc, #84]	@ (800c0a8 <LmHandlerInit+0x98>)
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 800c052:	4d16      	ldr	r5, [pc, #88]	@ (800c0ac <LmHandlerInit+0x9c>)
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 800c054:	699c      	ldr	r4, [r3, #24]
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 800c056:	4b16      	ldr	r3, [pc, #88]	@ (800c0b0 <LmHandlerInit+0xa0>)
        LmHandlerPackages[id] = package;
 800c058:	6010      	str	r0, [r2, #0]
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 800c05a:	62c3      	str	r3, [r0, #44]	@ 0x2c
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 800c05c:	e9c0 650c 	strd	r6, r5, [r0, #48]	@ 0x30
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 800c060:	6843      	ldr	r3, [r0, #4]
 800c062:	4914      	ldr	r1, [pc, #80]	@ (800c0b4 <LmHandlerInit+0xa4>)
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 800c064:	6184      	str	r4, [r0, #24]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 800c066:	22f2      	movs	r2, #242	@ 0xf2
 800c068:	4813      	ldr	r0, [pc, #76]	@ (800c0b8 <LmHandlerInit+0xa8>)
 800c06a:	4798      	blx	r3
    if( LmhpPackagesRegistrationInit( ( Version_t * )&fwVersion ) != LORAMAC_HANDLER_SUCCESS )
 800c06c:	a801      	add	r0, sp, #4
 800c06e:	f000 fb3b 	bl	800c6e8 <LmhpPackagesRegistrationInit>
 800c072:	3800      	subs	r0, #0
 800c074:	bf18      	it	ne
 800c076:	2001      	movne	r0, #1
 800c078:	4240      	negs	r0, r0
}
 800c07a:	b002      	add	sp, #8
 800c07c:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_HANDLER_ERROR;
 800c07e:	f04f 30ff 	mov.w	r0, #4294967295
 800c082:	e7fa      	b.n	800c07a <LmHandlerInit+0x6a>
 800c084:	200005e4 	.word	0x200005e4
 800c088:	0800bdb9 	.word	0x0800bdb9
 800c08c:	0800becd 	.word	0x0800becd
 800c090:	0800ba21 	.word	0x0800ba21
 800c094:	0800ba75 	.word	0x0800ba75
 800c098:	200005cc 	.word	0x200005cc
 800c09c:	200005f4 	.word	0x200005f4
 800c0a0:	0800c31d 	.word	0x0800c31d
 800c0a4:	20000610 	.word	0x20000610
 800c0a8:	0800bc65 	.word	0x0800bc65
 800c0ac:	0800bad5 	.word	0x0800bad5
 800c0b0:	0800bb6d 	.word	0x0800bb6d
 800c0b4:	200004d4 	.word	0x200004d4
 800c0b8:	200000bc 	.word	0x200000bc

0800c0bc <LmHandlerConfigure>:
{
 800c0bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    memcpy1( ( void * )&LmHandlerParams, ( const void * )handlerParams, sizeof( LmHandlerParams_t ) );
 800c0be:	4c42      	ldr	r4, [pc, #264]	@ (800c1c8 <LmHandlerConfigure+0x10c>)
{
 800c0c0:	4601      	mov	r1, r0
    memcpy1( ( void * )&LmHandlerParams, ( const void * )handlerParams, sizeof( LmHandlerParams_t ) );
 800c0c2:	2218      	movs	r2, #24
{
 800c0c4:	b099      	sub	sp, #100	@ 0x64
    memcpy1( ( void * )&LmHandlerParams, ( const void * )handlerParams, sizeof( LmHandlerParams_t ) );
 800c0c6:	4620      	mov	r0, r4
 800c0c8:	f006 f8dc 	bl	8012284 <memcpy1>
    loraInfo = LoraInfo_GetPtr();
 800c0cc:	f7fe f822 	bl	800a114 <LoraInfo_GetPtr>
    if( 0U == ( ( 1 << ( LmHandlerParams.ActiveRegion ) ) & ( loraInfo->Region ) ) )
 800c0d0:	7822      	ldrb	r2, [r4, #0]
 800c0d2:	6843      	ldr	r3, [r0, #4]
 800c0d4:	2601      	movs	r6, #1
 800c0d6:	fa06 f102 	lsl.w	r1, r6, r2
 800c0da:	4019      	ands	r1, r3
 800c0dc:	d105      	bne.n	800c0ea <LmHandlerConfigure+0x2e>
        MW_LOG( TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n" );
 800c0de:	4b3b      	ldr	r3, [pc, #236]	@ (800c1cc <LmHandlerConfigure+0x110>)
 800c0e0:	4632      	mov	r2, r6
 800c0e2:	4608      	mov	r0, r1
 800c0e4:	f009 fc86 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
        while( 1 ) {} /* error: Region is not defined in the MW */
 800c0e8:	e7fe      	b.n	800c0e8 <LmHandlerConfigure+0x2c>
    if( LoRaMacInitialization( &LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion ) != LORAMAC_STATUS_OK )
 800c0ea:	4d39      	ldr	r5, [pc, #228]	@ (800c1d0 <LmHandlerConfigure+0x114>)
 800c0ec:	4839      	ldr	r0, [pc, #228]	@ (800c1d4 <LmHandlerConfigure+0x118>)
 800c0ee:	4629      	mov	r1, r5
 800c0f0:	f002 f9de 	bl	800e4b0 <LoRaMacInitialization>
 800c0f4:	2800      	cmp	r0, #0
 800c0f6:	d164      	bne.n	800c1c2 <LmHandlerConfigure+0x106>
        mibReq.Type = MIB_NET_ID;
 800c0f8:	2305      	movs	r3, #5
        mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 800c0fa:	9005      	str	r0, [sp, #20]
        LoRaMacMibSetRequestConfirm( &mibReq );
 800c0fc:	a804      	add	r0, sp, #16
        mibReq.Type = MIB_NET_ID;
 800c0fe:	f88d 3010 	strb.w	r3, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 800c102:	f002 fd4b 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
    if( SecureElementInitMcuID( LoRaMacCallbacks.GetUniqueId, LoRaMacCallbacks.GetDevAddress ) != SECURE_ELEMENT_SUCCESS )
 800c106:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 800c10a:	f7ff f969 	bl	800b3e0 <SecureElementInitMcuID>
 800c10e:	4605      	mov	r5, r0
 800c110:	2800      	cmp	r0, #0
 800c112:	d156      	bne.n	800c1c2 <LmHandlerConfigure+0x106>
    CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 800c114:	4f30      	ldr	r7, [pc, #192]	@ (800c1d8 <LmHandlerConfigure+0x11c>)
    mibReq.Type = MIB_DEV_ADDR;
 800c116:	2306      	movs	r3, #6
    LoRaMacMibGetRequestConfirm( &mibReq );
 800c118:	a804      	add	r0, sp, #16
    mibReq.Type = MIB_DEV_ADDR;
 800c11a:	f88d 3010 	strb.w	r3, [sp, #16]
    LoRaMacMibGetRequestConfirm( &mibReq );
 800c11e:	f002 fc1d 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 800c122:	9b05      	ldr	r3, [sp, #20]
 800c124:	617b      	str	r3, [r7, #20]
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c126:	a804      	add	r0, sp, #16
 800c128:	f002 fd38 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_DEV_EUI;
 800c12c:	2302      	movs	r3, #2
    LoRaMacMibGetRequestConfirm( &mibReq );
 800c12e:	a804      	add	r0, sp, #16
    mibReq.Param.DevEui = CommissioningParams.DevEui;
 800c130:	9705      	str	r7, [sp, #20]
    mibReq.Type = MIB_DEV_EUI;
 800c132:	f88d 3010 	strb.w	r3, [sp, #16]
    mibReq.Param.JoinEui = CommissioningParams.JoinEui;
 800c136:	3708      	adds	r7, #8
    LoRaMacMibGetRequestConfirm( &mibReq );
 800c138:	f002 fc10 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    mibReq.Type = MIB_JOIN_EUI;
 800c13c:	2303      	movs	r3, #3
    LoRaMacMibGetRequestConfirm( &mibReq );
 800c13e:	a804      	add	r0, sp, #16
    mibReq.Type = MIB_JOIN_EUI;
 800c140:	f88d 3010 	strb.w	r3, [sp, #16]
    mibReq.Param.JoinEui = CommissioningParams.JoinEui;
 800c144:	9705      	str	r7, [sp, #20]
    LoRaMacMibGetRequestConfirm( &mibReq );
 800c146:	f002 fc09 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 800c14a:	270f      	movs	r7, #15
    SecureElementPrintKeys();
 800c14c:	f7ff f986 	bl	800b45c <SecureElementPrintKeys>
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c150:	a804      	add	r0, sp, #16
    mibReq.Type = MIB_PUBLIC_NETWORK;
 800c152:	f88d 7010 	strb.w	r7, [sp, #16]
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 800c156:	f88d 6014 	strb.w	r6, [sp, #20]
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c15a:	f002 fd1f 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 800c15e:	2310      	movs	r3, #16
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c160:	eb0d 0003 	add.w	r0, sp, r3
    mibReq.Type = MIB_REPEATER_SUPPORT;
 800c164:	f88d 3010 	strb.w	r3, [sp, #16]
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 800c168:	f88d 5014 	strb.w	r5, [sp, #20]
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c16c:	f002 fd16 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 800c170:	2304      	movs	r3, #4
 800c172:	f88d 3010 	strb.w	r3, [sp, #16]
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c176:	a804      	add	r0, sp, #16
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 800c178:	78a3      	ldrb	r3, [r4, #2]
 800c17a:	f88d 3014 	strb.w	r3, [sp, #20]
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c17e:	f002 fd0d 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_RXB_C_TIMEOUT;
 800c182:	2339      	movs	r3, #57	@ 0x39
 800c184:	f88d 3010 	strb.w	r3, [sp, #16]
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c188:	a804      	add	r0, sp, #16
    mibReq.Param.RxBCTimeout = LmHandlerParams.RxBCTimeout;
 800c18a:	6963      	ldr	r3, [r4, #20]
 800c18c:	9305      	str	r3, [sp, #20]
    LoRaMacMibSetRequestConfirm( &mibReq );
 800c18e:	f002 fd05 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 800c192:	a902      	add	r1, sp, #8
 800c194:	7820      	ldrb	r0, [r4, #0]
    getPhy.Attribute = PHY_DUTY_CYCLE;
 800c196:	f88d 7008 	strb.w	r7, [sp, #8]
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 800c19a:	f004 fba9 	bl	80108f0 <RegionGetPhyParam>
    LmHandlerParams.DutyCycleEnabled = ( bool ) phyParam.Value;
 800c19e:	1e03      	subs	r3, r0, #0
 800c1a0:	bf18      	it	ne
 800c1a2:	2301      	movne	r3, #1
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 800c1a4:	2122      	movs	r1, #34	@ 0x22
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 800c1a6:	2214      	movs	r2, #20
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800c1a8:	a80e      	add	r0, sp, #56	@ 0x38
    LmHandlerParams.DutyCycleEnabled = ( bool ) phyParam.Value;
 800c1aa:	71e3      	strb	r3, [r4, #7]
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 800c1ac:	f88d 1038 	strb.w	r1, [sp, #56]	@ 0x38
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 800c1b0:	920f      	str	r2, [sp, #60]	@ 0x3c
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800c1b2:	f002 fcf3 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 800c1b6:	79e0      	ldrb	r0, [r4, #7]
 800c1b8:	f003 fae4 	bl	800f784 <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 800c1bc:	4628      	mov	r0, r5
}
 800c1be:	b019      	add	sp, #100	@ 0x64
 800c1c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_HANDLER_ERROR;
 800c1c2:	f04f 30ff 	mov.w	r0, #4294967295
 800c1c6:	e7fa      	b.n	800c1be <LmHandlerConfigure+0x102>
 800c1c8:	200005f8 	.word	0x200005f8
 800c1cc:	08017440 	.word	0x08017440
 800c1d0:	200005cc 	.word	0x200005cc
 800c1d4:	200005e4 	.word	0x200005e4
 800c1d8:	20000624 	.word	0x20000624

0800c1dc <LmHandlerIsBusy>:
{
 800c1dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c1de:	b08b      	sub	sp, #44	@ 0x2c
    if( LoRaMacIsBusy( ) == true )
 800c1e0:	f001 f9e4 	bl	800d5ac <LoRaMacIsBusy>
 800c1e4:	b118      	cbz	r0, 800c1ee <LmHandlerIsBusy+0x12>
        return true;
 800c1e6:	2501      	movs	r5, #1
}
 800c1e8:	4628      	mov	r0, r5
 800c1ea:	b00b      	add	sp, #44	@ 0x2c
 800c1ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800c1ee:	2401      	movs	r4, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800c1f0:	4668      	mov	r0, sp
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800c1f2:	f88d 4000 	strb.w	r4, [sp]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800c1f6:	f002 fbb1 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 800c1fa:	b9f0      	cbnz	r0, 800c23a <LmHandlerIsBusy+0x5e>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 800c1fc:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800c200:	b1db      	cbz	r3, 800c23a <LmHandlerIsBusy+0x5e>
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 800c202:	4e13      	ldr	r6, [pc, #76]	@ (800c250 <LmHandlerIsBusy+0x74>)
 800c204:	6833      	ldr	r3, [r6, #0]
 800c206:	68db      	ldr	r3, [r3, #12]
 800c208:	4798      	blx	r3
 800c20a:	4605      	mov	r5, r0
 800c20c:	2800      	cmp	r0, #0
 800c20e:	d1ea      	bne.n	800c1e6 <LmHandlerIsBusy+0xa>
        if( ( LmHandlerPackages[i] != NULL ) && ( i != PACKAGE_ID_COMPLIANCE ) )
 800c210:	4637      	mov	r7, r6
 800c212:	f857 3b04 	ldr.w	r3, [r7], #4
 800c216:	b1b3      	cbz	r3, 800c246 <LmHandlerIsBusy+0x6a>
 800c218:	6873      	ldr	r3, [r6, #4]
 800c21a:	f106 0708 	add.w	r7, r6, #8
 800c21e:	b923      	cbnz	r3, 800c22a <LmHandlerIsBusy+0x4e>
 800c220:	e006      	b.n	800c230 <LmHandlerIsBusy+0x54>
 800c222:	f857 3b04 	ldr.w	r3, [r7], #4
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c226:	b264      	sxtb	r4, r4
        if( ( LmHandlerPackages[i] != NULL ) && ( i != PACKAGE_ID_COMPLIANCE ) )
 800c228:	b113      	cbz	r3, 800c230 <LmHandlerIsBusy+0x54>
            if( LmHandlerPackages[i]->IsTxPending( ) == true )
 800c22a:	691b      	ldr	r3, [r3, #16]
 800c22c:	4798      	blx	r3
 800c22e:	b960      	cbnz	r0, 800c24a <LmHandlerIsBusy+0x6e>
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c230:	3401      	adds	r4, #1
 800c232:	b2e4      	uxtb	r4, r4
 800c234:	2c05      	cmp	r4, #5
 800c236:	d1f4      	bne.n	800c222 <LmHandlerIsBusy+0x46>
 800c238:	e7d6      	b.n	800c1e8 <LmHandlerIsBusy+0xc>
        LmHandlerJoin( JoinParams.Mode, JoinParams.forceRejoin );
 800c23a:	4b06      	ldr	r3, [pc, #24]	@ (800c254 <LmHandlerIsBusy+0x78>)
 800c23c:	7a19      	ldrb	r1, [r3, #8]
 800c23e:	79d8      	ldrb	r0, [r3, #7]
 800c240:	f7ff fc94 	bl	800bb6c <LmHandlerJoin>
        return true;
 800c244:	e7cf      	b.n	800c1e6 <LmHandlerIsBusy+0xa>
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c246:	4604      	mov	r4, r0
 800c248:	e7f2      	b.n	800c230 <LmHandlerIsBusy+0x54>
                return true;
 800c24a:	4605      	mov	r5, r0
 800c24c:	e7cc      	b.n	800c1e8 <LmHandlerIsBusy+0xc>
 800c24e:	bf00      	nop
 800c250:	20000610 	.word	0x20000610
 800c254:	200000b0 	.word	0x200000b0

0800c258 <LmHandlerProcess>:
{
 800c258:	b570      	push	{r4, r5, r6, lr}
    LoRaMacProcess( );
 800c25a:	f001 f9c5 	bl	800d5e8 <LoRaMacProcess>
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c25e:	4e13      	ldr	r6, [pc, #76]	@ (800c2ac <LmHandlerProcess+0x54>)
 800c260:	f106 0514 	add.w	r5, r6, #20
    LoRaMacProcess( );
 800c264:	4634      	mov	r4, r6
        if( ( LmHandlerPackages[i] != NULL ) &&
 800c266:	f854 3b04 	ldr.w	r3, [r4], #4
 800c26a:	b14b      	cbz	r3, 800c280 <LmHandlerProcess+0x28>
 800c26c:	695a      	ldr	r2, [r3, #20]
 800c26e:	b13a      	cbz	r2, 800c280 <LmHandlerProcess+0x28>
    if( ( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ) )
 800c270:	689b      	ldr	r3, [r3, #8]
 800c272:	b12b      	cbz	r3, 800c280 <LmHandlerProcess+0x28>
        return LmHandlerPackages[id]->IsInitialized( );
 800c274:	4798      	blx	r3
            ( LmHandlerPackages[i]->Process != NULL ) &&
 800c276:	b118      	cbz	r0, 800c280 <LmHandlerProcess+0x28>
            LmHandlerPackages[i]->Process( );
 800c278:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800c27c:	695b      	ldr	r3, [r3, #20]
 800c27e:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c280:	42ac      	cmp	r4, r5
 800c282:	d1f0      	bne.n	800c266 <LmHandlerProcess+0xe>
        if( ( LmHandlerPackages[i] != NULL ) && ( i != PACKAGE_ID_COMPLIANCE ) )
 800c284:	6834      	ldr	r4, [r6, #0]
 800c286:	4d0a      	ldr	r5, [pc, #40]	@ (800c2b0 <LmHandlerProcess+0x58>)
 800c288:	b15c      	cbz	r4, 800c2a2 <LmHandlerProcess+0x4a>
 800c28a:	6872      	ldr	r2, [r6, #4]
 800c28c:	3504      	adds	r5, #4
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c28e:	2401      	movs	r4, #1
        if( ( LmHandlerPackages[i] != NULL ) && ( i != PACKAGE_ID_COMPLIANCE ) )
 800c290:	b922      	cbnz	r2, 800c29c <LmHandlerProcess+0x44>
 800c292:	e006      	b.n	800c2a2 <LmHandlerProcess+0x4a>
 800c294:	f855 2b04 	ldr.w	r2, [r5], #4
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c298:	b25c      	sxtb	r4, r3
        if( ( LmHandlerPackages[i] != NULL ) && ( i != PACKAGE_ID_COMPLIANCE ) )
 800c29a:	b112      	cbz	r2, 800c2a2 <LmHandlerProcess+0x4a>
            if( LmHandlerPackages[i]->IsTxPending( ) == true )
 800c29c:	6913      	ldr	r3, [r2, #16]
 800c29e:	4798      	blx	r3
 800c2a0:	b918      	cbnz	r0, 800c2aa <LmHandlerProcess+0x52>
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800c2a2:	1c63      	adds	r3, r4, #1
 800c2a4:	b2db      	uxtb	r3, r3
 800c2a6:	2b05      	cmp	r3, #5
 800c2a8:	d1f4      	bne.n	800c294 <LmHandlerProcess+0x3c>
}
 800c2aa:	bd70      	pop	{r4, r5, r6, pc}
 800c2ac:	20000610 	.word	0x20000610
 800c2b0:	20000614 	.word	0x20000614

0800c2b4 <LmHandlerGetDutyCycleWaitTime>:
    return DutyCycleWaitTime;
 800c2b4:	4b01      	ldr	r3, [pc, #4]	@ (800c2bc <LmHandlerGetDutyCycleWaitTime+0x8>)
}
 800c2b6:	6818      	ldr	r0, [r3, #0]
 800c2b8:	4770      	bx	lr
 800c2ba:	bf00      	nop
 800c2bc:	200005c8 	.word	0x200005c8

0800c2c0 <LmHandlerJoinStatus>:
{
 800c2c0:	b500      	push	{lr}
 800c2c2:	b08b      	sub	sp, #44	@ 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800c2c4:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800c2c6:	4668      	mov	r0, sp
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800c2c8:	f88d 3000 	strb.w	r3, [sp]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800c2cc:	f002 fb46 	bl	800e95c <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 800c2d0:	b938      	cbnz	r0, 800c2e2 <LmHandlerJoinStatus+0x22>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 800c2d2:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800c2d6:	3800      	subs	r0, #0
 800c2d8:	bf18      	it	ne
 800c2da:	2001      	movne	r0, #1
}
 800c2dc:	b00b      	add	sp, #44	@ 0x2c
 800c2de:	f85d fb04 	ldr.w	pc, [sp], #4
            return LORAMAC_HANDLER_RESET;
 800c2e2:	2000      	movs	r0, #0
}
 800c2e4:	b00b      	add	sp, #44	@ 0x2c
 800c2e6:	f85d fb04 	ldr.w	pc, [sp], #4
 800c2ea:	bf00      	nop

0800c2ec <LmHandlerStop>:
{
 800c2ec:	b508      	push	{r3, lr}
    if( LoRaMacDeInitialization() == LORAMAC_STATUS_OK )
 800c2ee:	f003 fa65 	bl	800f7bc <LoRaMacDeInitialization>
        return LORAMAC_HANDLER_SUCCESS;
 800c2f2:	2800      	cmp	r0, #0
}
 800c2f4:	bf14      	ite	ne
 800c2f6:	f06f 0001 	mvnne.w	r0, #1
 800c2fa:	2000      	moveq	r0, #0
 800c2fc:	bd08      	pop	{r3, pc}
 800c2fe:	bf00      	nop

0800c300 <LmHandlerHalt>:
{
 800c300:	b508      	push	{r3, lr}
    if( LoRaMacHalt() == LORAMAC_STATUS_OK )
 800c302:	f002 faa3 	bl	800e84c <LoRaMacHalt>
        return LORAMAC_HANDLER_SUCCESS;
 800c306:	2800      	cmp	r0, #0
}
 800c308:	bf14      	ite	ne
 800c30a:	f06f 0001 	mvnne.w	r0, #1
 800c30e:	2000      	moveq	r0, #0
 800c310:	bd08      	pop	{r3, pc}
 800c312:	bf00      	nop

0800c314 <LmHandlerNvmDataStore>:

    return lmhStatus;
#else
    return LORAMAC_HANDLER_ERROR;
#endif /* CONTEXT_MANAGEMENT_ENABLED */
}
 800c314:	f04f 30ff 	mov.w	r0, #4294967295
 800c318:	4770      	bx	lr
 800c31a:	bf00      	nop

0800c31c <NvmDataMgmtEvent>:
void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if ( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags |= notifyFlags;
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 800c31c:	4770      	bx	lr
 800c31e:	bf00      	nop

0800c320 <LmhpComplianceIsInitialized>:
    }
}

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
 800c320:	4b01      	ldr	r3, [pc, #4]	@ (800c328 <LmhpComplianceIsInitialized+0x8>)
}
 800c322:	7818      	ldrb	r0, [r3, #0]
 800c324:	4770      	bx	lr
 800c326:	bf00      	nop
 800c328:	20000640 	.word	0x20000640

0800c32c <LmhpComplianceIsRunning>:

static bool LmhpComplianceIsRunning( void )
{
    if( ComplianceTestState.Initialized == false )
 800c32c:	4b02      	ldr	r3, [pc, #8]	@ (800c338 <LmhpComplianceIsRunning+0xc>)
 800c32e:	7818      	ldrb	r0, [r3, #0]
 800c330:	b100      	cbz	r0, 800c334 <LmhpComplianceIsRunning+0x8>
    {
        return false;
    }

    return ComplianceTestState.IsRunning;
 800c332:	7858      	ldrb	r0, [r3, #1]
}
 800c334:	4770      	bx	lr
 800c336:	bf00      	nop
 800c338:	20000640 	.word	0x20000640

0800c33c <LmhpComplianceProcess>:
}

static void LmhpComplianceProcess( void )
{
    /* Nothing to process */
}
 800c33c:	4770      	bx	lr
 800c33e:	bf00      	nop

0800c340 <LmhpComplianceInit>:
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 800c340:	b158      	cbz	r0, 800c35a <LmhpComplianceInit+0x1a>
 800c342:	b149      	cbz	r1, 800c358 <LmhpComplianceInit+0x18>
        ComplianceTestState.DataBuffer = dataBuffer;
 800c344:	4b08      	ldr	r3, [pc, #32]	@ (800c368 <LmhpComplianceInit+0x28>)
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 800c346:	715a      	strb	r2, [r3, #5]
 800c348:	4a08      	ldr	r2, [pc, #32]	@ (800c36c <LmhpComplianceInit+0x2c>)
        ComplianceTestState.DataBuffer = dataBuffer;
 800c34a:	6099      	str	r1, [r3, #8]
        ComplianceTestState.Initialized = true;
 800c34c:	f04f 0c01 	mov.w	ip, #1
 800c350:	f883 c000 	strb.w	ip, [r3]
 800c354:	6010      	str	r0, [r2, #0]
}
 800c356:	4770      	bx	lr
        LmhpComplianceParams = NULL;
 800c358:	4608      	mov	r0, r1
 800c35a:	4b03      	ldr	r3, [pc, #12]	@ (800c368 <LmhpComplianceInit+0x28>)
 800c35c:	4a03      	ldr	r2, [pc, #12]	@ (800c36c <LmhpComplianceInit+0x2c>)
        ComplianceTestState.Initialized = false;
 800c35e:	4684      	mov	ip, r0
 800c360:	f883 c000 	strb.w	ip, [r3]
 800c364:	6010      	str	r0, [r2, #0]
}
 800c366:	4770      	bx	lr
 800c368:	20000640 	.word	0x20000640
 800c36c:	2000063c 	.word	0x2000063c

0800c370 <LmhpComplianceOnMcpsConfirm>:
    if( ComplianceTestState.Initialized == false )
 800c370:	4b07      	ldr	r3, [pc, #28]	@ (800c390 <LmhpComplianceOnMcpsConfirm+0x20>)
 800c372:	781a      	ldrb	r2, [r3, #0]
 800c374:	b122      	cbz	r2, 800c380 <LmhpComplianceOnMcpsConfirm+0x10>
    if( ( ComplianceTestState.IsRunning == true ) &&
 800c376:	785a      	ldrb	r2, [r3, #1]
 800c378:	b112      	cbz	r2, 800c380 <LmhpComplianceOnMcpsConfirm+0x10>
 800c37a:	7802      	ldrb	r2, [r0, #0]
 800c37c:	2a01      	cmp	r2, #1
 800c37e:	d000      	beq.n	800c382 <LmhpComplianceOnMcpsConfirm+0x12>
}
 800c380:	4770      	bx	lr
        ( mcpsConfirm->McpsRequest == MCPS_CONFIRMED ) &&
 800c382:	7902      	ldrb	r2, [r0, #4]
 800c384:	2a00      	cmp	r2, #0
 800c386:	d0fb      	beq.n	800c380 <LmhpComplianceOnMcpsConfirm+0x10>
        ComplianceTestState.DownLinkCounter++;
 800c388:	899a      	ldrh	r2, [r3, #12]
 800c38a:	3201      	adds	r2, #1
 800c38c:	819a      	strh	r2, [r3, #12]
 800c38e:	e7f7      	b.n	800c380 <LmhpComplianceOnMcpsConfirm+0x10>
 800c390:	20000640 	.word	0x20000640

0800c394 <LmhpComplianceOnMlmeConfirm>:
    if( ComplianceTestState.Initialized == false )
 800c394:	4b07      	ldr	r3, [pc, #28]	@ (800c3b4 <LmhpComplianceOnMlmeConfirm+0x20>)
 800c396:	781a      	ldrb	r2, [r3, #0]
 800c398:	b122      	cbz	r2, 800c3a4 <LmhpComplianceOnMlmeConfirm+0x10>
    if( ComplianceTestState.IsRunning == false )
 800c39a:	785a      	ldrb	r2, [r3, #1]
 800c39c:	b112      	cbz	r2, 800c3a4 <LmhpComplianceOnMlmeConfirm+0x10>
    if( mlmeConfirm->MlmeRequest == MLME_LINK_CHECK )
 800c39e:	7802      	ldrb	r2, [r0, #0]
 800c3a0:	2a05      	cmp	r2, #5
 800c3a2:	d000      	beq.n	800c3a6 <LmhpComplianceOnMlmeConfirm+0x12>
}
 800c3a4:	4770      	bx	lr
 800c3a6:	8902      	ldrh	r2, [r0, #8]
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
 800c3a8:	f8a3 200f 	strh.w	r2, [r3, #15]
        ComplianceTestState.LinkCheck = true;
 800c3ac:	2101      	movs	r1, #1
 800c3ae:	7399      	strb	r1, [r3, #14]
}
 800c3b0:	4770      	bx	lr
 800c3b2:	bf00      	nop
 800c3b4:	20000640 	.word	0x20000640

0800c3b8 <LmhpComplianceOnMcpsIndication>:
{
 800c3b8:	b530      	push	{r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 800c3ba:	4ca3      	ldr	r4, [pc, #652]	@ (800c648 <LmhpComplianceOnMcpsIndication+0x290>)
 800c3bc:	7823      	ldrb	r3, [r4, #0]
{
 800c3be:	b08f      	sub	sp, #60	@ 0x3c
    if( ComplianceTestState.Initialized == false )
 800c3c0:	b133      	cbz	r3, 800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
    if( mcpsIndication->RxData == false )
 800c3c2:	7b43      	ldrb	r3, [r0, #13]
 800c3c4:	b123      	cbz	r3, 800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
    if( ( ComplianceTestState.IsRunning == true ) &&
 800c3c6:	7865      	ldrb	r5, [r4, #1]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 800c3c8:	78c3      	ldrb	r3, [r0, #3]
    if( ( ComplianceTestState.IsRunning == true ) &&
 800c3ca:	b91d      	cbnz	r5, 800c3d4 <LmhpComplianceOnMcpsIndication+0x1c>
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 800c3cc:	2be0      	cmp	r3, #224	@ 0xe0
 800c3ce:	d01e      	beq.n	800c40e <LmhpComplianceOnMcpsIndication+0x56>
}
 800c3d0:	b00f      	add	sp, #60	@ 0x3c
 800c3d2:	bd30      	pop	{r4, r5, pc}
    if( ( ComplianceTestState.IsRunning == true ) &&
 800c3d4:	7b82      	ldrb	r2, [r0, #14]
 800c3d6:	b19a      	cbz	r2, 800c400 <LmhpComplianceOnMcpsIndication+0x48>
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 800c3d8:	2be0      	cmp	r3, #224	@ 0xe0
 800c3da:	d1f9      	bne.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
        ComplianceTestState.State = mcpsIndication->Buffer[0];
 800c3dc:	6882      	ldr	r2, [r0, #8]
 800c3de:	7813      	ldrb	r3, [r2, #0]
 800c3e0:	70a3      	strb	r3, [r4, #2]
        switch( ComplianceTestState.State )
 800c3e2:	2b0a      	cmp	r3, #10
 800c3e4:	d8f4      	bhi.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
 800c3e6:	e8df f013 	tbh	[pc, r3, lsl #1]
 800c3ea:	00f9      	.short	0x00f9
 800c3ec:	00f200f6 	.word	0x00f200f6
 800c3f0:	00d400ef 	.word	0x00d400ef
 800c3f4:	00ab00cd 	.word	0x00ab00cd
 800c3f8:	0083008a 	.word	0x0083008a
 800c3fc:	006f0079 	.word	0x006f0079
        ComplianceTestState.DownLinkCounter++;
 800c400:	89a2      	ldrh	r2, [r4, #12]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 800c402:	2be0      	cmp	r3, #224	@ 0xe0
        ComplianceTestState.DownLinkCounter++;
 800c404:	f102 0201 	add.w	r2, r2, #1
 800c408:	81a2      	strh	r2, [r4, #12]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 800c40a:	d1e1      	bne.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
 800c40c:	e7e6      	b.n	800c3dc <LmhpComplianceOnMcpsIndication+0x24>
        if( ( mcpsIndication->BufferSize == 4 ) &&
 800c40e:	7b02      	ldrb	r2, [r0, #12]
 800c410:	2a04      	cmp	r2, #4
 800c412:	d1dd      	bne.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 800c414:	6881      	ldr	r1, [r0, #8]
        if( ( mcpsIndication->BufferSize == 4 ) &&
 800c416:	7808      	ldrb	r0, [r1, #0]
 800c418:	2801      	cmp	r0, #1
 800c41a:	d1d9      	bne.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 800c41c:	7848      	ldrb	r0, [r1, #1]
 800c41e:	2801      	cmp	r0, #1
 800c420:	d1d6      	bne.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 800c422:	7888      	ldrb	r0, [r1, #2]
 800c424:	2801      	cmp	r0, #1
 800c426:	d1d3      	bne.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 800c428:	78c9      	ldrb	r1, [r1, #3]
 800c42a:	2901      	cmp	r1, #1
 800c42c:	d1d0      	bne.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
            ComplianceTestState.Port = 224;
 800c42e:	7123      	strb	r3, [r4, #4]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800c430:	a804      	add	r0, sp, #16
            ComplianceTestState.DataBufferSize = 2;
 800c432:	2302      	movs	r3, #2
 800c434:	71a3      	strb	r3, [r4, #6]
            ComplianceTestState.IsRunning = true;
 800c436:	7061      	strb	r1, [r4, #1]
            ComplianceTestState.State = 1;
 800c438:	8061      	strh	r1, [r4, #2]
            mibReq.Type = MIB_ADR;
 800c43a:	f88d 2010 	strb.w	r2, [sp, #16]
            mibReq.Param.AdrEnable = true;
 800c43e:	f88d 1014 	strb.w	r1, [sp, #20]
            ComplianceTestState.DownLinkCounter = 0;
 800c442:	60e5      	str	r5, [r4, #12]
            ComplianceTestState.DemodMargin = 0;
 800c444:	7425      	strb	r5, [r4, #16]
            LoRaMacMibSetRequestConfirm( &mibReq );
 800c446:	f002 fba9 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
            LoRaMacTestSetDutyCycleOn( false );
 800c44a:	4628      	mov	r0, r5
 800c44c:	f003 f99a 	bl	800f784 <LoRaMacTestSetDutyCycleOn>
            if( LmhpComplianceParams->StopPeripherals != NULL )
 800c450:	4b7e      	ldr	r3, [pc, #504]	@ (800c64c <LmhpComplianceOnMcpsIndication+0x294>)
 800c452:	681b      	ldr	r3, [r3, #0]
 800c454:	685b      	ldr	r3, [r3, #4]
 800c456:	b103      	cbz	r3, 800c45a <LmhpComplianceOnMcpsIndication+0xa2>
                LmhpComplianceParams->StopPeripherals( );
 800c458:	4798      	blx	r3
            TimerInit( &ComplianceTxNextPacketTimer, OnComplianceTxNextPacketTimerEvent );
 800c45a:	2500      	movs	r5, #0
 800c45c:	4b7c      	ldr	r3, [pc, #496]	@ (800c650 <LmhpComplianceOnMcpsIndication+0x298>)
 800c45e:	487d      	ldr	r0, [pc, #500]	@ (800c654 <LmhpComplianceOnMcpsIndication+0x29c>)
 800c460:	9500      	str	r5, [sp, #0]
 800c462:	462a      	mov	r2, r5
 800c464:	f04f 31ff 	mov.w	r1, #4294967295
 800c468:	f009 f914 	bl	8015694 <UTIL_TIMER_Create>
            TimerSetValue( &ComplianceTxNextPacketTimer, COMPLIANCE_TX_DUTYCYCLE );
 800c46c:	4879      	ldr	r0, [pc, #484]	@ (800c654 <LmhpComplianceOnMcpsIndication+0x29c>)
 800c46e:	f241 3188 	movw	r1, #5000	@ 0x1388
 800c472:	f009 f985 	bl	8015780 <UTIL_TIMER_SetPeriod>
    if( ComplianceTestState.Initialized == false )
 800c476:	7823      	ldrb	r3, [r4, #0]
 800c478:	2b00      	cmp	r3, #0
 800c47a:	d0a9      	beq.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
    if( ComplianceTestState.IsRunning == false )
 800c47c:	7863      	ldrb	r3, [r4, #1]
 800c47e:	2b00      	cmp	r3, #0
 800c480:	d0a6      	beq.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
    if( ComplianceTestState.LinkCheck == true )
 800c482:	7ba2      	ldrb	r2, [r4, #14]
        ComplianceTestState.DataBuffer[0] = 5;
 800c484:	68a3      	ldr	r3, [r4, #8]
    if( ComplianceTestState.LinkCheck == true )
 800c486:	2a00      	cmp	r2, #0
 800c488:	f000 80cd 	beq.w	800c626 <LmhpComplianceOnMcpsIndication+0x26e>
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 800c48c:	7be2      	ldrb	r2, [r4, #15]
 800c48e:	705a      	strb	r2, [r3, #1]
        ComplianceTestState.State = 1;
 800c490:	2201      	movs	r2, #1
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 800c492:	7c21      	ldrb	r1, [r4, #16]
        ComplianceTestState.State = 1;
 800c494:	70a2      	strb	r2, [r4, #2]
        ComplianceTestState.DataBufferSize = 3;
 800c496:	2003      	movs	r0, #3
        ComplianceTestState.DataBuffer[0] = 5;
 800c498:	2205      	movs	r2, #5
        ComplianceTestState.DataBufferSize = 3;
 800c49a:	71a0      	strb	r0, [r4, #6]
        ComplianceTestState.LinkCheck = false;
 800c49c:	73a5      	strb	r5, [r4, #14]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 800c49e:	7099      	strb	r1, [r3, #2]
        ComplianceTestState.DataBuffer[0] = 5;
 800c4a0:	701a      	strb	r2, [r3, #0]
    LmHandlerAppData_t appData =
 800c4a2:	79a2      	ldrb	r2, [r4, #6]
    TimerStart( &ComplianceTxNextPacketTimer );
 800c4a4:	486b      	ldr	r0, [pc, #428]	@ (800c654 <LmhpComplianceOnMcpsIndication+0x29c>)
    LmHandlerAppData_t appData =
 800c4a6:	9303      	str	r3, [sp, #12]
 800c4a8:	21e0      	movs	r1, #224	@ 0xe0
 800c4aa:	f88d 1008 	strb.w	r1, [sp, #8]
 800c4ae:	f88d 2009 	strb.w	r2, [sp, #9]
    TimerStart( &ComplianceTxNextPacketTimer );
 800c4b2:	f009 f909 	bl	80156c8 <UTIL_TIMER_Start>
    if( LmhpCompliancePackage.OnSendRequest == NULL)
 800c4b6:	4b68      	ldr	r3, [pc, #416]	@ (800c658 <LmhpComplianceOnMcpsIndication+0x2a0>)
 800c4b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c4ba:	2b00      	cmp	r3, #0
 800c4bc:	d088      	beq.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, true );
 800c4be:	78e1      	ldrb	r1, [r4, #3]
 800c4c0:	2201      	movs	r2, #1
 800c4c2:	a802      	add	r0, sp, #8
 800c4c4:	4798      	blx	r3
 800c4c6:	e783      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                    mlmeReq.Type = MLME_PING_SLOT_INFO;
 800c4c8:	230d      	movs	r3, #13
 800c4ca:	f88d 3010 	strb.w	r3, [sp, #16]
                    mlmeReq.Req.PingSlotInfo.PingSlot.Value = mcpsIndication->Buffer[1];
 800c4ce:	7853      	ldrb	r3, [r2, #1]
 800c4d0:	f88d 3014 	strb.w	r3, [sp, #20]
                    LoRaMacMlmeRequest( &mlmeReq );
 800c4d4:	a804      	add	r0, sp, #16
 800c4d6:	f002 fe43 	bl	800f160 <LoRaMacMlmeRequest>
                break;
 800c4da:	e779      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                    mibReq.Type = MIB_DEVICE_CLASS;
 800c4dc:	2300      	movs	r3, #0
 800c4de:	f88d 3010 	strb.w	r3, [sp, #16]
                    mibReq.Param.Class = ( DeviceClass_t )mcpsIndication->Buffer[1];;
 800c4e2:	7853      	ldrb	r3, [r2, #1]
 800c4e4:	f88d 3014 	strb.w	r3, [sp, #20]
                    LoRaMacMibSetRequestConfirm( &mibReq );
 800c4e8:	a804      	add	r0, sp, #16
 800c4ea:	f002 fb57 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
                break;
 800c4ee:	e76f      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                    mlmeReq.Type = MLME_DEVICE_TIME;
 800c4f0:	230a      	movs	r3, #10
                    LoRaMacMlmeRequest( &mlmeReq );
 800c4f2:	a804      	add	r0, sp, #16
                    mlmeReq.Type = MLME_DEVICE_TIME;
 800c4f4:	f88d 3010 	strb.w	r3, [sp, #16]
                    LoRaMacMlmeRequest( &mlmeReq );
 800c4f8:	f002 fe32 	bl	800f160 <LoRaMacMlmeRequest>
                break;
 800c4fc:	e768      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                    if( mcpsIndication->BufferSize == 3 )
 800c4fe:	7b03      	ldrb	r3, [r0, #12]
 800c500:	2b03      	cmp	r3, #3
 800c502:	f000 8087 	beq.w	800c614 <LmhpComplianceOnMcpsIndication+0x25c>
                    else if( mcpsIndication->BufferSize == 7 )
 800c506:	2b07      	cmp	r3, #7
 800c508:	d114      	bne.n	800c534 <LmhpComplianceOnMcpsIndication+0x17c>
                        mlmeReq.Type = MLME_TXCW_1;
 800c50a:	f88d 3010 	strb.w	r3, [sp, #16]
                        mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 800c50e:	f8b2 3001 	ldrh.w	r3, [r2, #1]
 800c512:	ba5b      	rev16	r3, r3
 800c514:	f8ad 3014 	strh.w	r3, [sp, #20]
                        mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 800c518:	7913      	ldrb	r3, [r2, #4]
 800c51a:	78d0      	ldrb	r0, [r2, #3]
 800c51c:	021b      	lsls	r3, r3, #8
 800c51e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 800c522:	7950      	ldrb	r0, [r2, #5]
 800c524:	2164      	movs	r1, #100	@ 0x64
 800c526:	4303      	orrs	r3, r0
 800c528:	fb01 f303 	mul.w	r3, r1, r3
 800c52c:	9306      	str	r3, [sp, #24]
                        mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 800c52e:	7993      	ldrb	r3, [r2, #6]
 800c530:	f88d 301c 	strb.w	r3, [sp, #28]
                    LoRaMacMlmeRequest( &mlmeReq );
 800c534:	a804      	add	r0, sp, #16
 800c536:	f002 fe13 	bl	800f160 <LoRaMacMlmeRequest>
                    ComplianceTestState.State = 1;
 800c53a:	2301      	movs	r3, #1
 800c53c:	70a3      	strb	r3, [r4, #2]
                break;
 800c53e:	e747      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                    mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 800c540:	4d42      	ldr	r5, [pc, #264]	@ (800c64c <LmhpComplianceOnMcpsIndication+0x294>)
                    TimerStop( &ComplianceTxNextPacketTimer );
 800c542:	4844      	ldr	r0, [pc, #272]	@ (800c654 <LmhpComplianceOnMcpsIndication+0x29c>)
 800c544:	f009 f8d2 	bl	80156ec <UTIL_TIMER_Stop>
                    mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 800c548:	682b      	ldr	r3, [r5, #0]
                    mibReq.Type = MIB_ADR;
 800c54a:	2204      	movs	r2, #4
 800c54c:	f88d 2010 	strb.w	r2, [sp, #16]
                    mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 800c550:	781a      	ldrb	r2, [r3, #0]
 800c552:	f88d 2014 	strb.w	r2, [sp, #20]
                    ComplianceTestState.DownLinkCounter = 0;
 800c556:	2300      	movs	r3, #0
                    LoRaMacMibSetRequestConfirm( &mibReq );
 800c558:	a804      	add	r0, sp, #16
                    ComplianceTestState.DownLinkCounter = 0;
 800c55a:	81a3      	strh	r3, [r4, #12]
                    ComplianceTestState.IsRunning = false;
 800c55c:	7063      	strb	r3, [r4, #1]
                    LoRaMacMibSetRequestConfirm( &mibReq );
 800c55e:	f002 fb1d 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
                    LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 800c562:	682b      	ldr	r3, [r5, #0]
 800c564:	7858      	ldrb	r0, [r3, #1]
 800c566:	f003 f90d 	bl	800f784 <LoRaMacTestSetDutyCycleOn>
                    if( LmhpComplianceParams->StartPeripherals != NULL )
 800c56a:	682b      	ldr	r3, [r5, #0]
 800c56c:	689b      	ldr	r3, [r3, #8]
 800c56e:	b103      	cbz	r3, 800c572 <LmhpComplianceOnMcpsIndication+0x1ba>
                        LmhpComplianceParams->StartPeripherals( );
 800c570:	4798      	blx	r3
                    if( LmhpCompliancePackage.OnJoinRequest != NULL )
 800c572:	4b39      	ldr	r3, [pc, #228]	@ (800c658 <LmhpComplianceOnMcpsIndication+0x2a0>)
 800c574:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c576:	2b00      	cmp	r3, #0
 800c578:	f43f af2a 	beq.w	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                        LmhpCompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA, true );
 800c57c:	2101      	movs	r1, #1
 800c57e:	2002      	movs	r0, #2
 800c580:	4798      	blx	r3
                break;
 800c582:	e725      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                    mlmeReq.Type = MLME_LINK_CHECK;
 800c584:	2305      	movs	r3, #5
                    LoRaMacMlmeRequest( &mlmeReq );
 800c586:	a804      	add	r0, sp, #16
                    mlmeReq.Type = MLME_LINK_CHECK;
 800c588:	f88d 3010 	strb.w	r3, [sp, #16]
                    LoRaMacMlmeRequest( &mlmeReq );
 800c58c:	f002 fde8 	bl	800f160 <LoRaMacMlmeRequest>
                break;
 800c590:	e71e      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 800c592:	7b01      	ldrb	r1, [r0, #12]
                for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 800c594:	7962      	ldrb	r2, [r4, #5]
                ComplianceTestState.DataBuffer[0] = 4;
 800c596:	68a3      	ldr	r3, [r4, #8]
                ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 800c598:	71a1      	strb	r1, [r4, #6]
                for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 800c59a:	428a      	cmp	r2, r1
 800c59c:	bf28      	it	cs
 800c59e:	460a      	movcs	r2, r1
                ComplianceTestState.DataBuffer[0] = 4;
 800c5a0:	2504      	movs	r5, #4
                for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 800c5a2:	2a01      	cmp	r2, #1
                ComplianceTestState.DataBuffer[0] = 4;
 800c5a4:	701d      	strb	r5, [r3, #0]
                for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 800c5a6:	f67f af13 	bls.w	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
 800c5aa:	1c59      	adds	r1, r3, #1
 800c5ac:	3a02      	subs	r2, #2
 800c5ae:	fa51 f182 	uxtab	r1, r1, r2
 800c5b2:	f1c3 0401 	rsb	r4, r3, #1
                    ComplianceTestState.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 800c5b6:	6882      	ldr	r2, [r0, #8]
 800c5b8:	441a      	add	r2, r3
 800c5ba:	5d12      	ldrb	r2, [r2, r4]
 800c5bc:	3201      	adds	r2, #1
 800c5be:	f803 2f01 	strb.w	r2, [r3, #1]!
                for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 800c5c2:	4299      	cmp	r1, r3
 800c5c4:	d1f7      	bne.n	800c5b6 <LmhpComplianceOnMcpsIndication+0x1fe>
 800c5c6:	e703      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                ComplianceTestState.State = 1;
 800c5c8:	2301      	movs	r3, #1
 800c5ca:	8063      	strh	r3, [r4, #2]
                break;
 800c5cc:	e700      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                ComplianceTestState.State = 1;
 800c5ce:	f240 1301 	movw	r3, #257	@ 0x101
 800c5d2:	8063      	strh	r3, [r4, #2]
                break;
 800c5d4:	e6fc      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                ComplianceTestState.DataBufferSize = 2;
 800c5d6:	2302      	movs	r3, #2
 800c5d8:	71a3      	strb	r3, [r4, #6]
                break;
 800c5da:	e6f9      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                    mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 800c5dc:	4d1b      	ldr	r5, [pc, #108]	@ (800c64c <LmhpComplianceOnMcpsIndication+0x294>)
                    TimerStop( &ComplianceTxNextPacketTimer );
 800c5de:	481d      	ldr	r0, [pc, #116]	@ (800c654 <LmhpComplianceOnMcpsIndication+0x29c>)
 800c5e0:	f009 f884 	bl	80156ec <UTIL_TIMER_Stop>
                    mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 800c5e4:	682b      	ldr	r3, [r5, #0]
                    mibReq.Type = MIB_ADR;
 800c5e6:	2204      	movs	r2, #4
 800c5e8:	f88d 2010 	strb.w	r2, [sp, #16]
                    mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 800c5ec:	781a      	ldrb	r2, [r3, #0]
 800c5ee:	f88d 2014 	strb.w	r2, [sp, #20]
                    ComplianceTestState.DownLinkCounter = 0;
 800c5f2:	2300      	movs	r3, #0
                    LoRaMacMibSetRequestConfirm( &mibReq );
 800c5f4:	a804      	add	r0, sp, #16
                    ComplianceTestState.DownLinkCounter = 0;
 800c5f6:	81a3      	strh	r3, [r4, #12]
                    ComplianceTestState.IsRunning = false;
 800c5f8:	7063      	strb	r3, [r4, #1]
                    LoRaMacMibSetRequestConfirm( &mibReq );
 800c5fa:	f002 facf 	bl	800eb9c <LoRaMacMibSetRequestConfirm>
                    LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 800c5fe:	682b      	ldr	r3, [r5, #0]
 800c600:	7858      	ldrb	r0, [r3, #1]
 800c602:	f003 f8bf 	bl	800f784 <LoRaMacTestSetDutyCycleOn>
                    if( LmhpComplianceParams->StartPeripherals != NULL )
 800c606:	682b      	ldr	r3, [r5, #0]
 800c608:	689b      	ldr	r3, [r3, #8]
 800c60a:	2b00      	cmp	r3, #0
 800c60c:	f43f aee0 	beq.w	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                        LmhpComplianceParams->StartPeripherals( );
 800c610:	4798      	blx	r3
                break;
 800c612:	e6dd      	b.n	800c3d0 <LmhpComplianceOnMcpsIndication+0x18>
                        mlmeReq.Type = MLME_TXCW;
 800c614:	2306      	movs	r3, #6
 800c616:	f88d 3010 	strb.w	r3, [sp, #16]
                        mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 800c61a:	f8b2 3001 	ldrh.w	r3, [r2, #1]
 800c61e:	ba5b      	rev16	r3, r3
 800c620:	f8ad 3014 	strh.w	r3, [sp, #20]
 800c624:	e786      	b.n	800c534 <LmhpComplianceOnMcpsIndication+0x17c>
        switch( ComplianceTestState.State )
 800c626:	78a2      	ldrb	r2, [r4, #2]
 800c628:	2a01      	cmp	r2, #1
 800c62a:	d005      	beq.n	800c638 <LmhpComplianceOnMcpsIndication+0x280>
 800c62c:	2a04      	cmp	r2, #4
 800c62e:	f47f af38 	bne.w	800c4a2 <LmhpComplianceOnMcpsIndication+0xea>
                ComplianceTestState.State = 1;
 800c632:	2201      	movs	r2, #1
 800c634:	70a2      	strb	r2, [r4, #2]
                break;
 800c636:	e734      	b.n	800c4a2 <LmhpComplianceOnMcpsIndication+0xea>
                ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 800c638:	89a2      	ldrh	r2, [r4, #12]
                ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 800c63a:	705a      	strb	r2, [r3, #1]
                ComplianceTestState.DataBufferSize = 2;
 800c63c:	2002      	movs	r0, #2
                ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 800c63e:	0a11      	lsrs	r1, r2, #8
                ComplianceTestState.DataBufferSize = 2;
 800c640:	71a0      	strb	r0, [r4, #6]
                ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 800c642:	7019      	strb	r1, [r3, #0]
                break;
 800c644:	e72d      	b.n	800c4a2 <LmhpComplianceOnMcpsIndication+0xea>
 800c646:	bf00      	nop
 800c648:	20000640 	.word	0x20000640
 800c64c:	2000063c 	.word	0x2000063c
 800c650:	0800c65d 	.word	0x0800c65d
 800c654:	20000654 	.word	0x20000654
 800c658:	200000c8 	.word	0x200000c8

0800c65c <OnComplianceTxNextPacketTimerEvent>:

static void OnComplianceTxNextPacketTimerEvent( void *context )
{
 800c65c:	b510      	push	{r4, lr}
    if( ComplianceTestState.Initialized == false )
 800c65e:	4c1d      	ldr	r4, [pc, #116]	@ (800c6d4 <OnComplianceTxNextPacketTimerEvent+0x78>)
 800c660:	7823      	ldrb	r3, [r4, #0]
{
 800c662:	b082      	sub	sp, #8
    if( ComplianceTestState.Initialized == false )
 800c664:	b1eb      	cbz	r3, 800c6a2 <OnComplianceTxNextPacketTimerEvent+0x46>
    if( ComplianceTestState.IsRunning == false )
 800c666:	7863      	ldrb	r3, [r4, #1]
 800c668:	b1db      	cbz	r3, 800c6a2 <OnComplianceTxNextPacketTimerEvent+0x46>
    if( ComplianceTestState.LinkCheck == true )
 800c66a:	7ba3      	ldrb	r3, [r4, #14]
        ComplianceTestState.DataBuffer[0] = 5;
 800c66c:	68a2      	ldr	r2, [r4, #8]
    if( ComplianceTestState.LinkCheck == true )
 800c66e:	b9d3      	cbnz	r3, 800c6a6 <OnComplianceTxNextPacketTimerEvent+0x4a>
        switch( ComplianceTestState.State )
 800c670:	78a3      	ldrb	r3, [r4, #2]
 800c672:	2b01      	cmp	r3, #1
 800c674:	d026      	beq.n	800c6c4 <OnComplianceTxNextPacketTimerEvent+0x68>
 800c676:	2b04      	cmp	r3, #4
                ComplianceTestState.State = 1;
 800c678:	bf09      	itett	eq
 800c67a:	2101      	moveq	r1, #1
        .BufferSize = ComplianceTestState.DataBufferSize,
 800c67c:	79a3      	ldrbne	r3, [r4, #6]
 800c67e:	79a3      	ldrbeq	r3, [r4, #6]
                ComplianceTestState.State = 1;
 800c680:	70a1      	strbeq	r1, [r4, #2]
    LmHandlerAppData_t appData =
 800c682:	21e0      	movs	r1, #224	@ 0xe0
    TimerStart( &ComplianceTxNextPacketTimer );
 800c684:	4814      	ldr	r0, [pc, #80]	@ (800c6d8 <OnComplianceTxNextPacketTimerEvent+0x7c>)
    LmHandlerAppData_t appData =
 800c686:	f88d 3001 	strb.w	r3, [sp, #1]
 800c68a:	f88d 1000 	strb.w	r1, [sp]
 800c68e:	9201      	str	r2, [sp, #4]
    TimerStart( &ComplianceTxNextPacketTimer );
 800c690:	f009 f81a 	bl	80156c8 <UTIL_TIMER_Start>
    if( LmhpCompliancePackage.OnSendRequest == NULL)
 800c694:	4b11      	ldr	r3, [pc, #68]	@ (800c6dc <OnComplianceTxNextPacketTimerEvent+0x80>)
 800c696:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c698:	b11b      	cbz	r3, 800c6a2 <OnComplianceTxNextPacketTimerEvent+0x46>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, true );
 800c69a:	78e1      	ldrb	r1, [r4, #3]
 800c69c:	2201      	movs	r2, #1
 800c69e:	4668      	mov	r0, sp
 800c6a0:	4798      	blx	r3
    LmhpComplianceTxProcess( );
}
 800c6a2:	b002      	add	sp, #8
 800c6a4:	bd10      	pop	{r4, pc}
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 800c6a6:	7be1      	ldrb	r1, [r4, #15]
 800c6a8:	7051      	strb	r1, [r2, #1]
        ComplianceTestState.State = 1;
 800c6aa:	2101      	movs	r1, #1
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 800c6ac:	7c20      	ldrb	r0, [r4, #16]
        ComplianceTestState.State = 1;
 800c6ae:	70a1      	strb	r1, [r4, #2]
        ComplianceTestState.DataBufferSize = 3;
 800c6b0:	2303      	movs	r3, #3
        ComplianceTestState.LinkCheck = false;
 800c6b2:	f04f 0c00 	mov.w	ip, #0
        ComplianceTestState.DataBuffer[0] = 5;
 800c6b6:	2105      	movs	r1, #5
        ComplianceTestState.LinkCheck = false;
 800c6b8:	f884 c00e 	strb.w	ip, [r4, #14]
        ComplianceTestState.DataBufferSize = 3;
 800c6bc:	71a3      	strb	r3, [r4, #6]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 800c6be:	7090      	strb	r0, [r2, #2]
        ComplianceTestState.DataBuffer[0] = 5;
 800c6c0:	7011      	strb	r1, [r2, #0]
        ComplianceTestState.State = 1;
 800c6c2:	e7de      	b.n	800c682 <OnComplianceTxNextPacketTimerEvent+0x26>
                ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 800c6c4:	89a1      	ldrh	r1, [r4, #12]
                ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 800c6c6:	7051      	strb	r1, [r2, #1]
                ComplianceTestState.DataBufferSize = 2;
 800c6c8:	2302      	movs	r3, #2
                ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 800c6ca:	0a08      	lsrs	r0, r1, #8
                ComplianceTestState.DataBufferSize = 2;
 800c6cc:	71a3      	strb	r3, [r4, #6]
                ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 800c6ce:	7010      	strb	r0, [r2, #0]
                break;
 800c6d0:	e7d7      	b.n	800c682 <OnComplianceTxNextPacketTimerEvent+0x26>
 800c6d2:	bf00      	nop
 800c6d4:	20000640 	.word	0x20000640
 800c6d8:	20000654 	.word	0x20000654
 800c6dc:	200000c8 	.word	0x200000c8

0800c6e0 <LmhpCompliancePackageFactory>:
}
 800c6e0:	4800      	ldr	r0, [pc, #0]	@ (800c6e4 <LmhpCompliancePackageFactory+0x4>)
 800c6e2:	4770      	bx	lr
 800c6e4:	200000c8 	.word	0x200000c8

0800c6e8 <LmhpPackagesRegistrationInit>:
    }
#endif /* LORAWAN_PACKAGES_VERSION */
#endif /* LORAWAN_DATA_DISTRIB_MGT */

    return LORAMAC_HANDLER_SUCCESS;
}
 800c6e8:	2000      	movs	r0, #0
 800c6ea:	4770      	bx	lr

0800c6ec <OnRadioRxError>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
}

static void OnRadioRxError( void )
{
    LoRaMacRadioEvents.Events.RxError = 1;
 800c6ec:	4a06      	ldr	r2, [pc, #24]	@ (800c708 <OnRadioRxError+0x1c>)
    return true;
}

static void OnMacProcessNotify( void )
{
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c6ee:	4907      	ldr	r1, [pc, #28]	@ (800c70c <OnRadioRxError+0x20>)
    LoRaMacRadioEvents.Events.RxError = 1;
 800c6f0:	7813      	ldrb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c6f2:	f8d1 1348 	ldr.w	r1, [r1, #840]	@ 0x348
    LoRaMacRadioEvents.Events.RxError = 1;
 800c6f6:	f043 0302 	orr.w	r3, r3, #2
 800c6fa:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c6fc:	b111      	cbz	r1, 800c704 <OnRadioRxError+0x18>
 800c6fe:	694b      	ldr	r3, [r1, #20]
 800c700:	b103      	cbz	r3, 800c704 <OnRadioRxError+0x18>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 800c702:	4718      	bx	r3
}
 800c704:	4770      	bx	lr
 800c706:	bf00      	nop
 800c708:	20000680 	.word	0x20000680
 800c70c:	20000dec 	.word	0x20000dec

0800c710 <OnAckTimeoutTimerEvent>:
{
 800c710:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.AckTimeoutTimer );
 800c712:	480f      	ldr	r0, [pc, #60]	@ (800c750 <OnAckTimeoutTimerEvent+0x40>)
 800c714:	f008 ffea 	bl	80156ec <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 800c718:	4b0e      	ldr	r3, [pc, #56]	@ (800c754 <OnAckTimeoutTimerEvent+0x44>)
 800c71a:	f893 2410 	ldrb.w	r2, [r3, #1040]	@ 0x410
 800c71e:	b112      	cbz	r2, 800c726 <OnAckTimeoutTimerEvent+0x16>
        MacCtx.AckTimeoutRetry = true;
 800c720:	2201      	movs	r2, #1
 800c722:	f883 240f 	strb.w	r2, [r3, #1039]	@ 0x40f
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800c726:	4a0c      	ldr	r2, [pc, #48]	@ (800c758 <OnAckTimeoutTimerEvent+0x48>)
 800c728:	f892 2118 	ldrb.w	r2, [r2, #280]	@ 0x118
 800c72c:	2a02      	cmp	r2, #2
 800c72e:	d105      	bne.n	800c73c <OnAckTimeoutTimerEvent+0x2c>
        MacCtx.MacFlags.Bits.MacDone = 1;
 800c730:	f893 2481 	ldrb.w	r2, [r3, #1153]	@ 0x481
 800c734:	f042 0210 	orr.w	r2, r2, #16
 800c738:	f883 2481 	strb.w	r2, [r3, #1153]	@ 0x481
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c73c:	f8d3 3348 	ldr.w	r3, [r3, #840]	@ 0x348
 800c740:	b123      	cbz	r3, 800c74c <OnAckTimeoutTimerEvent+0x3c>
 800c742:	695b      	ldr	r3, [r3, #20]
 800c744:	b113      	cbz	r3, 800c74c <OnAckTimeoutTimerEvent+0x3c>
}
 800c746:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        MacCtx.MacCallbacks->MacProcessNotify( );
 800c74a:	4718      	bx	r3
}
 800c74c:	bd10      	pop	{r4, pc}
 800c74e:	bf00      	nop
 800c750:	200011e0 	.word	0x200011e0
 800c754:	20000dec 	.word	0x20000dec
 800c758:	20000684 	.word	0x20000684

0800c75c <HandleRadioRxErrorTimeout>:
{
 800c75c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c75e:	4d3d      	ldr	r5, [pc, #244]	@ (800c854 <HandleRadioRxErrorTimeout+0xf8>)
 800c760:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800c764:	2b02      	cmp	r3, #2
{
 800c766:	4607      	mov	r7, r0
 800c768:	460e      	mov	r6, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c76a:	d002      	beq.n	800c772 <HandleRadioRxErrorTimeout+0x16>
        Radio.Sleep( );
 800c76c:	4b3a      	ldr	r3, [pc, #232]	@ (800c858 <HandleRadioRxErrorTimeout+0xfc>)
 800c76e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c770:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 800c772:	f003 f8e7 	bl	800f944 <LoRaMacClassBIsBeaconExpected>
 800c776:	4604      	mov	r4, r0
 800c778:	bb78      	cbnz	r0, 800c7da <HandleRadioRxErrorTimeout+0x7e>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800c77a:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800c77e:	2b01      	cmp	r3, #1
 800c780:	d03c      	beq.n	800c7fc <HandleRadioRxErrorTimeout+0xa0>
            if( MacCtx.NodeAckRequested == true )
 800c782:	4c36      	ldr	r4, [pc, #216]	@ (800c85c <HandleRadioRxErrorTimeout+0x100>)
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 800c784:	f894 3480 	ldrb.w	r3, [r4, #1152]	@ 0x480
            if( MacCtx.NodeAckRequested == true )
 800c788:	f894 2410 	ldrb.w	r2, [r4, #1040]	@ 0x410
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 800c78c:	b9a3      	cbnz	r3, 800c7b8 <HandleRadioRxErrorTimeout+0x5c>
            if( MacCtx.NodeAckRequested == true )
 800c78e:	b10a      	cbz	r2, 800c794 <HandleRadioRxErrorTimeout+0x38>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 800c790:	f884 7435 	strb.w	r7, [r4, #1077]	@ 0x435
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 800c794:	4638      	mov	r0, r7
 800c796:	f003 fae7 	bl	800fd68 <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 800c79a:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 800c79c:	f009 f898 	bl	80158d0 <UTIL_TIMER_GetElapsedTime>
 800c7a0:	f8d4 33b4 	ldr.w	r3, [r4, #948]	@ 0x3b4
 800c7a4:	4298      	cmp	r0, r3
 800c7a6:	d234      	bcs.n	800c812 <HandleRadioRxErrorTimeout+0xb6>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c7a8:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800c7ac:	2b02      	cmp	r3, #2
 800c7ae:	d121      	bne.n	800c7f4 <HandleRadioRxErrorTimeout+0x98>
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
 800c7b0:	2302      	movs	r3, #2
 800c7b2:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
}
 800c7b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if( MacCtx.NodeAckRequested == true )
 800c7b8:	b10a      	cbz	r2, 800c7be <HandleRadioRxErrorTimeout+0x62>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 800c7ba:	f884 6435 	strb.w	r6, [r4, #1077]	@ 0x435
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 800c7be:	4630      	mov	r0, r6
 800c7c0:	f003 fad2 	bl	800fd68 <LoRaMacConfirmQueueSetStatusCmn>
            if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c7c4:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800c7c8:	2b02      	cmp	r3, #2
 800c7ca:	d0f1      	beq.n	800c7b0 <HandleRadioRxErrorTimeout+0x54>
                MacCtx.MacFlags.Bits.MacDone = 1;
 800c7cc:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800c7d0:	f043 0310 	orr.w	r3, r3, #16
 800c7d4:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c7d8:	e00c      	b.n	800c7f4 <HandleRadioRxErrorTimeout+0x98>
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 800c7da:	2002      	movs	r0, #2
 800c7dc:	f003 f8a2 	bl	800f924 <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 800c7e0:	2000      	movs	r0, #0
 800c7e2:	f003 f8a7 	bl	800f934 <LoRaMacClassBBeaconTimerEvent>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800c7e6:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800c7ea:	2b01      	cmp	r3, #1
 800c7ec:	d006      	beq.n	800c7fc <HandleRadioRxErrorTimeout+0xa0>
 800c7ee:	4c1b      	ldr	r4, [pc, #108]	@ (800c85c <HandleRadioRxErrorTimeout+0x100>)
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c7f0:	2b02      	cmp	r3, #2
 800c7f2:	d0dd      	beq.n	800c7b0 <HandleRadioRxErrorTimeout+0x54>
        MacCtx.RxSlot = RX_SLOT_NONE;
 800c7f4:	2306      	movs	r3, #6
 800c7f6:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
}
 800c7fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( LoRaMacClassBIsPingExpected( ) == true )
 800c7fc:	f003 f8a4 	bl	800f948 <LoRaMacClassBIsPingExpected>
 800c800:	b998      	cbnz	r0, 800c82a <HandleRadioRxErrorTimeout+0xce>
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 800c802:	f003 f8a3 	bl	800f94c <LoRaMacClassBIsMulticastExpected>
 800c806:	b9d0      	cbnz	r0, 800c83e <HandleRadioRxErrorTimeout+0xe2>
    if( classBRx == false )
 800c808:	2c00      	cmp	r4, #0
 800c80a:	d0ba      	beq.n	800c782 <HandleRadioRxErrorTimeout+0x26>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c80c:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800c810:	e7ed      	b.n	800c7ee <HandleRadioRxErrorTimeout+0x92>
                TimerStop( &MacCtx.RxWindowTimer2 );
 800c812:	4813      	ldr	r0, [pc, #76]	@ (800c860 <HandleRadioRxErrorTimeout+0x104>)
 800c814:	f008 ff6a 	bl	80156ec <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 800c818:	f894 2481 	ldrb.w	r2, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c81c:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
                MacCtx.MacFlags.Bits.MacDone = 1;
 800c820:	f042 0210 	orr.w	r2, r2, #16
 800c824:	f884 2481 	strb.w	r2, [r4, #1153]	@ 0x481
 800c828:	e7e2      	b.n	800c7f0 <HandleRadioRxErrorTimeout+0x94>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 800c82a:	2000      	movs	r0, #0
 800c82c:	f003 f87c 	bl	800f928 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 800c830:	2000      	movs	r0, #0
 800c832:	f003 f881 	bl	800f938 <LoRaMacClassBPingSlotTimerEvent>
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 800c836:	f003 f889 	bl	800f94c <LoRaMacClassBIsMulticastExpected>
 800c83a:	2800      	cmp	r0, #0
 800c83c:	d0e6      	beq.n	800c80c <HandleRadioRxErrorTimeout+0xb0>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 800c83e:	2000      	movs	r0, #0
 800c840:	f003 f874 	bl	800f92c <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 800c844:	2000      	movs	r0, #0
 800c846:	f003 f879 	bl	800f93c <LoRaMacClassBMulticastSlotTimerEvent>
    if( classBRx == false )
 800c84a:	4c04      	ldr	r4, [pc, #16]	@ (800c85c <HandleRadioRxErrorTimeout+0x100>)
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800c84c:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800c850:	e7ce      	b.n	800c7f0 <HandleRadioRxErrorTimeout+0x94>
 800c852:	bf00      	nop
 800c854:	20000684 	.word	0x20000684
 800c858:	08017658 	.word	0x08017658
 800c85c:	20000dec 	.word	0x20000dec
 800c860:	20001184 	.word	0x20001184

0800c864 <OnRadioRxTimeout>:
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 800c864:	4a0a      	ldr	r2, [pc, #40]	@ (800c890 <OnRadioRxTimeout+0x2c>)
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c866:	490b      	ldr	r1, [pc, #44]	@ (800c894 <OnRadioRxTimeout+0x30>)
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 800c868:	7813      	ldrb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c86a:	f8d1 1348 	ldr.w	r1, [r1, #840]	@ 0x348
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 800c86e:	f043 0301 	orr.w	r3, r3, #1
{
 800c872:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 800c874:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c876:	b111      	cbz	r1, 800c87e <OnRadioRxTimeout+0x1a>
 800c878:	694b      	ldr	r3, [r1, #20]
 800c87a:	b103      	cbz	r3, 800c87e <OnRadioRxTimeout+0x1a>
        MacCtx.MacCallbacks->MacProcessNotify( );
 800c87c:	4798      	blx	r3
}
 800c87e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 800c882:	4b05      	ldr	r3, [pc, #20]	@ (800c898 <OnRadioRxTimeout+0x34>)
 800c884:	2201      	movs	r2, #1
 800c886:	2100      	movs	r1, #0
 800c888:	2002      	movs	r0, #2
 800c88a:	f009 b8b3 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 800c88e:	bf00      	nop
 800c890:	20000680 	.word	0x20000680
 800c894:	20000dec 	.word	0x20000dec
 800c898:	0801748c 	.word	0x0801748c

0800c89c <OnRadioTxTimeout>:
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 800c89c:	4a0a      	ldr	r2, [pc, #40]	@ (800c8c8 <OnRadioTxTimeout+0x2c>)
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c89e:	490b      	ldr	r1, [pc, #44]	@ (800c8cc <OnRadioTxTimeout+0x30>)
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 800c8a0:	7813      	ldrb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c8a2:	f8d1 1348 	ldr.w	r1, [r1, #840]	@ 0x348
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 800c8a6:	f043 0304 	orr.w	r3, r3, #4
{
 800c8aa:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 800c8ac:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c8ae:	b111      	cbz	r1, 800c8b6 <OnRadioTxTimeout+0x1a>
 800c8b0:	694b      	ldr	r3, [r1, #20]
 800c8b2:	b103      	cbz	r3, 800c8b6 <OnRadioTxTimeout+0x1a>
        MacCtx.MacCallbacks->MacProcessNotify( );
 800c8b4:	4798      	blx	r3
}
 800c8b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 800c8ba:	4b05      	ldr	r3, [pc, #20]	@ (800c8d0 <OnRadioTxTimeout+0x34>)
 800c8bc:	2201      	movs	r2, #1
 800c8be:	2100      	movs	r1, #0
 800c8c0:	2002      	movs	r0, #2
 800c8c2:	f009 b897 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 800c8c6:	bf00      	nop
 800c8c8:	20000680 	.word	0x20000680
 800c8cc:	20000dec 	.word	0x20000dec
 800c8d0:	0801749c 	.word	0x0801749c

0800c8d4 <OnRadioRxDone>:
{
 800c8d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c8d8:	460f      	mov	r7, r1
 800c8da:	4616      	mov	r6, r2
 800c8dc:	461d      	mov	r5, r3
 800c8de:	4680      	mov	r8, r0
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 800c8e0:	f008 ffec 	bl	80158bc <UTIL_TIMER_GetCurrentTime>
    LoRaMacRadioEvents.Events.RxDone = 1;
 800c8e4:	4a0c      	ldr	r2, [pc, #48]	@ (800c918 <OnRadioRxDone+0x44>)
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c8e6:	4b0d      	ldr	r3, [pc, #52]	@ (800c91c <OnRadioRxDone+0x48>)
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 800c8e8:	4c0d      	ldr	r4, [pc, #52]	@ (800c920 <OnRadioRxDone+0x4c>)
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c8ea:	f8d3 1348 	ldr.w	r1, [r3, #840]	@ 0x348
    LoRaMacRadioEvents.Events.RxDone = 1;
 800c8ee:	7813      	ldrb	r3, [r2, #0]
    RxDoneParams.Size = size;
 800c8f0:	8127      	strh	r7, [r4, #8]
    LoRaMacRadioEvents.Events.RxDone = 1;
 800c8f2:	f043 0308 	orr.w	r3, r3, #8
    RxDoneParams.Payload = payload;
 800c8f6:	e9c4 0800 	strd	r0, r8, [r4]
    LoRaMacRadioEvents.Events.RxDone = 1;
 800c8fa:	7013      	strb	r3, [r2, #0]
    RxDoneParams.Rssi = rssi;
 800c8fc:	8166      	strh	r6, [r4, #10]
    RxDoneParams.Snr = snr;
 800c8fe:	7325      	strb	r5, [r4, #12]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c900:	b111      	cbz	r1, 800c908 <OnRadioRxDone+0x34>
 800c902:	694b      	ldr	r3, [r1, #20]
 800c904:	b103      	cbz	r3, 800c908 <OnRadioRxDone+0x34>
        MacCtx.MacCallbacks->MacProcessNotify( );
 800c906:	4798      	blx	r3
}
 800c908:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 800c90c:	4b05      	ldr	r3, [pc, #20]	@ (800c924 <OnRadioRxDone+0x50>)
 800c90e:	2201      	movs	r2, #1
 800c910:	2100      	movs	r1, #0
 800c912:	2002      	movs	r0, #2
 800c914:	f009 b86e 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 800c918:	20000680 	.word	0x20000680
 800c91c:	20000dec 	.word	0x20000dec
 800c920:	2000066c 	.word	0x2000066c
 800c924:	080174ac 	.word	0x080174ac

0800c928 <OnRadioTxDone>:
{
 800c928:	b530      	push	{r4, r5, lr}
 800c92a:	b083      	sub	sp, #12
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 800c92c:	f008 ffc6 	bl	80158bc <UTIL_TIMER_GetCurrentTime>
    MacCtx.LastTxSysTime = SysTimeGet( );
 800c930:	466c      	mov	r4, sp
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 800c932:	4b10      	ldr	r3, [pc, #64]	@ (800c974 <OnRadioTxDone+0x4c>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 800c934:	4d10      	ldr	r5, [pc, #64]	@ (800c978 <OnRadioTxDone+0x50>)
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 800c936:	4602      	mov	r2, r0
    MacCtx.LastTxSysTime = SysTimeGet( );
 800c938:	4620      	mov	r0, r4
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 800c93a:	601a      	str	r2, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 800c93c:	f008 fa68 	bl	8014e10 <SysTimeGet>
 800c940:	e894 0003 	ldmia.w	r4, {r0, r1}
    LoRaMacRadioEvents.Events.TxDone = 1;
 800c944:	4a0d      	ldr	r2, [pc, #52]	@ (800c97c <OnRadioTxDone+0x54>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 800c946:	f505 744e 	add.w	r4, r5, #824	@ 0x338
    LoRaMacRadioEvents.Events.TxDone = 1;
 800c94a:	7813      	ldrb	r3, [r2, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 800c94c:	e884 0003 	stmia.w	r4, {r0, r1}
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c950:	f8d5 1348 	ldr.w	r1, [r5, #840]	@ 0x348
    LoRaMacRadioEvents.Events.TxDone = 1;
 800c954:	f043 0310 	orr.w	r3, r3, #16
 800c958:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800c95a:	b111      	cbz	r1, 800c962 <OnRadioTxDone+0x3a>
 800c95c:	694b      	ldr	r3, [r1, #20]
 800c95e:	b103      	cbz	r3, 800c962 <OnRadioTxDone+0x3a>
        MacCtx.MacCallbacks->MacProcessNotify( );
 800c960:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 800c962:	4b07      	ldr	r3, [pc, #28]	@ (800c980 <OnRadioTxDone+0x58>)
 800c964:	2201      	movs	r2, #1
 800c966:	2100      	movs	r1, #0
 800c968:	2002      	movs	r0, #2
}
 800c96a:	b003      	add	sp, #12
 800c96c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 800c970:	f009 b840 	b.w	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 800c974:	2000067c 	.word	0x2000067c
 800c978:	20000dec 	.word	0x20000dec
 800c97c:	20000680 	.word	0x20000680
 800c980:	080174bc 	.word	0x080174bc

0800c984 <ResetMacParameters.constprop.0>:
static void ResetMacParameters( bool isRejoin )
 800c984:	b570      	push	{r4, r5, r6, lr}
        Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 800c986:	4c4c      	ldr	r4, [pc, #304]	@ (800cab8 <ResetMacParameters.constprop.0+0x134>)
    MacCtx.ChannelsNbTransCounter = 0;
 800c988:	4e4c      	ldr	r6, [pc, #304]	@ (800cabc <ResetMacParameters.constprop.0+0x138>)
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 800c98a:	f894 20b1 	ldrb.w	r2, [r4, #177]	@ 0xb1
 800c98e:	f884 2069 	strb.w	r2, [r4, #105]	@ 0x69
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 800c992:	f104 03b4 	add.w	r3, r4, #180	@ 0xb4
 800c996:	e893 0003 	ldmia.w	r3, {r0, r1}
 800c99a:	f104 036c 	add.w	r3, r4, #108	@ 0x6c
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 800c99e:	f8b4 20c4 	ldrh.w	r2, [r4, #196]	@ 0xc4
 800c9a2:	f8a4 207c 	strh.w	r2, [r4, #124]	@ 0x7c
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 800c9a6:	e883 0003 	stmia.w	r3, {r0, r1}
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 800c9aa:	f8d4 20c8 	ldr.w	r2, [r4, #200]	@ 0xc8
 800c9ae:	f8c4 2080 	str.w	r2, [r4, #128]	@ 0x80
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 800c9b2:	f104 03bc 	add.w	r3, r4, #188	@ 0xbc
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 800c9b6:	f8d4 20cc 	ldr.w	r2, [r4, #204]	@ 0xcc
 800c9ba:	f8c4 2084 	str.w	r2, [r4, #132]	@ 0x84
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 800c9be:	e893 0003 	ldmia.w	r3, {r0, r1}
    Nvm.MacGroup2.MacParams.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;
 800c9c2:	f8d4 20d0 	ldr.w	r2, [r4, #208]	@ 0xd0
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 800c9c6:	f8b4 30dc 	ldrh.w	r3, [r4, #220]	@ 0xdc
    Nvm.MacGroup2.MacParams.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;
 800c9ca:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
static void ResetMacParameters( bool isRejoin )
 800c9ce:	b08e      	sub	sp, #56	@ 0x38
    MacCtx.ChannelsNbTransCounter = 0;
 800c9d0:	4a3b      	ldr	r2, [pc, #236]	@ (800cac0 <ResetMacParameters.constprop.0+0x13c>)
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 800c9d2:	8723      	strh	r3, [r4, #56]	@ 0x38
        Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 800c9d4:	2500      	movs	r5, #0
    Nvm.MacGroup2.AggregatedDCycle = 1;
 800c9d6:	2301      	movs	r3, #1
    MacCtx.ChannelsNbTransCounter = 0;
 800c9d8:	f8c6 240c 	str.w	r2, [r6, #1036]	@ 0x40c
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 800c9dc:	f104 0274 	add.w	r2, r4, #116	@ 0x74
    Nvm.MacGroup2.Rejoin1CycleInSec = 0;
 800c9e0:	e9c4 554e 	strd	r5, r5, [r4, #312]	@ 0x138
    Nvm.MacGroup2.AggregatedDCycle = 1;
 800c9e4:	f8a4 311e 	strh.w	r3, [r4, #286]	@ 0x11e
        Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 800c9e8:	f884 512c 	strb.w	r5, [r4, #300]	@ 0x12c
    Nvm.MacGroup1.AdrAckCounter = 0;
 800c9ec:	62a5      	str	r5, [r4, #40]	@ 0x28
    Nvm.MacGroup2.MaxDCycle = 0;
 800c9ee:	f884 511b 	strb.w	r5, [r4, #283]	@ 0x11b
    Nvm.MacGroup1.SrvAckRequested = false;
 800c9f2:	f884 503a 	strb.w	r5, [r4, #58]	@ 0x3a
    Nvm.MacGroup2.Rejoin0UplinksLimit = 0;
 800c9f6:	f8c4 5130 	str.w	r5, [r4, #304]	@ 0x130
    Nvm.MacGroup2.ForceRejoinMaxRetries = 0;
 800c9fa:	f8a4 5134 	strh.w	r5, [r4, #308]	@ 0x134
    Nvm.MacGroup2.IsRejoin0RequestQueued = 0;
 800c9fe:	f8a4 5141 	strh.w	r5, [r4, #321]	@ 0x141
    MacCtx.NodeAckRequested = false;
 800ca02:	f886 5410 	strb.w	r5, [r6, #1040]	@ 0x410
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 800ca06:	e882 0003 	stmia.w	r2, {r0, r1}
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 800ca0a:	f88d 3014 	strb.w	r3, [sp, #20]
    params.NvmGroup1 = &Nvm.RegionGroup1;
 800ca0e:	f504 7308 	add.w	r3, r4, #544	@ 0x220
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800ca12:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    params.NvmGroup1 = &Nvm.RegionGroup1;
 800ca16:	9303      	str	r3, [sp, #12]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800ca18:	a903      	add	r1, sp, #12
    params.NvmGroup2 = &Nvm.RegionGroup2;
 800ca1a:	f504 732d 	add.w	r3, r4, #692	@ 0x2b4
    Nvm.MacGroup2.IsRejoin2RequestQueued = 0;
 800ca1e:	f884 5143 	strb.w	r5, [r4, #323]	@ 0x143
    params.NvmGroup2 = &Nvm.RegionGroup2;
 800ca22:	9304      	str	r3, [sp, #16]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800ca24:	f003 ff74 	bl	8010910 <RegionInitDefaults>
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 800ca28:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800ca2a:	f8c6 33d0 	str.w	r3, [r6, #976]	@ 0x3d0
    MacCtx.RxWindow2Config.RxContinuous = false;
 800ca2e:	f44f 7280 	mov.w	r2, #256	@ 0x100
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ca32:	f894 307d 	ldrb.w	r3, [r4, #125]	@ 0x7d
    MacCtx.RxWindow2Config.RxContinuous = false;
 800ca36:	f8a6 23de 	strh.w	r2, [r6, #990]	@ 0x3de
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 800ca3a:	f886 53cc 	strb.w	r5, [r6, #972]	@ 0x3cc
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ca3e:	f886 33dc 	strb.w	r3, [r6, #988]	@ 0x3dc
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800ca42:	f506 7e73 	add.w	lr, r6, #972	@ 0x3cc
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 800ca46:	f894 308c 	ldrb.w	r3, [r4, #140]	@ 0x8c
 800ca4a:	f886 33dd 	strb.w	r3, [r6, #989]	@ 0x3dd
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800ca4e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800ca52:	f506 7c78 	add.w	ip, r6, #992	@ 0x3e0
 800ca56:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    if( MacCtx.MacCallbacks != NULL )
 800ca5a:	f8d6 4348 	ldr.w	r4, [r6, #840]	@ 0x348
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800ca5e:	f8de 3000 	ldr.w	r3, [lr]
    MacCtx.Channel = 0;
 800ca62:	f886 5411 	strb.w	r5, [r6, #1041]	@ 0x411
    classBCallbacks.MacProcessNotify = NULL;
 800ca66:	e9cd 5501 	strd	r5, r5, [sp, #4]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800ca6a:	f240 2501 	movw	r5, #513	@ 0x201
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800ca6e:	f8cc 3000 	str.w	r3, [ip]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800ca72:	f8a6 53f2 	strh.w	r5, [r6, #1010]	@ 0x3f2
    if( MacCtx.MacCallbacks != NULL )
 800ca76:	b11c      	cbz	r4, 800ca80 <ResetMacParameters.constprop.0+0xfc>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 800ca78:	6862      	ldr	r2, [r4, #4]
 800ca7a:	6963      	ldr	r3, [r4, #20]
 800ca7c:	e9cd 2301 	strd	r2, r3, [sp, #4]
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 800ca80:	4a10      	ldr	r2, [pc, #64]	@ (800cac4 <ResetMacParameters.constprop.0+0x140>)
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 800ca82:	4b11      	ldr	r3, [pc, #68]	@ (800cac8 <ResetMacParameters.constprop.0+0x144>)
 800ca84:	9306      	str	r3, [sp, #24]
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 800ca86:	f1a2 019c 	sub.w	r1, r2, #156	@ 0x9c
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 800ca8a:	f1a3 0444 	sub.w	r4, r3, #68	@ 0x44
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 800ca8e:	f1a3 0014 	sub.w	r0, r3, #20
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 800ca92:	3325      	adds	r3, #37	@ 0x25
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 800ca94:	e9cd 4007 	strd	r4, r0, [sp, #28]
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 800ca98:	e9cd 3209 	strd	r3, r2, [sp, #36]	@ 0x24
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 800ca9c:	f1a2 0598 	sub.w	r5, r2, #152	@ 0x98
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 800caa0:	1d14      	adds	r4, r2, #4
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 800caa2:	910b      	str	r1, [sp, #44]	@ 0x2c
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 800caa4:	f202 626c 	addw	r2, r2, #1644	@ 0x66c
 800caa8:	a901      	add	r1, sp, #4
 800caaa:	a806      	add	r0, sp, #24
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 800caac:	e9cd 540c 	strd	r5, r4, [sp, #48]	@ 0x30
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 800cab0:	f002 ff36 	bl	800f920 <LoRaMacClassBInit>
}
 800cab4:	b00e      	add	sp, #56	@ 0x38
 800cab6:	bd70      	pop	{r4, r5, r6, pc}
 800cab8:	20000684 	.word	0x20000684
 800cabc:	20000dec 	.word	0x20000dec
 800cac0:	00010100 	.word	0x00010100
 800cac4:	20000768 	.word	0x20000768
 800cac8:	20001248 	.word	0x20001248

0800cacc <OnRxWindow2TimerEvent>:
{
 800cacc:	b570      	push	{r4, r5, r6, lr}
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 800cace:	4c1b      	ldr	r4, [pc, #108]	@ (800cb3c <OnRxWindow2TimerEvent+0x70>)
 800cad0:	f894 3480 	ldrb.w	r3, [r4, #1152]	@ 0x480
 800cad4:	b903      	cbnz	r3, 800cad8 <OnRxWindow2TimerEvent+0xc>
}
 800cad6:	bd70      	pop	{r4, r5, r6, pc}
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 800cad8:	4d19      	ldr	r5, [pc, #100]	@ (800cb40 <OnRxWindow2TimerEvent+0x74>)
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 800cada:	f894 2411 	ldrb.w	r2, [r4, #1041]	@ 0x411
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 800cade:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
 800cae0:	f8c4 33d0 	str.w	r3, [r4, #976]	@ 0x3d0
    Radio.Standby( );
 800cae4:	4e17      	ldr	r6, [pc, #92]	@ (800cb44 <OnRxWindow2TimerEvent+0x78>)
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 800cae6:	f895 308c 	ldrb.w	r3, [r5, #140]	@ 0x8c
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 800caea:	f884 23cc 	strb.w	r2, [r4, #972]	@ 0x3cc
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 800caee:	f884 33dd 	strb.w	r3, [r4, #989]	@ 0x3dd
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800caf2:	f895 207d 	ldrb.w	r2, [r5, #125]	@ 0x7d
 800caf6:	f884 23dc 	strb.w	r2, [r4, #988]	@ 0x3dc
    MacCtx.RxWindow2Config.RxContinuous = false;
 800cafa:	f44f 7380 	mov.w	r3, #256	@ 0x100
    TimerStop( rxTimer );
 800cafe:	f504 7066 	add.w	r0, r4, #920	@ 0x398
    MacCtx.RxWindow2Config.RxContinuous = false;
 800cb02:	f8a4 33de 	strh.w	r3, [r4, #990]	@ 0x3de
    TimerStop( rxTimer );
 800cb06:	f008 fdf1 	bl	80156ec <UTIL_TIMER_Stop>
    Radio.Standby( );
 800cb0a:	6b33      	ldr	r3, [r6, #48]	@ 0x30
 800cb0c:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800cb0e:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
 800cb12:	f204 421c 	addw	r2, r4, #1052	@ 0x41c
 800cb16:	f504 7173 	add.w	r1, r4, #972	@ 0x3cc
 800cb1a:	f003 ff25 	bl	8010968 <RegionRxConfig>
 800cb1e:	2800      	cmp	r0, #0
 800cb20:	d0d9      	beq.n	800cad6 <OnRxWindow2TimerEvent+0xa>
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800cb22:	f894 241c 	ldrb.w	r2, [r4, #1052]	@ 0x41c
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 800cb26:	6b73      	ldr	r3, [r6, #52]	@ 0x34
 800cb28:	6d68      	ldr	r0, [r5, #84]	@ 0x54
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800cb2a:	f884 245e 	strb.w	r2, [r4, #1118]	@ 0x45e
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 800cb2e:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 800cb30:	f894 33df 	ldrb.w	r3, [r4, #991]	@ 0x3df
 800cb34:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
}
 800cb38:	bd70      	pop	{r4, r5, r6, pc}
 800cb3a:	bf00      	nop
 800cb3c:	20000dec 	.word	0x20000dec
 800cb40:	20000684 	.word	0x20000684
 800cb44:	08017658 	.word	0x08017658

0800cb48 <ProcessMacCommands.constprop.0>:
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 800cb48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cb4c:	b08f      	sub	sp, #60	@ 0x3c
    uint8_t status = 0;
 800cb4e:	2700      	movs	r7, #0
 800cb50:	f88d 700d 	strb.w	r7, [sp, #13]
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 800cb54:	f8ad 7010 	strh.w	r7, [sp, #16]
    while( macIndex < commandsSize )
 800cb58:	2900      	cmp	r1, #0
 800cb5a:	d040      	beq.n	800cbde <ProcessMacCommands.constprop.0+0x96>
 800cb5c:	4605      	mov	r5, r0
 800cb5e:	4690      	mov	r8, r2
 800cb60:	460e      	mov	r6, r1
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 800cb62:	463c      	mov	r4, r7
 800cb64:	5d28      	ldrb	r0, [r5, r4]
 800cb66:	f003 f883 	bl	800fc70 <LoRaMacCommandsGetCmdSize>
 800cb6a:	4420      	add	r0, r4
 800cb6c:	42b0      	cmp	r0, r6
 800cb6e:	dc36      	bgt.n	800cbde <ProcessMacCommands.constprop.0+0x96>
        switch( payload[macIndex++] )
 800cb70:	5d2b      	ldrb	r3, [r5, r4]
 800cb72:	1c62      	adds	r2, r4, #1
 800cb74:	3b02      	subs	r3, #2
 800cb76:	fa5f f982 	uxtb.w	r9, r2
 800cb7a:	2b11      	cmp	r3, #17
 800cb7c:	d82f      	bhi.n	800cbde <ProcessMacCommands.constprop.0+0x96>
 800cb7e:	e8df f013 	tbh	[pc, r3, lsl #1]
 800cb82:	0209      	.short	0x0209
 800cb84:	01de01f2 	.word	0x01de01f2
 800cb88:	0182019a 	.word	0x0182019a
 800cb8c:	0133014b 	.word	0x0133014b
 800cb90:	00ad00f0 	.word	0x00ad00f0
 800cb94:	002e002e 	.word	0x002e002e
 800cb98:	002e0059 	.word	0x002e0059
 800cb9c:	00db002e 	.word	0x00db002e
 800cba0:	00310039 	.word	0x00310039
 800cba4:	0012      	.short	0x0012
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 800cba6:	1ce3      	adds	r3, r4, #3
                    frequency = ( uint32_t )payload[macIndex++];
 800cba8:	1ca2      	adds	r2, r4, #2
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 800cbaa:	b2db      	uxtb	r3, r3
 800cbac:	b2d2      	uxtb	r2, r2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 800cbae:	5ceb      	ldrb	r3, [r5, r3]
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 800cbb0:	5caa      	ldrb	r2, [r5, r2]
                    frequency = ( uint32_t )payload[macIndex++];
 800cbb2:	f815 1009 	ldrb.w	r1, [r5, r9]
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 800cbb6:	041b      	lsls	r3, r3, #16
 800cbb8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800cbbc:	430b      	orrs	r3, r1
                    frequency *= 100;
 800cbbe:	2064      	movs	r0, #100	@ 0x64
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 800cbc0:	fb03 f000 	mul.w	r0, r3, r0
 800cbc4:	f002 feda 	bl	800f97c <LoRaMacClassBBeaconFreqReq>
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 800cbc8:	3404      	adds	r4, #4
 800cbca:	f88d 0010 	strb.w	r0, [sp, #16]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 800cbce:	2201      	movs	r2, #1
 800cbd0:	a904      	add	r1, sp, #16
 800cbd2:	2013      	movs	r0, #19
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 800cbd4:	b2e4      	uxtb	r4, r4
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 800cbd6:	f002 fee9 	bl	800f9ac <LoRaMacCommandsAddCmd>
    while( macIndex < commandsSize )
 800cbda:	42a6      	cmp	r6, r4
 800cbdc:	d8c2      	bhi.n	800cb64 <ProcessMacCommands.constprop.0+0x1c>
}
 800cbde:	b00f      	add	sp, #60	@ 0x3c
 800cbe0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 800cbe4:	200e      	movs	r0, #14
 800cbe6:	f003 f8e1 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800cbea:	2800      	cmp	r0, #0
 800cbec:	f040 81eb 	bne.w	800cfc6 <ProcessMacCommands.constprop.0+0x47e>
        switch( payload[macIndex++] )
 800cbf0:	464c      	mov	r4, r9
 800cbf2:	e7f2      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 800cbf4:	1ce3      	adds	r3, r4, #3
                frequency = ( uint32_t )payload[macIndex++];
 800cbf6:	1ca2      	adds	r2, r4, #2
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 800cbf8:	b2db      	uxtb	r3, r3
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 800cbfa:	b2d2      	uxtb	r2, r2
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 800cbfc:	5ceb      	ldrb	r3, [r5, r3]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 800cbfe:	5caa      	ldrb	r2, [r5, r2]
                frequency = ( uint32_t )payload[macIndex++];
 800cc00:	f815 1009 	ldrb.w	r1, [r5, r9]
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 800cc04:	041b      	lsls	r3, r3, #16
 800cc06:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800cc0a:	1d22      	adds	r2, r4, #4
 800cc0c:	b2d2      	uxtb	r2, r2
 800cc0e:	430b      	orrs	r3, r1
                datarate = payload[macIndex++] & 0x0F;
 800cc10:	5ca8      	ldrb	r0, [r5, r2]
                frequency *= 100;
 800cc12:	2164      	movs	r1, #100	@ 0x64
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 800cc14:	fb03 f101 	mul.w	r1, r3, r1
 800cc18:	f000 000f 	and.w	r0, r0, #15
 800cc1c:	f002 fea8 	bl	800f970 <LoRaMacClassBPingSlotChannelReq>
                datarate = payload[macIndex++] & 0x0F;
 800cc20:	3405      	adds	r4, #5
                macCmdPayload[0] = status;
 800cc22:	f88d 0010 	strb.w	r0, [sp, #16]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 800cc26:	2201      	movs	r2, #1
 800cc28:	a904      	add	r1, sp, #16
 800cc2a:	2011      	movs	r0, #17
                datarate = payload[macIndex++] & 0x0F;
 800cc2c:	b2e4      	uxtb	r4, r4
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 800cc2e:	f002 febd 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800cc32:	e7d2      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 800cc34:	200a      	movs	r0, #10
 800cc36:	f003 f8b9 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800cc3a:	2800      	cmp	r0, #0
 800cc3c:	d0d8      	beq.n	800cbf0 <ProcessMacCommands.constprop.0+0xa8>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 800cc3e:	210a      	movs	r1, #10
 800cc40:	2000      	movs	r0, #0
 800cc42:	f003 f857 	bl	800fcf4 <LoRaMacConfirmQueueSetStatus>
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 800cc46:	1ce3      	adds	r3, r4, #3
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 800cc48:	b2db      	uxtb	r3, r3
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 800cc4a:	1ca2      	adds	r2, r4, #2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 800cc4c:	b2d2      	uxtb	r2, r2
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 800cc4e:	f815 1009 	ldrb.w	r1, [r5, r9]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 800cc52:	f815 9003 	ldrb.w	r9, [r5, r3]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 800cc56:	5caa      	ldrb	r2, [r5, r2]
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 800cc58:	f8df b328 	ldr.w	fp, [pc, #808]	@ 800cf84 <ProcessMacCommands.constprop.0+0x43c>
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 800cc5c:	ea4f 4909 	mov.w	r9, r9, lsl #16
 800cc60:	ea49 2902 	orr.w	r9, r9, r2, lsl #8
 800cc64:	1d22      	adds	r2, r4, #4
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 800cc66:	1d63      	adds	r3, r4, #5
 800cc68:	b2d2      	uxtb	r2, r2
 800cc6a:	b2db      	uxtb	r3, r3
 800cc6c:	5caa      	ldrb	r2, [r5, r2]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 800cc6e:	5ceb      	ldrb	r3, [r5, r3]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 800cc70:	ea49 0901 	orr.w	r9, r9, r1
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 800cc74:	ea49 6902 	orr.w	r9, r9, r2, lsl #24
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 800cc78:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800cc7c:	fb02 f303 	mul.w	r3, r2, r3
 800cc80:	121b      	asrs	r3, r3, #8
                    sysTimeCurrent = SysTimeGet( );
 800cc82:	f10d 0a28 	add.w	sl, sp, #40	@ 0x28
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 800cc86:	f8ad 301c 	strh.w	r3, [sp, #28]
                    sysTimeCurrent = SysTimeGet( );
 800cc8a:	4650      	mov	r0, sl
                    SysTime_t sysTime = { 0 };
 800cc8c:	2300      	movs	r3, #0
 800cc8e:	f8ad 301e 	strh.w	r3, [sp, #30]
                    sysTimeCurrent = SysTimeGet( );
 800cc92:	f008 f8bd 	bl	8014e10 <SysTimeGet>
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 800cc96:	4bbc      	ldr	r3, [pc, #752]	@ (800cf88 <ProcessMacCommands.constprop.0+0x440>)
 800cc98:	444b      	add	r3, r9
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 800cc9a:	9306      	str	r3, [sp, #24]
 800cc9c:	f8db 333c 	ldr.w	r3, [fp, #828]	@ 0x33c
 800cca0:	9300      	str	r3, [sp, #0]
 800cca2:	f10d 0918 	add.w	r9, sp, #24
 800cca6:	e899 0006 	ldmia.w	r9, {r1, r2}
 800ccaa:	f8db 3338 	ldr.w	r3, [fp, #824]	@ 0x338
 800ccae:	a808      	add	r0, sp, #32
 800ccb0:	f008 f86c 	bl	8014d8c <SysTimeSub>
 800ccb4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800ccb6:	9300      	str	r3, [sp, #0]
 800ccb8:	e89a 0006 	ldmia.w	sl, {r1, r2}
 800ccbc:	9b08      	ldr	r3, [sp, #32]
 800ccbe:	4648      	mov	r0, r9
 800ccc0:	f008 f848 	bl	8014d54 <SysTimeAdd>
                    SysTimeSet( sysTime );
 800ccc4:	e899 0003 	ldmia.w	r9, {r0, r1}
 800ccc8:	f008 f87c 	bl	8014dc4 <SysTimeSet>
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 800cccc:	3406      	adds	r4, #6
                    LoRaMacClassBDeviceTimeAns( );
 800ccce:	f002 fe53 	bl	800f978 <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 800ccd2:	2301      	movs	r3, #1
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 800ccd4:	b2e4      	uxtb	r4, r4
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 800ccd6:	f88b 3430 	strb.w	r3, [fp, #1072]	@ 0x430
 800ccda:	e77e      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                dlChannelReq.ChannelId = payload[macIndex++];
 800ccdc:	f815 3009 	ldrb.w	r3, [r5, r9]
 800cce0:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800cce4:	1d23      	adds	r3, r4, #4
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 800cce6:	1ce2      	adds	r2, r4, #3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800cce8:	b2db      	uxtb	r3, r3
 800ccea:	b2d2      	uxtb	r2, r2
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ccec:	5ceb      	ldrb	r3, [r5, r3]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800ccee:	5caa      	ldrb	r2, [r5, r2]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ccf0:	041b      	lsls	r3, r3, #16
 800ccf2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                dlChannelReq.ChannelId = payload[macIndex++];
 800ccf6:	1ca2      	adds	r2, r4, #2
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 800ccf8:	b2d2      	uxtb	r2, r2
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 800ccfa:	a90a      	add	r1, sp, #40	@ 0x28
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 800ccfc:	5caa      	ldrb	r2, [r5, r2]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ccfe:	4313      	orrs	r3, r2
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 800cd00:	4aa2      	ldr	r2, [pc, #648]	@ (800cf8c <ProcessMacCommands.constprop.0+0x444>)
 800cd02:	f892 0048 	ldrb.w	r0, [r2, #72]	@ 0x48
                dlChannelReq.Rx1Frequency *= 100;
 800cd06:	2264      	movs	r2, #100	@ 0x64
 800cd08:	fb02 f303 	mul.w	r3, r2, r3
 800cd0c:	930b      	str	r3, [sp, #44]	@ 0x2c
                status = 0x03;
 800cd0e:	2303      	movs	r3, #3
 800cd10:	f88d 300d 	strb.w	r3, [sp, #13]
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 800cd14:	f003 fe66 	bl	80109e4 <RegionDlChannelReq>
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800cd18:	3405      	adds	r4, #5
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 800cd1a:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 800cd1c:	2800      	cmp	r0, #0
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800cd1e:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 800cd20:	f88d 300d 	strb.w	r3, [sp, #13]
                if( ( int8_t )status >= 0 )
 800cd24:	f6ff af59 	blt.w	800cbda <ProcessMacCommands.constprop.0+0x92>
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 800cd28:	2201      	movs	r2, #1
 800cd2a:	a904      	add	r1, sp, #16
 800cd2c:	200a      	movs	r0, #10
                    macCmdPayload[0] = status;
 800cd2e:	f88d 3010 	strb.w	r3, [sp, #16]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 800cd32:	f002 fe3b 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800cd36:	e750      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 800cd38:	200d      	movs	r0, #13
 800cd3a:	f003 f837 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800cd3e:	2800      	cmp	r0, #0
 800cd40:	f43f af56 	beq.w	800cbf0 <ProcessMacCommands.constprop.0+0xa8>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 800cd44:	210d      	movs	r1, #13
 800cd46:	2000      	movs	r0, #0
 800cd48:	f002 ffd4 	bl	800fcf4 <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 800cd4c:	4b8d      	ldr	r3, [pc, #564]	@ (800cf84 <ProcessMacCommands.constprop.0+0x43c>)
 800cd4e:	f893 3480 	ldrb.w	r3, [r3, #1152]	@ 0x480
 800cd52:	3b04      	subs	r3, #4
 800cd54:	2b01      	cmp	r3, #1
 800cd56:	f67f af4b 	bls.w	800cbf0 <ProcessMacCommands.constprop.0+0xa8>
                        LoRaMacClassBPingSlotInfoAns( );
 800cd5a:	f002 fe07 	bl	800f96c <LoRaMacClassBPingSlotInfoAns>
        switch( payload[macIndex++] )
 800cd5e:	464c      	mov	r4, r9
 800cd60:	e73b      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                uint8_t eirpDwellTime = payload[macIndex++];
 800cd62:	f815 3009 	ldrb.w	r3, [r5, r9]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 800cd66:	f8df 9224 	ldr.w	r9, [pc, #548]	@ 800cf8c <ProcessMacCommands.constprop.0+0x444>
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 800cd6a:	f3c3 1100 	ubfx	r1, r3, #4, #1
 800cd6e:	f04f 0200 	mov.w	r2, #0
 800cd72:	f361 0207 	bfi	r2, r1, #0, #8
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 800cd76:	f3c3 1140 	ubfx	r1, r3, #5, #1
 800cd7a:	f361 220f 	bfi	r2, r1, #8, #8
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 800cd7e:	f003 030f 	and.w	r3, r3, #15
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 800cd82:	f899 0048 	ldrb.w	r0, [r9, #72]	@ 0x48
 800cd86:	f8ad 2014 	strh.w	r2, [sp, #20]
 800cd8a:	a905      	add	r1, sp, #20
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 800cd8c:	f88d 3016 	strb.w	r3, [sp, #22]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 800cd90:	f003 fe20 	bl	80109d4 <RegionTxParamSetupReq>
                uint8_t eirpDwellTime = payload[macIndex++];
 800cd94:	3402      	adds	r4, #2
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 800cd96:	3001      	adds	r0, #1
                uint8_t eirpDwellTime = payload[macIndex++];
 800cd98:	b2e4      	uxtb	r4, r4
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 800cd9a:	f43f af1e 	beq.w	800cbda <ProcessMacCommands.constprop.0+0x92>
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 800cd9e:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800cda2:	4a7b      	ldr	r2, [pc, #492]	@ (800cf90 <ProcessMacCommands.constprop.0+0x448>)
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 800cda4:	f8bd a014 	ldrh.w	sl, [sp, #20]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 800cda8:	5cd0      	ldrb	r0, [r2, r3]
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 800cdaa:	f8a9 a07c 	strh.w	sl, [r9, #124]	@ 0x7c
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 800cdae:	f7f3 fd0d 	bl	80007cc <__aeabi_ui2f>
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800cdb2:	a90a      	add	r1, sp, #40	@ 0x28
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 800cdb4:	f8c9 0080 	str.w	r0, [r9, #128]	@ 0x80
                    getPhy.Attribute = PHY_MIN_TX_DR;
 800cdb8:	2302      	movs	r3, #2
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800cdba:	f899 0048 	ldrb.w	r0, [r9, #72]	@ 0x48
                    getPhy.Attribute = PHY_MIN_TX_DR;
 800cdbe:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800cdc2:	f88d a02a 	strb.w	sl, [sp, #42]	@ 0x2a
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800cdc6:	f003 fd93 	bl	80108f0 <RegionGetPhyParam>
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 800cdca:	f999 3039 	ldrsb.w	r3, [r9, #57]	@ 0x39
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800cdce:	9006      	str	r0, [sp, #24]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 800cdd0:	b240      	sxtb	r0, r0
 800cdd2:	4298      	cmp	r0, r3
 800cdd4:	bfb8      	it	lt
 800cdd6:	4618      	movlt	r0, r3
 800cdd8:	f889 0039 	strb.w	r0, [r9, #57]	@ 0x39
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 800cddc:	2200      	movs	r2, #0
 800cdde:	a904      	add	r1, sp, #16
 800cde0:	2009      	movs	r0, #9
 800cde2:	f002 fde3 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800cde6:	e6f8      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                uint8_t delay = payload[macIndex++] & 0x0F;
 800cde8:	f815 3009 	ldrb.w	r3, [r5, r9]
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 800cdec:	f003 030f 	and.w	r3, r3, #15
 800cdf0:	2b01      	cmp	r3, #1
 800cdf2:	bf38      	it	cc
 800cdf4:	2301      	movcc	r3, #1
 800cdf6:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800cdfa:	fb02 f303 	mul.w	r3, r2, r3
 800cdfe:	4a63      	ldr	r2, [pc, #396]	@ (800cf8c <ProcessMacCommands.constprop.0+0x444>)
 800ce00:	6593      	str	r3, [r2, #88]	@ 0x58
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 800ce02:	f503 737a 	add.w	r3, r3, #1000	@ 0x3e8
 800ce06:	65d3      	str	r3, [r2, #92]	@ 0x5c
                uint8_t delay = payload[macIndex++] & 0x0F;
 800ce08:	3402      	adds	r4, #2
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 800ce0a:	2200      	movs	r2, #0
 800ce0c:	a904      	add	r1, sp, #16
 800ce0e:	2008      	movs	r0, #8
                uint8_t delay = payload[macIndex++] & 0x0F;
 800ce10:	b2e4      	uxtb	r4, r4
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 800ce12:	f002 fdcb 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800ce16:	e6e0      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                newChannelReq.ChannelId = payload[macIndex++];
 800ce18:	f815 3009 	ldrb.w	r3, [r5, r9]
 800ce1c:	f88d 301c 	strb.w	r3, [sp, #28]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800ce20:	1d23      	adds	r3, r4, #4
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 800ce22:	1ce2      	adds	r2, r4, #3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ce24:	b2db      	uxtb	r3, r3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800ce26:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ce28:	5ceb      	ldrb	r3, [r5, r3]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800ce2a:	5caa      	ldrb	r2, [r5, r2]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ce2c:	041b      	lsls	r3, r3, #16
 800ce2e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                newChannelReq.ChannelId = payload[macIndex++];
 800ce32:	1ca2      	adds	r2, r4, #2
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 800ce34:	b2d2      	uxtb	r2, r2
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 800ce36:	a906      	add	r1, sp, #24
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 800ce38:	5caa      	ldrb	r2, [r5, r2]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ce3a:	4313      	orrs	r3, r2
 800ce3c:	1d62      	adds	r2, r4, #5
 800ce3e:	b2d2      	uxtb	r2, r2
                chParam.DrRange.Value = payload[macIndex++];
 800ce40:	3406      	adds	r4, #6
 800ce42:	5caa      	ldrb	r2, [r5, r2]
 800ce44:	f88d 2030 	strb.w	r2, [sp, #48]	@ 0x30
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 800ce48:	4a50      	ldr	r2, [pc, #320]	@ (800cf8c <ProcessMacCommands.constprop.0+0x444>)
 800ce4a:	f892 0048 	ldrb.w	r0, [r2, #72]	@ 0x48
                chParam.Frequency *= 100;
 800ce4e:	2264      	movs	r2, #100	@ 0x64
 800ce50:	fb02 f303 	mul.w	r3, r2, r3
 800ce54:	930a      	str	r3, [sp, #40]	@ 0x28
                status = 0x03;
 800ce56:	2303      	movs	r3, #3
 800ce58:	f88d 300d 	strb.w	r3, [sp, #13]
                newChannelReq.NewChannel = &chParam;
 800ce5c:	ab0a      	add	r3, sp, #40	@ 0x28
 800ce5e:	9306      	str	r3, [sp, #24]
                chParam.Rx1Frequency = 0;
 800ce60:	2300      	movs	r3, #0
 800ce62:	930b      	str	r3, [sp, #44]	@ 0x2c
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 800ce64:	f003 fdae 	bl	80109c4 <RegionNewChannelReq>
 800ce68:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 800ce6a:	2800      	cmp	r0, #0
                chParam.DrRange.Value = payload[macIndex++];
 800ce6c:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 800ce6e:	f88d 300d 	strb.w	r3, [sp, #13]
                if( ( int8_t )status >= 0 )
 800ce72:	f6ff aeb2 	blt.w	800cbda <ProcessMacCommands.constprop.0+0x92>
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 800ce76:	2201      	movs	r2, #1
 800ce78:	a904      	add	r1, sp, #16
 800ce7a:	2007      	movs	r0, #7
                    macCmdPayload[0] = status;
 800ce7c:	f88d 3010 	strb.w	r3, [sp, #16]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 800ce80:	f002 fd94 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800ce84:	e6a9      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 800ce86:	4b3f      	ldr	r3, [pc, #252]	@ (800cf84 <ProcessMacCommands.constprop.0+0x43c>)
 800ce88:	f8d3 3348 	ldr.w	r3, [r3, #840]	@ 0x348
 800ce8c:	2b00      	cmp	r3, #0
 800ce8e:	f000 8098 	beq.w	800cfc2 <ProcessMacCommands.constprop.0+0x47a>
 800ce92:	681b      	ldr	r3, [r3, #0]
 800ce94:	2b00      	cmp	r3, #0
 800ce96:	f000 8094 	beq.w	800cfc2 <ProcessMacCommands.constprop.0+0x47a>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 800ce9a:	4798      	blx	r3
                macCmdPayload[0] = batteryLevel;
 800ce9c:	f88d 0010 	strb.w	r0, [sp, #16]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 800cea0:	f008 033f 	and.w	r3, r8, #63	@ 0x3f
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 800cea4:	2202      	movs	r2, #2
 800cea6:	a904      	add	r1, sp, #16
 800cea8:	2006      	movs	r0, #6
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 800ceaa:	f88d 3011 	strb.w	r3, [sp, #17]
        switch( payload[macIndex++] )
 800ceae:	464c      	mov	r4, r9
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 800ceb0:	f002 fd7c 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800ceb4:	e691      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800ceb6:	1d23      	adds	r3, r4, #4
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 800ceb8:	1ce1      	adds	r1, r4, #3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800ceba:	b2db      	uxtb	r3, r3
 800cebc:	b2c9      	uxtb	r1, r1
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800cebe:	5ceb      	ldrb	r3, [r5, r3]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 800cec0:	5c69      	ldrb	r1, [r5, r1]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 800cec2:	f815 2009 	ldrb.w	r2, [r5, r9]
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 800cec6:	f8df 90c4 	ldr.w	r9, [pc, #196]	@ 800cf8c <ProcessMacCommands.constprop.0+0x444>
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ceca:	041b      	lsls	r3, r3, #16
 800cecc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                macIndex++;
 800ced0:	1ca1      	adds	r1, r4, #2
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 800ced2:	b2c9      	uxtb	r1, r1
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 800ced4:	f899 0048 	ldrb.w	r0, [r9, #72]	@ 0x48
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 800ced8:	5c69      	ldrb	r1, [r5, r1]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800ceda:	430b      	orrs	r3, r1
                rxParamSetupReq.Frequency *= 100;
 800cedc:	2164      	movs	r1, #100	@ 0x64
 800cede:	fb01 f303 	mul.w	r3, r1, r3
 800cee2:	930b      	str	r3, [sp, #44]	@ 0x2c
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 800cee4:	f3c2 1302 	ubfx	r3, r2, #4, #3
 800cee8:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 800ceec:	f002 020f 	and.w	r2, r2, #15
                status = 0x07;
 800cef0:	2307      	movs	r3, #7
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 800cef2:	a90a      	add	r1, sp, #40	@ 0x28
                status = 0x07;
 800cef4:	f88d 300d 	strb.w	r3, [sp, #13]
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 800cef8:	f88d 2028 	strb.w	r2, [sp, #40]	@ 0x28
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 800cefc:	f003 fd5a 	bl	80109b4 <RegionRxParamSetupReq>
                if( ( status & 0x07 ) == 0x07 )
 800cf00:	f000 0307 	and.w	r3, r0, #7
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800cf04:	3405      	adds	r4, #5
                if( ( status & 0x07 ) == 0x07 )
 800cf06:	2b07      	cmp	r3, #7
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 800cf08:	b2e4      	uxtb	r4, r4
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 800cf0a:	f88d 000d 	strb.w	r0, [sp, #13]
                if( ( status & 0x07 ) == 0x07 )
 800cf0e:	d10e      	bne.n	800cf2e <ProcessMacCommands.constprop.0+0x3e6>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 800cf10:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 800cf14:	f889 3070 	strb.w	r3, [r9, #112]	@ 0x70
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 800cf18:	f889 3078 	strb.w	r3, [r9, #120]	@ 0x78
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 800cf1c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800cf1e:	f8c9 306c 	str.w	r3, [r9, #108]	@ 0x6c
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 800cf22:	f8c9 3074 	str.w	r3, [r9, #116]	@ 0x74
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 800cf26:	f89d 3029 	ldrb.w	r3, [sp, #41]	@ 0x29
 800cf2a:	f889 3069 	strb.w	r3, [r9, #105]	@ 0x69
                macCmdPayload[0] = status;
 800cf2e:	f88d 0010 	strb.w	r0, [sp, #16]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 800cf32:	2201      	movs	r2, #1
 800cf34:	a904      	add	r1, sp, #16
 800cf36:	2005      	movs	r0, #5
 800cf38:	f002 fd38 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800cf3c:	e64d      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 800cf3e:	f815 3009 	ldrb.w	r3, [r5, r9]
 800cf42:	4912      	ldr	r1, [pc, #72]	@ (800cf8c <ProcessMacCommands.constprop.0+0x444>)
 800cf44:	f003 030f 	and.w	r3, r3, #15
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 800cf48:	2201      	movs	r2, #1
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 800cf4a:	f881 311b 	strb.w	r3, [r1, #283]	@ 0x11b
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 800cf4e:	fa02 f303 	lsl.w	r3, r2, r3
 800cf52:	f8a1 311e 	strh.w	r3, [r1, #286]	@ 0x11e
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 800cf56:	3402      	adds	r4, #2
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 800cf58:	2200      	movs	r2, #0
 800cf5a:	a904      	add	r1, sp, #16
 800cf5c:	2004      	movs	r0, #4
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 800cf5e:	b2e4      	uxtb	r4, r4
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 800cf60:	f002 fd24 	bl	800f9ac <LoRaMacCommandsAddCmd>
                break;
 800cf64:	e639      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                int8_t linkAdrDatarate = DR_0;
 800cf66:	2300      	movs	r3, #0
 800cf68:	f88d 300e 	strb.w	r3, [sp, #14]
                int8_t linkAdrTxPower = TX_POWER_0;
 800cf6c:	f88d 300f 	strb.w	r3, [sp, #15]
                uint8_t linkAdrNbRep = 0;
 800cf70:	f88d 3014 	strb.w	r3, [sp, #20]
                uint8_t linkAdrNbBytesParsed = 0;
 800cf74:	f88d 3018 	strb.w	r3, [sp, #24]
                if( adrBlockFound == false )
 800cf78:	2f00      	cmp	r7, #0
 800cf7a:	d039      	beq.n	800cff0 <ProcessMacCommands.constprop.0+0x4a8>
                break;
 800cf7c:	464c      	mov	r4, r9
 800cf7e:	2701      	movs	r7, #1
 800cf80:	e62b      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
 800cf82:	bf00      	nop
 800cf84:	20000dec 	.word	0x20000dec
 800cf88:	12d53d80 	.word	0x12d53d80
 800cf8c:	20000684 	.word	0x20000684
 800cf90:	080174cc 	.word	0x080174cc
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 800cf94:	2005      	movs	r0, #5
 800cf96:	f002 ff09 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800cf9a:	2800      	cmp	r0, #0
 800cf9c:	f43f ae28 	beq.w	800cbf0 <ProcessMacCommands.constprop.0+0xa8>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 800cfa0:	2105      	movs	r1, #5
 800cfa2:	2000      	movs	r0, #0
 800cfa4:	f002 fea6 	bl	800fcf4 <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 800cfa8:	4a3e      	ldr	r2, [pc, #248]	@ (800d0a4 <ProcessMacCommands.constprop.0+0x55c>)
 800cfaa:	f815 3009 	ldrb.w	r3, [r5, r9]
 800cfae:	f882 3450 	strb.w	r3, [r2, #1104]	@ 0x450
 800cfb2:	1ca3      	adds	r3, r4, #2
 800cfb4:	b2db      	uxtb	r3, r3
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 800cfb6:	3403      	adds	r4, #3
 800cfb8:	5ceb      	ldrb	r3, [r5, r3]
 800cfba:	f882 3451 	strb.w	r3, [r2, #1105]	@ 0x451
 800cfbe:	b2e4      	uxtb	r4, r4
 800cfc0:	e60b      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 800cfc2:	20ff      	movs	r0, #255	@ 0xff
 800cfc4:	e76a      	b.n	800ce9c <ProcessMacCommands.constprop.0+0x354>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 800cfc6:	210e      	movs	r1, #14
 800cfc8:	2000      	movs	r0, #0
 800cfca:	f002 fe93 	bl	800fcf4 <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 800cfce:	1ca3      	adds	r3, r4, #2
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 800cfd0:	b2db      	uxtb	r3, r3
 800cfd2:	f815 2009 	ldrb.w	r2, [r5, r9]
 800cfd6:	5ce8      	ldrb	r0, [r5, r3]
 800cfd8:	1ce3      	adds	r3, r4, #3
 800cfda:	b2db      	uxtb	r3, r3
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 800cfdc:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 800cfe0:	5ce9      	ldrb	r1, [r5, r3]
 800cfe2:	4b31      	ldr	r3, [pc, #196]	@ (800d0a8 <ProcessMacCommands.constprop.0+0x560>)
                    beaconTimingChannel = payload[macIndex++];
 800cfe4:	3404      	adds	r4, #4
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 800cfe6:	681a      	ldr	r2, [r3, #0]
                    beaconTimingChannel = payload[macIndex++];
 800cfe8:	b2e4      	uxtb	r4, r4
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 800cfea:	f002 fcc3 	bl	800f974 <LoRaMacClassBBeaconTimingAns>
 800cfee:	e5f4      	b.n	800cbda <ProcessMacCommands.constprop.0+0x92>
                    linkAdrReq.Payload = &payload[macIndex - 1];
 800cff0:	f109 33ff 	add.w	r3, r9, #4294967295
 800cff4:	442b      	add	r3, r5
 800cff6:	930b      	str	r3, [sp, #44]	@ 0x2c
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 800cff8:	1b33      	subs	r3, r6, r4
 800cffa:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 800cffe:	ab06      	add	r3, sp, #24
 800d000:	9301      	str	r3, [sp, #4]
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 800d002:	4f2a      	ldr	r7, [pc, #168]	@ (800d0ac <ProcessMacCommands.constprop.0+0x564>)
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 800d004:	ab05      	add	r3, sp, #20
 800d006:	9300      	str	r3, [sp, #0]
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 800d008:	f897 311a 	ldrb.w	r3, [r7, #282]	@ 0x11a
 800d00c:	f88d 3032 	strb.w	r3, [sp, #50]	@ 0x32
                    linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800d010:	f897 307c 	ldrb.w	r3, [r7, #124]	@ 0x7c
 800d014:	f88d 3031 	strb.w	r3, [sp, #49]	@ 0x31
                    linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 800d018:	f897 3039 	ldrb.w	r3, [r7, #57]	@ 0x39
 800d01c:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
                    linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 800d020:	f897 3038 	ldrb.w	r3, [r7, #56]	@ 0x38
 800d024:	f88d 3034 	strb.w	r3, [sp, #52]	@ 0x34
                    linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 800d028:	f897 3068 	ldrb.w	r3, [r7, #104]	@ 0x68
 800d02c:	f88d 3035 	strb.w	r3, [sp, #53]	@ 0x35
                    linkAdrReq.Version = Nvm.MacGroup2.Version;
 800d030:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 800d034:	930a      	str	r3, [sp, #40]	@ 0x28
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 800d036:	f897 0048 	ldrb.w	r0, [r7, #72]	@ 0x48
 800d03a:	f10d 030f 	add.w	r3, sp, #15
 800d03e:	f10d 020e 	add.w	r2, sp, #14
 800d042:	a90a      	add	r1, sp, #40	@ 0x28
 800d044:	f003 fca4 	bl	8010990 <RegionLinkAdrReq>
 800d048:	f88d 000d 	strb.w	r0, [sp, #13]
                    if( ( status & 0x07 ) == 0x07 )
 800d04c:	f000 0007 	and.w	r0, r0, #7
 800d050:	2807      	cmp	r0, #7
 800d052:	d019      	beq.n	800d088 <ProcessMacCommands.constprop.0+0x540>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 800d054:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800d058:	2b04      	cmp	r3, #4
 800d05a:	d911      	bls.n	800d080 <ProcessMacCommands.constprop.0+0x538>
 800d05c:	f8df 9050 	ldr.w	r9, [pc, #80]	@ 800d0b0 <ProcessMacCommands.constprop.0+0x568>
 800d060:	2700      	movs	r7, #0
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 800d062:	2201      	movs	r2, #1
 800d064:	f10d 010d 	add.w	r1, sp, #13
 800d068:	2003      	movs	r0, #3
 800d06a:	f002 fc9f 	bl	800f9ac <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 800d06e:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800d072:	3701      	adds	r7, #1
 800d074:	b2fa      	uxtb	r2, r7
 800d076:	fba9 0103 	umull	r0, r1, r9, r3
 800d07a:	ebb2 0f91 	cmp.w	r2, r1, lsr #2
 800d07e:	d3f0      	bcc.n	800d062 <ProcessMacCommands.constprop.0+0x51a>
                    macIndex += linkAdrNbBytesParsed - 1;
 800d080:	4423      	add	r3, r4
 800d082:	fa5f f983 	uxtb.w	r9, r3
 800d086:	e779      	b.n	800cf7c <ProcessMacCommands.constprop.0+0x434>
                        Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 800d088:	f89d 300e 	ldrb.w	r3, [sp, #14]
 800d08c:	f887 3039 	strb.w	r3, [r7, #57]	@ 0x39
                        Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 800d090:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800d094:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
                        Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 800d098:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800d09c:	f887 3068 	strb.w	r3, [r7, #104]	@ 0x68
 800d0a0:	e7d8      	b.n	800d054 <ProcessMacCommands.constprop.0+0x50c>
 800d0a2:	bf00      	nop
 800d0a4:	20000dec 	.word	0x20000dec
 800d0a8:	2000066c 	.word	0x2000066c
 800d0ac:	20000684 	.word	0x20000684
 800d0b0:	cccccccd 	.word	0xcccccccd

0800d0b4 <OnRxWindow1TimerEvent>:
{
 800d0b4:	b570      	push	{r4, r5, r6, lr}
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 800d0b6:	4d18      	ldr	r5, [pc, #96]	@ (800d118 <OnRxWindow1TimerEvent+0x64>)
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 800d0b8:	4c18      	ldr	r4, [pc, #96]	@ (800d11c <OnRxWindow1TimerEvent+0x68>)
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 800d0ba:	f895 3069 	ldrb.w	r3, [r5, #105]	@ 0x69
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 800d0be:	f894 2411 	ldrb.w	r2, [r4, #1041]	@ 0x411
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 800d0c2:	f884 33bb 	strb.w	r3, [r4, #955]	@ 0x3bb
    Radio.Standby( );
 800d0c6:	4e16      	ldr	r6, [pc, #88]	@ (800d120 <OnRxWindow1TimerEvent+0x6c>)
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 800d0c8:	f895 308c 	ldrb.w	r3, [r5, #140]	@ 0x8c
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 800d0cc:	f884 23b8 	strb.w	r2, [r4, #952]	@ 0x3b8
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 800d0d0:	f884 33c9 	strb.w	r3, [r4, #969]	@ 0x3c9
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800d0d4:	f895 207d 	ldrb.w	r2, [r5, #125]	@ 0x7d
 800d0d8:	f884 23c8 	strb.w	r2, [r4, #968]	@ 0x3c8
    MacCtx.RxWindow1Config.RxContinuous = false;
 800d0dc:	2300      	movs	r3, #0
    TimerStop( rxTimer );
 800d0de:	f504 7060 	add.w	r0, r4, #896	@ 0x380
    MacCtx.RxWindow1Config.RxContinuous = false;
 800d0e2:	f8a4 33ca 	strh.w	r3, [r4, #970]	@ 0x3ca
    TimerStop( rxTimer );
 800d0e6:	f008 fb01 	bl	80156ec <UTIL_TIMER_Stop>
    Radio.Standby( );
 800d0ea:	6b33      	ldr	r3, [r6, #48]	@ 0x30
 800d0ec:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800d0ee:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
 800d0f2:	f204 421c 	addw	r2, r4, #1052	@ 0x41c
 800d0f6:	f504 716e 	add.w	r1, r4, #952	@ 0x3b8
 800d0fa:	f003 fc35 	bl	8010968 <RegionRxConfig>
 800d0fe:	b150      	cbz	r0, 800d116 <OnRxWindow1TimerEvent+0x62>
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800d100:	f894 241c 	ldrb.w	r2, [r4, #1052]	@ 0x41c
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 800d104:	6b73      	ldr	r3, [r6, #52]	@ 0x34
 800d106:	6d68      	ldr	r0, [r5, #84]	@ 0x54
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800d108:	f884 245e 	strb.w	r2, [r4, #1118]	@ 0x45e
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 800d10c:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 800d10e:	f894 33cb 	ldrb.w	r3, [r4, #971]	@ 0x3cb
 800d112:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
}
 800d116:	bd70      	pop	{r4, r5, r6, pc}
 800d118:	20000684 	.word	0x20000684
 800d11c:	20000dec 	.word	0x20000dec
 800d120:	08017658 	.word	0x08017658

0800d124 <PrepareRxDoneAbort>:
{
 800d124:	b538      	push	{r3, r4, r5, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 800d126:	4c31      	ldr	r4, [pc, #196]	@ (800d1ec <PrepareRxDoneAbort+0xc8>)
 800d128:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
    if( MacCtx.NodeAckRequested == true )
 800d12c:	f894 2410 	ldrb.w	r2, [r4, #1040]	@ 0x410
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 800d130:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800d134:	f8c4 3340 	str.w	r3, [r4, #832]	@ 0x340
    if( MacCtx.NodeAckRequested == true )
 800d138:	b982      	cbnz	r2, 800d15c <PrepareRxDoneAbort+0x38>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800d13a:	4b2d      	ldr	r3, [pc, #180]	@ (800d1f0 <PrepareRxDoneAbort+0xcc>)
 800d13c:	f893 2118 	ldrb.w	r2, [r3, #280]	@ 0x118
    MacCtx.MacFlags.Bits.McpsInd = 1;
 800d140:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800d144:	f023 0312 	bic.w	r3, r3, #18
 800d148:	f043 0312 	orr.w	r3, r3, #18
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800d14c:	2a02      	cmp	r2, #2
    MacCtx.MacFlags.Bits.McpsInd = 1;
 800d14e:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800d152:	d01f      	beq.n	800d194 <PrepareRxDoneAbort+0x70>
        MacCtx.RxSlot = RX_SLOT_NONE;
 800d154:	2306      	movs	r3, #6
 800d156:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
}
 800d15a:	bd38      	pop	{r3, r4, r5, pc}
    TimerStop( &MacCtx.AckTimeoutTimer );
 800d15c:	f504 707d 	add.w	r0, r4, #1012	@ 0x3f4
 800d160:	f008 fac4 	bl	80156ec <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 800d164:	f894 3410 	ldrb.w	r3, [r4, #1040]	@ 0x410
 800d168:	b9c3      	cbnz	r3, 800d19c <PrepareRxDoneAbort+0x78>
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800d16a:	4d21      	ldr	r5, [pc, #132]	@ (800d1f0 <PrepareRxDoneAbort+0xcc>)
 800d16c:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800d170:	2b02      	cmp	r3, #2
 800d172:	d01b      	beq.n	800d1ac <PrepareRxDoneAbort+0x88>
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800d174:	f8d4 3348 	ldr.w	r3, [r4, #840]	@ 0x348
 800d178:	b373      	cbz	r3, 800d1d8 <PrepareRxDoneAbort+0xb4>
 800d17a:	695b      	ldr	r3, [r3, #20]
 800d17c:	b363      	cbz	r3, 800d1d8 <PrepareRxDoneAbort+0xb4>
        MacCtx.MacCallbacks->MacProcessNotify( );
 800d17e:	4798      	blx	r3
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800d180:	f895 2118 	ldrb.w	r2, [r5, #280]	@ 0x118
 800d184:	e7dc      	b.n	800d140 <PrepareRxDoneAbort+0x1c>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 800d186:	b2db      	uxtb	r3, r3
 800d188:	f023 0312 	bic.w	r3, r3, #18
 800d18c:	f043 0312 	orr.w	r3, r3, #18
 800d190:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
 800d194:	2302      	movs	r3, #2
 800d196:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
}
 800d19a:	bd38      	pop	{r3, r4, r5, pc}
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800d19c:	4d14      	ldr	r5, [pc, #80]	@ (800d1f0 <PrepareRxDoneAbort+0xcc>)
        MacCtx.AckTimeoutRetry = true;
 800d19e:	2301      	movs	r3, #1
 800d1a0:	f884 340f 	strb.w	r3, [r4, #1039]	@ 0x40f
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800d1a4:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800d1a8:	2b02      	cmp	r3, #2
 800d1aa:	d1e3      	bne.n	800d174 <PrepareRxDoneAbort+0x50>
        MacCtx.MacFlags.Bits.MacDone = 1;
 800d1ac:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800d1b0:	f8d4 2348 	ldr.w	r2, [r4, #840]	@ 0x348
        MacCtx.MacFlags.Bits.MacDone = 1;
 800d1b4:	f043 0310 	orr.w	r3, r3, #16
 800d1b8:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800d1bc:	2a00      	cmp	r2, #0
 800d1be:	d0e2      	beq.n	800d186 <PrepareRxDoneAbort+0x62>
 800d1c0:	6953      	ldr	r3, [r2, #20]
 800d1c2:	2b00      	cmp	r3, #0
 800d1c4:	d1db      	bne.n	800d17e <PrepareRxDoneAbort+0x5a>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 800d1c6:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800d1ca:	f023 0312 	bic.w	r3, r3, #18
 800d1ce:	f043 0312 	orr.w	r3, r3, #18
 800d1d2:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800d1d6:	e7dd      	b.n	800d194 <PrepareRxDoneAbort+0x70>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 800d1d8:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800d1dc:	f023 0312 	bic.w	r3, r3, #18
 800d1e0:	f043 0312 	orr.w	r3, r3, #18
 800d1e4:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800d1e8:	e7b4      	b.n	800d154 <PrepareRxDoneAbort+0x30>
 800d1ea:	bf00      	nop
 800d1ec:	20000dec 	.word	0x20000dec
 800d1f0:	20000684 	.word	0x20000684

0800d1f4 <ScheduleTx>:
{
 800d1f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d1f8:	b092      	sub	sp, #72	@ 0x48
 800d1fa:	4606      	mov	r6, r0
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 800d1fc:	f002 fba2 	bl	800f944 <LoRaMacClassBIsBeaconExpected>
 800d200:	2800      	cmp	r0, #0
 800d202:	d17c      	bne.n	800d2fe <ScheduleTx+0x10a>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800d204:	4cbf      	ldr	r4, [pc, #764]	@ (800d504 <ScheduleTx+0x310>)
 800d206:	f894 3118 	ldrb.w	r3, [r4, #280]	@ 0x118
 800d20a:	2b01      	cmp	r3, #1
 800d20c:	f000 8137 	beq.w	800d47e <ScheduleTx+0x28a>
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 800d210:	6b23      	ldr	r3, [r4, #48]	@ 0x30
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 800d212:	4dbd      	ldr	r5, [pc, #756]	@ (800d508 <ScheduleTx+0x314>)
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 800d214:	b93b      	cbnz	r3, 800d226 <ScheduleTx+0x32>
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 800d216:	f8b4 311e 	ldrh.w	r3, [r4, #286]	@ 0x11e
 800d21a:	f8d5 2414 	ldr.w	r2, [r5, #1044]	@ 0x414
 800d21e:	3b01      	subs	r3, #1
 800d220:	fb02 f303 	mul.w	r3, r2, r3
 800d224:	6323      	str	r3, [r4, #48]	@ 0x30
    switch( MacCtx.TxMsg.Type )
 800d226:	f895 3104 	ldrb.w	r3, [r5, #260]	@ 0x104
 800d22a:	2b00      	cmp	r3, #0
 800d22c:	d05c      	beq.n	800d2e8 <ScheduleTx+0xf4>
 800d22e:	2b04      	cmp	r3, #4
 800d230:	d003      	beq.n	800d23a <ScheduleTx+0x46>
            return LORAMAC_STATUS_PARAMETER_INVALID;
 800d232:	2003      	movs	r0, #3
}
 800d234:	b012      	add	sp, #72	@ 0x48
 800d236:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 800d23a:	f8df 92d0 	ldr.w	r9, [pc, #720]	@ 800d50c <ScheduleTx+0x318>
 800d23e:	4648      	mov	r0, r9
 800d240:	f003 fade 	bl	8010800 <LoRaMacSerializerData>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 800d244:	2800      	cmp	r0, #0
 800d246:	d156      	bne.n	800d2f6 <ScheduleTx+0x102>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 800d248:	f895 310c 	ldrb.w	r3, [r5, #268]	@ 0x10c
 800d24c:	802b      	strh	r3, [r5, #0]
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 800d24e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800d250:	930c      	str	r3, [sp, #48]	@ 0x30
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800d252:	f10d 0818 	add.w	r8, sp, #24
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800d256:	f894 3039 	ldrb.w	r3, [r4, #57]	@ 0x39
 800d25a:	f88d 3038 	strb.w	r3, [sp, #56]	@ 0x38
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800d25e:	4640      	mov	r0, r8
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 800d260:	f894 311c 	ldrb.w	r3, [r4, #284]	@ 0x11c
 800d264:	f88d 303a 	strb.w	r3, [sp, #58]	@ 0x3a
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800d268:	f007 fdf8 	bl	8014e5c <SysTimeGetMcuTime>
 800d26c:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
 800d270:	9300      	str	r3, [sp, #0]
 800d272:	af02      	add	r7, sp, #8
 800d274:	e898 0006 	ldmia.w	r8, {r1, r2}
 800d278:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
 800d27c:	4638      	mov	r0, r7
 800d27e:	f007 fd85 	bl	8014d8c <SysTimeSub>
 800d282:	e897 0003 	ldmia.w	r7, {r0, r1}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 800d286:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 800d288:	930d      	str	r3, [sp, #52]	@ 0x34
    nextChan.PktLen = MacCtx.PktBufferLen;
 800d28a:	882b      	ldrh	r3, [r5, #0]
 800d28c:	f8ad 3046 	strh.w	r3, [sp, #70]	@ 0x46
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800d290:	ab0f      	add	r3, sp, #60	@ 0x3c
 800d292:	e883 0003 	stmia.w	r3, {r0, r1}
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800d296:	f894 212c 	ldrb.w	r2, [r4, #300]	@ 0x12c
    nextChan.LastTxIsJoinRequest = false;
 800d29a:	2300      	movs	r3, #0
 800d29c:	f88d 3044 	strb.w	r3, [sp, #68]	@ 0x44
    nextChan.Joined = true;
 800d2a0:	2301      	movs	r3, #1
 800d2a2:	f88d 3039 	strb.w	r3, [sp, #57]	@ 0x39
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800d2a6:	b372      	cbz	r2, 800d306 <ScheduleTx+0x112>
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 800d2a8:	4b99      	ldr	r3, [pc, #612]	@ (800d510 <ScheduleTx+0x31c>)
 800d2aa:	9300      	str	r3, [sp, #0]
 800d2ac:	4b99      	ldr	r3, [pc, #612]	@ (800d514 <ScheduleTx+0x320>)
 800d2ae:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
 800d2b2:	f1a3 0273 	sub.w	r2, r3, #115	@ 0x73
 800d2b6:	a90c      	add	r1, sp, #48	@ 0x30
 800d2b8:	f003 fba6 	bl	8010a08 <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 800d2bc:	b340      	cbz	r0, 800d310 <ScheduleTx+0x11c>
        if( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED )
 800d2be:	280b      	cmp	r0, #11
 800d2c0:	d1b8      	bne.n	800d234 <ScheduleTx+0x40>
            if( MacCtx.DutyCycleWaitTime != 0 )
 800d2c2:	f8d5 1484 	ldr.w	r1, [r5, #1156]	@ 0x484
 800d2c6:	b319      	cbz	r1, 800d310 <ScheduleTx+0x11c>
                if( allowDelayedTx == true )
 800d2c8:	2e00      	cmp	r6, #0
 800d2ca:	d0b3      	beq.n	800d234 <ScheduleTx+0x40>
                    MacCtx.MacState |= LORAMAC_TX_DELAYED;
 800d2cc:	f8d5 3340 	ldr.w	r3, [r5, #832]	@ 0x340
                    TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 800d2d0:	4891      	ldr	r0, [pc, #580]	@ (800d518 <ScheduleTx+0x324>)
                    MacCtx.MacState |= LORAMAC_TX_DELAYED;
 800d2d2:	f043 0320 	orr.w	r3, r3, #32
 800d2d6:	f8c5 3340 	str.w	r3, [r5, #832]	@ 0x340
                    TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 800d2da:	f008 fa51 	bl	8015780 <UTIL_TIMER_SetPeriod>
                    TimerStart( &MacCtx.TxDelayedTimer );
 800d2de:	488e      	ldr	r0, [pc, #568]	@ (800d518 <ScheduleTx+0x324>)
 800d2e0:	f008 f9f2 	bl	80156c8 <UTIL_TIMER_Start>
                    return LORAMAC_STATUS_OK;
 800d2e4:	2000      	movs	r0, #0
 800d2e6:	e7a5      	b.n	800d234 <ScheduleTx+0x40>
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 800d2e8:	f8df 9220 	ldr.w	r9, [pc, #544]	@ 800d50c <ScheduleTx+0x318>
 800d2ec:	4648      	mov	r0, r9
 800d2ee:	f003 fa51 	bl	8010794 <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 800d2f2:	2800      	cmp	r0, #0
 800d2f4:	d0a8      	beq.n	800d248 <ScheduleTx+0x54>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 800d2f6:	2011      	movs	r0, #17
}
 800d2f8:	b012      	add	sp, #72	@ 0x48
 800d2fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 800d2fe:	200e      	movs	r0, #14
}
 800d300:	b012      	add	sp, #72	@ 0x48
 800d302:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nextChan.LastTxIsJoinRequest = true;
 800d306:	f88d 3044 	strb.w	r3, [sp, #68]	@ 0x44
        nextChan.Joined = false;
 800d30a:	f88d 2039 	strb.w	r2, [sp, #57]	@ 0x39
 800d30e:	e7cb      	b.n	800d2a8 <ScheduleTx+0xb4>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800d310:	f894 6048 	ldrb.w	r6, [r4, #72]	@ 0x48
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 800d314:	f994 3069 	ldrsb.w	r3, [r4, #105]	@ 0x69
 800d318:	f994 2039 	ldrsb.w	r2, [r4, #57]	@ 0x39
 800d31c:	f894 107d 	ldrb.w	r1, [r4, #125]	@ 0x7d
 800d320:	4630      	mov	r0, r6
 800d322:	f003 fb87 	bl	8010a34 <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800d326:	b241      	sxtb	r1, r0
 800d328:	4630      	mov	r0, r6
 800d32a:	4e7c      	ldr	r6, [pc, #496]	@ (800d51c <ScheduleTx+0x328>)
 800d32c:	9600      	str	r6, [sp, #0]
 800d32e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 800d330:	f894 2050 	ldrb.w	r2, [r4, #80]	@ 0x50
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800d334:	3614      	adds	r6, #20
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800d336:	f003 fb09 	bl	801094c <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800d33a:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 800d33c:	9600      	str	r6, [sp, #0]
 800d33e:	f894 2050 	ldrb.w	r2, [r4, #80]	@ 0x50
 800d342:	f994 1070 	ldrsb.w	r1, [r4, #112]	@ 0x70
 800d346:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
 800d34a:	f003 faff 	bl	801094c <RegionComputeRxWindowParameters>
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 800d34e:	f8d5 13c4 	ldr.w	r1, [r5, #964]	@ 0x3c4
 800d352:	6da3      	ldr	r3, [r4, #88]	@ 0x58
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 800d354:	f8d5 23d8 	ldr.w	r2, [r5, #984]	@ 0x3d8
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 800d358:	440b      	add	r3, r1
 800d35a:	f8c5 33b0 	str.w	r3, [r5, #944]	@ 0x3b0
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 800d35e:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800d360:	4413      	add	r3, r2
 800d362:	f8c5 33b4 	str.w	r3, [r5, #948]	@ 0x3b4
    if( MacCtx.TxMsg.Type != LORAMAC_MSG_TYPE_DATA )
 800d366:	f895 3104 	ldrb.w	r3, [r5, #260]	@ 0x104
 800d36a:	2b04      	cmp	r3, #4
 800d36c:	d007      	beq.n	800d37e <ScheduleTx+0x18a>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 800d36e:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 800d370:	440b      	add	r3, r1
 800d372:	f8c5 33b0 	str.w	r3, [r5, #944]	@ 0x3b0
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 800d376:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800d378:	4413      	add	r3, r2
 800d37a:	f8c5 33b4 	str.w	r3, [r5, #948]	@ 0x3b4
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 800d37e:	f894 312c 	ldrb.w	r3, [r4, #300]	@ 0x12c
    size_t macCmdsSize = 0;
 800d382:	2200      	movs	r2, #0
 800d384:	9204      	str	r2, [sp, #16]
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 800d386:	ae04      	add	r6, sp, #16
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 800d388:	2b00      	cmp	r3, #0
 800d38a:	f040 8082 	bne.w	800d492 <ScheduleTx+0x29e>
 800d38e:	af08      	add	r7, sp, #32
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800d390:	f894 3039 	ldrb.w	r3, [r4, #57]	@ 0x39
 800d394:	f88d 3021 	strb.w	r3, [sp, #33]	@ 0x21
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 800d398:	f894 3038 	ldrb.w	r3, [r4, #56]	@ 0x38
 800d39c:	f88d 3022 	strb.w	r3, [sp, #34]	@ 0x22
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 800d3a0:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 800d3a4:	9309      	str	r3, [sp, #36]	@ 0x24
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 800d3a6:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
 800d3aa:	930a      	str	r3, [sp, #40]	@ 0x28
    txConfig.PktLen = MacCtx.PktBufferLen;
 800d3ac:	882b      	ldrh	r3, [r5, #0]
 800d3ae:	f8ad 302c 	strh.w	r3, [sp, #44]	@ 0x2c
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 800d3b2:	4632      	mov	r2, r6
 800d3b4:	4b5a      	ldr	r3, [pc, #360]	@ (800d520 <ScheduleTx+0x32c>)
    return SendFrameOnChannel( MacCtx.Channel );
 800d3b6:	f895 6411 	ldrb.w	r6, [r5, #1041]	@ 0x411
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 800d3ba:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    txConfig.Channel = channel;
 800d3be:	f88d 6020 	strb.w	r6, [sp, #32]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 800d3c2:	4639      	mov	r1, r7
    int8_t txPower = 0;
 800d3c4:	2700      	movs	r7, #0
 800d3c6:	f88d 7010 	strb.w	r7, [sp, #16]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 800d3ca:	f003 fad7 	bl	801097c <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800d3ce:	2301      	movs	r3, #1
 800d3d0:	f885 3435 	strb.w	r3, [r5, #1077]	@ 0x435
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800d3d4:	f894 3039 	ldrb.w	r3, [r4, #57]	@ 0x39
 800d3d8:	f885 3436 	strb.w	r3, [r5, #1078]	@ 0x436
    MacCtx.McpsConfirm.TxPower = txPower;
 800d3dc:	f89d 3010 	ldrb.w	r3, [sp, #16]
 800d3e0:	f885 3437 	strb.w	r3, [r5, #1079]	@ 0x437
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 800d3e4:	f8d5 3414 	ldr.w	r3, [r5, #1044]	@ 0x414
    MacCtx.McpsConfirm.Channel = channel;
 800d3e8:	f8c5 6444 	str.w	r6, [r5, #1092]	@ 0x444
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 800d3ec:	f8c5 343c 	str.w	r3, [r5, #1084]	@ 0x43c
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 800d3f0:	f8c5 344c 	str.w	r3, [r5, #1100]	@ 0x44c
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 800d3f4:	f002 faac 	bl	800f950 <LoRaMacClassBIsBeaconModeActive>
 800d3f8:	2800      	cmp	r0, #0
 800d3fa:	d175      	bne.n	800d4e8 <ScheduleTx+0x2f4>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800d3fc:	f894 3118 	ldrb.w	r3, [r4, #280]	@ 0x118
 800d400:	2b01      	cmp	r3, #1
 800d402:	d079      	beq.n	800d4f8 <ScheduleTx+0x304>
    LoRaMacClassBHaltBeaconing( );
 800d404:	f002 faa8 	bl	800f958 <LoRaMacClassBHaltBeaconing>
    switch( MacCtx.TxMsg.Type )
 800d408:	f895 3104 	ldrb.w	r3, [r5, #260]	@ 0x104
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 800d40c:	f994 4039 	ldrsb.w	r4, [r4, #57]	@ 0x39
 800d410:	f895 6411 	ldrb.w	r6, [r5, #1041]	@ 0x411
    uint32_t fCntUp = 0;
 800d414:	2000      	movs	r0, #0
 800d416:	9005      	str	r0, [sp, #20]
    switch( MacCtx.TxMsg.Type )
 800d418:	2b00      	cmp	r3, #0
 800d41a:	d05d      	beq.n	800d4d8 <ScheduleTx+0x2e4>
 800d41c:	2b04      	cmp	r3, #4
 800d41e:	f47f af08 	bne.w	800d232 <ScheduleTx+0x3e>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 800d422:	a805      	add	r0, sp, #20
 800d424:	f002 fe76 	bl	8010114 <LoRaMacCryptoGetFCntUp>
 800d428:	2800      	cmp	r0, #0
 800d42a:	d168      	bne.n	800d4fe <ScheduleTx+0x30a>
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 800d42c:	f895 340c 	ldrb.w	r3, [r5, #1036]	@ 0x40c
                fCntUp -= 1;
 800d430:	9805      	ldr	r0, [sp, #20]
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 800d432:	b91b      	cbnz	r3, 800d43c <ScheduleTx+0x248>
 800d434:	f895 340e 	ldrb.w	r3, [r5, #1038]	@ 0x40e
 800d438:	2b01      	cmp	r3, #1
 800d43a:	d901      	bls.n	800d440 <ScheduleTx+0x24c>
                fCntUp -= 1;
 800d43c:	3801      	subs	r0, #1
 800d43e:	9005      	str	r0, [sp, #20]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 800d440:	4b32      	ldr	r3, [pc, #200]	@ (800d50c <ScheduleTx+0x318>)
 800d442:	4632      	mov	r2, r6
 800d444:	b2e1      	uxtb	r1, r4
 800d446:	f003 f805 	bl	8010454 <LoRaMacCryptoSecureMessage>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 800d44a:	2800      	cmp	r0, #0
 800d44c:	f47f af53 	bne.w	800d2f6 <ScheduleTx+0x102>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800d450:	f8d5 3340 	ldr.w	r3, [r5, #832]	@ 0x340
    if( MacCtx.NodeAckRequested == false )
 800d454:	f895 2410 	ldrb.w	r2, [r5, #1040]	@ 0x410
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 800d458:	f895 110c 	ldrb.w	r1, [r5, #268]	@ 0x10c
 800d45c:	8029      	strh	r1, [r5, #0]
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800d45e:	f043 0302 	orr.w	r3, r3, #2
 800d462:	f8c5 3340 	str.w	r3, [r5, #832]	@ 0x340
    if( MacCtx.NodeAckRequested == false )
 800d466:	b922      	cbnz	r2, 800d472 <ScheduleTx+0x27e>
        MacCtx.ChannelsNbTransCounter++;
 800d468:	f895 340c 	ldrb.w	r3, [r5, #1036]	@ 0x40c
 800d46c:	3301      	adds	r3, #1
 800d46e:	f885 340c 	strb.w	r3, [r5, #1036]	@ 0x40c
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 800d472:	4b2c      	ldr	r3, [pc, #176]	@ (800d524 <ScheduleTx+0x330>)
 800d474:	482c      	ldr	r0, [pc, #176]	@ (800d528 <ScheduleTx+0x334>)
 800d476:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800d478:	4798      	blx	r3
    return LORAMAC_STATUS_OK;
 800d47a:	2000      	movs	r0, #0
 800d47c:	e6da      	b.n	800d234 <ScheduleTx+0x40>
        if( LoRaMacClassBIsPingExpected( ) == true )
 800d47e:	f002 fa63 	bl	800f948 <LoRaMacClassBIsPingExpected>
 800d482:	b920      	cbnz	r0, 800d48e <ScheduleTx+0x29a>
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 800d484:	f002 fa62 	bl	800f94c <LoRaMacClassBIsMulticastExpected>
 800d488:	2800      	cmp	r0, #0
 800d48a:	f43f aec1 	beq.w	800d210 <ScheduleTx+0x1c>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 800d48e:	200f      	movs	r0, #15
 800d490:	e6d0      	b.n	800d234 <ScheduleTx+0x40>
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 800d492:	4630      	mov	r0, r6
 800d494:	f002 fb82 	bl	800fb9c <LoRaMacCommandsGetSizeSerializedCmds>
 800d498:	bb20      	cbnz	r0, 800d4e4 <ScheduleTx+0x2f0>
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 800d49a:	f894 308c 	ldrb.w	r3, [r4, #140]	@ 0x8c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800d49e:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 800d4a2:	f895 8237 	ldrb.w	r8, [r5, #567]	@ 0x237
 800d4a6:	f89d a010 	ldrb.w	sl, [sp, #16]
 800d4aa:	330d      	adds	r3, #13
 800d4ac:	f88d 3020 	strb.w	r3, [sp, #32]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800d4b0:	af08      	add	r7, sp, #32
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 800d4b2:	f994 3039 	ldrsb.w	r3, [r4, #57]	@ 0x39
    getPhy.Datarate = datarate;
 800d4b6:	f88d 3021 	strb.w	r3, [sp, #33]	@ 0x21
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800d4ba:	4639      	mov	r1, r7
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800d4bc:	f894 307c 	ldrb.w	r3, [r4, #124]	@ 0x7c
 800d4c0:	f88d 3022 	strb.w	r3, [sp, #34]	@ 0x22
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800d4c4:	f003 fa14 	bl	80108f0 <RegionGetPhyParam>
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 800d4c8:	44d0      	add	r8, sl
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800d4ca:	9005      	str	r0, [sp, #20]
    return phyParam.Value;
 800d4cc:	b2c0      	uxtb	r0, r0
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 800d4ce:	4540      	cmp	r0, r8
 800d4d0:	f4bf af5e 	bcs.w	800d390 <ScheduleTx+0x19c>
            return LORAMAC_STATUS_LENGTH_ERROR;
 800d4d4:	2008      	movs	r0, #8
 800d4d6:	e6ad      	b.n	800d234 <ScheduleTx+0x40>
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 800d4d8:	4648      	mov	r0, r9
 800d4da:	f002 febb 	bl	8010254 <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 800d4de:	2800      	cmp	r0, #0
 800d4e0:	d0b6      	beq.n	800d450 <ScheduleTx+0x25c>
 800d4e2:	e708      	b.n	800d2f6 <ScheduleTx+0x102>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 800d4e4:	2013      	movs	r0, #19
 800d4e6:	e6a5      	b.n	800d234 <ScheduleTx+0x40>
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 800d4e8:	f8d5 0414 	ldr.w	r0, [r5, #1044]	@ 0x414
 800d4ec:	f002 fa48 	bl	800f980 <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 800d4f0:	2800      	cmp	r0, #0
 800d4f2:	d083      	beq.n	800d3fc <ScheduleTx+0x208>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 800d4f4:	2010      	movs	r0, #16
    return SendFrameOnChannel( MacCtx.Channel );
 800d4f6:	e69d      	b.n	800d234 <ScheduleTx+0x40>
        LoRaMacClassBStopRxSlots( );
 800d4f8:	f002 fa44 	bl	800f984 <LoRaMacClassBStopRxSlots>
 800d4fc:	e782      	b.n	800d404 <ScheduleTx+0x210>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 800d4fe:	2012      	movs	r0, #18
 800d500:	e698      	b.n	800d234 <ScheduleTx+0x40>
 800d502:	bf00      	nop
 800d504:	20000684 	.word	0x20000684
 800d508:	20000dec 	.word	0x20000dec
 800d50c:	20000ef4 	.word	0x20000ef4
 800d510:	200006b4 	.word	0x200006b4
 800d514:	20001270 	.word	0x20001270
 800d518:	20001154 	.word	0x20001154
 800d51c:	200011a4 	.word	0x200011a4
 800d520:	20001200 	.word	0x20001200
 800d524:	08017658 	.word	0x08017658
 800d528:	20000dee 	.word	0x20000dee

0800d52c <OnTxDelayedTimerEvent>:
{
 800d52c:	b538      	push	{r3, r4, r5, lr}
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 800d52e:	4c1d      	ldr	r4, [pc, #116]	@ (800d5a4 <OnTxDelayedTimerEvent+0x78>)
    TimerStop( &MacCtx.TxDelayedTimer );
 800d530:	f504 705a 	add.w	r0, r4, #872	@ 0x368
 800d534:	f008 f8da 	bl	80156ec <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 800d538:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
    switch( ScheduleTx( true ) )
 800d53c:	2001      	movs	r0, #1
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 800d53e:	f023 0320 	bic.w	r3, r3, #32
 800d542:	f8c4 3340 	str.w	r3, [r4, #832]	@ 0x340
    switch( ScheduleTx( true ) )
 800d546:	f7ff fe55 	bl	800d1f4 <ScheduleTx>
 800d54a:	b108      	cbz	r0, 800d550 <OnTxDelayedTimerEvent+0x24>
 800d54c:	280b      	cmp	r0, #11
 800d54e:	d100      	bne.n	800d552 <OnTxDelayedTimerEvent+0x26>
}
 800d550:	bd38      	pop	{r3, r4, r5, pc}
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800d552:	4d15      	ldr	r5, [pc, #84]	@ (800d5a8 <OnTxDelayedTimerEvent+0x7c>)
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 800d554:	f894 340e 	ldrb.w	r3, [r4, #1038]	@ 0x40e
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800d558:	f895 2039 	ldrb.w	r2, [r5, #57]	@ 0x39
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 800d55c:	f884 3439 	strb.w	r3, [r4, #1081]	@ 0x439
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 800d560:	2009      	movs	r0, #9
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800d562:	f884 2436 	strb.w	r2, [r4, #1078]	@ 0x436
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 800d566:	f884 0435 	strb.w	r0, [r4, #1077]	@ 0x435
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 800d56a:	f002 fbfd 	bl	800fd68 <LoRaMacConfirmQueueSetStatusCmn>
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 800d56e:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800d572:	079b      	lsls	r3, r3, #30
 800d574:	d411      	bmi.n	800d59a <OnTxDelayedTimerEvent+0x6e>
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 800d576:	f895 311a 	ldrb.w	r3, [r5, #282]	@ 0x11a
 800d57a:	b113      	cbz	r3, 800d582 <OnTxDelayedTimerEvent+0x56>
            Nvm.MacGroup1.AdrAckCounter++;
 800d57c:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 800d57e:	3301      	adds	r3, #1
 800d580:	62ab      	str	r3, [r5, #40]	@ 0x28
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800d582:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
    MacCtx.ChannelsNbTransCounter = 0;
 800d586:	2200      	movs	r2, #0
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800d588:	f023 0302 	bic.w	r3, r3, #2
    MacCtx.ChannelsNbTransCounter = 0;
 800d58c:	f884 240c 	strb.w	r2, [r4, #1036]	@ 0x40c
    MacCtx.AckTimeoutRetry = false;
 800d590:	f8a4 240f 	strh.w	r2, [r4, #1039]	@ 0x40f
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800d594:	f8c4 3340 	str.w	r3, [r4, #832]	@ 0x340
}
 800d598:	bd38      	pop	{r3, r4, r5, pc}
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 800d59a:	f894 347f 	ldrb.w	r3, [r4, #1151]	@ 0x47f
 800d59e:	2b01      	cmp	r3, #1
 800d5a0:	d8e9      	bhi.n	800d576 <OnTxDelayedTimerEvent+0x4a>
 800d5a2:	e7ee      	b.n	800d582 <OnTxDelayedTimerEvent+0x56>
 800d5a4:	20000dec 	.word	0x20000dec
 800d5a8:	20000684 	.word	0x20000684

0800d5ac <LoRaMacIsBusy>:
    if( MacCtx.MacState == LORAMAC_STOPPED )
 800d5ac:	4a07      	ldr	r2, [pc, #28]	@ (800d5cc <LoRaMacIsBusy+0x20>)
 800d5ae:	f8d2 3340 	ldr.w	r3, [r2, #832]	@ 0x340
 800d5b2:	2b01      	cmp	r3, #1
 800d5b4:	d008      	beq.n	800d5c8 <LoRaMacIsBusy+0x1c>
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 800d5b6:	b92b      	cbnz	r3, 800d5c4 <LoRaMacIsBusy+0x18>
 800d5b8:	f892 0482 	ldrb.w	r0, [r2, #1154]	@ 0x482
 800d5bc:	3801      	subs	r0, #1
 800d5be:	bf18      	it	ne
 800d5c0:	2001      	movne	r0, #1
 800d5c2:	4770      	bx	lr
    return true;
 800d5c4:	2001      	movs	r0, #1
}
 800d5c6:	4770      	bx	lr
        return false;
 800d5c8:	2000      	movs	r0, #0
 800d5ca:	4770      	bx	lr
 800d5cc:	20000dec 	.word	0x20000dec

0800d5d0 <LoRaMacIsStopped>:
    if( MacCtx.MacState == LORAMAC_STOPPED )
 800d5d0:	4b04      	ldr	r3, [pc, #16]	@ (800d5e4 <LoRaMacIsStopped+0x14>)
 800d5d2:	f8d3 0340 	ldr.w	r0, [r3, #832]	@ 0x340
}
 800d5d6:	f1a0 0001 	sub.w	r0, r0, #1
 800d5da:	fab0 f080 	clz	r0, r0
 800d5de:	0940      	lsrs	r0, r0, #5
 800d5e0:	4770      	bx	lr
 800d5e2:	bf00      	nop
 800d5e4:	20000dec 	.word	0x20000dec

0800d5e8 <LoRaMacProcess>:
{
 800d5e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d5ec:	b0dd      	sub	sp, #372	@ 0x174
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800d5ee:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800d5f2:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 800d5f4:	4a5b      	ldr	r2, [pc, #364]	@ (800d764 <LoRaMacProcess+0x17c>)
    LoRaMacRadioEvents.Value = 0;
 800d5f6:	2000      	movs	r0, #0
    events = LoRaMacRadioEvents;
 800d5f8:	6813      	ldr	r3, [r2, #0]
    LoRaMacRadioEvents.Value = 0;
 800d5fa:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800d5fc:	f381 8810 	msr	PRIMASK, r1
    if( events.Value != 0 )
 800d600:	2b00      	cmp	r3, #0
 800d602:	f040 8099 	bne.w	800d738 <LoRaMacProcess+0x150>
 800d606:	4c58      	ldr	r4, [pc, #352]	@ (800d768 <LoRaMacProcess+0x180>)
    LoRaMacClassBProcess( );
 800d608:	f002 f9be 	bl	800f988 <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 800d60c:	f894 6481 	ldrb.w	r6, [r4, #1153]	@ 0x481
 800d610:	06f0      	lsls	r0, r6, #27
 800d612:	d565      	bpl.n	800d6e0 <LoRaMacProcess+0xf8>
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 800d614:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
 800d618:	0619      	lsls	r1, r3, #24
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800d61a:	bf48      	it	mi
 800d61c:	f023 0382 	bicmi.w	r3, r3, #130	@ 0x82
    MacCtx.AllowRequests = requestState;
 800d620:	f04f 0200 	mov.w	r2, #0
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800d624:	bf48      	it	mi
 800d626:	f8c4 3340 	strmi.w	r3, [r4, #832]	@ 0x340
}
#endif /* LORAMAC_VERSION */

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 800d62a:	f016 0f05 	tst.w	r6, #5
    MacCtx.AllowRequests = requestState;
 800d62e:	f884 2482 	strb.w	r2, [r4, #1154]	@ 0x482
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 800d632:	f040 821f 	bne.w	800da74 <LoRaMacProcess+0x48c>
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 800d636:	0777      	lsls	r7, r6, #29
 800d638:	f100 8416 	bmi.w	800de68 <LoRaMacProcess+0x880>
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 800d63c:	f006 0301 	and.w	r3, r6, #1
 800d640:	b3a3      	cbz	r3, 800d6ac <LoRaMacProcess+0xc4>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 800d642:	f894 3434 	ldrb.w	r3, [r4, #1076]	@ 0x434
 800d646:	2b00      	cmp	r3, #0
 800d648:	f000 8245 	beq.w	800dad6 <LoRaMacProcess+0x4ee>
 800d64c:	2b03      	cmp	r3, #3
 800d64e:	f000 8242 	beq.w	800dad6 <LoRaMacProcess+0x4ee>
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 800d652:	2b01      	cmp	r3, #1
 800d654:	f000 8568 	beq.w	800e128 <LoRaMacProcess+0xb40>
            MacCtx.MacFlags.Bits.MacDone = 0;
 800d658:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
            MacCtx.AckTimeoutRetry = false;
 800d65c:	2000      	movs	r0, #0
            MacCtx.MacFlags.Bits.MacDone = 0;
 800d65e:	f36f 1304 	bfc	r3, #4, #1
 800d662:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
            MacCtx.AckTimeoutRetry = false;
 800d666:	f884 040f 	strb.w	r0, [r4, #1039]	@ 0x40f
            OnTxDelayedTimerEvent( NULL );
 800d66a:	f7ff ff5f 	bl	800d52c <OnTxDelayedTimerEvent>
    if( MacCtx.MacState == LORAMAC_IDLE )
 800d66e:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
 800d672:	bb63      	cbnz	r3, 800d6ce <LoRaMacProcess+0xe6>
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 800d674:	f894 6481 	ldrb.w	r6, [r4, #1153]	@ 0x481
 800d678:	07f7      	lsls	r7, r6, #31
 800d67a:	d51a      	bpl.n	800d6b2 <LoRaMacProcess+0xca>
            MacCtx.MacFlags.Bits.McpsReq = 0;
 800d67c:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800d680:	f36f 0300 	bfc	r3, #0, #1
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 800d684:	075d      	lsls	r5, r3, #29
            MacCtx.MacFlags.Bits.McpsReq = 0;
 800d686:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 800d68a:	b2da      	uxtb	r2, r3
 800d68c:	d503      	bpl.n	800d696 <LoRaMacProcess+0xae>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 800d68e:	f36f 0282 	bfc	r2, #2, #1
 800d692:	f884 2481 	strb.w	r2, [r4, #1153]	@ 0x481
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 800d696:	f8d4 3344 	ldr.w	r3, [r4, #836]	@ 0x344
 800d69a:	4834      	ldr	r0, [pc, #208]	@ (800d76c <LoRaMacProcess+0x184>)
 800d69c:	2201      	movs	r2, #1
 800d69e:	f884 2482 	strb.w	r2, [r4, #1154]	@ 0x482
 800d6a2:	681b      	ldr	r3, [r3, #0]
 800d6a4:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 800d6a6:	0771      	lsls	r1, r6, #29
 800d6a8:	d509      	bpl.n	800d6be <LoRaMacProcess+0xd6>
 800d6aa:	e205      	b.n	800dab8 <LoRaMacProcess+0x4d0>
    if( MacCtx.MacState == LORAMAC_IDLE )
 800d6ac:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
 800d6b0:	b96b      	cbnz	r3, 800d6ce <LoRaMacProcess+0xe6>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 800d6b2:	0770      	lsls	r0, r6, #29
 800d6b4:	f100 81f7 	bmi.w	800daa6 <LoRaMacProcess+0x4be>
    MacCtx.AllowRequests = requestState;
 800d6b8:	2301      	movs	r3, #1
 800d6ba:	f884 3482 	strb.w	r3, [r4, #1154]	@ 0x482
        LoRaMacClassBResumeBeaconing( );
 800d6be:	f002 f94d 	bl	800f95c <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 800d6c2:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800d6c6:	f36f 1304 	bfc	r3, #4, #1
 800d6ca:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 800d6ce:	f894 6481 	ldrb.w	r6, [r4, #1153]	@ 0x481
    MacCtx.AllowRequests = requestState;
 800d6d2:	2301      	movs	r3, #1
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 800d6d4:	f046 0620 	orr.w	r6, r6, #32
    MacCtx.AllowRequests = requestState;
 800d6d8:	f884 3482 	strb.w	r3, [r4, #1154]	@ 0x482
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 800d6dc:	f884 6481 	strb.w	r6, [r4, #1153]	@ 0x481
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 800d6e0:	0732      	lsls	r2, r6, #28
 800d6e2:	d50e      	bpl.n	800d702 <LoRaMacProcess+0x11a>
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 800d6e4:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 800d6e8:	f8d4 2344 	ldr.w	r2, [r4, #836]	@ 0x344
 800d6ec:	4920      	ldr	r1, [pc, #128]	@ (800d770 <LoRaMacProcess+0x188>)
 800d6ee:	68d2      	ldr	r2, [r2, #12]
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 800d6f0:	f36f 03c3 	bfc	r3, #3, #1
 800d6f4:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 800d6f8:	f1a1 0020 	sub.w	r0, r1, #32
 800d6fc:	4790      	blx	r2
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 800d6fe:	f894 6481 	ldrb.w	r6, [r4, #1153]	@ 0x481
 800d702:	07b3      	lsls	r3, r6, #30
 800d704:	d50c      	bpl.n	800d720 <LoRaMacProcess+0x138>
        MacCtx.MacFlags.Bits.McpsInd = 0;
 800d706:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 800d70a:	f8d4 2344 	ldr.w	r2, [r4, #836]	@ 0x344
 800d70e:	4918      	ldr	r1, [pc, #96]	@ (800d770 <LoRaMacProcess+0x188>)
 800d710:	6852      	ldr	r2, [r2, #4]
        MacCtx.MacFlags.Bits.McpsInd = 0;
 800d712:	f36f 0341 	bfc	r3, #1, #1
 800d716:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 800d71a:	f1a1 0064 	sub.w	r0, r1, #100	@ 0x64
 800d71e:	4790      	blx	r2
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 800d720:	f894 3480 	ldrb.w	r3, [r4, #1152]	@ 0x480
 800d724:	2b02      	cmp	r3, #2
 800d726:	f000 816c 	beq.w	800da02 <LoRaMacProcess+0x41a>
    if( MacCtx.MacFlags.Bits.NvmHandle == 1 )
 800d72a:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800d72e:	069f      	lsls	r7, r3, #26
 800d730:	d420      	bmi.n	800d774 <LoRaMacProcess+0x18c>
}
 800d732:	b05d      	add	sp, #372	@ 0x174
 800d734:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( events.Events.TxDone == 1 )
 800d738:	06df      	lsls	r7, r3, #27
 800d73a:	b2de      	uxtb	r6, r3
 800d73c:	f100 81fa 	bmi.w	800db34 <LoRaMacProcess+0x54c>
 800d740:	4c09      	ldr	r4, [pc, #36]	@ (800d768 <LoRaMacProcess+0x180>)
        if( events.Events.RxDone == 1 )
 800d742:	0735      	lsls	r5, r6, #28
 800d744:	f100 8294 	bmi.w	800dc70 <LoRaMacProcess+0x688>
        if( events.Events.TxTimeout == 1 )
 800d748:	0773      	lsls	r3, r6, #29
 800d74a:	f100 8270 	bmi.w	800dc2e <LoRaMacProcess+0x646>
        if( events.Events.RxError == 1 )
 800d74e:	07b7      	lsls	r7, r6, #30
 800d750:	f100 8268 	bmi.w	800dc24 <LoRaMacProcess+0x63c>
        if( events.Events.RxTimeout == 1 )
 800d754:	07f5      	lsls	r5, r6, #31
 800d756:	f57f af57 	bpl.w	800d608 <LoRaMacProcess+0x20>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 800d75a:	2104      	movs	r1, #4
 800d75c:	2003      	movs	r0, #3
 800d75e:	f7fe fffd 	bl	800c75c <HandleRadioRxErrorTimeout>
}
 800d762:	e751      	b.n	800d608 <LoRaMacProcess+0x20>
 800d764:	20000680 	.word	0x20000680
 800d768:	20000dec 	.word	0x20000dec
 800d76c:	20001220 	.word	0x20001220
 800d770:	20001268 	.word	0x20001268
    if( MacCtx.MacState != LORAMAC_IDLE )
 800d774:	f8d4 6340 	ldr.w	r6, [r4, #832]	@ 0x340
        MacCtx.MacFlags.Bits.NvmHandle = 0;
 800d778:	f36f 1345 	bfc	r3, #5, #1
 800d77c:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( MacCtx.MacState != LORAMAC_IDLE )
 800d780:	2e00      	cmp	r6, #0
 800d782:	d1d6      	bne.n	800d732 <LoRaMacProcess+0x14a>
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 800d784:	4db2      	ldr	r5, [pc, #712]	@ (800da50 <LoRaMacProcess+0x468>)
 800d786:	2124      	movs	r1, #36	@ 0x24
 800d788:	4628      	mov	r0, r5
 800d78a:	f004 fddb 	bl	8012344 <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 800d78e:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800d790:	4298      	cmp	r0, r3
 800d792:	f000 82dd 	beq.w	800dd50 <LoRaMacProcess+0x768>
        nvmData->Crypto.Crc32 = crc;
 800d796:	2371      	movs	r3, #113	@ 0x71
 800d798:	f04f 0e51 	mov.w	lr, #81	@ 0x51
 800d79c:	e9cd 3e02 	strd	r3, lr, [sp, #8]
 800d7a0:	2249      	movs	r2, #73	@ 0x49
 800d7a2:	2369      	movs	r3, #105	@ 0x69
 800d7a4:	e9cd 320a 	strd	r3, r2, [sp, #40]	@ 0x28
 800d7a8:	2129      	movs	r1, #41	@ 0x29
 800d7aa:	2359      	movs	r3, #89	@ 0x59
 800d7ac:	e9cd 3108 	strd	r3, r1, [sp, #32]
 800d7b0:	6268      	str	r0, [r5, #36]	@ 0x24
 800d7b2:	2339      	movs	r3, #57	@ 0x39
 800d7b4:	2079      	movs	r0, #121	@ 0x79
 800d7b6:	e9cd 3006 	strd	r3, r0, [sp, #24]
 800d7ba:	2619      	movs	r6, #25
 800d7bc:	2309      	movs	r3, #9
 800d7be:	e9cd 3604 	strd	r3, r6, [sp, #16]
 800d7c2:	f04f 0c45 	mov.w	ip, #69	@ 0x45
 800d7c6:	2365      	movs	r3, #101	@ 0x65
 800d7c8:	e9cd 3c1a 	strd	r3, ip, [sp, #104]	@ 0x68
 800d7cc:	f04f 0e25 	mov.w	lr, #37	@ 0x25
 800d7d0:	2355      	movs	r3, #85	@ 0x55
 800d7d2:	e9cd 3e18 	strd	r3, lr, [sp, #96]	@ 0x60
 800d7d6:	2275      	movs	r2, #117	@ 0x75
 800d7d8:	2335      	movs	r3, #53	@ 0x35
 800d7da:	e9cd 3216 	strd	r3, r2, [sp, #88]	@ 0x58
 800d7de:	2115      	movs	r1, #21
 800d7e0:	234d      	movs	r3, #77	@ 0x4d
 800d7e2:	e9cd 3114 	strd	r3, r1, [sp, #80]	@ 0x50
 800d7e6:	206d      	movs	r0, #109	@ 0x6d
 800d7e8:	232d      	movs	r3, #45	@ 0x2d
 800d7ea:	e9cd 3012 	strd	r3, r0, [sp, #72]	@ 0x48
 800d7ee:	265d      	movs	r6, #93	@ 0x5d
 800d7f0:	237d      	movs	r3, #125	@ 0x7d
 800d7f2:	e9cd 3610 	strd	r3, r6, [sp, #64]	@ 0x40
 800d7f6:	f04f 0c3d 	mov.w	ip, #61	@ 0x3d
 800d7fa:	231d      	movs	r3, #29
 800d7fc:	e9cd 3c0e 	strd	r3, ip, [sp, #56]	@ 0x38
 800d800:	f04f 0e0d 	mov.w	lr, #13
 800d804:	2305      	movs	r3, #5
 800d806:	e9cd 3e0c 	strd	r3, lr, [sp, #48]	@ 0x30
 800d80a:	2243      	movs	r2, #67	@ 0x43
 800d80c:	2363      	movs	r3, #99	@ 0x63
 800d80e:	e9cd 323a 	strd	r3, r2, [sp, #232]	@ 0xe8
 800d812:	2123      	movs	r1, #35	@ 0x23
 800d814:	2353      	movs	r3, #83	@ 0x53
 800d816:	e9cd 3138 	strd	r3, r1, [sp, #224]	@ 0xe0
 800d81a:	2073      	movs	r0, #115	@ 0x73
 800d81c:	2333      	movs	r3, #51	@ 0x33
 800d81e:	e9cd 3036 	strd	r3, r0, [sp, #216]	@ 0xd8
 800d822:	2613      	movs	r6, #19
 800d824:	234b      	movs	r3, #75	@ 0x4b
 800d826:	e9cd 3634 	strd	r3, r6, [sp, #208]	@ 0xd0
 800d82a:	f04f 0c6b 	mov.w	ip, #107	@ 0x6b
 800d82e:	232b      	movs	r3, #43	@ 0x2b
 800d830:	e9cd 3c32 	strd	r3, ip, [sp, #200]	@ 0xc8
 800d834:	f04f 0e5b 	mov.w	lr, #91	@ 0x5b
 800d838:	237b      	movs	r3, #123	@ 0x7b
 800d83a:	e9cd 3e30 	strd	r3, lr, [sp, #192]	@ 0xc0
 800d83e:	223b      	movs	r2, #59	@ 0x3b
 800d840:	231b      	movs	r3, #27
 800d842:	e9cd 322e 	strd	r3, r2, [sp, #184]	@ 0xb8
 800d846:	210b      	movs	r1, #11
 800d848:	2347      	movs	r3, #71	@ 0x47
 800d84a:	e9cd 312c 	strd	r3, r1, [sp, #176]	@ 0xb0
 800d84e:	2067      	movs	r0, #103	@ 0x67
 800d850:	2327      	movs	r3, #39	@ 0x27
 800d852:	e9cd 302a 	strd	r3, r0, [sp, #168]	@ 0xa8
 800d856:	2657      	movs	r6, #87	@ 0x57
 800d858:	2377      	movs	r3, #119	@ 0x77
 800d85a:	e9cd 3628 	strd	r3, r6, [sp, #160]	@ 0xa0
 800d85e:	f04f 0c37 	mov.w	ip, #55	@ 0x37
 800d862:	2317      	movs	r3, #23
 800d864:	e9cd 3c26 	strd	r3, ip, [sp, #152]	@ 0x98
 800d868:	f04f 0e4f 	mov.w	lr, #79	@ 0x4f
 800d86c:	236f      	movs	r3, #111	@ 0x6f
 800d86e:	e9cd 3e24 	strd	r3, lr, [sp, #144]	@ 0x90
 800d872:	222f      	movs	r2, #47	@ 0x2f
 800d874:	235f      	movs	r3, #95	@ 0x5f
 800d876:	e9cd 3222 	strd	r3, r2, [sp, #136]	@ 0x88
 800d87a:	217f      	movs	r1, #127	@ 0x7f
 800d87c:	233f      	movs	r3, #63	@ 0x3f
 800d87e:	e9cd 3120 	strd	r3, r1, [sp, #128]	@ 0x80
 800d882:	201f      	movs	r0, #31
 800d884:	230f      	movs	r3, #15
 800d886:	2607      	movs	r6, #7
 800d888:	e9cd 301e 	strd	r3, r0, [sp, #120]	@ 0x78
 800d88c:	2303      	movs	r3, #3
 800d88e:	e9cd 361c 	strd	r3, r6, [sp, #112]	@ 0x70
 800d892:	2741      	movs	r7, #65	@ 0x41
 800d894:	f04f 0961 	mov.w	r9, #97	@ 0x61
 800d898:	f04f 0821 	mov.w	r8, #33	@ 0x21
 800d89c:	f04f 0b31 	mov.w	fp, #49	@ 0x31
 800d8a0:	f04f 0a11 	mov.w	sl, #17
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 800d8a4:	2601      	movs	r6, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 800d8a6:	486b      	ldr	r0, [pc, #428]	@ (800da54 <LoRaMacProcess+0x46c>)
 800d8a8:	211c      	movs	r1, #28
 800d8aa:	f004 fd4b 	bl	8012344 <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 800d8ae:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 800d8b0:	4298      	cmp	r0, r3
 800d8b2:	d03a      	beq.n	800d92a <LoRaMacProcess+0x342>
        nvmData->MacGroup1.Crc32 = crc;
 800d8b4:	e9dd 3838 	ldrd	r3, r8, [sp, #224]	@ 0xe0
 800d8b8:	9303      	str	r3, [sp, #12]
 800d8ba:	9b37      	ldr	r3, [sp, #220]	@ 0xdc
 800d8bc:	9302      	str	r3, [sp, #8]
 800d8be:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
 800d8c0:	930b      	str	r3, [sp, #44]	@ 0x2c
 800d8c2:	9b33      	ldr	r3, [sp, #204]	@ 0xcc
 800d8c4:	930a      	str	r3, [sp, #40]	@ 0x28
 800d8c6:	9b32      	ldr	r3, [sp, #200]	@ 0xc8
 800d8c8:	9309      	str	r3, [sp, #36]	@ 0x24
 800d8ca:	9b31      	ldr	r3, [sp, #196]	@ 0xc4
 800d8cc:	9308      	str	r3, [sp, #32]
 800d8ce:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
 800d8d0:	9307      	str	r3, [sp, #28]
 800d8d2:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 800d8d4:	9306      	str	r3, [sp, #24]
 800d8d6:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 800d8d8:	9305      	str	r3, [sp, #20]
 800d8da:	9b2d      	ldr	r3, [sp, #180]	@ 0xb4
 800d8dc:	9304      	str	r3, [sp, #16]
 800d8de:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 800d8e0:	931b      	str	r3, [sp, #108]	@ 0x6c
 800d8e2:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 800d8e4:	931a      	str	r3, [sp, #104]	@ 0x68
 800d8e6:	9b2a      	ldr	r3, [sp, #168]	@ 0xa8
 800d8e8:	6468      	str	r0, [r5, #68]	@ 0x44
 800d8ea:	e9dd 973a 	ldrd	r9, r7, [sp, #232]	@ 0xe8
 800d8ee:	e9dd ab35 	ldrd	sl, fp, [sp, #212]	@ 0xd4
 800d8f2:	9319      	str	r3, [sp, #100]	@ 0x64
 800d8f4:	9b29      	ldr	r3, [sp, #164]	@ 0xa4
 800d8f6:	9318      	str	r3, [sp, #96]	@ 0x60
 800d8f8:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 800d8fa:	9317      	str	r3, [sp, #92]	@ 0x5c
 800d8fc:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 800d8fe:	9316      	str	r3, [sp, #88]	@ 0x58
 800d900:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 800d902:	9315      	str	r3, [sp, #84]	@ 0x54
 800d904:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 800d906:	9314      	str	r3, [sp, #80]	@ 0x50
 800d908:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 800d90a:	9313      	str	r3, [sp, #76]	@ 0x4c
 800d90c:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 800d90e:	9312      	str	r3, [sp, #72]	@ 0x48
 800d910:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 800d912:	9311      	str	r3, [sp, #68]	@ 0x44
 800d914:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 800d916:	9310      	str	r3, [sp, #64]	@ 0x40
 800d918:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 800d91a:	930f      	str	r3, [sp, #60]	@ 0x3c
 800d91c:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 800d91e:	930e      	str	r3, [sp, #56]	@ 0x38
 800d920:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 800d922:	930d      	str	r3, [sp, #52]	@ 0x34
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 800d924:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
        nvmData->MacGroup1.Crc32 = crc;
 800d926:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 800d928:	930c      	str	r3, [sp, #48]	@ 0x30
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 800d92a:	484b      	ldr	r0, [pc, #300]	@ (800da58 <LoRaMacProcess+0x470>)
 800d92c:	21fc      	movs	r1, #252	@ 0xfc
 800d92e:	f004 fd09 	bl	8012344 <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 800d932:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
 800d936:	4298      	cmp	r0, r3
 800d938:	d01b      	beq.n	800d972 <LoRaMacProcess+0x38a>
        nvmData->MacGroup2.Crc32 = crc;
 800d93a:	e9dd 3818 	ldrd	r3, r8, [sp, #96]	@ 0x60
 800d93e:	9303      	str	r3, [sp, #12]
 800d940:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 800d942:	9302      	str	r3, [sp, #8]
 800d944:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 800d946:	930b      	str	r3, [sp, #44]	@ 0x2c
 800d948:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 800d94a:	930a      	str	r3, [sp, #40]	@ 0x28
 800d94c:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 800d94e:	9309      	str	r3, [sp, #36]	@ 0x24
 800d950:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 800d952:	9308      	str	r3, [sp, #32]
 800d954:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 800d956:	9307      	str	r3, [sp, #28]
 800d958:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800d95a:	9306      	str	r3, [sp, #24]
 800d95c:	e9dd 971a 	ldrd	r9, r7, [sp, #104]	@ 0x68
 800d960:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 800d962:	9305      	str	r3, [sp, #20]
 800d964:	e9dd ab15 	ldrd	sl, fp, [sp, #84]	@ 0x54
 800d968:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 800d96a:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
        nvmData->MacGroup2.Crc32 = crc;
 800d96c:	f8c5 0144 	str.w	r0, [r5, #324]	@ 0x144
 800d970:	9304      	str	r3, [sp, #16]
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 800d972:	483a      	ldr	r0, [pc, #232]	@ (800da5c <LoRaMacProcess+0x474>)
 800d974:	21d4      	movs	r1, #212	@ 0xd4
 800d976:	f004 fce5 	bl	8012344 <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 800d97a:	f8d5 321c 	ldr.w	r3, [r5, #540]	@ 0x21c
 800d97e:	4298      	cmp	r0, r3
 800d980:	d00b      	beq.n	800d99a <LoRaMacProcess+0x3b2>
        nvmData->SecureElement.Crc32 = crc;
 800d982:	e9dd 3808 	ldrd	r3, r8, [sp, #32]
 800d986:	e9dd 970a 	ldrd	r9, r7, [sp, #40]	@ 0x28
 800d98a:	e9dd ab05 	ldrd	sl, fp, [sp, #20]
 800d98e:	9303      	str	r3, [sp, #12]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 800d990:	9e04      	ldr	r6, [sp, #16]
        nvmData->SecureElement.Crc32 = crc;
 800d992:	9b07      	ldr	r3, [sp, #28]
 800d994:	f8c5 021c 	str.w	r0, [r5, #540]	@ 0x21c
 800d998:	9302      	str	r3, [sp, #8]
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 800d99a:	4831      	ldr	r0, [pc, #196]	@ (800da60 <LoRaMacProcess+0x478>)
 800d99c:	2190      	movs	r1, #144	@ 0x90
 800d99e:	f004 fcd1 	bl	8012344 <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 800d9a2:	f8d5 32b0 	ldr.w	r3, [r5, #688]	@ 0x2b0
 800d9a6:	4298      	cmp	r0, r3
 800d9a8:	d005      	beq.n	800d9b6 <LoRaMacProcess+0x3ce>
        nvmData->RegionGroup1.Crc32 = crc;
 800d9aa:	e9dd 9702 	ldrd	r9, r7, [sp, #8]
 800d9ae:	f8c5 02b0 	str.w	r0, [r5, #688]	@ 0x2b0
 800d9b2:	46d8      	mov	r8, fp
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 800d9b4:	4656      	mov	r6, sl
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 800d9b6:	482b      	ldr	r0, [pc, #172]	@ (800da64 <LoRaMacProcess+0x47c>)
 800d9b8:	f44f 6193 	mov.w	r1, #1176	@ 0x498
 800d9bc:	f004 fcc2 	bl	8012344 <Crc32>
    if( crc != nvmData->RegionGroup2.Crc32 )
 800d9c0:	f8d5 374c 	ldr.w	r3, [r5, #1868]	@ 0x74c
 800d9c4:	4298      	cmp	r0, r3
 800d9c6:	d003      	beq.n	800d9d0 <LoRaMacProcess+0x3e8>
        nvmData->RegionGroup2.Crc32 = crc;
 800d9c8:	f8c5 074c 	str.w	r0, [r5, #1868]	@ 0x74c
 800d9cc:	464f      	mov	r7, r9
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 800d9ce:	4646      	mov	r6, r8
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 800d9d0:	4825      	ldr	r0, [pc, #148]	@ (800da68 <LoRaMacProcess+0x480>)
 800d9d2:	2114      	movs	r1, #20
 800d9d4:	f004 fcb6 	bl	8012344 <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 800d9d8:	f8d5 3764 	ldr.w	r3, [r5, #1892]	@ 0x764
 800d9dc:	4298      	cmp	r0, r3
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 800d9de:	f8d4 3348 	ldr.w	r3, [r4, #840]	@ 0x348
        nvmData->ClassB.Crc32 = crc;
 800d9e2:	bf1c      	itt	ne
 800d9e4:	f8c5 0764 	strne.w	r0, [r5, #1892]	@ 0x764
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 800d9e8:	463e      	movne	r6, r7
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 800d9ea:	2b00      	cmp	r3, #0
 800d9ec:	f43f aea1 	beq.w	800d732 <LoRaMacProcess+0x14a>
 800d9f0:	691b      	ldr	r3, [r3, #16]
 800d9f2:	2b00      	cmp	r3, #0
 800d9f4:	f43f ae9d 	beq.w	800d732 <LoRaMacProcess+0x14a>
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 800d9f8:	4630      	mov	r0, r6
}
 800d9fa:	b05d      	add	sp, #372	@ 0x174
 800d9fc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 800da00:	4718      	bx	r3
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800da02:	4d13      	ldr	r5, [pc, #76]	@ (800da50 <LoRaMacProcess+0x468>)
 800da04:	4e19      	ldr	r6, [pc, #100]	@ (800da6c <LoRaMacProcess+0x484>)
 800da06:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 800da08:	f895 2050 	ldrb.w	r2, [r5, #80]	@ 0x50
 800da0c:	9600      	str	r6, [sp, #0]
 800da0e:	f995 1078 	ldrsb.w	r1, [r5, #120]	@ 0x78
 800da12:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
 800da16:	f002 ff99 	bl	801094c <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800da1a:	f240 2301 	movw	r3, #513	@ 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800da1e:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800da22:	f8a4 33f2 	strh.w	r3, [r4, #1010]	@ 0x3f2
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800da26:	f106 023c 	add.w	r2, r6, #60	@ 0x3c
 800da2a:	4631      	mov	r1, r6
 800da2c:	f002 ff9c 	bl	8010968 <RegionRxConfig>
 800da30:	2800      	cmp	r0, #0
 800da32:	f43f ae7a 	beq.w	800d72a <LoRaMacProcess+0x142>
        Radio.Rx( 0 ); // Continuous mode
 800da36:	4b0e      	ldr	r3, [pc, #56]	@ (800da70 <LoRaMacProcess+0x488>)
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800da38:	f894 241c 	ldrb.w	r2, [r4, #1052]	@ 0x41c
        Radio.Rx( 0 ); // Continuous mode
 800da3c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800da3e:	f884 245e 	strb.w	r2, [r4, #1118]	@ 0x45e
        Radio.Rx( 0 ); // Continuous mode
 800da42:	2000      	movs	r0, #0
 800da44:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 800da46:	f894 33f3 	ldrb.w	r3, [r4, #1011]	@ 0x3f3
 800da4a:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
}
 800da4e:	e66c      	b.n	800d72a <LoRaMacProcess+0x142>
 800da50:	20000684 	.word	0x20000684
 800da54:	200006ac 	.word	0x200006ac
 800da58:	200006cc 	.word	0x200006cc
 800da5c:	200007cc 	.word	0x200007cc
 800da60:	200008a4 	.word	0x200008a4
 800da64:	20000938 	.word	0x20000938
 800da68:	20000dd4 	.word	0x20000dd4
 800da6c:	200011cc 	.word	0x200011cc
 800da70:	08017658 	.word	0x08017658
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 800da74:	200c      	movs	r0, #12
 800da76:	f002 f999 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 800da7a:	f894 6481 	ldrb.w	r6, [r4, #1153]	@ 0x481
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 800da7e:	2800      	cmp	r0, #0
 800da80:	f43f add9 	beq.w	800d636 <LoRaMacProcess+0x4e>
 800da84:	07f2      	lsls	r2, r6, #31
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 800da86:	f006 0304 	and.w	r3, r6, #4
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 800da8a:	f100 81ea 	bmi.w	800de62 <LoRaMacProcess+0x87a>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 800da8e:	2b00      	cmp	r3, #0
 800da90:	f43f ae0c 	beq.w	800d6ac <LoRaMacProcess+0xc4>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800da94:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
 800da98:	f023 0302 	bic.w	r3, r3, #2
 800da9c:	f8c4 3340 	str.w	r3, [r4, #832]	@ 0x340
    if( MacCtx.MacState == LORAMAC_IDLE )
 800daa0:	2b00      	cmp	r3, #0
 800daa2:	f47f ae14 	bne.w	800d6ce <LoRaMacProcess+0xe6>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 800daa6:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
    MacCtx.AllowRequests = requestState;
 800daaa:	2201      	movs	r2, #1
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 800daac:	f36f 0382 	bfc	r3, #2, #1
 800dab0:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    MacCtx.AllowRequests = requestState;
 800dab4:	f884 2482 	strb.w	r2, [r4, #1154]	@ 0x482
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 800dab8:	489c      	ldr	r0, [pc, #624]	@ (800dd2c <LoRaMacProcess+0x744>)
 800daba:	f002 f997 	bl	800fdec <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 800dabe:	f002 f9f9 	bl	800feb4 <LoRaMacConfirmQueueGetCnt>
 800dac2:	2800      	cmp	r0, #0
 800dac4:	f43f adfb 	beq.w	800d6be <LoRaMacProcess+0xd6>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 800dac8:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800dacc:	f043 0304 	orr.w	r3, r3, #4
 800dad0:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
 800dad4:	e5f3      	b.n	800d6be <LoRaMacProcess+0xd6>
        Nvm.MacGroup2.MacParams.ChannelsNbTrans )
 800dad6:	4d96      	ldr	r5, [pc, #600]	@ (800dd30 <LoRaMacProcess+0x748>)
    if( MacCtx.ChannelsNbTransCounter >=
 800dad8:	f894 240c 	ldrb.w	r2, [r4, #1036]	@ 0x40c
 800dadc:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
 800dae0:	429a      	cmp	r2, r3
 800dae2:	d20a      	bcs.n	800dafa <LoRaMacProcess+0x512>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 800dae4:	07b6      	lsls	r6, r6, #30
 800dae6:	f57f adb7 	bpl.w	800d658 <LoRaMacProcess+0x70>
        if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 800daea:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800daee:	b123      	cbz	r3, 800dafa <LoRaMacProcess+0x512>
            if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 800daf0:	f894 347f 	ldrb.w	r3, [r4, #1151]	@ 0x47f
 800daf4:	2b00      	cmp	r3, #0
 800daf6:	f47f adaf 	bne.w	800d658 <LoRaMacProcess+0x70>
            TimerStop( &MacCtx.TxDelayedTimer );
 800dafa:	488e      	ldr	r0, [pc, #568]	@ (800dd34 <LoRaMacProcess+0x74c>)
 800dafc:	f007 fdf6 	bl	80156ec <UTIL_TIMER_Stop>
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 800db00:	f894 2481 	ldrb.w	r2, [r4, #1153]	@ 0x481
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 800db04:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 800db08:	0792      	lsls	r2, r2, #30
 800db0a:	d503      	bpl.n	800db14 <LoRaMacProcess+0x52c>
 800db0c:	f894 247f 	ldrb.w	r2, [r4, #1151]	@ 0x47f
 800db10:	2a01      	cmp	r2, #1
 800db12:	d905      	bls.n	800db20 <LoRaMacProcess+0x538>
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 800db14:	f895 211a 	ldrb.w	r2, [r5, #282]	@ 0x11a
 800db18:	b112      	cbz	r2, 800db20 <LoRaMacProcess+0x538>
            Nvm.MacGroup1.AdrAckCounter++;
 800db1a:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 800db1c:	3201      	adds	r2, #1
 800db1e:	62aa      	str	r2, [r5, #40]	@ 0x28
    MacCtx.ChannelsNbTransCounter = 0;
 800db20:	2200      	movs	r2, #0
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800db22:	f023 0322 	bic.w	r3, r3, #34	@ 0x22
    MacCtx.ChannelsNbTransCounter = 0;
 800db26:	f884 240c 	strb.w	r2, [r4, #1036]	@ 0x40c
    MacCtx.AckTimeoutRetry = false;
 800db2a:	f8a4 240f 	strh.w	r2, [r4, #1039]	@ 0x40f
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800db2e:	f8c4 3340 	str.w	r3, [r4, #832]	@ 0x340
    return true;
 800db32:	e59e      	b.n	800d672 <LoRaMacProcess+0x8a>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800db34:	4d7e      	ldr	r5, [pc, #504]	@ (800dd30 <LoRaMacProcess+0x748>)
 800db36:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800db3a:	2b02      	cmp	r3, #2
 800db3c:	d002      	beq.n	800db44 <LoRaMacProcess+0x55c>
        Radio.Sleep( );
 800db3e:	4b7e      	ldr	r3, [pc, #504]	@ (800dd38 <LoRaMacProcess+0x750>)
 800db40:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800db42:	4798      	blx	r3
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800db44:	f3ef 8910 	mrs	r9, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800db48:	b672      	cpsid	i
    uint32_t offset = TimerGetCurrentTime( ) - TxDoneParams.CurTime;
 800db4a:	f8df 81f0 	ldr.w	r8, [pc, #496]	@ 800dd3c <LoRaMacProcess+0x754>
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay - offset );
 800db4e:	4c7c      	ldr	r4, [pc, #496]	@ (800dd40 <LoRaMacProcess+0x758>)
    uint32_t offset = TimerGetCurrentTime( ) - TxDoneParams.CurTime;
 800db50:	f007 feb4 	bl	80158bc <UTIL_TIMER_GetCurrentTime>
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay - offset );
 800db54:	f8d8 7000 	ldr.w	r7, [r8]
 800db58:	f8d4 13b0 	ldr.w	r1, [r4, #944]	@ 0x3b0
 800db5c:	1a3f      	subs	r7, r7, r0
 800db5e:	4439      	add	r1, r7
 800db60:	f504 7060 	add.w	r0, r4, #896	@ 0x380
 800db64:	f007 fe0c 	bl	8015780 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 800db68:	f504 7060 	add.w	r0, r4, #896	@ 0x380
 800db6c:	f007 fdac 	bl	80156c8 <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay - offset );
 800db70:	f8d4 13b4 	ldr.w	r1, [r4, #948]	@ 0x3b4
 800db74:	f504 7066 	add.w	r0, r4, #920	@ 0x398
 800db78:	4439      	add	r1, r7
 800db7a:	f007 fe01 	bl	8015780 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 800db7e:	f504 7066 	add.w	r0, r4, #920	@ 0x398
 800db82:	f007 fda1 	bl	80156c8 <UTIL_TIMER_Start>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800db86:	f389 8810 	msr	PRIMASK, r9
    if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 800db8a:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800db8e:	2b02      	cmp	r3, #2
 800db90:	d002      	beq.n	800db98 <LoRaMacProcess+0x5b0>
 800db92:	f894 3410 	ldrb.w	r3, [r4, #1040]	@ 0x410
 800db96:	b18b      	cbz	r3, 800dbbc <LoRaMacProcess+0x5d4>
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 800db98:	2316      	movs	r3, #22
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800db9a:	a946      	add	r1, sp, #280	@ 0x118
 800db9c:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 800dba0:	f88d 3118 	strb.w	r3, [sp, #280]	@ 0x118
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800dba4:	f002 fea4 	bl	80108f0 <RegionGetPhyParam>
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 800dba8:	f8d4 13b4 	ldr.w	r1, [r4, #948]	@ 0x3b4
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800dbac:	9044      	str	r0, [sp, #272]	@ 0x110
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 800dbae:	4401      	add	r1, r0
 800dbb0:	4864      	ldr	r0, [pc, #400]	@ (800dd44 <LoRaMacProcess+0x75c>)
 800dbb2:	f007 fde5 	bl	8015780 <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.AckTimeoutTimer );
 800dbb6:	4863      	ldr	r0, [pc, #396]	@ (800dd44 <LoRaMacProcess+0x75c>)
 800dbb8:	f007 fd86 	bl	80156c8 <UTIL_TIMER_Start>
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 800dbbc:	f8d8 3000 	ldr.w	r3, [r8]
    txDone.Channel = MacCtx.Channel;
 800dbc0:	f894 2411 	ldrb.w	r2, [r4, #1041]	@ 0x411
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 800dbc4:	62eb      	str	r3, [r5, #44]	@ 0x2c
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800dbc6:	f50d 7884 	add.w	r8, sp, #264	@ 0x108
 800dbca:	4640      	mov	r0, r8
    txDone.Channel = MacCtx.Channel;
 800dbcc:	f88d 2140 	strb.w	r2, [sp, #320]	@ 0x140
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 800dbd0:	9351      	str	r3, [sp, #324]	@ 0x144
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800dbd2:	f007 f943 	bl	8014e5c <SysTimeGetMcuTime>
 800dbd6:	f8d5 3124 	ldr.w	r3, [r5, #292]	@ 0x124
 800dbda:	9300      	str	r3, [sp, #0]
 800dbdc:	af3c      	add	r7, sp, #240	@ 0xf0
 800dbde:	e898 0006 	ldmia.w	r8, {r1, r2}
 800dbe2:	f8d5 3120 	ldr.w	r3, [r5, #288]	@ 0x120
 800dbe6:	4638      	mov	r0, r7
 800dbe8:	f007 f8d0 	bl	8014d8c <SysTimeSub>
 800dbec:	e897 0003 	ldmia.w	r7, {r0, r1}
 800dbf0:	ab53      	add	r3, sp, #332	@ 0x14c
 800dbf2:	e883 0003 	stmia.w	r3, {r0, r1}
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800dbf6:	f895 312c 	ldrb.w	r3, [r5, #300]	@ 0x12c
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 800dbfa:	f8d4 2414 	ldr.w	r2, [r4, #1044]	@ 0x414
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 800dbfe:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 800dc02:	9252      	str	r2, [sp, #328]	@ 0x148
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800dc04:	3b00      	subs	r3, #0
 800dc06:	bf18      	it	ne
 800dc08:	2301      	movne	r3, #1
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 800dc0a:	a950      	add	r1, sp, #320	@ 0x140
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800dc0c:	f88d 3141 	strb.w	r3, [sp, #321]	@ 0x141
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 800dc10:	f002 fe78 	bl	8010904 <RegionSetBandTxDone>
    if( MacCtx.NodeAckRequested == false )
 800dc14:	f894 3410 	ldrb.w	r3, [r4, #1040]	@ 0x410
 800dc18:	2b00      	cmp	r3, #0
 800dc1a:	f47f ad92 	bne.w	800d742 <LoRaMacProcess+0x15a>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 800dc1e:	f884 3435 	strb.w	r3, [r4, #1077]	@ 0x435
}
 800dc22:	e58e      	b.n	800d742 <LoRaMacProcess+0x15a>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 800dc24:	2106      	movs	r1, #6
 800dc26:	2005      	movs	r0, #5
 800dc28:	f7fe fd98 	bl	800c75c <HandleRadioRxErrorTimeout>
}
 800dc2c:	e592      	b.n	800d754 <LoRaMacProcess+0x16c>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800dc2e:	4d40      	ldr	r5, [pc, #256]	@ (800dd30 <LoRaMacProcess+0x748>)
 800dc30:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800dc34:	2b02      	cmp	r3, #2
 800dc36:	d076      	beq.n	800dd26 <LoRaMacProcess+0x73e>
        Radio.Sleep( );
 800dc38:	4b3f      	ldr	r3, [pc, #252]	@ (800dd38 <LoRaMacProcess+0x750>)
 800dc3a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800dc3c:	4798      	blx	r3
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800dc3e:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800dc42:	2b02      	cmp	r3, #2
 800dc44:	d06f      	beq.n	800dd26 <LoRaMacProcess+0x73e>
        MacCtx.RxSlot = RX_SLOT_NONE;
 800dc46:	2306      	movs	r3, #6
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 800dc48:	2002      	movs	r0, #2
 800dc4a:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
 800dc4e:	f884 0435 	strb.w	r0, [r4, #1077]	@ 0x435
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 800dc52:	f002 f889 	bl	800fd68 <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 800dc56:	f894 3410 	ldrb.w	r3, [r4, #1040]	@ 0x410
 800dc5a:	b113      	cbz	r3, 800dc62 <LoRaMacProcess+0x67a>
        MacCtx.AckTimeoutRetry = true;
 800dc5c:	2301      	movs	r3, #1
 800dc5e:	f884 340f 	strb.w	r3, [r4, #1039]	@ 0x40f
    MacCtx.MacFlags.Bits.MacDone = 1;
 800dc62:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800dc66:	f043 0310 	orr.w	r3, r3, #16
 800dc6a:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
}
 800dc6e:	e56e      	b.n	800d74e <LoRaMacProcess+0x166>
    uint8_t *payload = RxDoneParams.Payload;
 800dc70:	4a35      	ldr	r2, [pc, #212]	@ (800dd48 <LoRaMacProcess+0x760>)
    Radio.Sleep( );
 800dc72:	4b31      	ldr	r3, [pc, #196]	@ (800dd38 <LoRaMacProcess+0x750>)
    uint32_t address = Nvm.MacGroup2.DevAddr;
 800dc74:	4d2e      	ldr	r5, [pc, #184]	@ (800dd30 <LoRaMacProcess+0x748>)
    Radio.Sleep( );
 800dc76:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
    uint8_t *payload = RxDoneParams.Payload;
 800dc78:	f8d2 b004 	ldr.w	fp, [r2, #4]
    uint16_t size = RxDoneParams.Size;
 800dc7c:	f8b2 a008 	ldrh.w	sl, [r2, #8]
    int16_t rssi = RxDoneParams.Rssi;
 800dc80:	f9b2 900a 	ldrsh.w	r9, [r2, #10]
    int8_t snr = RxDoneParams.Snr;
 800dc84:	f992 700c 	ldrsb.w	r7, [r2, #12]
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 800dc88:	f894 2480 	ldrb.w	r2, [r4, #1152]	@ 0x480
 800dc8c:	f884 247f 	strb.w	r2, [r4, #1151]	@ 0x47f
    uint32_t downLinkCounter = 0;
 800dc90:	2300      	movs	r3, #0
 800dc92:	933f      	str	r3, [sp, #252]	@ 0xfc
    MacCtx.McpsConfirm.AckReceived = false;
 800dc94:	f884 3438 	strb.w	r3, [r4, #1080]	@ 0x438
    MacCtx.McpsIndication.Multicast = 0;
 800dc98:	f8a4 341a 	strh.w	r3, [r4, #1050]	@ 0x41a
    MacCtx.McpsIndication.IsUplinkTxPending = 0;
 800dc9c:	f884 341d 	strb.w	r3, [r4, #1053]	@ 0x41d
    MacCtx.McpsIndication.Buffer = NULL;
 800dca0:	f8c4 3420 	str.w	r3, [r4, #1056]	@ 0x420
    MacCtx.McpsIndication.BufferSize = 0;
 800dca4:	f884 3424 	strb.w	r3, [r4, #1060]	@ 0x424
    MacCtx.McpsIndication.RxData = false;
 800dca8:	f8a4 3425 	strh.w	r3, [r4, #1061]	@ 0x425
    MacCtx.McpsIndication.DownLinkCounter = 0;
 800dcac:	f8c4 3428 	str.w	r3, [r4, #1064]	@ 0x428
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 800dcb0:	f884 3418 	strb.w	r3, [r4, #1048]	@ 0x418
    MacCtx.McpsIndication.DevAddress = 0;
 800dcb4:	f8c4 342c 	str.w	r3, [r4, #1068]	@ 0x42c
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 800dcb8:	f884 3430 	strb.w	r3, [r4, #1072]	@ 0x430
    MacCtx.RxStatus.Rssi = rssi;
 800dcbc:	f8a4 947c 	strh.w	r9, [r4, #1148]	@ 0x47c
    uint32_t address = Nvm.MacGroup2.DevAddr;
 800dcc0:	f8d5 30e4 	ldr.w	r3, [r5, #228]	@ 0xe4
    MacCtx.RxStatus.Snr = snr;
 800dcc4:	f884 747e 	strb.w	r7, [r4, #1150]	@ 0x47e
    uint32_t address = Nvm.MacGroup2.DevAddr;
 800dcc8:	9302      	str	r3, [sp, #8]
    Radio.Sleep( );
 800dcca:	4788      	blx	r1
    TimerStop( &MacCtx.RxWindowTimer2 );
 800dccc:	481f      	ldr	r0, [pc, #124]	@ (800dd4c <LoRaMacProcess+0x764>)
 800dcce:	f007 fd0d 	bl	80156ec <UTIL_TIMER_Stop>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 800dcd2:	4651      	mov	r1, sl
 800dcd4:	4658      	mov	r0, fp
 800dcd6:	f001 fe33 	bl	800f940 <LoRaMacClassBRxBeacon>
 800dcda:	4680      	mov	r8, r0
 800dcdc:	b9f0      	cbnz	r0, 800dd1c <LoRaMacProcess+0x734>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800dcde:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800dce2:	2b01      	cmp	r3, #1
 800dce4:	f000 80f9 	beq.w	800deda <LoRaMacProcess+0x8f2>
    if( size == 0 )
 800dce8:	f1ba 0f00 	cmp.w	sl, #0
 800dcec:	d010      	beq.n	800dd10 <LoRaMacProcess+0x728>
    macHdr.Value = payload[pktHeaderLen++];
 800dcee:	f89b 8000 	ldrb.w	r8, [fp]
    switch( macHdr.Bits.MType )
 800dcf2:	ea4f 1358 	mov.w	r3, r8, lsr #5
 800dcf6:	3b01      	subs	r3, #1
 800dcf8:	2b06      	cmp	r3, #6
 800dcfa:	f200 80d0 	bhi.w	800de9e <LoRaMacProcess+0x8b6>
 800dcfe:	e8df f013 	tbh	[pc, r3, lsl #1]
 800dd02:	017d      	.short	0x017d
 800dd04:	00fe00ce 	.word	0x00fe00ce
 800dd08:	00fb00ce 	.word	0x00fb00ce
 800dd0c:	01b400ce 	.word	0x01b400ce
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800dd10:	2301      	movs	r3, #1
 800dd12:	f884 3419 	strb.w	r3, [r4, #1049]	@ 0x419
                PrepareRxDoneAbort( );
 800dd16:	f7ff fa05 	bl	800d124 <PrepareRxDoneAbort>
                return;
 800dd1a:	e515      	b.n	800d748 <LoRaMacProcess+0x160>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 800dd1c:	f8a4 9472 	strh.w	r9, [r4, #1138]	@ 0x472
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 800dd20:	f884 7474 	strb.w	r7, [r4, #1140]	@ 0x474
        return;
 800dd24:	e510      	b.n	800d748 <LoRaMacProcess+0x160>
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
 800dd26:	2302      	movs	r3, #2
 800dd28:	e78e      	b.n	800dc48 <LoRaMacProcess+0x660>
 800dd2a:	bf00      	nop
 800dd2c:	20001234 	.word	0x20001234
 800dd30:	20000684 	.word	0x20000684
 800dd34:	20001154 	.word	0x20001154
 800dd38:	08017658 	.word	0x08017658
 800dd3c:	2000067c 	.word	0x2000067c
 800dd40:	20000dec 	.word	0x20000dec
 800dd44:	200011e0 	.word	0x200011e0
 800dd48:	2000066c 	.word	0x2000066c
 800dd4c:	20001184 	.word	0x20001184
 800dd50:	2370      	movs	r3, #112	@ 0x70
 800dd52:	2250      	movs	r2, #80	@ 0x50
 800dd54:	e9cd 3202 	strd	r3, r2, [sp, #8]
 800dd58:	2148      	movs	r1, #72	@ 0x48
 800dd5a:	2368      	movs	r3, #104	@ 0x68
 800dd5c:	e9cd 310a 	strd	r3, r1, [sp, #40]	@ 0x28
 800dd60:	2028      	movs	r0, #40	@ 0x28
 800dd62:	2358      	movs	r3, #88	@ 0x58
 800dd64:	e9cd 3008 	strd	r3, r0, [sp, #32]
 800dd68:	f04f 0c78 	mov.w	ip, #120	@ 0x78
 800dd6c:	2338      	movs	r3, #56	@ 0x38
 800dd6e:	e9cd 3c06 	strd	r3, ip, [sp, #24]
 800dd72:	f04f 0e18 	mov.w	lr, #24
 800dd76:	2308      	movs	r3, #8
 800dd78:	e9cd 3e04 	strd	r3, lr, [sp, #16]
 800dd7c:	2244      	movs	r2, #68	@ 0x44
 800dd7e:	2364      	movs	r3, #100	@ 0x64
 800dd80:	e9cd 321a 	strd	r3, r2, [sp, #104]	@ 0x68
 800dd84:	2124      	movs	r1, #36	@ 0x24
 800dd86:	2354      	movs	r3, #84	@ 0x54
 800dd88:	e9cd 3118 	strd	r3, r1, [sp, #96]	@ 0x60
 800dd8c:	2074      	movs	r0, #116	@ 0x74
 800dd8e:	2334      	movs	r3, #52	@ 0x34
 800dd90:	e9cd 3016 	strd	r3, r0, [sp, #88]	@ 0x58
 800dd94:	f04f 0c14 	mov.w	ip, #20
 800dd98:	234c      	movs	r3, #76	@ 0x4c
 800dd9a:	e9cd 3c14 	strd	r3, ip, [sp, #80]	@ 0x50
 800dd9e:	f04f 0e6c 	mov.w	lr, #108	@ 0x6c
 800dda2:	232c      	movs	r3, #44	@ 0x2c
 800dda4:	e9cd 3e12 	strd	r3, lr, [sp, #72]	@ 0x48
 800dda8:	225c      	movs	r2, #92	@ 0x5c
 800ddaa:	237c      	movs	r3, #124	@ 0x7c
 800ddac:	e9cd 3210 	strd	r3, r2, [sp, #64]	@ 0x40
 800ddb0:	213c      	movs	r1, #60	@ 0x3c
 800ddb2:	231c      	movs	r3, #28
 800ddb4:	e9cd 310e 	strd	r3, r1, [sp, #56]	@ 0x38
 800ddb8:	200c      	movs	r0, #12
 800ddba:	2304      	movs	r3, #4
 800ddbc:	e9cd 300c 	strd	r3, r0, [sp, #48]	@ 0x30
 800ddc0:	f04f 0c42 	mov.w	ip, #66	@ 0x42
 800ddc4:	2362      	movs	r3, #98	@ 0x62
 800ddc6:	e9cd 3c3a 	strd	r3, ip, [sp, #232]	@ 0xe8
 800ddca:	f04f 0e22 	mov.w	lr, #34	@ 0x22
 800ddce:	2352      	movs	r3, #82	@ 0x52
 800ddd0:	e9cd 3e38 	strd	r3, lr, [sp, #224]	@ 0xe0
 800ddd4:	2272      	movs	r2, #114	@ 0x72
 800ddd6:	2332      	movs	r3, #50	@ 0x32
 800ddd8:	e9cd 3236 	strd	r3, r2, [sp, #216]	@ 0xd8
 800dddc:	2112      	movs	r1, #18
 800ddde:	234a      	movs	r3, #74	@ 0x4a
 800dde0:	e9cd 3134 	strd	r3, r1, [sp, #208]	@ 0xd0
 800dde4:	206a      	movs	r0, #106	@ 0x6a
 800dde6:	232a      	movs	r3, #42	@ 0x2a
 800dde8:	e9cd 3032 	strd	r3, r0, [sp, #200]	@ 0xc8
 800ddec:	f04f 0c5a 	mov.w	ip, #90	@ 0x5a
 800ddf0:	237a      	movs	r3, #122	@ 0x7a
 800ddf2:	e9cd 3c30 	strd	r3, ip, [sp, #192]	@ 0xc0
 800ddf6:	f04f 0e3a 	mov.w	lr, #58	@ 0x3a
 800ddfa:	231a      	movs	r3, #26
 800ddfc:	e9cd 3e2e 	strd	r3, lr, [sp, #184]	@ 0xb8
 800de00:	220a      	movs	r2, #10
 800de02:	2346      	movs	r3, #70	@ 0x46
 800de04:	e9cd 322c 	strd	r3, r2, [sp, #176]	@ 0xb0
 800de08:	2166      	movs	r1, #102	@ 0x66
 800de0a:	2326      	movs	r3, #38	@ 0x26
 800de0c:	e9cd 312a 	strd	r3, r1, [sp, #168]	@ 0xa8
 800de10:	2056      	movs	r0, #86	@ 0x56
 800de12:	2376      	movs	r3, #118	@ 0x76
 800de14:	e9cd 3028 	strd	r3, r0, [sp, #160]	@ 0xa0
 800de18:	f04f 0c36 	mov.w	ip, #54	@ 0x36
 800de1c:	2316      	movs	r3, #22
 800de1e:	e9cd 3c26 	strd	r3, ip, [sp, #152]	@ 0x98
 800de22:	f04f 0e4e 	mov.w	lr, #78	@ 0x4e
 800de26:	236e      	movs	r3, #110	@ 0x6e
 800de28:	e9cd 3e24 	strd	r3, lr, [sp, #144]	@ 0x90
 800de2c:	222e      	movs	r2, #46	@ 0x2e
 800de2e:	235e      	movs	r3, #94	@ 0x5e
 800de30:	e9cd 3222 	strd	r3, r2, [sp, #136]	@ 0x88
 800de34:	217e      	movs	r1, #126	@ 0x7e
 800de36:	233e      	movs	r3, #62	@ 0x3e
 800de38:	e9cd 3120 	strd	r3, r1, [sp, #128]	@ 0x80
 800de3c:	201e      	movs	r0, #30
 800de3e:	230e      	movs	r3, #14
 800de40:	e9cd 301e 	strd	r3, r0, [sp, #120]	@ 0x78
 800de44:	f04f 0c06 	mov.w	ip, #6
 800de48:	2302      	movs	r3, #2
 800de4a:	e9cd 3c1c 	strd	r3, ip, [sp, #112]	@ 0x70
 800de4e:	2740      	movs	r7, #64	@ 0x40
 800de50:	f04f 0960 	mov.w	r9, #96	@ 0x60
 800de54:	f04f 0820 	mov.w	r8, #32
 800de58:	f04f 0b30 	mov.w	fp, #48	@ 0x30
 800de5c:	f04f 0a10 	mov.w	sl, #16
 800de60:	e521      	b.n	800d8a6 <LoRaMacProcess+0x2be>
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 800de62:	2b00      	cmp	r3, #0
 800de64:	f43f abed 	beq.w	800d642 <LoRaMacProcess+0x5a>
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 800de68:	2001      	movs	r0, #1
 800de6a:	f001 ff9f 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800de6e:	b130      	cbz	r0, 800de7e <LoRaMacProcess+0x896>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 800de70:	2001      	movs	r0, #1
 800de72:	f001 ff5b 	bl	800fd2c <LoRaMacConfirmQueueGetStatus>
 800de76:	b940      	cbnz	r0, 800de8a <LoRaMacProcess+0x8a2>
                MacCtx.ChannelsNbTransCounter = 0;
 800de78:	f884 040c 	strb.w	r0, [r4, #1036]	@ 0x40c
 800de7c:	e005      	b.n	800de8a <LoRaMacProcess+0x8a2>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 800de7e:	2006      	movs	r0, #6
 800de80:	f001 ff94 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800de84:	2800      	cmp	r0, #0
 800de86:	f000 817e 	beq.w	800e186 <LoRaMacProcess+0xb9e>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800de8a:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 800de8e:	f894 6481 	ldrb.w	r6, [r4, #1153]	@ 0x481
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 800de92:	f023 0302 	bic.w	r3, r3, #2
 800de96:	f8c4 3340 	str.w	r3, [r4, #832]	@ 0x340
 800de9a:	f7ff bbcf 	b.w	800d63c <LoRaMacProcess+0x54>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800de9e:	2301      	movs	r3, #1
 800dea0:	f884 3419 	strb.w	r3, [r4, #1049]	@ 0x419
            PrepareRxDoneAbort( );
 800dea4:	f7ff f93e 	bl	800d124 <PrepareRxDoneAbort>
    if( MacCtx.NodeAckRequested == true )
 800dea8:	f894 3410 	ldrb.w	r3, [r4, #1040]	@ 0x410
 800deac:	2b00      	cmp	r3, #0
 800deae:	f000 80f4 	beq.w	800e09a <LoRaMacProcess+0xab2>
        if( MacCtx.McpsConfirm.AckReceived == true )
 800deb2:	f894 3438 	ldrb.w	r3, [r4, #1080]	@ 0x438
 800deb6:	2b00      	cmp	r3, #0
 800deb8:	f040 810e 	bne.w	800e0d8 <LoRaMacProcess+0xaf0>
    MacCtx.MacFlags.Bits.MacDone = 1;
 800debc:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800dec0:	f895 2118 	ldrb.w	r2, [r5, #280]	@ 0x118
    MacCtx.MacFlags.Bits.MacDone = 1;
 800dec4:	f043 0310 	orr.w	r3, r3, #16
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800dec8:	2a02      	cmp	r2, #2
    MacCtx.MacFlags.Bits.MacDone = 1;
 800deca:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800dece:	f040 80ee 	bne.w	800e0ae <LoRaMacProcess+0xac6>
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
 800ded2:	2302      	movs	r3, #2
 800ded4:	f884 3480 	strb.w	r3, [r4, #1152]	@ 0x480
 800ded8:	e436      	b.n	800d748 <LoRaMacProcess+0x160>
        if( LoRaMacClassBIsPingExpected( ) == true )
 800deda:	f001 fd35 	bl	800f948 <LoRaMacClassBIsPingExpected>
 800dede:	2800      	cmp	r0, #0
 800dee0:	f000 8110 	beq.w	800e104 <LoRaMacProcess+0xb1c>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 800dee4:	4640      	mov	r0, r8
 800dee6:	f001 fd1f 	bl	800f928 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 800deea:	4640      	mov	r0, r8
 800deec:	f001 fd24 	bl	800f938 <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 800def0:	2304      	movs	r3, #4
 800def2:	f884 347f 	strb.w	r3, [r4, #1151]	@ 0x47f
 800def6:	e6f7      	b.n	800dce8 <LoRaMacProcess+0x700>
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 800def8:	2301      	movs	r3, #1
 800defa:	f884 3418 	strb.w	r3, [r4, #1048]	@ 0x418
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800defe:	f895 308c 	ldrb.w	r3, [r5, #140]	@ 0x8c
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800df02:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
 800df06:	330d      	adds	r3, #13
 800df08:	f88d 3100 	strb.w	r3, [sp, #256]	@ 0x100
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800df0c:	f895 307d 	ldrb.w	r3, [r5, #125]	@ 0x7d
 800df10:	f88d 3102 	strb.w	r3, [sp, #258]	@ 0x102
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800df14:	a940      	add	r1, sp, #256	@ 0x100
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 800df16:	f894 341c 	ldrb.w	r3, [r4, #1052]	@ 0x41c
 800df1a:	f88d 3101 	strb.w	r3, [sp, #257]	@ 0x101
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800df1e:	f002 fce7 	bl	80108f0 <RegionGetPhyParam>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 800df22:	f1aa 030d 	sub.w	r3, sl, #13
 800df26:	b21b      	sxth	r3, r3
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800df28:	903e      	str	r0, [sp, #248]	@ 0xf8
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 800df2a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800df2e:	b200      	sxth	r0, r0
 800df30:	4283      	cmp	r3, r0
 800df32:	f73f aeed 	bgt.w	800dd10 <LoRaMacProcess+0x728>
 800df36:	f1ba 0f0b 	cmp.w	sl, #11
 800df3a:	f67f aee9 	bls.w	800dd10 <LoRaMacProcess+0x728>
            macMsgData.FRMPayload = MacCtx.RxPayload;
 800df3e:	4bb9      	ldr	r3, [pc, #740]	@ (800e224 <LoRaMacProcess+0xc3c>)
 800df40:	9359      	str	r3, [sp, #356]	@ 0x164
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 800df42:	a850      	add	r0, sp, #320	@ 0x140
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 800df44:	23ff      	movs	r3, #255	@ 0xff
            macMsgData.BufSize = size;
 800df46:	f88d a144 	strb.w	sl, [sp, #324]	@ 0x144
            macMsgData.Buffer = payload;
 800df4a:	f8cd b140 	str.w	fp, [sp, #320]	@ 0x140
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 800df4e:	f88d 3168 	strb.w	r3, [sp, #360]	@ 0x168
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 800df52:	f002 fbbf 	bl	80106d4 <LoRaMacParserData>
 800df56:	4682      	mov	sl, r0
 800df58:	2800      	cmp	r0, #0
 800df5a:	f47f aed9 	bne.w	800dd10 <LoRaMacProcess+0x728>
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 800df5e:	f89d 114c 	ldrb.w	r1, [sp, #332]	@ 0x14c
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 800df62:	9a52      	ldr	r2, [sp, #328]	@ 0x148
 800df64:	f8c4 242c 	str.w	r2, [r4, #1068]	@ 0x42c
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 800df68:	0708      	lsls	r0, r1, #28
 800df6a:	f040 811f 	bne.w	800e1ac <LoRaMacProcess+0xbc4>
    else if( macMsg->FRMPayloadSize == 0 )
 800df6e:	f89d 3168 	ldrb.w	r3, [sp, #360]	@ 0x168
 800df72:	2b00      	cmp	r3, #0
 800df74:	f000 8124 	beq.w	800e1c0 <LoRaMacProcess+0xbd8>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 800df78:	f89d 3160 	ldrb.w	r3, [sp, #352]	@ 0x160
        *fType = FRAME_TYPE_C;
 800df7c:	2b00      	cmp	r3, #0
 800df7e:	bf14      	ite	ne
 800df80:	2303      	movne	r3, #3
 800df82:	2302      	moveq	r3, #2
 800df84:	4699      	mov	r9, r3
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 800df86:	f8d5 00ec 	ldr.w	r0, [r5, #236]	@ 0xec
            downLinkCounter = 0;
 800df8a:	2300      	movs	r3, #0
 800df8c:	4282      	cmp	r2, r0
 800df8e:	933f      	str	r3, [sp, #252]	@ 0xfc
                    ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) )
 800df90:	f895 30e9 	ldrb.w	r3, [r5, #233]	@ 0xe9
 800df94:	f040 808d 	bne.w	800e0b2 <LoRaMacProcess+0xaca>
    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;
 800df98:	f04f 0b01 	mov.w	fp, #1
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 800df9c:	2b00      	cmp	r3, #0
 800df9e:	f040 8127 	bne.w	800e1f0 <LoRaMacProcess+0xc08>
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 800dfa2:	2315      	movs	r3, #21
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800dfa4:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 800dfa8:	f88d 3100 	strb.w	r3, [sp, #256]	@ 0x100
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800dfac:	a940      	add	r1, sp, #256	@ 0x100
 800dfae:	f002 fc9f 	bl	80108f0 <RegionGetPhyParam>
 800dfb2:	f895 312a 	ldrb.w	r3, [r5, #298]	@ 0x12a
 800dfb6:	903e      	str	r0, [sp, #248]	@ 0xf8
    switch( addrID )
 800dfb8:	f1bb 0f00 	cmp.w	fp, #0
 800dfbc:	f040 81a5 	bne.w	800e30a <LoRaMacProcess+0xd22>
 800dfc0:	2304      	movs	r3, #4
 800dfc2:	9303      	str	r3, [sp, #12]
    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 800dfc4:	b281      	uxth	r1, r0
 800dfc6:	f8bd 214e 	ldrh.w	r2, [sp, #334]	@ 0x14e
 800dfca:	9803      	ldr	r0, [sp, #12]
 800dfcc:	ab3f      	add	r3, sp, #252	@ 0xfc
 800dfce:	f002 f8af 	bl	8010130 <LoRaMacCryptoGetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 800dfd2:	2800      	cmp	r0, #0
 800dfd4:	f000 812c 	beq.w	800e230 <LoRaMacProcess+0xc48>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 800dfd8:	2807      	cmp	r0, #7
 800dfda:	f000 820e 	beq.w	800e3fa <LoRaMacProcess+0xe12>
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 800dfde:	2808      	cmp	r0, #8
 800dfe0:	f040 8197 	bne.w	800e312 <LoRaMacProcess+0xd2a>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 800dfe4:	230a      	movs	r3, #10
 800dfe6:	f884 3419 	strb.w	r3, [r4, #1049]	@ 0x419
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 800dfea:	9b3f      	ldr	r3, [sp, #252]	@ 0xfc
 800dfec:	f8c4 3428 	str.w	r3, [r4, #1064]	@ 0x428
                MacCtx.MlmeIndication.DownLinkCounter = downLinkCounter;
 800dff0:	f8c4 3460 	str.w	r3, [r4, #1120]	@ 0x460
                PrepareRxDoneAbort( );
 800dff4:	f7ff f896 	bl	800d124 <PrepareRxDoneAbort>
                return;
 800dff8:	f7ff bba6 	b.w	800d748 <LoRaMacProcess+0x160>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 800dffc:	f1ba 0f10 	cmp.w	sl, #16
 800e000:	f67f ae86 	bls.w	800dd10 <LoRaMacProcess+0x728>
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 800e004:	f895 312c 	ldrb.w	r3, [r5, #300]	@ 0x12c
            macMsgJoinAccept.Buffer = payload;
 800e008:	f8cd b118 	str.w	fp, [sp, #280]	@ 0x118
            macMsgJoinAccept.BufSize = size;
 800e00c:	fa5f fa8a 	uxtb.w	sl, sl
 800e010:	f88d a11c 	strb.w	sl, [sp, #284]	@ 0x11c
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 800e014:	2b00      	cmp	r3, #0
 800e016:	f47f ae7b 	bne.w	800dd10 <LoRaMacProcess+0x728>
            SecureElementGetJoinEui( joinEui );
 800e01a:	a850      	add	r0, sp, #320	@ 0x140
 800e01c:	f7fd fcd8 	bl	800b9d0 <SecureElementGetJoinEui>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, joinEui, &macMsgJoinAccept );
 800e020:	a950      	add	r1, sp, #320	@ 0x140
 800e022:	aa46      	add	r2, sp, #280	@ 0x118
 800e024:	20ff      	movs	r0, #255	@ 0xff
 800e026:	f002 f941 	bl	80102ac <LoRaMacCryptoHandleJoinAccept>
            verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800e02a:	f89d 3128 	ldrb.w	r3, [sp, #296]	@ 0x128
 800e02e:	f3c3 0303 	ubfx	r3, r3, #0, #4
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, joinEui, &macMsgJoinAccept );
 800e032:	4607      	mov	r7, r0
            verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800e034:	f88d 3100 	strb.w	r3, [sp, #256]	@ 0x100
            rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );
 800e038:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verifyRxDr.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800e03c:	f895 307d 	ldrb.w	r3, [r5, #125]	@ 0x7d
 800e040:	f88d 3101 	strb.w	r3, [sp, #257]	@ 0x101
            rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );
 800e044:	2207      	movs	r2, #7
 800e046:	a940      	add	r1, sp, #256	@ 0x100
 800e048:	f002 fc68 	bl	801091c <RegionVerify>
            if( ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) && ( rxDrValid == true ) )
 800e04c:	b917      	cbnz	r7, 800e054 <LoRaMacProcess+0xa6c>
 800e04e:	2800      	cmp	r0, #0
 800e050:	f040 8165 	bne.w	800e31e <LoRaMacProcess+0xd36>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 800e054:	2001      	movs	r0, #1
 800e056:	f001 fea9 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800e05a:	2800      	cmp	r0, #0
 800e05c:	f43f af24 	beq.w	800dea8 <LoRaMacProcess+0x8c0>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 800e060:	2101      	movs	r1, #1
 800e062:	2007      	movs	r0, #7
 800e064:	f001 fe46 	bl	800fcf4 <LoRaMacConfirmQueueSetStatus>
 800e068:	e71e      	b.n	800dea8 <LoRaMacProcess+0x8c0>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 800e06a:	4f6e      	ldr	r7, [pc, #440]	@ (800e224 <LoRaMacProcess+0xc3c>)
 800e06c:	f10a 3aff 	add.w	sl, sl, #4294967295
 800e070:	f10b 0101 	add.w	r1, fp, #1
 800e074:	fa1f f28a 	uxth.w	r2, sl
 800e078:	4638      	mov	r0, r7
 800e07a:	f004 f903 	bl	8012284 <memcpy1>
            MacCtx.MacFlags.Bits.McpsInd = 1;
 800e07e:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 800e082:	f8c4 7420 	str.w	r7, [r4, #1056]	@ 0x420
            MacCtx.MacFlags.Bits.McpsInd = 1;
 800e086:	f043 0302 	orr.w	r3, r3, #2
 800e08a:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 800e08e:	2303      	movs	r3, #3
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 800e090:	f884 a424 	strb.w	sl, [r4, #1060]	@ 0x424
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 800e094:	f8a4 3418 	strh.w	r3, [r4, #1048]	@ 0x418
            break;
 800e098:	e706      	b.n	800dea8 <LoRaMacProcess+0x8c0>
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800e09a:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800e09e:	2b02      	cmp	r3, #2
 800e0a0:	d01a      	beq.n	800e0d8 <LoRaMacProcess+0xaf0>
    MacCtx.MacFlags.Bits.MacDone = 1;
 800e0a2:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800e0a6:	f043 0310 	orr.w	r3, r3, #16
 800e0aa:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
        MacCtx.RxSlot = RX_SLOT_NONE;
 800e0ae:	2306      	movs	r3, #6
 800e0b0:	e710      	b.n	800ded4 <LoRaMacProcess+0x8ec>
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 800e0b2:	2315      	movs	r3, #21
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e0b4:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 800e0b8:	f88d 3100 	strb.w	r3, [sp, #256]	@ 0x100
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e0bc:	a940      	add	r1, sp, #256	@ 0x100
 800e0be:	f002 fc17 	bl	80108f0 <RegionGetPhyParam>
 800e0c2:	f895 312a 	ldrb.w	r3, [r5, #298]	@ 0x12a
 800e0c6:	903e      	str	r0, [sp, #248]	@ 0xf8
            if( lrWanVersion.Fields.Minor == 1 )
 800e0c8:	2b01      	cmp	r3, #1
 800e0ca:	f000 81d8 	beq.w	800e47e <LoRaMacProcess+0xe96>
                *fCntID = FCNT_DOWN;
 800e0ce:	2303      	movs	r3, #3
 800e0d0:	f04f 0b01 	mov.w	fp, #1
 800e0d4:	9303      	str	r3, [sp, #12]
 800e0d6:	e775      	b.n	800dfc4 <LoRaMacProcess+0x9dc>
    TimerStop( &MacCtx.AckTimeoutTimer );
 800e0d8:	4853      	ldr	r0, [pc, #332]	@ (800e228 <LoRaMacProcess+0xc40>)
 800e0da:	f007 fb07 	bl	80156ec <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 800e0de:	f894 3410 	ldrb.w	r3, [r4, #1040]	@ 0x410
 800e0e2:	b113      	cbz	r3, 800e0ea <LoRaMacProcess+0xb02>
        MacCtx.AckTimeoutRetry = true;
 800e0e4:	2301      	movs	r3, #1
 800e0e6:	f884 340f 	strb.w	r3, [r4, #1039]	@ 0x40f
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800e0ea:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800e0ee:	2b02      	cmp	r3, #2
 800e0f0:	d069      	beq.n	800e1c6 <LoRaMacProcess+0xbde>
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800e0f2:	f8d4 3348 	ldr.w	r3, [r4, #840]	@ 0x348
 800e0f6:	2b00      	cmp	r3, #0
 800e0f8:	d0d3      	beq.n	800e0a2 <LoRaMacProcess+0xaba>
 800e0fa:	695b      	ldr	r3, [r3, #20]
 800e0fc:	2b00      	cmp	r3, #0
 800e0fe:	d0d0      	beq.n	800e0a2 <LoRaMacProcess+0xaba>
        MacCtx.MacCallbacks->MacProcessNotify( );
 800e100:	4798      	blx	r3
 800e102:	e6db      	b.n	800debc <LoRaMacProcess+0x8d4>
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 800e104:	9003      	str	r0, [sp, #12]
 800e106:	f001 fc21 	bl	800f94c <LoRaMacClassBIsMulticastExpected>
 800e10a:	9b03      	ldr	r3, [sp, #12]
 800e10c:	2800      	cmp	r0, #0
 800e10e:	f43f adeb 	beq.w	800dce8 <LoRaMacProcess+0x700>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 800e112:	4618      	mov	r0, r3
 800e114:	f001 fc0a 	bl	800f92c <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 800e118:	9b03      	ldr	r3, [sp, #12]
 800e11a:	4618      	mov	r0, r3
 800e11c:	f001 fc0e 	bl	800f93c <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 800e120:	2305      	movs	r3, #5
 800e122:	f884 347f 	strb.w	r3, [r4, #1151]	@ 0x47f
 800e126:	e5df      	b.n	800dce8 <LoRaMacProcess+0x700>
            if( MacCtx.AckTimeoutRetry == true )
 800e128:	f894 340f 	ldrb.w	r3, [r4, #1039]	@ 0x40f
 800e12c:	b3bb      	cbz	r3, 800e19e <LoRaMacProcess+0xbb6>
    if( MacCtx.AckTimeoutRetriesCounter >=
 800e12e:	f894 340e 	ldrb.w	r3, [r4, #1038]	@ 0x40e
 800e132:	f894 240d 	ldrb.w	r2, [r4, #1037]	@ 0x40d
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 800e136:	4d3d      	ldr	r5, [pc, #244]	@ (800e22c <LoRaMacProcess+0xc44>)
    if( MacCtx.AckTimeoutRetriesCounter >=
 800e138:	429a      	cmp	r2, r3
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 800e13a:	f895 112a 	ldrb.w	r1, [r5, #298]	@ 0x12a
    if( MacCtx.AckTimeoutRetriesCounter >=
 800e13e:	f240 8138 	bls.w	800e3b2 <LoRaMacProcess+0xdca>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 800e142:	07b0      	lsls	r0, r6, #30
 800e144:	f100 8153 	bmi.w	800e3ee <LoRaMacProcess+0xe06>
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 800e148:	2900      	cmp	r1, #0
 800e14a:	f47f aa85 	bne.w	800d658 <LoRaMacProcess+0x70>
        MacCtx.AckTimeoutRetriesCounter++;
 800e14e:	3301      	adds	r3, #1
 800e150:	b2db      	uxtb	r3, r3
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 800e152:	07d9      	lsls	r1, r3, #31
        MacCtx.AckTimeoutRetriesCounter++;
 800e154:	f884 340e 	strb.w	r3, [r4, #1038]	@ 0x40e
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 800e158:	f57f aa7e 	bpl.w	800d658 <LoRaMacProcess+0x70>
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 800e15c:	2122      	movs	r1, #34	@ 0x22
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800e15e:	f895 207c 	ldrb.w	r2, [r5, #124]	@ 0x7c
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800e162:	f895 3039 	ldrb.w	r3, [r5, #57]	@ 0x39
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 800e166:	f88d 1140 	strb.w	r1, [sp, #320]	@ 0x140
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e16a:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800e16e:	f88d 2142 	strb.w	r2, [sp, #322]	@ 0x142
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e172:	a950      	add	r1, sp, #320	@ 0x140
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800e174:	f88d 3141 	strb.w	r3, [sp, #321]	@ 0x141
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e178:	f002 fbba 	bl	80108f0 <RegionGetPhyParam>
 800e17c:	9046      	str	r0, [sp, #280]	@ 0x118
            Nvm.MacGroup1.ChannelsDatarate = phyParam.Value;
 800e17e:	f885 0039 	strb.w	r0, [r5, #57]	@ 0x39
        if( stopRetransmission == true )
 800e182:	f7ff ba69 	b.w	800d658 <LoRaMacProcess+0x70>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 800e186:	2007      	movs	r0, #7
 800e188:	f001 fe10 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 800e18c:	2800      	cmp	r0, #0
 800e18e:	f47f ae7c 	bne.w	800de8a <LoRaMacProcess+0x8a2>
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 800e192:	f894 6481 	ldrb.w	r6, [r4, #1153]	@ 0x481
 800e196:	f006 0301 	and.w	r3, r6, #1
 800e19a:	f7ff ba51 	b.w	800d640 <LoRaMacProcess+0x58>
    if( MacCtx.MacState == LORAMAC_IDLE )
 800e19e:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
 800e1a2:	2b00      	cmp	r3, #0
 800e1a4:	f43f aa6a 	beq.w	800d67c <LoRaMacProcess+0x94>
 800e1a8:	f7ff ba91 	b.w	800d6ce <LoRaMacProcess+0xe6>
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 800e1ac:	f89d 3160 	ldrb.w	r3, [sp, #352]	@ 0x160
 800e1b0:	2b00      	cmp	r3, #0
 800e1b2:	f040 80b2 	bne.w	800e31a <LoRaMacProcess+0xd32>
    else if( macMsg->FRMPayloadSize == 0 )
 800e1b6:	f89d 3168 	ldrb.w	r3, [sp, #360]	@ 0x168
 800e1ba:	2b00      	cmp	r3, #0
 800e1bc:	f47f ada8 	bne.w	800dd10 <LoRaMacProcess+0x728>
        *fType = FRAME_TYPE_B;
 800e1c0:	2301      	movs	r3, #1
 800e1c2:	4699      	mov	r9, r3
 800e1c4:	e6df      	b.n	800df86 <LoRaMacProcess+0x99e>
        MacCtx.MacFlags.Bits.MacDone = 1;
 800e1c6:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800e1ca:	f8d4 2348 	ldr.w	r2, [r4, #840]	@ 0x348
        MacCtx.MacFlags.Bits.MacDone = 1;
 800e1ce:	f043 0310 	orr.w	r3, r3, #16
 800e1d2:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800e1d6:	2a00      	cmp	r2, #0
 800e1d8:	f43f ae7b 	beq.w	800ded2 <LoRaMacProcess+0x8ea>
 800e1dc:	6953      	ldr	r3, [r2, #20]
 800e1de:	2b00      	cmp	r3, #0
 800e1e0:	d18e      	bne.n	800e100 <LoRaMacProcess+0xb18>
    MacCtx.MacFlags.Bits.MacDone = 1;
 800e1e2:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800e1e6:	f043 0310 	orr.w	r3, r3, #16
 800e1ea:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800e1ee:	e670      	b.n	800ded2 <LoRaMacProcess+0x8ea>
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 800e1f0:	f8d5 310c 	ldr.w	r3, [r5, #268]	@ 0x10c
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 800e1f4:	f895 b0ea 	ldrb.w	fp, [r5, #234]	@ 0xea
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 800e1f8:	681b      	ldr	r3, [r3, #0]
 800e1fa:	933f      	str	r3, [sp, #252]	@ 0xfc
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800e1fc:	f895 3118 	ldrb.w	r3, [r5, #280]	@ 0x118
 800e200:	2b02      	cmp	r3, #2
 800e202:	d102      	bne.n	800e20a <LoRaMacProcess+0xc22>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 800e204:	2303      	movs	r3, #3
 800e206:	f884 347f 	strb.w	r3, [r4, #1151]	@ 0x47f
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 800e20a:	464b      	mov	r3, r9
 800e20c:	2b03      	cmp	r3, #3
 800e20e:	f47f ad7f 	bne.w	800dd10 <LoRaMacProcess+0x728>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 800e212:	f011 0f60 	tst.w	r1, #96	@ 0x60
 800e216:	f47f ad7b 	bne.w	800dd10 <LoRaMacProcess+0x728>
 800e21a:	9002      	str	r0, [sp, #8]
 800e21c:	f04f 0a01 	mov.w	sl, #1
 800e220:	e6bf      	b.n	800dfa2 <LoRaMacProcess+0x9ba>
 800e222:	bf00      	nop
 800e224:	20001024 	.word	0x20001024
 800e228:	200011e0 	.word	0x200011e0
 800e22c:	20000684 	.word	0x20000684
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 800e230:	ab50      	add	r3, sp, #320	@ 0x140
 800e232:	9300      	str	r3, [sp, #0]
 800e234:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
 800e238:	9b3f      	ldr	r3, [sp, #252]	@ 0xfc
 800e23a:	4658      	mov	r0, fp
 800e23c:	f002 f962 	bl	8010504 <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 800e240:	2800      	cmp	r0, #0
 800e242:	f040 80f1 	bne.w	800e428 <LoRaMacProcess+0xe40>
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 800e246:	f89d 314c 	ldrb.w	r3, [sp, #332]	@ 0x14c
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 800e24a:	9a3f      	ldr	r2, [sp, #252]	@ 0xfc
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 800e24c:	f884 0419 	strb.w	r0, [r4, #1049]	@ 0x419
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 800e250:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800e254:	f884 3426 	strb.w	r3, [r4, #1062]	@ 0x426
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 800e258:	f884 3438 	strb.w	r3, [r4, #1080]	@ 0x438
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 800e25c:	f894 347f 	ldrb.w	r3, [r4, #1151]	@ 0x47f
            MacCtx.McpsIndication.Multicast = multicast;
 800e260:	f884 a41a 	strb.w	sl, [r4, #1050]	@ 0x41a
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 800e264:	2b01      	cmp	r3, #1
                Nvm.MacGroup1.AdrAckCounter = 0;
 800e266:	bf98      	it	ls
 800e268:	62a8      	strls	r0, [r5, #40]	@ 0x28
            if( multicast == 1 )
 800e26a:	f1ba 0f01 	cmp.w	sl, #1
            MacCtx.McpsIndication.Buffer = NULL;
 800e26e:	f8c4 0420 	str.w	r0, [r4, #1056]	@ 0x420
            MacCtx.McpsIndication.BufferSize = 0;
 800e272:	f884 0424 	strb.w	r0, [r4, #1060]	@ 0x424
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 800e276:	f884 0435 	strb.w	r0, [r4, #1077]	@ 0x435
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 800e27a:	f8c4 2428 	str.w	r2, [r4, #1064]	@ 0x428
            MacCtx.MlmeIndication.DownLinkCounter = downLinkCounter;
 800e27e:	f8c4 2460 	str.w	r2, [r4, #1120]	@ 0x460
            if( multicast == 1 )
 800e282:	f000 80f3 	beq.w	800e46c <LoRaMacProcess+0xe84>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 800e286:	f008 08e0 	and.w	r8, r8, #224	@ 0xe0
 800e28a:	f1b8 0fa0 	cmp.w	r8, #160	@ 0xa0
 800e28e:	f000 8102 	beq.w	800e496 <LoRaMacProcess+0xeae>
                    Nvm.MacGroup1.SrvAckRequested = false;
 800e292:	2200      	movs	r2, #0
 800e294:	f885 203a 	strb.w	r2, [r5, #58]	@ 0x3a
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 800e298:	f884 2418 	strb.w	r2, [r4, #1048]	@ 0x418
            if( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) )
 800e29c:	f89d 214c 	ldrb.w	r2, [sp, #332]	@ 0x14c
 800e2a0:	06d1      	lsls	r1, r2, #27
 800e2a2:	d505      	bpl.n	800e2b0 <LoRaMacProcess+0xcc8>
 800e2a4:	f895 2118 	ldrb.w	r2, [r5, #280]	@ 0x118
 800e2a8:	b912      	cbnz	r2, 800e2b0 <LoRaMacProcess+0xcc8>
                MacCtx.McpsIndication.IsUplinkTxPending = 1;
 800e2aa:	2201      	movs	r2, #1
 800e2ac:	f884 241d 	strb.w	r2, [r4, #1053]	@ 0x41d
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 800e2b0:	2b01      	cmp	r3, #1
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 800e2b2:	f894 1434 	ldrb.w	r1, [r4, #1076]	@ 0x434
 800e2b6:	f89d 214c 	ldrb.w	r2, [sp, #332]	@ 0x14c
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 800e2ba:	f240 80cf 	bls.w	800e45c <LoRaMacProcess+0xe74>
            switch( fType )
 800e2be:	464b      	mov	r3, r9
 800e2c0:	2b02      	cmp	r3, #2
 800e2c2:	f000 80c0 	beq.w	800e446 <LoRaMacProcess+0xe5e>
 800e2c6:	2b03      	cmp	r3, #3
 800e2c8:	d00a      	beq.n	800e2e0 <LoRaMacProcess+0xcf8>
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 800e2ca:	f89d 114c 	ldrb.w	r1, [sp, #332]	@ 0x14c
 800e2ce:	2b01      	cmp	r3, #1
 800e2d0:	463a      	mov	r2, r7
 800e2d2:	f001 010f 	and.w	r1, r1, #15
 800e2d6:	a854      	add	r0, sp, #336	@ 0x150
 800e2d8:	f000 80b9 	beq.w	800e44e <LoRaMacProcess+0xe66>
 800e2dc:	f7fe fc34 	bl	800cb48 <ProcessMacCommands.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 800e2e0:	f89d 2160 	ldrb.w	r2, [sp, #352]	@ 0x160
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 800e2e4:	9b59      	ldr	r3, [sp, #356]	@ 0x164
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 800e2e6:	f884 241b 	strb.w	r2, [r4, #1051]	@ 0x41b
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 800e2ea:	f8c4 3420 	str.w	r3, [r4, #1056]	@ 0x420
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 800e2ee:	f89d 2168 	ldrb.w	r2, [sp, #360]	@ 0x168
 800e2f2:	f884 2424 	strb.w	r2, [r4, #1060]	@ 0x424
                    MacCtx.McpsIndication.RxData = true;
 800e2f6:	2301      	movs	r3, #1
 800e2f8:	f884 3425 	strb.w	r3, [r4, #1061]	@ 0x425
            MacCtx.MacFlags.Bits.McpsInd = 1;
 800e2fc:	f894 3481 	ldrb.w	r3, [r4, #1153]	@ 0x481
 800e300:	f043 0302 	orr.w	r3, r3, #2
 800e304:	f884 3481 	strb.w	r3, [r4, #1153]	@ 0x481
            break;
 800e308:	e5ce      	b.n	800dea8 <LoRaMacProcess+0x8c0>
    switch( addrID )
 800e30a:	f1bb 0f01 	cmp.w	fp, #1
 800e30e:	f43f aedb 	beq.w	800e0c8 <LoRaMacProcess+0xae0>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800e312:	2301      	movs	r3, #1
 800e314:	f884 3419 	strb.w	r3, [r4, #1049]	@ 0x419
 800e318:	e667      	b.n	800dfea <LoRaMacProcess+0xa02>
        *fType = FRAME_TYPE_A;
 800e31a:	46d1      	mov	r9, sl
 800e31c:	e633      	b.n	800df86 <LoRaMacProcess+0x99e>
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 800e31e:	f89d 3123 	ldrb.w	r3, [sp, #291]	@ 0x123
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 800e322:	f89d 2122 	ldrb.w	r2, [sp, #290]	@ 0x122
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 800e326:	9949      	ldr	r1, [sp, #292]	@ 0x124
 800e328:	f8c5 10e4 	str.w	r1, [r5, #228]	@ 0xe4
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 800e32c:	041b      	lsls	r3, r3, #16
 800e32e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 800e332:	f89d 2121 	ldrb.w	r2, [sp, #289]	@ 0x121
                SecureElementSetDevAddr( ACTIVATION_TYPE_OTAA, Nvm.MacGroup2.DevAddr );
 800e336:	2002      	movs	r0, #2
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 800e338:	4313      	orrs	r3, r2
 800e33a:	f8c5 30e0 	str.w	r3, [r5, #224]	@ 0xe0
                SecureElementSetDevAddr( ACTIVATION_TYPE_OTAA, Nvm.MacGroup2.DevAddr );
 800e33e:	f7fd fb55 	bl	800b9ec <SecureElementSetDevAddr>
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 800e342:	f89d 3129 	ldrb.w	r3, [sp, #297]	@ 0x129
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 800e346:	f89d 2128 	ldrb.w	r2, [sp, #296]	@ 0x128
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 800e34a:	f885 712a 	strb.w	r7, [r5, #298]	@ 0x12a
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 800e34e:	2b01      	cmp	r3, #1
 800e350:	bf38      	it	cc
 800e352:	2301      	movcc	r3, #1
 800e354:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800e358:	fb00 f303 	mul.w	r3, r0, r3
 800e35c:	65ab      	str	r3, [r5, #88]	@ 0x58
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 800e35e:	4403      	add	r3, r0
 800e360:	65eb      	str	r3, [r5, #92]	@ 0x5c
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800e362:	f3c2 0303 	ubfx	r3, r2, #0, #4
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 800e366:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800e36a:	f885 3070 	strb.w	r3, [r5, #112]	@ 0x70
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 800e36e:	f3c2 1202 	ubfx	r2, r2, #4, #3
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800e372:	f885 3078 	strb.w	r3, [r5, #120]	@ 0x78
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = 1;
 800e376:	f04f 0801 	mov.w	r8, #1
                applyCFList.Payload = macMsgJoinAccept.CFList;
 800e37a:	f50d 7395 	add.w	r3, sp, #298	@ 0x12a
                applyCFList.Size = size - 17;
 800e37e:	f1aa 0a11 	sub.w	sl, sl, #17
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 800e382:	a944      	add	r1, sp, #272	@ 0x110
                applyCFList.Payload = macMsgJoinAccept.CFList;
 800e384:	9344      	str	r3, [sp, #272]	@ 0x110
                applyCFList.Size = size - 17;
 800e386:	f88d a114 	strb.w	sl, [sp, #276]	@ 0x114
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 800e38a:	f885 2069 	strb.w	r2, [r5, #105]	@ 0x69
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = 1;
 800e38e:	f885 8068 	strb.w	r8, [r5, #104]	@ 0x68
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 800e392:	f002 facd 	bl	8010930 <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 800e396:	2302      	movs	r3, #2
                if( LoRaMacConfirmQueueIsCmdActive( joinType ) == true )
 800e398:	4640      	mov	r0, r8
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 800e39a:	f885 312c 	strb.w	r3, [r5, #300]	@ 0x12c
                if( LoRaMacConfirmQueueIsCmdActive( joinType ) == true )
 800e39e:	f001 fd05 	bl	800fdac <LoRaMacConfirmQueueIsCmdActive>
 800e3a2:	2800      	cmp	r0, #0
 800e3a4:	f43f ad80 	beq.w	800dea8 <LoRaMacProcess+0x8c0>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, joinType );
 800e3a8:	4641      	mov	r1, r8
 800e3aa:	4638      	mov	r0, r7
 800e3ac:	f001 fca2 	bl	800fcf4 <LoRaMacConfirmQueueSetStatus>
 800e3b0:	e57a      	b.n	800dea8 <LoRaMacProcess+0x8c0>
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 800e3b2:	2900      	cmp	r1, #0
 800e3b4:	f47f aba1 	bne.w	800dafa <LoRaMacProcess+0x512>
    if( MacCtx.McpsConfirm.AckReceived == false )
 800e3b8:	f894 6438 	ldrb.w	r6, [r4, #1080]	@ 0x438
 800e3bc:	b98e      	cbnz	r6, 800e3e2 <LoRaMacProcess+0xdfa>
        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 800e3be:	2302      	movs	r3, #2
 800e3c0:	f88d 3148 	strb.w	r3, [sp, #328]	@ 0x148
        params.NvmGroup1 = &Nvm.RegionGroup1;
 800e3c4:	f505 7308 	add.w	r3, r5, #544	@ 0x220
 800e3c8:	9350      	str	r3, [sp, #320]	@ 0x140
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800e3ca:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
        params.NvmGroup2 = &Nvm.RegionGroup2;
 800e3ce:	f505 732d 	add.w	r3, r5, #692	@ 0x2b4
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800e3d2:	a950      	add	r1, sp, #320	@ 0x140
        params.NvmGroup2 = &Nvm.RegionGroup2;
 800e3d4:	9351      	str	r3, [sp, #324]	@ 0x144
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800e3d6:	f002 fa9b 	bl	8010910 <RegionInitDefaults>
        MacCtx.NodeAckRequested = false;
 800e3da:	f884 6410 	strb.w	r6, [r4, #1040]	@ 0x410
        MacCtx.McpsConfirm.AckReceived = false;
 800e3de:	f884 6438 	strb.w	r6, [r4, #1080]	@ 0x438
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 800e3e2:	f894 340e 	ldrb.w	r3, [r4, #1038]	@ 0x40e
 800e3e6:	f884 3439 	strb.w	r3, [r4, #1081]	@ 0x439
        if( stopRetransmission == true )
 800e3ea:	f7ff bb86 	b.w	800dafa <LoRaMacProcess+0x512>
        if( MacCtx.McpsConfirm.AckReceived == true )
 800e3ee:	f894 2438 	ldrb.w	r2, [r4, #1080]	@ 0x438
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 800e3f2:	bb19      	cbnz	r1, 800e43c <LoRaMacProcess+0xe54>
                    if( stopRetransmission == false )
 800e3f4:	2a00      	cmp	r2, #0
 800e3f6:	d1f4      	bne.n	800e3e2 <LoRaMacProcess+0xdfa>
 800e3f8:	e6a9      	b.n	800e14e <LoRaMacProcess+0xb66>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 800e3fa:	2308      	movs	r3, #8
 800e3fc:	f884 3419 	strb.w	r3, [r4, #1049]	@ 0x419
                    if( ( Nvm.MacGroup2.Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( Nvm.MacGroup1.LastRxMic == macMsgData.MIC ) )
 800e400:	f895 312a 	ldrb.w	r3, [r5, #298]	@ 0x12a
 800e404:	2b00      	cmp	r3, #0
 800e406:	f47f adf0 	bne.w	800dfea <LoRaMacProcess+0xa02>
 800e40a:	f008 08e0 	and.w	r8, r8, #224	@ 0xe0
 800e40e:	f1b8 0fa0 	cmp.w	r8, #160	@ 0xa0
 800e412:	f47f adea 	bne.w	800dfea <LoRaMacProcess+0xa02>
 800e416:	6b6a      	ldr	r2, [r5, #52]	@ 0x34
 800e418:	9b5b      	ldr	r3, [sp, #364]	@ 0x16c
 800e41a:	429a      	cmp	r2, r3
 800e41c:	f47f ade5 	bne.w	800dfea <LoRaMacProcess+0xa02>
                        Nvm.MacGroup1.SrvAckRequested = true;
 800e420:	2301      	movs	r3, #1
 800e422:	f885 303a 	strb.w	r3, [r5, #58]	@ 0x3a
 800e426:	e5e0      	b.n	800dfea <LoRaMacProcess+0xa02>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;
 800e428:	2802      	cmp	r0, #2
 800e42a:	bf14      	ite	ne
 800e42c:	230c      	movne	r3, #12
 800e42e:	230b      	moveq	r3, #11
 800e430:	f884 3419 	strb.w	r3, [r4, #1049]	@ 0x419
                PrepareRxDoneAbort( );
 800e434:	f7fe fe76 	bl	800d124 <PrepareRxDoneAbort>
                return;
 800e438:	f7ff b986 	b.w	800d748 <LoRaMacProcess+0x160>
        if( stopRetransmission == true )
 800e43c:	2a00      	cmp	r2, #0
 800e43e:	f43f a90b 	beq.w	800d658 <LoRaMacProcess+0x70>
 800e442:	f7ff bb5a 	b.w	800dafa <LoRaMacProcess+0x512>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 800e446:	f89d 1168 	ldrb.w	r1, [sp, #360]	@ 0x168
 800e44a:	9859      	ldr	r0, [sp, #356]	@ 0x164
 800e44c:	463a      	mov	r2, r7
 800e44e:	f7fe fb7b 	bl	800cb48 <ProcessMacCommands.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 800e452:	f89d 3160 	ldrb.w	r3, [sp, #352]	@ 0x160
 800e456:	f884 341b 	strb.w	r3, [r4, #1051]	@ 0x41b
                    break;
 800e45a:	e74f      	b.n	800e2fc <LoRaMacProcess+0xd14>
        if( request == MCPS_CONFIRMED )
 800e45c:	2901      	cmp	r1, #1
 800e45e:	d102      	bne.n	800e466 <LoRaMacProcess+0xe7e>
            if( fCtrl.Bits.Ack == 1 )
 800e460:	0692      	lsls	r2, r2, #26
 800e462:	f57f af2c 	bpl.w	800e2be <LoRaMacProcess+0xcd6>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 800e466:	f001 fb5f 	bl	800fb28 <LoRaMacCommandsRemoveStickyAnsCmds>
 800e46a:	e728      	b.n	800e2be <LoRaMacProcess+0xcd6>
            if( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) )
 800e46c:	f895 203a 	ldrb.w	r2, [r5, #58]	@ 0x3a
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 800e470:	2102      	movs	r1, #2
 800e472:	f884 1418 	strb.w	r1, [r4, #1048]	@ 0x418
            if( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) )
 800e476:	2a00      	cmp	r2, #0
 800e478:	f47f af14 	bne.w	800e2a4 <LoRaMacProcess+0xcbc>
 800e47c:	e70e      	b.n	800e29c <LoRaMacProcess+0xcb4>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 800e47e:	469b      	mov	fp, r3
 800e480:	464a      	mov	r2, r9
 800e482:	f06f 0309 	mvn.w	r3, #9
 800e486:	4113      	asrs	r3, r2
 800e488:	f003 0301 	and.w	r3, r3, #1
 800e48c:	f1c3 0302 	rsb	r3, r3, #2
 800e490:	b2db      	uxtb	r3, r3
 800e492:	9303      	str	r3, [sp, #12]
 800e494:	e596      	b.n	800dfc4 <LoRaMacProcess+0x9dc>
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 800e496:	f895 212a 	ldrb.w	r2, [r5, #298]	@ 0x12a
                    Nvm.MacGroup1.SrvAckRequested = true;
 800e49a:	2101      	movs	r1, #1
 800e49c:	f885 103a 	strb.w	r1, [r5, #58]	@ 0x3a
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 800e4a0:	b90a      	cbnz	r2, 800e4a6 <LoRaMacProcess+0xebe>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 800e4a2:	9a5b      	ldr	r2, [sp, #364]	@ 0x16c
 800e4a4:	636a      	str	r2, [r5, #52]	@ 0x34
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 800e4a6:	2201      	movs	r2, #1
 800e4a8:	f884 2418 	strb.w	r2, [r4, #1048]	@ 0x418
            if( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) )
 800e4ac:	e6fa      	b.n	800e2a4 <LoRaMacProcess+0xcbc>
 800e4ae:	bf00      	nop

0800e4b0 <LoRaMacInitialization>:
    }
    return 0;
}

LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 800e4b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e4b4:	b08a      	sub	sp, #40	@ 0x28
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 800e4b6:	2800      	cmp	r0, #0
 800e4b8:	f000 8188 	beq.w	800e7cc <LoRaMacInitialization+0x31c>
 800e4bc:	4688      	mov	r8, r1
 800e4be:	2900      	cmp	r1, #0
 800e4c0:	f000 8184 	beq.w	800e7cc <LoRaMacInitialization+0x31c>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 800e4c4:	6803      	ldr	r3, [r0, #0]
 800e4c6:	4605      	mov	r5, r0
 800e4c8:	2b00      	cmp	r3, #0
 800e4ca:	f000 817f 	beq.w	800e7cc <LoRaMacInitialization+0x31c>
 800e4ce:	6843      	ldr	r3, [r0, #4]
 800e4d0:	2b00      	cmp	r3, #0
 800e4d2:	f000 817b 	beq.w	800e7cc <LoRaMacInitialization+0x31c>
        ( primitives->MacMcpsIndication == NULL ) ||
 800e4d6:	6883      	ldr	r3, [r0, #8]
 800e4d8:	2b00      	cmp	r3, #0
 800e4da:	f000 8177 	beq.w	800e7cc <LoRaMacInitialization+0x31c>
        ( primitives->MacMlmeConfirm == NULL ) ||
 800e4de:	68c3      	ldr	r3, [r0, #12]
 800e4e0:	2b00      	cmp	r3, #0
 800e4e2:	f000 8173 	beq.w	800e7cc <LoRaMacInitialization+0x31c>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 800e4e6:	4610      	mov	r0, r2
 800e4e8:	4617      	mov	r7, r2
 800e4ea:	f002 f9fb 	bl	80108e4 <RegionIsActive>
 800e4ee:	2800      	cmp	r0, #0
 800e4f0:	f000 8176 	beq.w	800e7e0 <LoRaMacInitialization+0x330>

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 800e4f4:	4cbe      	ldr	r4, [pc, #760]	@ (800e7f0 <LoRaMacInitialization+0x340>)
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 800e4f6:	4ebf      	ldr	r6, [pc, #764]	@ (800e7f4 <LoRaMacInitialization+0x344>)
    LoRaMacConfirmQueueInit( primitives );
 800e4f8:	4628      	mov	r0, r5
 800e4fa:	f001 fbc3 	bl	800fc84 <LoRaMacConfirmQueueInit>
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 800e4fe:	f44f 62ed 	mov.w	r2, #1896	@ 0x768
 800e502:	2100      	movs	r1, #0
 800e504:	4620      	mov	r0, r4
 800e506:	f003 ff19 	bl	801233c <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 800e50a:	f44f 62a1 	mov.w	r2, #1288	@ 0x508
 800e50e:	2100      	movs	r1, #0
 800e510:	4630      	mov	r0, r6
 800e512:	f003 ff13 	bl	801233c <memset1>
    Nvm.MacGroup2.Region = region;
    Nvm.MacGroup2.DeviceClass = CLASS_A;
    Nvm.MacGroup2.MacParams.RepeaterSupport = false;

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 800e516:	4bb8      	ldr	r3, [pc, #736]	@ (800e7f8 <LoRaMacInitialization+0x348>)
 800e518:	f8c4 3128 	str.w	r3, [r4, #296]	@ 0x128
    MacCtx.AckTimeoutRetries = 1;
 800e51c:	f240 1301 	movw	r3, #257	@ 0x101
    Nvm.MacGroup2.Region = region;
 800e520:	f884 7048 	strb.w	r7, [r4, #72]	@ 0x48
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
#endif /* LORAMAC_VERSION */

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e524:	4638      	mov	r0, r7
 800e526:	a905      	add	r1, sp, #20
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 800e528:	2700      	movs	r7, #0
    MacCtx.AckTimeoutRetries = 1;
 800e52a:	f8a6 340d 	strh.w	r3, [r6, #1037]	@ 0x40d
    getPhy.Attribute = PHY_DUTY_CYCLE;
 800e52e:	230f      	movs	r3, #15
 800e530:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 800e534:	f884 7118 	strb.w	r7, [r4, #280]	@ 0x118
    Nvm.MacGroup2.MacParams.RepeaterSupport = false;
 800e538:	f884 708c 	strb.w	r7, [r4, #140]	@ 0x8c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e53c:	f002 f9d8 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 800e540:	1bc0      	subs	r0, r0, r7
 800e542:	bf18      	it	ne
 800e544:	2001      	movne	r0, #1

    getPhy.Attribute = PHY_DEF_TX_POWER;
 800e546:	f04f 0a0a 	mov.w	sl, #10
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 800e54a:	f884 011c 	strb.w	r0, [r4, #284]	@ 0x11c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e54e:	a905      	add	r1, sp, #20
 800e550:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_TX_POWER;
 800e554:	f88d a014 	strb.w	sl, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e558:	f002 f9ca 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;

    getPhy.Attribute = PHY_DEF_TX_DR;
 800e55c:	f04f 0906 	mov.w	r9, #6
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 800e560:	f884 00dc 	strb.w	r0, [r4, #220]	@ 0xdc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e564:	a905      	add	r1, sp, #20
 800e566:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_TX_DR;
 800e56a:	f88d 9014 	strb.w	r9, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e56e:	f002 f9bf 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 800e572:	2310      	movs	r3, #16
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 800e574:	f884 00dd 	strb.w	r0, [r4, #221]	@ 0xdd
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e578:	a905      	add	r1, sp, #20
 800e57a:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 800e57e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e582:	f002 f9b5 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 800e586:	2311      	movs	r3, #17
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 800e588:	f8c4 009c 	str.w	r0, [r4, #156]	@ 0x9c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e58c:	a905      	add	r1, sp, #20
 800e58e:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 800e592:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e596:	f002 f9ab 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 800e59a:	2312      	movs	r3, #18
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 800e59c:	f8c4 00a0 	str.w	r0, [r4, #160]	@ 0xa0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5a0:	a905      	add	r1, sp, #20
 800e5a2:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 800e5a6:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5aa:	f002 f9a1 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 800e5ae:	2313      	movs	r3, #19
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 800e5b0:	f8c4 00a4 	str.w	r0, [r4, #164]	@ 0xa4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5b4:	a905      	add	r1, sp, #20
 800e5b6:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 800e5ba:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5be:	f002 f997 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 800e5c2:	2314      	movs	r3, #20
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 800e5c4:	f8c4 00a8 	str.w	r0, [r4, #168]	@ 0xa8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5c8:	a905      	add	r1, sp, #20
 800e5ca:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 800e5ce:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5d2:	f002 f98d 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 800e5d6:	2317      	movs	r3, #23
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 800e5d8:	f8c4 00ac 	str.w	r0, [r4, #172]	@ 0xac
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5dc:	a905      	add	r1, sp, #20
 800e5de:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 800e5e2:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5e6:	f002 f983 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 800e5ea:	2318      	movs	r3, #24
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 800e5ec:	f884 00b1 	strb.w	r0, [r4, #177]	@ 0xb1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5f0:	a905      	add	r1, sp, #20
 800e5f2:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 800e5f6:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e5fa:	f002 f979 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_DR;
 800e5fe:	2319      	movs	r3, #25
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 800e600:	f8c4 00b4 	str.w	r0, [r4, #180]	@ 0xb4
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 800e604:	f8c4 00bc 	str.w	r0, [r4, #188]	@ 0xbc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e608:	a905      	add	r1, sp, #20
 800e60a:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_RX2_DR;
 800e60e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e612:	f002 f96d 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 800e616:	b2c0      	uxtb	r0, r0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 800e618:	231e      	movs	r3, #30
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 800e61a:	f884 00b8 	strb.w	r0, [r4, #184]	@ 0xb8
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 800e61e:	f884 00c0 	strb.w	r0, [r4, #192]	@ 0xc0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e622:	a905      	add	r1, sp, #20
 800e624:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 800e628:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e62c:	f002 f960 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 800e630:	231f      	movs	r3, #31
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 800e632:	f884 00c4 	strb.w	r0, [r4, #196]	@ 0xc4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e636:	a905      	add	r1, sp, #20
 800e638:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 800e63c:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e640:	f002 f956 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 800e644:	2320      	movs	r3, #32
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 800e646:	f884 00c5 	strb.w	r0, [r4, #197]	@ 0xc5
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e64a:	a905      	add	r1, sp, #20
 800e64c:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 800e650:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e654:	f002 f94c 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 800e658:	2321      	movs	r3, #33	@ 0x21
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 800e65a:	f8c4 00c8 	str.w	r0, [r4, #200]	@ 0xc8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e65e:	a905      	add	r1, sp, #20
 800e660:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 800e664:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e668:	f002 f942 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 800e66c:	230b      	movs	r3, #11
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 800e66e:	f8c4 00cc 	str.w	r0, [r4, #204]	@ 0xcc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e672:	a905      	add	r1, sp, #20
 800e674:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 800e678:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e67c:	f002 f938 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = phyParam.Value;

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 800e680:	230c      	movs	r3, #12
    Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = phyParam.Value;
 800e682:	f8a4 00d0 	strh.w	r0, [r4, #208]	@ 0xd0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e686:	a905      	add	r1, sp, #20
 800e688:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 800e68c:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e690:	f002 f92e 	bl	80108f0 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 800e694:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 800e698:	65a3      	str	r3, [r4, #88]	@ 0x58
 800e69a:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
 800e69e:	65e3      	str	r3, [r4, #92]	@ 0x5c
 800e6a0:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
 800e6a4:	6623      	str	r3, [r4, #96]	@ 0x60
 800e6a6:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
 800e6aa:	6663      	str	r3, [r4, #100]	@ 0x64
 800e6ac:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
 800e6b0:	6563      	str	r3, [r4, #84]	@ 0x54
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;

#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
    params.NvmGroup1 = &Nvm.RegionGroup1;
 800e6b2:	f504 7308 	add.w	r3, r4, #544	@ 0x220
    params.NvmGroup2 = &Nvm.RegionGroup2;
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800e6b6:	a907      	add	r1, sp, #28
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e6b8:	9004      	str	r0, [sp, #16]
    Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = phyParam.Value;
 800e6ba:	f8a4 00d2 	strh.w	r0, [r4, #210]	@ 0xd2
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 800e6be:	f884 9098 	strb.w	r9, [r4, #152]	@ 0x98
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800e6c2:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 800e6c6:	f884 9050 	strb.w	r9, [r4, #80]	@ 0x50
    params.NvmGroup1 = &Nvm.RegionGroup1;
 800e6ca:	9307      	str	r3, [sp, #28]
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 800e6cc:	f04f 0901 	mov.w	r9, #1
    params.NvmGroup2 = &Nvm.RegionGroup2;
 800e6d0:	f504 732d 	add.w	r3, r4, #692	@ 0x2b4
 800e6d4:	9308      	str	r3, [sp, #32]
    params.Type = INIT_TYPE_DEFAULTS;
 800e6d6:	f88d 7024 	strb.w	r7, [sp, #36]	@ 0x24
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 800e6da:	f8c4 a094 	str.w	sl, [r4, #148]	@ 0x94
    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 800e6de:	f8c4 a04c 	str.w	sl, [r4, #76]	@ 0x4c
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 800e6e2:	f884 90b0 	strb.w	r9, [r4, #176]	@ 0xb0
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 800e6e6:	f884 9068 	strb.w	r9, [r4, #104]	@ 0x68
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800e6ea:	f002 f911 	bl	8010910 <RegionInitDefaults>
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    // FPort 224 is enabled by default.
    Nvm.MacGroup2.IsCertPortOn = true;
#endif /* LORAMAC_VERSION */

    MacCtx.MacCallbacks = callbacks;
 800e6ee:	f8c6 8348 	str.w	r8, [r6, #840]	@ 0x348
    ResetMacParameters( false );
 800e6f2:	f7fe f947 	bl	800c984 <ResetMacParameters.constprop.0>
    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
    Nvm.MacGroup1.AggregatedTimeOff = 0;

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 800e6f6:	9700      	str	r7, [sp, #0]
 800e6f8:	463a      	mov	r2, r7
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 800e6fa:	e9c4 770b 	strd	r7, r7, [r4, #44]	@ 0x2c
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 800e6fe:	4b3f      	ldr	r3, [pc, #252]	@ (800e7fc <LoRaMacInitialization+0x34c>)
    MacCtx.MacPrimitives = primitives;
 800e700:	f8c6 5344 	str.w	r5, [r6, #836]	@ 0x344
    MacCtx.MacFlags.Value = 0;
 800e704:	f886 7481 	strb.w	r7, [r6, #1153]	@ 0x481
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 800e708:	f04f 31ff 	mov.w	r1, #4294967295
    Nvm.MacGroup2.PublicNetwork = true;
 800e70c:	f884 9119 	strb.w	r9, [r4, #281]	@ 0x119
    MacCtx.MacState = LORAMAC_STOPPED;
 800e710:	f8c6 9340 	str.w	r9, [r6, #832]	@ 0x340
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 800e714:	f506 705a 	add.w	r0, r6, #872	@ 0x368
 800e718:	f006 ffbc 	bl	8015694 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 800e71c:	463a      	mov	r2, r7
 800e71e:	4b38      	ldr	r3, [pc, #224]	@ (800e800 <LoRaMacInitialization+0x350>)
 800e720:	9700      	str	r7, [sp, #0]
 800e722:	f04f 31ff 	mov.w	r1, #4294967295
 800e726:	f506 7060 	add.w	r0, r6, #896	@ 0x380
 800e72a:	f006 ffb3 	bl	8015694 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 800e72e:	463a      	mov	r2, r7
 800e730:	4b34      	ldr	r3, [pc, #208]	@ (800e804 <LoRaMacInitialization+0x354>)
 800e732:	9700      	str	r7, [sp, #0]
 800e734:	f04f 31ff 	mov.w	r1, #4294967295
 800e738:	f506 7066 	add.w	r0, r6, #920	@ 0x398
 800e73c:	f006 ffaa 	bl	8015694 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.Rejoin1CycleTimer, OnRejoin1CycleTimerEvent );
    TimerInit( &MacCtx.ForceRejoinReqCycleTimer, OnForceRejoinReqCycleTimerEvent );
#endif /* LORAMAC_VERSION */

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 800e740:	ad02      	add	r5, sp, #8
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 800e742:	463a      	mov	r2, r7
 800e744:	4b30      	ldr	r3, [pc, #192]	@ (800e808 <LoRaMacInitialization+0x358>)
 800e746:	9700      	str	r7, [sp, #0]
 800e748:	f04f 31ff 	mov.w	r1, #4294967295
 800e74c:	f506 707d 	add.w	r0, r6, #1012	@ 0x3f4
 800e750:	f006 ffa0 	bl	8015694 <UTIL_TIMER_Create>
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 800e754:	4628      	mov	r0, r5
 800e756:	f006 fb81 	bl	8014e5c <SysTimeGetMcuTime>
 800e75a:	e895 0003 	ldmia.w	r5, {r0, r1}
    // Initialize MAC radio events
    LoRaMacRadioEvents.Value = 0;
#endif /* LORAMAC_VERSION */

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 800e75e:	4b2b      	ldr	r3, [pc, #172]	@ (800e80c <LoRaMacInitialization+0x35c>)
 800e760:	f8c6 334c 	str.w	r3, [r6, #844]	@ 0x34c
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 800e764:	f504 7390 	add.w	r3, r4, #288	@ 0x120
 800e768:	e883 0003 	stmia.w	r3, {r0, r1}
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 800e76c:	4a28      	ldr	r2, [pc, #160]	@ (800e810 <LoRaMacInitialization+0x360>)
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 800e76e:	4b29      	ldr	r3, [pc, #164]	@ (800e814 <LoRaMacInitialization+0x364>)
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
    Radio.Init( &MacCtx.RadioEvents );
 800e770:	4f29      	ldr	r7, [pc, #164]	@ (800e818 <LoRaMacInitialization+0x368>)
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 800e772:	f8c6 2354 	str.w	r2, [r6, #852]	@ 0x354
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 800e776:	f8c6 335c 	str.w	r3, [r6, #860]	@ 0x35c
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 800e77a:	4a28      	ldr	r2, [pc, #160]	@ (800e81c <LoRaMacInitialization+0x36c>)
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 800e77c:	4b28      	ldr	r3, [pc, #160]	@ (800e820 <LoRaMacInitialization+0x370>)
 800e77e:	f8c6 3358 	str.w	r3, [r6, #856]	@ 0x358
    Radio.Init( &MacCtx.RadioEvents );
 800e782:	f506 7053 	add.w	r0, r6, #844	@ 0x34c
 800e786:	683b      	ldr	r3, [r7, #0]
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 800e788:	f8c6 2350 	str.w	r2, [r6, #848]	@ 0x350
    Radio.Init( &MacCtx.RadioEvents );
 800e78c:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement ) != SECURE_ELEMENT_SUCCESS )
 800e78e:	f504 70a4 	add.w	r0, r4, #328	@ 0x148
 800e792:	f7fc fe15 	bl	800b3c0 <SecureElementInit>
 800e796:	b9f0      	cbnz	r0, 800e7d6 <LoRaMacInitialization+0x326>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Initialize Crypto module
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 800e798:	4620      	mov	r0, r4
 800e79a:	f001 fc97 	bl	80100cc <LoRaMacCryptoInit>
 800e79e:	b9d0      	cbnz	r0, 800e7d6 <LoRaMacInitialization+0x326>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Initialize MAC commands module
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 800e7a0:	f001 f8f4 	bl	800f98c <LoRaMacCommandsInit>
 800e7a4:	bb08      	cbnz	r0, 800e7ea <LoRaMacInitialization+0x33a>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Set multicast downlink counter reference
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 800e7a6:	481f      	ldr	r0, [pc, #124]	@ (800e824 <LoRaMacInitialization+0x374>)
 800e7a8:	f001 fd0c 	bl	80101c4 <LoRaMacCryptoSetMulticastReference>
 800e7ac:	4605      	mov	r5, r0
 800e7ae:	b990      	cbnz	r0, 800e7d6 <LoRaMacInitialization+0x326>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Random seed initialization
    srand1( Radio.Random( ) );
 800e7b0:	697b      	ldr	r3, [r7, #20]
 800e7b2:	4798      	blx	r3
 800e7b4:	f003 fd40 	bl	8012238 <srand1>

    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 800e7b8:	f894 0119 	ldrb.w	r0, [r4, #281]	@ 0x119
 800e7bc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800e7be:	4798      	blx	r3
    Radio.Sleep( );
 800e7c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e7c2:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 800e7c4:	2301      	movs	r3, #1
 800e7c6:	f886 3482 	strb.w	r3, [r6, #1154]	@ 0x482

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );

    return LORAMAC_STATUS_OK;
 800e7ca:	e000      	b.n	800e7ce <LoRaMacInitialization+0x31e>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800e7cc:	2503      	movs	r5, #3
}
 800e7ce:	4628      	mov	r0, r5
 800e7d0:	b00a      	add	sp, #40	@ 0x28
 800e7d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return LORAMAC_STATUS_CRYPTO_ERROR;
 800e7d6:	2511      	movs	r5, #17
}
 800e7d8:	4628      	mov	r0, r5
 800e7da:	b00a      	add	sp, #40	@ 0x28
 800e7dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 800e7e0:	2509      	movs	r5, #9
}
 800e7e2:	4628      	mov	r0, r5
 800e7e4:	b00a      	add	sp, #40	@ 0x28
 800e7e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 800e7ea:	2513      	movs	r5, #19
 800e7ec:	e7ef      	b.n	800e7ce <LoRaMacInitialization+0x31e>
 800e7ee:	bf00      	nop
 800e7f0:	20000684 	.word	0x20000684
 800e7f4:	20000dec 	.word	0x20000dec
 800e7f8:	01000300 	.word	0x01000300
 800e7fc:	0800d52d 	.word	0x0800d52d
 800e800:	0800d0b5 	.word	0x0800d0b5
 800e804:	0800cacd 	.word	0x0800cacd
 800e808:	0800c711 	.word	0x0800c711
 800e80c:	0800c929 	.word	0x0800c929
 800e810:	0800c8d5 	.word	0x0800c8d5
 800e814:	0800c6ed 	.word	0x0800c6ed
 800e818:	08017658 	.word	0x08017658
 800e81c:	0800c89d 	.word	0x0800c89d
 800e820:	0800c865 	.word	0x0800c865
 800e824:	2000076c 	.word	0x2000076c

0800e828 <LoRaMacStart>:
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800e828:	4b06      	ldr	r3, [pc, #24]	@ (800e844 <LoRaMacStart+0x1c>)

LoRaMacStatus_t LoRaMacStart( void )
{
    MacCtx.MacState = LORAMAC_IDLE;
 800e82a:	4a07      	ldr	r2, [pc, #28]	@ (800e848 <LoRaMacStart+0x20>)
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800e82c:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
        MacCtx.RxSlot = RX_SLOT_NONE;
 800e830:	2b02      	cmp	r3, #2
    MacCtx.MacState = LORAMAC_IDLE;
 800e832:	f04f 0000 	mov.w	r0, #0
        MacCtx.RxSlot = RX_SLOT_NONE;
 800e836:	bf18      	it	ne
 800e838:	2306      	movne	r3, #6
    MacCtx.MacState = LORAMAC_IDLE;
 800e83a:	f8c2 0340 	str.w	r0, [r2, #832]	@ 0x340
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 800e83e:	f882 3480 	strb.w	r3, [r2, #1152]	@ 0x480
    UpdateRxSlotIdleState();
    return LORAMAC_STATUS_OK;
}
 800e842:	4770      	bx	lr
 800e844:	20000684 	.word	0x20000684
 800e848:	20000dec 	.word	0x20000dec

0800e84c <LoRaMacHalt>:
    }
    return LORAMAC_STATUS_BUSY;
}

LoRaMacStatus_t LoRaMacHalt( void )
{
 800e84c:	b510      	push	{r4, lr}
    // Stop Timers
    TimerStop( &MacCtx.TxDelayedTimer );
 800e84e:	4c0d      	ldr	r4, [pc, #52]	@ (800e884 <LoRaMacHalt+0x38>)
 800e850:	4620      	mov	r0, r4
 800e852:	f006 ff4b 	bl	80156ec <UTIL_TIMER_Stop>
    TimerStop( &MacCtx.RxWindowTimer1 );
 800e856:	f104 0018 	add.w	r0, r4, #24
 800e85a:	f006 ff47 	bl	80156ec <UTIL_TIMER_Stop>
    TimerStop( &MacCtx.RxWindowTimer2 );
 800e85e:	f104 0030 	add.w	r0, r4, #48	@ 0x30
 800e862:	f006 ff43 	bl	80156ec <UTIL_TIMER_Stop>
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    TimerStop( &MacCtx.AckTimeoutTimer );
 800e866:	f104 008c 	add.w	r0, r4, #140	@ 0x8c
 800e86a:	f006 ff3f 	bl	80156ec <UTIL_TIMER_Stop>
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    TimerStop( &MacCtx.RetransmitTimeoutTimer );
#endif /* LORAMAC_VERSION */

    // Take care about class B
    LoRaMacClassBHaltBeaconing( );
 800e86e:	f001 f873 	bl	800f958 <LoRaMacClassBHaltBeaconing>

    // Switch off Radio
    Radio.Sleep( );
 800e872:	4b05      	ldr	r3, [pc, #20]	@ (800e888 <LoRaMacHalt+0x3c>)
 800e874:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e876:	4798      	blx	r3

    // Preserve the Nvm context if data retention
    memcpy1( ( uint8_t* ) &NvmBackup, ( uint8_t* ) &Nvm, sizeof( LoRaMacNvmData_t ) );
#endif /* CONTEXT_MANAGEMENT_ENABLED */

    MacCtx.MacState = LORAMAC_STOPPED;
 800e878:	2301      	movs	r3, #1
 800e87a:	f844 3c28 	str.w	r3, [r4, #-40]

    return LORAMAC_STATUS_OK;
}
 800e87e:	2000      	movs	r0, #0
 800e880:	bd10      	pop	{r4, pc}
 800e882:	bf00      	nop
 800e884:	20001154 	.word	0x20001154
 800e888:	08017658 	.word	0x08017658

0800e88c <LoRaMacQueryTxPossible>:

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 800e88c:	b570      	push	{r4, r5, r6, lr}
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 800e88e:	4c32      	ldr	r4, [pc, #200]	@ (800e958 <LoRaMacQueryTxPossible+0xcc>)
{
 800e890:	b08c      	sub	sp, #48	@ 0x30
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 800e892:	f894 30dd 	ldrb.w	r3, [r4, #221]	@ 0xdd
 800e896:	f88d 3006 	strb.w	r3, [sp, #6]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 800e89a:	f894 30dc 	ldrb.w	r3, [r4, #220]	@ 0xdc
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 800e89e:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 800e8a0:	f88d 3007 	strb.w	r3, [sp, #7]
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    uint8_t nbTrans = MacCtx.ChannelsNbTransCounter;
#endif /* LORAMAC_VERSION */
    size_t macCmdsSize = 0;
 800e8a4:	2300      	movs	r3, #0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 800e8a6:	9202      	str	r2, [sp, #8]
    size_t macCmdsSize = 0;
 800e8a8:	9303      	str	r3, [sp, #12]

    if( txInfo == NULL )
 800e8aa:	2900      	cmp	r1, #0
 800e8ac:	d04e      	beq.n	800e94c <LoRaMacQueryTxPossible+0xc0>
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // Setup ADR request
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    adrNext.Version = Nvm.MacGroup2.Version;
 800e8ae:	460d      	mov	r5, r1
#endif /* LORAMAC_VERSION */
    adrNext.UpdateChanMask = false;
 800e8b0:	f88d 3020 	strb.w	r3, [sp, #32]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;
 800e8b4:	f8d4 1088 	ldr.w	r1, [r4, #136]	@ 0x88
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 800e8b8:	f894 311a 	ldrb.w	r3, [r4, #282]	@ 0x11a
 800e8bc:	f88d 3021 	strb.w	r3, [sp, #33]	@ 0x21
    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;
 800e8c0:	910a      	str	r1, [sp, #40]	@ 0x28
    adrNext.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800e8c2:	8f23      	ldrh	r3, [r4, #56]	@ 0x38
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    adrNext.NbTrans = MacCtx.ChannelsNbTransCounter;
#endif /* LORAMAC_VERSION */
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800e8c4:	f894 107c 	ldrb.w	r1, [r4, #124]	@ 0x7c
 800e8c8:	f88d 102e 	strb.w	r1, [sp, #46]	@ 0x2e
    adrNext.Version = Nvm.MacGroup2.Version;
 800e8cc:	f8d4 1128 	ldr.w	r1, [r4, #296]	@ 0x128
 800e8d0:	9107      	str	r1, [sp, #28]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800e8d2:	ba5b      	rev16	r3, r3
    adrNext.Region = Nvm.MacGroup2.Region;
 800e8d4:	f894 1048 	ldrb.w	r1, [r4, #72]	@ 0x48
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 800e8d8:	9209      	str	r2, [sp, #36]	@ 0x24
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800e8da:	f8ad 302c 	strh.w	r3, [sp, #44]	@ 0x2c

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 800e8de:	f10d 0207 	add.w	r2, sp, #7
 800e8e2:	ab02      	add	r3, sp, #8
    adrNext.Region = Nvm.MacGroup2.Region;
 800e8e4:	f88d 102f 	strb.w	r1, [sp, #47]	@ 0x2f
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 800e8e8:	4606      	mov	r6, r0
 800e8ea:	f10d 0106 	add.w	r1, sp, #6
 800e8ee:	a807      	add	r0, sp, #28
 800e8f0:	f000 ff9e 	bl	800f830 <LoRaMacAdrCalcNext>
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800e8f4:	f894 307c 	ldrb.w	r3, [r4, #124]	@ 0x7c
 800e8f8:	f88d 3016 	strb.w	r3, [sp, #22]
 800e8fc:	f894 308c 	ldrb.w	r3, [r4, #140]	@ 0x8c
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &nbTrans, &adrAckCounter );
#endif /* LORAMAC_VERSION */

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 800e900:	f99d 2006 	ldrsb.w	r2, [sp, #6]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e904:	f894 0048 	ldrb.w	r0, [r4, #72]	@ 0x48
    getPhy.Datarate = datarate;
 800e908:	f88d 2015 	strb.w	r2, [sp, #21]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 800e90c:	330d      	adds	r3, #13
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800e90e:	a905      	add	r1, sp, #20
 800e910:	f88d 3014 	strb.w	r3, [sp, #20]
 800e914:	f001 ffec 	bl	80108f0 <RegionGetPhyParam>
    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 800e918:	7068      	strb	r0, [r5, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 800e91a:	a803      	add	r0, sp, #12
 800e91c:	f001 f93e 	bl	800fb9c <LoRaMacCommandsGetSizeSerializedCmds>
 800e920:	b9b8      	cbnz	r0, 800e952 <LoRaMacQueryTxPossible+0xc6>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 800e922:	9a03      	ldr	r2, [sp, #12]
 800e924:	2a0f      	cmp	r2, #15
 800e926:	d80c      	bhi.n	800e942 <LoRaMacQueryTxPossible+0xb6>
 800e928:	786b      	ldrb	r3, [r5, #1]
 800e92a:	429a      	cmp	r2, r3
 800e92c:	d809      	bhi.n	800e942 <LoRaMacQueryTxPossible+0xb6>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 800e92e:	4416      	add	r6, r2
 800e930:	42b3      	cmp	r3, r6
 800e932:	bf2c      	ite	cs
 800e934:	2000      	movcs	r0, #0
 800e936:	2001      	movcc	r0, #1
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 800e938:	1a9a      	subs	r2, r3, r2
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 800e93a:	00c0      	lsls	r0, r0, #3
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 800e93c:	702a      	strb	r2, [r5, #0]
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 800e93e:	b00c      	add	sp, #48	@ 0x30
 800e940:	bd70      	pop	{r4, r5, r6, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 800e942:	2300      	movs	r3, #0
           return LORAMAC_STATUS_LENGTH_ERROR;
 800e944:	2008      	movs	r0, #8
        txInfo->MaxPossibleApplicationDataSize = 0;
 800e946:	702b      	strb	r3, [r5, #0]
}
 800e948:	b00c      	add	sp, #48	@ 0x30
 800e94a:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800e94c:	2003      	movs	r0, #3
}
 800e94e:	b00c      	add	sp, #48	@ 0x30
 800e950:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 800e952:	2013      	movs	r0, #19
}
 800e954:	b00c      	add	sp, #48	@ 0x30
 800e956:	bd70      	pop	{r4, r5, r6, pc}
 800e958:	20000684 	.word	0x20000684

0800e95c <LoRaMacMibGetRequestConfirm>:
{
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 800e95c:	2800      	cmp	r0, #0
 800e95e:	d047      	beq.n	800e9f0 <LoRaMacMibGetRequestConfirm+0x94>
{
 800e960:	b510      	push	{r4, lr}
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 800e962:	7803      	ldrb	r3, [r0, #0]
{
 800e964:	b084      	sub	sp, #16
 800e966:	4604      	mov	r4, r0
    switch( mibGet->Type )
 800e968:	2b3f      	cmp	r3, #63	@ 0x3f
 800e96a:	d843      	bhi.n	800e9f4 <LoRaMacMibGetRequestConfirm+0x98>
 800e96c:	e8df f013 	tbh	[pc, r3, lsl #1]
 800e970:	00ab00b0 	.word	0x00ab00b0
 800e974:	00a300a7 	.word	0x00a300a7
 800e978:	0099009e 	.word	0x0099009e
 800e97c:	00420092 	.word	0x00420092
 800e980:	00420042 	.word	0x00420042
 800e984:	00420042 	.word	0x00420042
 800e988:	00420042 	.word	0x00420042
 800e98c:	00e70042 	.word	0x00e70042
 800e990:	00df00e2 	.word	0x00df00e2
 800e994:	00d100d8 	.word	0x00d100d8
 800e998:	00c300ca 	.word	0x00c300ca
 800e99c:	00b500c0 	.word	0x00b500c0
 800e9a0:	005b005f 	.word	0x005b005f
 800e9a4:	00530057 	.word	0x00530057
 800e9a8:	004a004f 	.word	0x004a004f
 800e9ac:	008d0064 	.word	0x008d0064
 800e9b0:	01020107 	.word	0x01020107
 800e9b4:	00f900fe 	.word	0x00f900fe
 800e9b8:	00ef00f4 	.word	0x00ef00f4
 800e9bc:	008a00ec 	.word	0x008a00ec
 800e9c0:	00820042 	.word	0x00820042
 800e9c4:	00420042 	.word	0x00420042
 800e9c8:	00420042 	.word	0x00420042
 800e9cc:	00420042 	.word	0x00420042
 800e9d0:	00420042 	.word	0x00420042
 800e9d4:	00420042 	.word	0x00420042
 800e9d8:	00420042 	.word	0x00420042
 800e9dc:	00420042 	.word	0x00420042
 800e9e0:	007d0042 	.word	0x007d0042
 800e9e4:	00730078 	.word	0x00730078
 800e9e8:	0069006e 	.word	0x0069006e
 800e9ec:	00470047 	.word	0x00470047
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800e9f0:	2003      	movs	r0, #3
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
            break;
        }
    }
    return status;
}
 800e9f2:	4770      	bx	lr
 800e9f4:	b004      	add	sp, #16
 800e9f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 800e9fa:	f000 bfb3 	b.w	800f964 <LoRaMacClassBMibGetRequestConfirm>
    switch( mibGet->Type )
 800e9fe:	2018      	movs	r0, #24
}
 800ea00:	b004      	add	sp, #16
 800ea02:	bd10      	pop	{r4, pc}
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 800ea04:	4b60      	ldr	r3, [pc, #384]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea06:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800ea08:	6043      	str	r3, [r0, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 800ea0a:	2000      	movs	r0, #0
 800ea0c:	e7f8      	b.n	800ea00 <LoRaMacMibGetRequestConfirm+0xa4>
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 800ea0e:	4b5e      	ldr	r3, [pc, #376]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea10:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800ea12:	6043      	str	r3, [r0, #4]
            break;
 800ea14:	e7f9      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 800ea16:	4b5c      	ldr	r3, [pc, #368]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea18:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800ea1a:	6043      	str	r3, [r0, #4]
            break;
 800ea1c:	e7f5      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 800ea1e:	4b5a      	ldr	r3, [pc, #360]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea20:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800ea22:	6043      	str	r3, [r0, #4]
            break;
 800ea24:	e7f1      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 800ea26:	4b58      	ldr	r3, [pc, #352]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea28:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800ea2a:	6043      	str	r3, [r0, #4]
            break;
 800ea2c:	e7ed      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 800ea2e:	4b56      	ldr	r3, [pc, #344]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea30:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
 800ea34:	7103      	strb	r3, [r0, #4]
            break;
 800ea36:	e7e8      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 800ea38:	4b53      	ldr	r3, [pc, #332]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea3a:	f893 30dd 	ldrb.w	r3, [r3, #221]	@ 0xdd
 800ea3e:	7103      	strb	r3, [r0, #4]
            break;
 800ea40:	e7e3      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay;
 800ea42:	4b51      	ldr	r3, [pc, #324]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea44:	f8b3 30d2 	ldrh.w	r3, [r3, #210]	@ 0xd2
 800ea48:	8083      	strh	r3, [r0, #4]
            break;
 800ea4a:	e7de      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;
 800ea4c:	4b4e      	ldr	r3, [pc, #312]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea4e:	f8b3 30d0 	ldrh.w	r3, [r3, #208]	@ 0xd0
 800ea52:	8083      	strh	r3, [r0, #4]
            break;
 800ea54:	e7d9      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;
 800ea56:	4b4c      	ldr	r3, [pc, #304]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea58:	f8b3 308a 	ldrh.w	r3, [r3, #138]	@ 0x8a
 800ea5c:	8083      	strh	r3, [r0, #4]
            break;
 800ea5e:	e7d4      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;
 800ea60:	4b49      	ldr	r3, [pc, #292]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea62:	f8b3 3088 	ldrh.w	r3, [r3, #136]	@ 0x88
 800ea66:	8083      	strh	r3, [r0, #4]
            break;
 800ea68:	e7cf      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.RxBCTimeout = Nvm.MacGroup2.MacParams.RxBCTimeout;
 800ea6a:	4b47      	ldr	r3, [pc, #284]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea6c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800ea70:	6043      	str	r3, [r0, #4]
            break;
 800ea72:	e7ca      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 800ea74:	4b44      	ldr	r3, [pc, #272]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea76:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
 800ea7a:	6043      	str	r3, [r0, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 800ea7c:	f001 ffe4 	bl	8010a48 <RegionGetVersion>
 800ea80:	60a0      	str	r0, [r4, #8]
            break;
 800ea82:	e7c2      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.BackupContexts = NULL;
 800ea84:	2300      	movs	r3, #0
 800ea86:	6043      	str	r3, [r0, #4]
            break;
 800ea88:	e7bf      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 800ea8a:	4b3f      	ldr	r3, [pc, #252]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea8c:	f893 3039 	ldrb.w	r3, [r3, #57]	@ 0x39
 800ea90:	7103      	strb	r3, [r0, #4]
            break;
 800ea92:	e7ba      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            SecureElementGetDevAddr( Nvm.MacGroup2.NetworkActivation, &mibGet->Param.DevAddr );
 800ea94:	4b3c      	ldr	r3, [pc, #240]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ea96:	1d01      	adds	r1, r0, #4
 800ea98:	f893 012c 	ldrb.w	r0, [r3, #300]	@ 0x12c
 800ea9c:	f7fc ffb0 	bl	800ba00 <SecureElementGetDevAddr>
            break;
 800eaa0:	e7b3      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 800eaa2:	4b39      	ldr	r3, [pc, #228]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eaa4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800eaa8:	6043      	str	r3, [r0, #4]
            break;
 800eaaa:	e7ae      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 800eaac:	4b36      	ldr	r3, [pc, #216]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eaae:	f893 311a 	ldrb.w	r3, [r3, #282]	@ 0x11a
 800eab2:	7103      	strb	r3, [r0, #4]
            break;
 800eab4:	e7a9      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
             SecureElementGetJoinEui( mibGet->Param.JoinEui );
 800eab6:	6840      	ldr	r0, [r0, #4]
 800eab8:	f7fc ff8a 	bl	800b9d0 <SecureElementGetJoinEui>
            break;
 800eabc:	e7a5      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            SecureElementGetDevEui( mibGet->Param.DevEui );
 800eabe:	6840      	ldr	r0, [r0, #4]
 800eac0:	f7fc ff68 	bl	800b994 <SecureElementGetDevEui>
            break;
 800eac4:	e7a1      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 800eac6:	4b30      	ldr	r3, [pc, #192]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eac8:	f893 312c 	ldrb.w	r3, [r3, #300]	@ 0x12c
 800eacc:	7103      	strb	r3, [r0, #4]
            break;
 800eace:	e79c      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 800ead0:	4b2d      	ldr	r3, [pc, #180]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800ead2:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 800ead6:	7103      	strb	r3, [r0, #4]
            break;
 800ead8:	e797      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800eada:	4a2b      	ldr	r2, [pc, #172]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 800eadc:	231b      	movs	r3, #27
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800eade:	f892 0048 	ldrb.w	r0, [r2, #72]	@ 0x48
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 800eae2:	f88d 3008 	strb.w	r3, [sp, #8]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800eae6:	a902      	add	r1, sp, #8
 800eae8:	f001 ff02 	bl	80108f0 <RegionGetPhyParam>
            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;
 800eaec:	6060      	str	r0, [r4, #4]
            break;
 800eaee:	e78c      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800eaf0:	4a25      	ldr	r2, [pc, #148]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
            getPhy.Attribute = PHY_CHANNELS_MASK;
 800eaf2:	231a      	movs	r3, #26
 800eaf4:	e7f3      	b.n	800eade <LoRaMacMibGetRequestConfirm+0x182>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 800eaf6:	4b25      	ldr	r3, [pc, #148]	@ (800eb8c <LoRaMacMibGetRequestConfirm+0x230>)
 800eaf8:	e893 0003 	ldmia.w	r3, {r0, r1}
 800eafc:	3404      	adds	r4, #4
 800eafe:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 800eb02:	e782      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 800eb04:	4b22      	ldr	r3, [pc, #136]	@ (800eb90 <LoRaMacMibGetRequestConfirm+0x234>)
 800eb06:	e893 0003 	ldmia.w	r3, {r0, r1}
 800eb0a:	3404      	adds	r4, #4
 800eb0c:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 800eb10:	e77b      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 800eb12:	4b20      	ldr	r3, [pc, #128]	@ (800eb94 <LoRaMacMibGetRequestConfirm+0x238>)
 800eb14:	e893 0003 	ldmia.w	r3, {r0, r1}
 800eb18:	3404      	adds	r4, #4
 800eb1a:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 800eb1e:	e774      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 800eb20:	4b1d      	ldr	r3, [pc, #116]	@ (800eb98 <LoRaMacMibGetRequestConfirm+0x23c>)
 800eb22:	e893 0003 	ldmia.w	r3, {r0, r1}
 800eb26:	3404      	adds	r4, #4
 800eb28:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 800eb2c:	e76d      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800eb2e:	4a16      	ldr	r2, [pc, #88]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
            getPhy.Attribute = PHY_CHANNELS;
 800eb30:	231d      	movs	r3, #29
 800eb32:	e7d4      	b.n	800eade <LoRaMacMibGetRequestConfirm+0x182>
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 800eb34:	4b14      	ldr	r3, [pc, #80]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb36:	f893 308c 	ldrb.w	r3, [r3, #140]	@ 0x8c
 800eb3a:	7103      	strb	r3, [r0, #4]
            break;
 800eb3c:	e765      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 800eb3e:	4b12      	ldr	r3, [pc, #72]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb40:	f893 3119 	ldrb.w	r3, [r3, #281]	@ 0x119
 800eb44:	7103      	strb	r3, [r0, #4]
            break;
 800eb46:	e760      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.Contexts = &Nvm;
 800eb48:	4b0f      	ldr	r3, [pc, #60]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb4a:	6043      	str	r3, [r0, #4]
            break;
 800eb4c:	e75d      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 800eb4e:	4b0e      	ldr	r3, [pc, #56]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb50:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800eb54:	6043      	str	r3, [r0, #4]
            break;
 800eb56:	e758      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 800eb58:	4b0b      	ldr	r3, [pc, #44]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb5a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800eb5e:	6043      	str	r3, [r0, #4]
            break;
 800eb60:	e753      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 800eb62:	4b09      	ldr	r3, [pc, #36]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb64:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800eb68:	7103      	strb	r3, [r0, #4]
            break;
 800eb6a:	e74e      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 800eb6c:	4b06      	ldr	r3, [pc, #24]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb6e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800eb70:	6043      	str	r3, [r0, #4]
            break;
 800eb72:	e74a      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 800eb74:	4b04      	ldr	r3, [pc, #16]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb76:	f893 30dc 	ldrb.w	r3, [r3, #220]	@ 0xdc
 800eb7a:	7103      	strb	r3, [r0, #4]
            break;
 800eb7c:	e745      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 800eb7e:	4b02      	ldr	r3, [pc, #8]	@ (800eb88 <LoRaMacMibGetRequestConfirm+0x22c>)
 800eb80:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 800eb84:	7103      	strb	r3, [r0, #4]
            break;
 800eb86:	e740      	b.n	800ea0a <LoRaMacMibGetRequestConfirm+0xae>
 800eb88:	20000684 	.word	0x20000684
 800eb8c:	20000740 	.word	0x20000740
 800eb90:	200006f8 	.word	0x200006f8
 800eb94:	20000738 	.word	0x20000738
 800eb98:	200006f0 	.word	0x200006f0

0800eb9c <LoRaMacMibSetRequestConfirm>:
{
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 800eb9c:	2800      	cmp	r0, #0
 800eb9e:	f000 82d5 	beq.w	800f14c <LoRaMacMibSetRequestConfirm+0x5b0>
{
 800eba2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 800eba6:	4da5      	ldr	r5, [pc, #660]	@ (800ee3c <LoRaMacMibSetRequestConfirm+0x2a0>)
 800eba8:	f8d5 3340 	ldr.w	r3, [r5, #832]	@ 0x340
 800ebac:	079b      	lsls	r3, r3, #30
{
 800ebae:	b085      	sub	sp, #20
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 800ebb0:	d445      	bmi.n	800ec3e <LoRaMacMibSetRequestConfirm+0xa2>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 800ebb2:	7803      	ldrb	r3, [r0, #0]
 800ebb4:	4604      	mov	r4, r0
 800ebb6:	2b3f      	cmp	r3, #63	@ 0x3f
 800ebb8:	d845      	bhi.n	800ec46 <LoRaMacMibSetRequestConfirm+0xaa>
 800ebba:	e8df f013 	tbh	[pc, r3, lsl #1]
 800ebbe:	0122      	.short	0x0122
 800ebc0:	014e011a 	.word	0x014e011a
 800ebc4:	01550147 	.word	0x01550147
 800ebc8:	019c013a 	.word	0x019c013a
 800ebcc:	01860191 	.word	0x01860191
 800ebd0:	0170017b 	.word	0x0170017b
 800ebd4:	01c90164 	.word	0x01c90164
 800ebd8:	01b301be 	.word	0x01b301be
 800ebdc:	011501a9 	.word	0x011501a9
 800ebe0:	00f20044 	.word	0x00f20044
 800ebe4:	007800be 	.word	0x007800be
 800ebe8:	00d500db 	.word	0x00d500db
 800ebec:	00610069 	.word	0x00610069
 800ebf0:	0059005d 	.word	0x0059005d
 800ebf4:	00510055 	.word	0x00510055
 800ebf8:	02200232 	.word	0x02200232
 800ebfc:	01f8020a 	.word	0x01f8020a
 800ec00:	01e001e6 	.word	0x01e001e6
 800ec04:	01d401d9 	.word	0x01d401d9
 800ec08:	004f024f 	.word	0x004f024f
 800ec0c:	02400044 	.word	0x02400044
 800ec10:	00440044 	.word	0x00440044
 800ec14:	00440044 	.word	0x00440044
 800ec18:	00440044 	.word	0x00440044
 800ec1c:	00440044 	.word	0x00440044
 800ec20:	00440044 	.word	0x00440044
 800ec24:	00440044 	.word	0x00440044
 800ec28:	00440044 	.word	0x00440044
 800ec2c:	00440044 	.word	0x00440044
 800ec30:	0236023b 	.word	0x0236023b
 800ec34:	015a015f 	.word	0x015a015f
 800ec38:	0049004b 	.word	0x0049004b
 800ec3c:	0049      	.short	0x0049
        return LORAMAC_STATUS_BUSY;
 800ec3e:	2001      	movs	r0, #1
        // Handle NVM potential changes
        MacCtx.MacFlags.Bits.NvmHandle = 1;
    }
#endif /* LORAMAC_VERSION */
    return status;
}
 800ec40:	b005      	add	sp, #20
 800ec42:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800ec46:	b005      	add	sp, #20
 800ec48:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 800ec4c:	f000 be8c 	b.w	800f968 <LoRaMacMibClassBSetRequestConfirm>
    switch( mibSet->Type )
 800ec50:	2018      	movs	r0, #24
 800ec52:	e7f5      	b.n	800ec40 <LoRaMacMibSetRequestConfirm+0xa4>
            Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = mibSet->Param.AdrAckDelay;
 800ec54:	4b7a      	ldr	r3, [pc, #488]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800ec56:	8882      	ldrh	r2, [r0, #4]
 800ec58:	f8a3 20d2 	strh.w	r2, [r3, #210]	@ 0xd2
                status = LORAMAC_STATUS_OK;
 800ec5c:	2000      	movs	r0, #0
 800ec5e:	e7ef      	b.n	800ec40 <LoRaMacMibSetRequestConfirm+0xa4>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 800ec60:	4b77      	ldr	r3, [pc, #476]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800ec62:	6842      	ldr	r2, [r0, #4]
 800ec64:	661a      	str	r2, [r3, #96]	@ 0x60
            break;
 800ec66:	e7f9      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 800ec68:	4b75      	ldr	r3, [pc, #468]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800ec6a:	6842      	ldr	r2, [r0, #4]
 800ec6c:	65da      	str	r2, [r3, #92]	@ 0x5c
            break;
 800ec6e:	e7f5      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 800ec70:	4b73      	ldr	r3, [pc, #460]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800ec72:	6842      	ldr	r2, [r0, #4]
 800ec74:	659a      	str	r2, [r3, #88]	@ 0x58
            break;
 800ec76:	e7f1      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 800ec78:	4b71      	ldr	r3, [pc, #452]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800ec7a:	6842      	ldr	r2, [r0, #4]
 800ec7c:	655a      	str	r2, [r3, #84]	@ 0x54
            break;
 800ec7e:	e7ed      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 800ec80:	7903      	ldrb	r3, [r0, #4]
 800ec82:	1e5a      	subs	r2, r3, #1
 800ec84:	2a0e      	cmp	r2, #14
 800ec86:	d810      	bhi.n	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 800ec88:	4a6d      	ldr	r2, [pc, #436]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800ec8a:	f882 3068 	strb.w	r3, [r2, #104]	@ 0x68
 800ec8e:	e7e5      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 800ec90:	4b6b      	ldr	r3, [pc, #428]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 800ec92:	6842      	ldr	r2, [r0, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 800ec94:	f893 0048 	ldrb.w	r0, [r3, #72]	@ 0x48
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 800ec98:	2301      	movs	r3, #1
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 800ec9a:	a902      	add	r1, sp, #8
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 800ec9c:	9202      	str	r2, [sp, #8]
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 800ec9e:	f88d 300c 	strb.w	r3, [sp, #12]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 800eca2:	f001 fe4b 	bl	801093c <RegionChanMaskSet>
 800eca6:	2800      	cmp	r0, #0
 800eca8:	d1d8      	bne.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 800ecaa:	2003      	movs	r0, #3
 800ecac:	e7c8      	b.n	800ec40 <LoRaMacMibSetRequestConfirm+0xa4>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ecae:	4e64      	ldr	r6, [pc, #400]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 800ecb0:	7a02      	ldrb	r2, [r0, #8]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ecb2:	f896 307d 	ldrb.w	r3, [r6, #125]	@ 0x7d
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 800ecb6:	f88d 2008 	strb.w	r2, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 800ecba:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ecbe:	f88d 3009 	strb.w	r3, [sp, #9]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 800ecc2:	2207      	movs	r2, #7
 800ecc4:	a902      	add	r1, sp, #8
 800ecc6:	f001 fe29 	bl	801091c <RegionVerify>
 800ecca:	2800      	cmp	r0, #0
 800eccc:	d0ed      	beq.n	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 800ecce:	3404      	adds	r4, #4
 800ecd0:	e894 0003 	ldmia.w	r4, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 800ecd4:	f896 2118 	ldrb.w	r2, [r6, #280]	@ 0x118
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 800ecd8:	f106 0374 	add.w	r3, r6, #116	@ 0x74
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 800ecdc:	2a02      	cmp	r2, #2
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 800ecde:	e883 0003 	stmia.w	r3, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 800ece2:	d1bb      	bne.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800ece4:	f896 312c 	ldrb.w	r3, [r6, #300]	@ 0x12c
 800ece8:	2b00      	cmp	r3, #0
 800ecea:	d0b7      	beq.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
                    Radio.Sleep( );
 800ecec:	4f55      	ldr	r7, [pc, #340]	@ (800ee44 <LoRaMacMibSetRequestConfirm+0x2a8>)
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800ecee:	4c56      	ldr	r4, [pc, #344]	@ (800ee48 <LoRaMacMibSetRequestConfirm+0x2ac>)
                    Radio.Sleep( );
 800ecf0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ecf2:	4798      	blx	r3
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800ecf4:	6cf3      	ldr	r3, [r6, #76]	@ 0x4c
 800ecf6:	9400      	str	r4, [sp, #0]
 800ecf8:	f896 2050 	ldrb.w	r2, [r6, #80]	@ 0x50
 800ecfc:	f996 1078 	ldrsb.w	r1, [r6, #120]	@ 0x78
 800ed00:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
 800ed04:	f001 fe22 	bl	801094c <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800ed08:	f240 2301 	movw	r3, #513	@ 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800ed0c:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800ed10:	f8a5 33f2 	strh.w	r3, [r5, #1010]	@ 0x3f2
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800ed14:	f104 023c 	add.w	r2, r4, #60	@ 0x3c
 800ed18:	4621      	mov	r1, r4
 800ed1a:	f001 fe25 	bl	8010968 <RegionRxConfig>
 800ed1e:	2800      	cmp	r0, #0
 800ed20:	d09c      	beq.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800ed22:	f895 241c 	ldrb.w	r2, [r5, #1052]	@ 0x41c
        Radio.Rx( 0 ); // Continuous mode
 800ed26:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800ed28:	f885 245e 	strb.w	r2, [r5, #1118]	@ 0x45e
        Radio.Rx( 0 ); // Continuous mode
 800ed2c:	2000      	movs	r0, #0
 800ed2e:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 800ed30:	f895 33f3 	ldrb.w	r3, [r5, #1011]	@ 0x3f3
 800ed34:	f885 3480 	strb.w	r3, [r5, #1152]	@ 0x480
}
 800ed38:	e790      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ed3a:	4d41      	ldr	r5, [pc, #260]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 800ed3c:	7a01      	ldrb	r1, [r0, #8]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ed3e:	f895 307d 	ldrb.w	r3, [r5, #125]	@ 0x7d
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 800ed42:	f88d 1008 	strb.w	r1, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 800ed46:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ed4a:	f88d 3009 	strb.w	r3, [sp, #9]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 800ed4e:	2207      	movs	r2, #7
 800ed50:	a902      	add	r1, sp, #8
 800ed52:	f001 fde3 	bl	801091c <RegionVerify>
 800ed56:	2800      	cmp	r0, #0
 800ed58:	d0a7      	beq.n	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 800ed5a:	3404      	adds	r4, #4
 800ed5c:	e894 0003 	ldmia.w	r4, {r0, r1}
 800ed60:	35b4      	adds	r5, #180	@ 0xb4
 800ed62:	e885 0003 	stmia.w	r5, {r0, r1}
 800ed66:	e779      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 800ed68:	4b35      	ldr	r3, [pc, #212]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 800ed6a:	6842      	ldr	r2, [r0, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 800ed6c:	f893 0048 	ldrb.w	r0, [r3, #72]	@ 0x48
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 800ed70:	2300      	movs	r3, #0
 800ed72:	e792      	b.n	800ec9a <LoRaMacMibSetRequestConfirm+0xfe>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ed74:	4d32      	ldr	r5, [pc, #200]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 800ed76:	7a01      	ldrb	r1, [r0, #8]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ed78:	f895 307d 	ldrb.w	r3, [r5, #125]	@ 0x7d
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 800ed7c:	f88d 1008 	strb.w	r1, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 800ed80:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800ed84:	f88d 3009 	strb.w	r3, [sp, #9]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 800ed88:	2207      	movs	r2, #7
 800ed8a:	a902      	add	r1, sp, #8
 800ed8c:	f001 fdc6 	bl	801091c <RegionVerify>
 800ed90:	2800      	cmp	r0, #0
 800ed92:	d08a      	beq.n	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 800ed94:	3404      	adds	r4, #4
 800ed96:	e894 0003 	ldmia.w	r4, {r0, r1}
 800ed9a:	35bc      	adds	r5, #188	@ 0xbc
 800ed9c:	e885 0003 	stmia.w	r5, {r0, r1}
 800eda0:	e75c      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800eda2:	4d27      	ldr	r5, [pc, #156]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 800eda4:	7a02      	ldrb	r2, [r0, #8]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800eda6:	f895 307d 	ldrb.w	r3, [r5, #125]	@ 0x7d
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 800edaa:	f88d 2008 	strb.w	r2, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 800edae:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800edb2:	f88d 3009 	strb.w	r3, [sp, #9]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 800edb6:	2207      	movs	r2, #7
 800edb8:	a902      	add	r1, sp, #8
 800edba:	f001 fdaf 	bl	801091c <RegionVerify>
 800edbe:	2800      	cmp	r0, #0
 800edc0:	f43f af73 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 800edc4:	6863      	ldr	r3, [r4, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 800edc6:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 800edca:	9302      	str	r3, [sp, #8]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 800edcc:	2200      	movs	r2, #0
 800edce:	a902      	add	r1, sp, #8
 800edd0:	f001 fda4 	bl	801091c <RegionVerify>
 800edd4:	2800      	cmp	r0, #0
 800edd6:	f43f af68 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 800edda:	3404      	adds	r4, #4
 800eddc:	e894 0003 	ldmia.w	r4, {r0, r1}
 800ede0:	356c      	adds	r5, #108	@ 0x6c
 800ede2:	e885 0003 	stmia.w	r5, {r0, r1}
 800ede6:	e739      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 800ede8:	4b15      	ldr	r3, [pc, #84]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800edea:	7902      	ldrb	r2, [r0, #4]
 800edec:	f883 208c 	strb.w	r2, [r3, #140]	@ 0x8c
            break;
 800edf0:	e734      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 800edf2:	7903      	ldrb	r3, [r0, #4]
 800edf4:	2b02      	cmp	r3, #2
 800edf6:	f43f af58 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 800edfa:	4a11      	ldr	r2, [pc, #68]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800edfc:	f882 312c 	strb.w	r3, [r2, #300]	@ 0x12c
 800ee00:	e72c      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
    switch( Nvm.MacGroup2.DeviceClass )
 800ee02:	4e0f      	ldr	r6, [pc, #60]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
            status = SwitchClass( mibSet->Param.Class );
 800ee04:	7904      	ldrb	r4, [r0, #4]
    switch( Nvm.MacGroup2.DeviceClass )
 800ee06:	f896 3118 	ldrb.w	r3, [r6, #280]	@ 0x118
 800ee0a:	2b01      	cmp	r3, #1
 800ee0c:	f000 812b 	beq.w	800f066 <LoRaMacMibSetRequestConfirm+0x4ca>
 800ee10:	2b02      	cmp	r3, #2
 800ee12:	f000 8131 	beq.w	800f078 <LoRaMacMibSetRequestConfirm+0x4dc>
 800ee16:	2b00      	cmp	r3, #0
 800ee18:	f47f af47 	bne.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
            if( deviceClass == CLASS_A )
 800ee1c:	2c00      	cmp	r4, #0
 800ee1e:	f040 8137 	bne.w	800f090 <LoRaMacMibSetRequestConfirm+0x4f4>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 800ee22:	f106 036c 	add.w	r3, r6, #108	@ 0x6c
 800ee26:	e893 0003 	ldmia.w	r3, {r0, r1}
 800ee2a:	3674      	adds	r6, #116	@ 0x74
 800ee2c:	e886 0003 	stmia.w	r6, {r0, r1}
            if( deviceClass == CLASS_C )
 800ee30:	e714      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 800ee32:	4b03      	ldr	r3, [pc, #12]	@ (800ee40 <LoRaMacMibSetRequestConfirm+0x2a4>)
 800ee34:	6842      	ldr	r2, [r0, #4]
 800ee36:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
            break;
 800ee3a:	e70f      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800ee3c:	20000dec 	.word	0x20000dec
 800ee40:	20000684 	.word	0x20000684
 800ee44:	08017658 	.word	0x08017658
 800ee48:	200011cc 	.word	0x200011cc
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 800ee4c:	6840      	ldr	r0, [r0, #4]
 800ee4e:	f7fc fdaf 	bl	800b9b0 <SecureElementSetJoinEui>
 800ee52:	2800      	cmp	r0, #0
 800ee54:	f43f af02 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800ee58:	e727      	b.n	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 800ee5a:	6840      	ldr	r0, [r0, #4]
 800ee5c:	f7fc fd8c 	bl	800b978 <SecureElementSetDevEui>
 800ee60:	2800      	cmp	r0, #0
 800ee62:	f43f aefb 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800ee66:	e720      	b.n	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 800ee68:	4bb9      	ldr	r3, [pc, #740]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800ee6a:	7902      	ldrb	r2, [r0, #4]
 800ee6c:	f883 211a 	strb.w	r2, [r3, #282]	@ 0x11a
            break;
 800ee70:	e6f4      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = mibSet->Param.AdrAckLimit;
 800ee72:	4bb7      	ldr	r3, [pc, #732]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800ee74:	8882      	ldrh	r2, [r0, #4]
 800ee76:	f8a3 20d0 	strh.w	r2, [r3, #208]	@ 0xd0
            break;
 800ee7a:	e6ef      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.AdrAckDelay = mibSet->Param.AdrAckDelay;
 800ee7c:	4bb4      	ldr	r3, [pc, #720]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800ee7e:	8882      	ldrh	r2, [r0, #4]
 800ee80:	f8a3 208a 	strh.w	r2, [r3, #138]	@ 0x8a
            break;
 800ee84:	e6ea      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( mibSet->Param.McKEKey != NULL )
 800ee86:	6841      	ldr	r1, [r0, #4]
 800ee88:	2900      	cmp	r1, #0
 800ee8a:	f43f af0e 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 800ee8e:	200c      	movs	r0, #12
 800ee90:	f001 f9a4 	bl	80101dc <LoRaMacCryptoSetKey>
 800ee94:	2800      	cmp	r0, #0
 800ee96:	f43f aee1 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 800ee9a:	2011      	movs	r0, #17
 800ee9c:	e6d0      	b.n	800ec40 <LoRaMacMibSetRequestConfirm+0xa4>
            if( mibSet->Param.AppSKey != NULL )
 800ee9e:	6841      	ldr	r1, [r0, #4]
 800eea0:	2900      	cmp	r1, #0
 800eea2:	f43f af02 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 800eea6:	2009      	movs	r0, #9
 800eea8:	f001 f998 	bl	80101dc <LoRaMacCryptoSetKey>
 800eeac:	2800      	cmp	r0, #0
 800eeae:	f43f aed5 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800eeb2:	e7f2      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            if( mibSet->Param.NwkSKey != NULL )
 800eeb4:	6841      	ldr	r1, [r0, #4]
 800eeb6:	2900      	cmp	r1, #0
 800eeb8:	f43f aef7 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 800eebc:	2008      	movs	r0, #8
 800eebe:	f001 f98d 	bl	80101dc <LoRaMacCryptoSetKey>
 800eec2:	2800      	cmp	r0, #0
 800eec4:	f43f aeca 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800eec8:	e7e7      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            if( mibSet->Param.NwkKey != NULL )
 800eeca:	6841      	ldr	r1, [r0, #4]
 800eecc:	2900      	cmp	r1, #0
 800eece:	f43f aeec 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 800eed2:	2001      	movs	r0, #1
 800eed4:	f001 f982 	bl	80101dc <LoRaMacCryptoSetKey>
 800eed8:	2800      	cmp	r0, #0
 800eeda:	f43f aebf 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800eede:	e7dc      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            if( mibSet->Param.AppKey != NULL )
 800eee0:	6841      	ldr	r1, [r0, #4]
 800eee2:	2900      	cmp	r1, #0
 800eee4:	f43f aee1 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 800eee8:	2000      	movs	r0, #0
 800eeea:	f001 f977 	bl	80101dc <LoRaMacCryptoSetKey>
 800eeee:	2800      	cmp	r0, #0
 800eef0:	f43f aeb4 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800eef4:	e7d1      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            if(SecureElementSetDevAddr( Nvm.MacGroup2.NetworkActivation, mibSet->Param.DevAddr ) != SECURE_ELEMENT_SUCCESS )
 800eef6:	4d96      	ldr	r5, [pc, #600]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800eef8:	6841      	ldr	r1, [r0, #4]
 800eefa:	f895 012c 	ldrb.w	r0, [r5, #300]	@ 0x12c
 800eefe:	f7fc fd75 	bl	800b9ec <SecureElementSetDevAddr>
 800ef02:	2800      	cmp	r0, #0
 800ef04:	f47f aed1 	bne.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 800ef08:	6863      	ldr	r3, [r4, #4]
 800ef0a:	f8c5 30e4 	str.w	r3, [r5, #228]	@ 0xe4
 800ef0e:	e6a5      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 800ef10:	4c90      	ldr	r4, [pc, #576]	@ (800f154 <LoRaMacMibSetRequestConfirm+0x5b8>)
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 800ef12:	4a8f      	ldr	r2, [pc, #572]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800ef14:	7900      	ldrb	r0, [r0, #4]
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 800ef16:	6da3      	ldr	r3, [r4, #88]	@ 0x58
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 800ef18:	f882 0119 	strb.w	r0, [r2, #281]	@ 0x119
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 800ef1c:	4798      	blx	r3
            Radio.Sleep( );
 800ef1e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 800ef20:	4798      	blx	r3
            break;
 800ef22:	e69b      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( mibSet->Param.McNwkSKey0 != NULL )
 800ef24:	6841      	ldr	r1, [r0, #4]
 800ef26:	2900      	cmp	r1, #0
 800ef28:	f43f aebf 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 800ef2c:	200f      	movs	r0, #15
 800ef2e:	f001 f955 	bl	80101dc <LoRaMacCryptoSetKey>
 800ef32:	2800      	cmp	r0, #0
 800ef34:	f43f ae92 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800ef38:	e7af      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            if( mibSet->Param.McAppSKey0 != NULL )
 800ef3a:	6841      	ldr	r1, [r0, #4]
 800ef3c:	2900      	cmp	r1, #0
 800ef3e:	f43f aeb4 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 800ef42:	200e      	movs	r0, #14
 800ef44:	f001 f94a 	bl	80101dc <LoRaMacCryptoSetKey>
 800ef48:	2800      	cmp	r0, #0
 800ef4a:	f43f ae87 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800ef4e:	e7a4      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            if( mibSet->Param.McKey0 != NULL )
 800ef50:	6841      	ldr	r1, [r0, #4]
 800ef52:	2900      	cmp	r1, #0
 800ef54:	f43f aea9 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 800ef58:	200d      	movs	r0, #13
 800ef5a:	f001 f93f 	bl	80101dc <LoRaMacCryptoSetKey>
 800ef5e:	2800      	cmp	r0, #0
 800ef60:	f43f ae7c 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800ef64:	e799      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 800ef66:	4b7a      	ldr	r3, [pc, #488]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800ef68:	6842      	ldr	r2, [r0, #4]
 800ef6a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            break;
 800ef6e:	e675      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 800ef70:	4b77      	ldr	r3, [pc, #476]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800ef72:	7902      	ldrb	r2, [r0, #4]
 800ef74:	f883 2098 	strb.w	r2, [r3, #152]	@ 0x98
 800ef78:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
            break;
 800ef7c:	e66e      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 800ef7e:	4b74      	ldr	r3, [pc, #464]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800ef80:	6842      	ldr	r2, [r0, #4]
 800ef82:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 800ef86:	64da      	str	r2, [r3, #76]	@ 0x4c
            break;
 800ef88:	e668      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 800ef8a:	4d71      	ldr	r5, [pc, #452]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 800ef8c:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 800ef8e:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 800ef92:	f88d 3008 	strb.w	r3, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 800ef96:	220a      	movs	r2, #10
 800ef98:	a902      	add	r1, sp, #8
 800ef9a:	f001 fcbf 	bl	801091c <RegionVerify>
 800ef9e:	2800      	cmp	r0, #0
 800efa0:	f43f ae83 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 800efa4:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800efa8:	f885 30dc 	strb.w	r3, [r5, #220]	@ 0xdc
 800efac:	e656      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 800efae:	4d68      	ldr	r5, [pc, #416]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 800efb0:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 800efb2:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 800efb6:	f88d 3008 	strb.w	r3, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 800efba:	2209      	movs	r2, #9
 800efbc:	a902      	add	r1, sp, #8
 800efbe:	f001 fcad 	bl	801091c <RegionVerify>
 800efc2:	2800      	cmp	r0, #0
 800efc4:	f43f ae71 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 800efc8:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800efcc:	f885 3038 	strb.w	r3, [r5, #56]	@ 0x38
 800efd0:	e644      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800efd2:	4d5f      	ldr	r5, [pc, #380]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 800efd4:	7901      	ldrb	r1, [r0, #4]
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800efd6:	f895 307c 	ldrb.w	r3, [r5, #124]	@ 0x7c
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 800efda:	f88d 1008 	strb.w	r1, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 800efde:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800efe2:	f88d 300a 	strb.w	r3, [sp, #10]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 800efe6:	2205      	movs	r2, #5
 800efe8:	a902      	add	r1, sp, #8
 800efea:	f001 fc97 	bl	801091c <RegionVerify>
 800efee:	2800      	cmp	r0, #0
 800eff0:	f43f ae5b 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 800eff4:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800eff8:	f885 3039 	strb.w	r3, [r5, #57]	@ 0x39
 800effc:	e62e      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 800effe:	4d54      	ldr	r5, [pc, #336]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 800f000:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 800f002:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 800f006:	f88d 3008 	strb.w	r3, [sp, #8]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 800f00a:	2206      	movs	r2, #6
 800f00c:	a902      	add	r1, sp, #8
 800f00e:	f001 fc85 	bl	801091c <RegionVerify>
 800f012:	2800      	cmp	r0, #0
 800f014:	f43f ae49 	beq.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 800f018:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800f01c:	f885 30dd 	strb.w	r3, [r5, #221]	@ 0xdd
 800f020:	e61c      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 800f022:	4b4b      	ldr	r3, [pc, #300]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800f024:	6842      	ldr	r2, [r0, #4]
 800f026:	665a      	str	r2, [r3, #100]	@ 0x64
            break;
 800f028:	e618      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.AdrAckLimit = mibSet->Param.AdrAckLimit;
 800f02a:	4b49      	ldr	r3, [pc, #292]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800f02c:	8882      	ldrh	r2, [r0, #4]
 800f02e:	f8a3 2088 	strh.w	r2, [r3, #136]	@ 0x88
            break;
 800f032:	e613      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            Nvm.MacGroup2.MacParams.RxBCTimeout = mibSet->Param.RxBCTimeout;
 800f034:	4b46      	ldr	r3, [pc, #280]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800f036:	6842      	ldr	r2, [r0, #4]
 800f038:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
            break;
 800f03c:	e60e      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 800f03e:	7983      	ldrb	r3, [r0, #6]
 800f040:	2b01      	cmp	r3, #1
 800f042:	f63f ae32 	bhi.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 800f046:	6842      	ldr	r2, [r0, #4]
 800f048:	4b41      	ldr	r3, [pc, #260]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 800f04a:	4610      	mov	r0, r2
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 800f04c:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 800f050:	f001 f858 	bl	8010104 <LoRaMacCryptoSetLrWanVersion>
 800f054:	2800      	cmp	r0, #0
 800f056:	f43f ae01 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
 800f05a:	e71e      	b.n	800ee9a <LoRaMacMibSetRequestConfirm+0x2fe>
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 800f05c:	4b3c      	ldr	r3, [pc, #240]	@ (800f150 <LoRaMacMibSetRequestConfirm+0x5b4>)
 800f05e:	6842      	ldr	r2, [r0, #4]
 800f060:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc
            break;
 800f064:	e5fa      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            status = LoRaMacClassBSwitchClass( deviceClass );
 800f066:	4620      	mov	r0, r4
 800f068:	f000 fc7a 	bl	800f960 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 800f06c:	2800      	cmp	r0, #0
 800f06e:	f47f ade7 	bne.w	800ec40 <LoRaMacMibSetRequestConfirm+0xa4>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 800f072:	f886 4118 	strb.w	r4, [r6, #280]	@ 0x118
 800f076:	e5e3      	b.n	800ec40 <LoRaMacMibSetRequestConfirm+0xa4>
            if( deviceClass == CLASS_A )
 800f078:	2c00      	cmp	r4, #0
 800f07a:	f47f ae16 	bne.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                Radio.Sleep( );
 800f07e:	4b35      	ldr	r3, [pc, #212]	@ (800f154 <LoRaMacMibSetRequestConfirm+0x5b8>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 800f080:	f886 4118 	strb.w	r4, [r6, #280]	@ 0x118
                MacCtx.RxSlot = RX_SLOT_NONE;
 800f084:	2206      	movs	r2, #6
                Radio.Sleep( );
 800f086:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
                MacCtx.RxSlot = RX_SLOT_NONE;
 800f088:	f885 2480 	strb.w	r2, [r5, #1152]	@ 0x480
                Radio.Sleep( );
 800f08c:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 800f08e:	e5e5      	b.n	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
            if( deviceClass == CLASS_B )
 800f090:	2c01      	cmp	r4, #1
 800f092:	d0e8      	beq.n	800f066 <LoRaMacMibSetRequestConfirm+0x4ca>
            if( deviceClass == CLASS_C )
 800f094:	2c02      	cmp	r4, #2
 800f096:	f47f ae08 	bne.w	800ecaa <LoRaMacMibSetRequestConfirm+0x10e>
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800f09a:	4f2f      	ldr	r7, [pc, #188]	@ (800f158 <LoRaMacMibSetRequestConfirm+0x5bc>)
 800f09c:	f896 90e9 	ldrb.w	r9, [r6, #233]	@ 0xe9
                        ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Class == CLASS_C ) )
 800f0a0:	f896 8100 	ldrb.w	r8, [r6, #256]	@ 0x100
                Nvm.MacGroup2.DeviceClass = deviceClass;
 800f0a4:	f886 4118 	strb.w	r4, [r6, #280]	@ 0x118
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800f0a8:	f1a7 0e14 	sub.w	lr, r7, #20
 800f0ac:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800f0b0:	46bc      	mov	ip, r7
 800f0b2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800f0b6:	f8de 3000 	ldr.w	r3, [lr]
 800f0ba:	f8cc 3000 	str.w	r3, [ip]
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 800f0be:	f885 43f3 	strb.w	r4, [r5, #1011]	@ 0x3f3
                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 800f0c2:	f1b9 0f00 	cmp.w	r9, #0
 800f0c6:	d002      	beq.n	800f0ce <LoRaMacMibSetRequestConfirm+0x532>
                    if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) &&
 800f0c8:	f1b8 0f02 	cmp.w	r8, #2
 800f0cc:	d024      	beq.n	800f118 <LoRaMacMibSetRequestConfirm+0x57c>
                Radio.Sleep( );
 800f0ce:	f8df 8084 	ldr.w	r8, [pc, #132]	@ 800f154 <LoRaMacMibSetRequestConfirm+0x5b8>
                MacCtx.NodeAckRequested = false;
 800f0d2:	2400      	movs	r4, #0
                Radio.Sleep( );
 800f0d4:	f8d8 302c 	ldr.w	r3, [r8, #44]	@ 0x2c
                MacCtx.NodeAckRequested = false;
 800f0d8:	f885 4410 	strb.w	r4, [r5, #1040]	@ 0x410
                Radio.Sleep( );
 800f0dc:	4798      	blx	r3
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 800f0de:	9700      	str	r7, [sp, #0]
 800f0e0:	6cf3      	ldr	r3, [r6, #76]	@ 0x4c
 800f0e2:	f896 2050 	ldrb.w	r2, [r6, #80]	@ 0x50
 800f0e6:	f996 1078 	ldrsb.w	r1, [r6, #120]	@ 0x78
 800f0ea:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
 800f0ee:	f001 fc2d 	bl	801094c <RegionComputeRxWindowParameters>
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800f0f2:	4a1a      	ldr	r2, [pc, #104]	@ (800f15c <LoRaMacMibSetRequestConfirm+0x5c0>)
 800f0f4:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800f0f8:	f240 2301 	movw	r3, #513	@ 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800f0fc:	f1a2 013c 	sub.w	r1, r2, #60	@ 0x3c
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800f100:	f8a5 33f2 	strh.w	r3, [r5, #1010]	@ 0x3f2
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800f104:	f001 fc30 	bl	8010968 <RegionRxConfig>
 800f108:	2800      	cmp	r0, #0
 800f10a:	f43f ada7 	beq.w	800ec5c <LoRaMacMibSetRequestConfirm+0xc0>
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 800f10e:	f895 241c 	ldrb.w	r2, [r5, #1052]	@ 0x41c
        Radio.Rx( 0 ); // Continuous mode
 800f112:	f8d8 3034 	ldr.w	r3, [r8, #52]	@ 0x34
 800f116:	e607      	b.n	800ed28 <LoRaMacMibSetRequestConfirm+0x18c>
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Datarate;
 800f118:	f896 2108 	ldrb.w	r2, [r6, #264]	@ 0x108
 800f11c:	f886 2078 	strb.w	r2, [r6, #120]	@ 0x78
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 800f120:	f895 2411 	ldrb.w	r2, [r5, #1041]	@ 0x411
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Frequency;
 800f124:	f8d6 3104 	ldr.w	r3, [r6, #260]	@ 0x104
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 800f128:	f885 23e0 	strb.w	r2, [r5, #992]	@ 0x3e0
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800f12c:	f896 207d 	ldrb.w	r2, [r6, #125]	@ 0x7d
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Frequency;
 800f130:	6773      	str	r3, [r6, #116]	@ 0x74
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 800f132:	f8c5 33e4 	str.w	r3, [r5, #996]	@ 0x3e4
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800f136:	f885 23f0 	strb.w	r2, [r5, #1008]	@ 0x3f0
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 800f13a:	f240 3301 	movw	r3, #769	@ 0x301
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 800f13e:	f896 208c 	ldrb.w	r2, [r6, #140]	@ 0x8c
 800f142:	f885 23f1 	strb.w	r2, [r5, #1009]	@ 0x3f1
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 800f146:	f8a5 33f2 	strh.w	r3, [r5, #1010]	@ 0x3f2
                        break;
 800f14a:	e7c0      	b.n	800f0ce <LoRaMacMibSetRequestConfirm+0x532>
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 800f14c:	2003      	movs	r0, #3
}
 800f14e:	4770      	bx	lr
 800f150:	20000684 	.word	0x20000684
 800f154:	08017658 	.word	0x08017658
 800f158:	200011cc 	.word	0x200011cc
 800f15c:	20001208 	.word	0x20001208

0800f160 <LoRaMacMlmeRequest>:

    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 800f160:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f164:	b086      	sub	sp, #24
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 800f166:	2300      	movs	r3, #0
 800f168:	f8ad 3000 	strh.w	r3, [sp]

    if( mlmeRequest == NULL )
 800f16c:	2800      	cmp	r0, #0
 800f16e:	d039      	beq.n	800f1e4 <LoRaMacMlmeRequest+0x84>
    if( MacCtx.MacState == LORAMAC_STOPPED )
 800f170:	4e9c      	ldr	r6, [pc, #624]	@ (800f3e4 <LoRaMacMlmeRequest+0x284>)
 800f172:	f8d6 3340 	ldr.w	r3, [r6, #832]	@ 0x340
 800f176:	2b01      	cmp	r3, #1
 800f178:	4604      	mov	r4, r0
 800f17a:	d009      	beq.n	800f190 <LoRaMacMlmeRequest+0x30>
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 800f17c:	b123      	cbz	r3, 800f188 <LoRaMacMlmeRequest+0x28>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = 0;
#endif /* LORAMAC_VERSION */

    if( LoRaMacIsBusy( ) == true )
    {
        return LORAMAC_STATUS_BUSY;
 800f17e:	2501      	movs	r5, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 800f180:	4628      	mov	r0, r5
 800f182:	b006      	add	sp, #24
 800f184:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 800f188:	f896 3482 	ldrb.w	r3, [r6, #1154]	@ 0x482
 800f18c:	2b01      	cmp	r3, #1
 800f18e:	d1f6      	bne.n	800f17e <LoRaMacMlmeRequest+0x1e>
    if( LoRaMacConfirmQueueIsFull( ) == true )
 800f190:	f000 fe96 	bl	800fec0 <LoRaMacConfirmQueueIsFull>
 800f194:	2800      	cmp	r0, #0
 800f196:	d1f2      	bne.n	800f17e <LoRaMacMlmeRequest+0x1e>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 800f198:	f000 fe8c 	bl	800feb4 <LoRaMacConfirmQueueGetCnt>
 800f19c:	4601      	mov	r1, r0
 800f19e:	b1e0      	cbz	r0, 800f1da <LoRaMacMlmeRequest+0x7a>
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 800f1a0:	f896 3481 	ldrb.w	r3, [r6, #1153]	@ 0x481
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800f1a4:	2201      	movs	r2, #1
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 800f1a6:	f043 0304 	orr.w	r3, r3, #4
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800f1aa:	f886 2449 	strb.w	r2, [r6, #1097]	@ 0x449
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 800f1ae:	f886 3481 	strb.w	r3, [r6, #1153]	@ 0x481
    queueElement.Request = mlmeRequest->Type;
 800f1b2:	7823      	ldrb	r3, [r4, #0]
 800f1b4:	f88d 3004 	strb.w	r3, [sp, #4]
    queueElement.RestrictCommonReadyToHandle = false;
 800f1b8:	2100      	movs	r1, #0
    switch( mlmeRequest->Type )
 800f1ba:	3b01      	subs	r3, #1
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800f1bc:	f88d 2005 	strb.w	r2, [sp, #5]
    queueElement.RestrictCommonReadyToHandle = false;
 800f1c0:	f88d 1007 	strb.w	r1, [sp, #7]
    switch( mlmeRequest->Type )
 800f1c4:	2b0d      	cmp	r3, #13
 800f1c6:	d812      	bhi.n	800f1ee <LoRaMacMlmeRequest+0x8e>
 800f1c8:	e8df f003 	tbb	[pc, r3]
 800f1cc:	1111119d 	.word	0x1111119d
 800f1d0:	11226f64 	.word	0x11226f64
 800f1d4:	41113711 	.word	0x41113711
 800f1d8:	934d      	.short	0x934d
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 800f1da:	4883      	ldr	r0, [pc, #524]	@ (800f3e8 <LoRaMacMlmeRequest+0x288>)
 800f1dc:	2214      	movs	r2, #20
 800f1de:	f003 f8ad 	bl	801233c <memset1>
 800f1e2:	e7dd      	b.n	800f1a0 <LoRaMacMlmeRequest+0x40>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800f1e4:	2503      	movs	r5, #3
}
 800f1e6:	4628      	mov	r0, r5
 800f1e8:	b006      	add	sp, #24
 800f1ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f1ee:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 800f1f2:	2502      	movs	r5, #2
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f1f4:	6123      	str	r3, [r4, #16]
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 800f1f6:	f000 fe5d 	bl	800feb4 <LoRaMacConfirmQueueGetCnt>
 800f1fa:	2800      	cmp	r0, #0
 800f1fc:	d1c0      	bne.n	800f180 <LoRaMacMlmeRequest+0x20>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 800f1fe:	f896 3481 	ldrb.w	r3, [r6, #1153]	@ 0x481
            MacCtx.NodeAckRequested = false;
 800f202:	f886 0410 	strb.w	r0, [r6, #1040]	@ 0x410
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 800f206:	f360 0382 	bfi	r3, r0, #2, #1
 800f20a:	f886 3481 	strb.w	r3, [r6, #1153]	@ 0x481
 800f20e:	e7b7      	b.n	800f180 <LoRaMacMlmeRequest+0x20>
    Radio.SetTxContinuousWave( frequency, power, timeout );
 800f210:	4b76      	ldr	r3, [pc, #472]	@ (800f3ec <LoRaMacMlmeRequest+0x28c>)
 800f212:	88a2      	ldrh	r2, [r4, #4]
 800f214:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f216:	f994 100c 	ldrsb.w	r1, [r4, #12]
 800f21a:	68a0      	ldr	r0, [r4, #8]
 800f21c:	4798      	blx	r3
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800f21e:	f8d6 2340 	ldr.w	r2, [r6, #832]	@ 0x340
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f222:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800f226:	f042 0202 	orr.w	r2, r2, #2
 800f22a:	f8c6 2340 	str.w	r2, [r6, #832]	@ 0x340
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f22e:	6123      	str	r3, [r4, #16]
        LoRaMacConfirmQueueAdd( &queueElement );
 800f230:	a801      	add	r0, sp, #4
 800f232:	f000 fd3d 	bl	800fcb0 <LoRaMacConfirmQueueAdd>
 800f236:	2500      	movs	r5, #0
 800f238:	e7a2      	b.n	800f180 <LoRaMacMlmeRequest+0x20>
            if (LoRaMacCommandsGetCmd( MOTE_MAC_DEVICE_TIME_REQ, &newCmd ) == LORAMAC_COMMANDS_SUCCESS)
 800f23a:	a902      	add	r1, sp, #8
 800f23c:	200d      	movs	r0, #13
 800f23e:	f000 fc29 	bl	800fa94 <LoRaMacCommandsGetCmd>
 800f242:	2800      	cmp	r0, #0
 800f244:	f040 80a3 	bne.w	800f38e <LoRaMacMlmeRequest+0x22e>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f248:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
    if( status != LORAMAC_STATUS_OK )
 800f24c:	e7ef      	b.n	800f22e <LoRaMacMlmeRequest+0xce>
            queueElement.RestrictCommonReadyToHandle = true;
 800f24e:	2501      	movs	r5, #1
 800f250:	f88d 5007 	strb.w	r5, [sp, #7]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 800f254:	f000 fb6c 	bl	800f930 <LoRaMacClassBIsAcquisitionInProgress>
 800f258:	4607      	mov	r7, r0
 800f25a:	2800      	cmp	r0, #0
 800f25c:	f000 80a1 	beq.w	800f3a2 <LoRaMacMlmeRequest+0x242>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f260:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
    if( status != LORAMAC_STATUS_OK )
 800f264:	e7c6      	b.n	800f1f4 <LoRaMacMlmeRequest+0x94>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 800f266:	4b62      	ldr	r3, [pc, #392]	@ (800f3f0 <LoRaMacMlmeRequest+0x290>)
 800f268:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 800f26c:	2b00      	cmp	r3, #0
 800f26e:	d1be      	bne.n	800f1ee <LoRaMacMlmeRequest+0x8e>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 800f270:	7925      	ldrb	r5, [r4, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 800f272:	f005 0007 	and.w	r0, r5, #7
 800f276:	f000 fb6d 	bl	800f954 <LoRaMacClassBSetPingSlotInfo>
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 800f27a:	2201      	movs	r2, #1
 800f27c:	4669      	mov	r1, sp
 800f27e:	2010      	movs	r0, #16
                macCmdPayload[0] = value;
 800f280:	f88d 5000 	strb.w	r5, [sp]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 800f284:	f000 fb92 	bl	800f9ac <LoRaMacCommandsAddCmd>
 800f288:	2800      	cmp	r0, #0
 800f28a:	d0dd      	beq.n	800f248 <LoRaMacMlmeRequest+0xe8>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f28c:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 800f290:	2513      	movs	r5, #19
 800f292:	e7af      	b.n	800f1f4 <LoRaMacMlmeRequest+0x94>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 800f294:	2200      	movs	r2, #0
 800f296:	4669      	mov	r1, sp
 800f298:	2002      	movs	r0, #2
 800f29a:	f000 fb87 	bl	800f9ac <LoRaMacCommandsAddCmd>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f29e:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 800f2a2:	2800      	cmp	r0, #0
 800f2a4:	d0c3      	beq.n	800f22e <LoRaMacMlmeRequest+0xce>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 800f2a6:	2513      	movs	r5, #19
 800f2a8:	e7a4      	b.n	800f1f4 <LoRaMacMlmeRequest+0x94>
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800f2aa:	4b51      	ldr	r3, [pc, #324]	@ (800f3f0 <LoRaMacMlmeRequest+0x290>)
    continuousWave.Channel = MacCtx.Channel;
 800f2ac:	f896 1411 	ldrb.w	r1, [r6, #1041]	@ 0x411
 800f2b0:	f88d 1008 	strb.w	r1, [sp, #8]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800f2b4:	f893 1039 	ldrb.w	r1, [r3, #57]	@ 0x39
 800f2b8:	f88d 1009 	strb.w	r1, [sp, #9]
    continuousWave.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 800f2bc:	f893 1038 	ldrb.w	r1, [r3, #56]	@ 0x38
 800f2c0:	f88d 100a 	strb.w	r1, [sp, #10]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 800f2c4:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
 800f2c8:	9103      	str	r1, [sp, #12]
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 800f2ca:	f8d3 1084 	ldr.w	r1, [r3, #132]	@ 0x84
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 800f2ce:	88a2      	ldrh	r2, [r4, #4]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 800f2d0:	f893 0048 	ldrb.w	r0, [r3, #72]	@ 0x48
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 800f2d4:	9104      	str	r1, [sp, #16]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 800f2d6:	a902      	add	r1, sp, #8
    continuousWave.Timeout = timeout;
 800f2d8:	f8ad 2014 	strh.w	r2, [sp, #20]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 800f2dc:	f001 fba4 	bl	8010a28 <RegionSetContinuousWave>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800f2e0:	f8d6 2340 	ldr.w	r2, [r6, #832]	@ 0x340
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f2e4:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800f2e8:	f042 0202 	orr.w	r2, r2, #2
 800f2ec:	f8c6 2340 	str.w	r2, [r6, #832]	@ 0x340
    if( status != LORAMAC_STATUS_OK )
 800f2f0:	e79d      	b.n	800f22e <LoRaMacMlmeRequest+0xce>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 800f2f2:	2200      	movs	r2, #0
 800f2f4:	4669      	mov	r1, sp
 800f2f6:	2012      	movs	r0, #18
 800f2f8:	f000 fb58 	bl	800f9ac <LoRaMacCommandsAddCmd>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f2fc:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 800f300:	2800      	cmp	r0, #0
 800f302:	d1d0      	bne.n	800f2a6 <LoRaMacMlmeRequest+0x146>
 800f304:	e793      	b.n	800f22e <LoRaMacMlmeRequest+0xce>
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 800f306:	f8d6 3340 	ldr.w	r3, [r6, #832]	@ 0x340
 800f30a:	f013 0520 	ands.w	r5, r3, #32
 800f30e:	f47f af36 	bne.w	800f17e <LoRaMacMlmeRequest+0x1e>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 800f312:	4f37      	ldr	r7, [pc, #220]	@ (800f3f0 <LoRaMacMlmeRequest+0x290>)
            ResetMacParameters( false );
 800f314:	f7fd fb36 	bl	800c984 <ResetMacParameters.constprop.0>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 800f318:	f994 1005 	ldrsb.w	r1, [r4, #5]
 800f31c:	f897 0048 	ldrb.w	r0, [r7, #72]	@ 0x48
 800f320:	462a      	mov	r2, r5
 800f322:	f001 fb67 	bl	80109f4 <RegionAlternateDr>
 800f326:	f887 0039 	strb.w	r0, [r7, #57]	@ 0x39
            Nvm.MacGroup1.ChannelsTxPower = mlmeRequest->Req.Join.TxPower;
 800f32a:	79a3      	ldrb	r3, [r4, #6]
 800f32c:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 800f330:	2307      	movs	r3, #7
 800f332:	f88d 3005 	strb.w	r3, [sp, #5]
    switch( Nvm.MacGroup2.DeviceClass )
 800f336:	f897 3118 	ldrb.w	r3, [r7, #280]	@ 0x118
 800f33a:	2b01      	cmp	r3, #1
 800f33c:	d049      	beq.n	800f3d2 <LoRaMacMlmeRequest+0x272>
 800f33e:	2b02      	cmp	r3, #2
 800f340:	d03e      	beq.n	800f3c0 <LoRaMacMlmeRequest+0x260>
 800f342:	b3a3      	cbz	r3, 800f3ae <LoRaMacMlmeRequest+0x24e>
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 800f344:	4d2b      	ldr	r5, [pc, #172]	@ (800f3f4 <LoRaMacMlmeRequest+0x294>)
 800f346:	f8c6 5108 	str.w	r5, [r6, #264]	@ 0x108
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 800f34a:	23ff      	movs	r3, #255	@ 0xff
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 800f34c:	f04f 0800 	mov.w	r8, #0
            SecureElementGetJoinEui( MacCtx.TxMsg.Message.JoinReq.JoinEUI );
 800f350:	f505 7086 	add.w	r0, r5, #268	@ 0x10c
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 800f354:	f8a6 310c 	strh.w	r3, [r6, #268]	@ 0x10c
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 800f358:	f886 8104 	strb.w	r8, [r6, #260]	@ 0x104
            SecureElementGetJoinEui( MacCtx.TxMsg.Message.JoinReq.JoinEUI );
 800f35c:	f7fc fb38 	bl	800b9d0 <SecureElementGetJoinEui>
            SecureElementGetDevEui( MacCtx.TxMsg.Message.JoinReq.DevEUI );
 800f360:	f505 708a 	add.w	r0, r5, #276	@ 0x114
 800f364:	f7fc fb16 	bl	800b994 <SecureElementGetDevEui>
    status = ScheduleTx( allowDelayedTx );
 800f368:	4640      	mov	r0, r8
 800f36a:	f7fd ff43 	bl	800d1f4 <ScheduleTx>
            if( status != LORAMAC_STATUS_OK )
 800f36e:	4605      	mov	r5, r0
 800f370:	2800      	cmp	r0, #0
 800f372:	f43f af69 	beq.w	800f248 <LoRaMacMlmeRequest+0xe8>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 800f376:	f994 1005 	ldrsb.w	r1, [r4, #5]
 800f37a:	f897 0048 	ldrb.w	r0, [r7, #72]	@ 0x48
 800f37e:	2201      	movs	r2, #1
 800f380:	f001 fb38 	bl	80109f4 <RegionAlternateDr>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f384:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 800f388:	f887 0039 	strb.w	r0, [r7, #57]	@ 0x39
    if( status != LORAMAC_STATUS_OK )
 800f38c:	e732      	b.n	800f1f4 <LoRaMacMlmeRequest+0x94>
            else if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 800f38e:	2200      	movs	r2, #0
 800f390:	4669      	mov	r1, sp
 800f392:	200d      	movs	r0, #13
 800f394:	f000 fb0a 	bl	800f9ac <LoRaMacCommandsAddCmd>
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f398:	f8d6 3484 	ldr.w	r3, [r6, #1156]	@ 0x484
            else if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 800f39c:	2800      	cmp	r0, #0
 800f39e:	d182      	bne.n	800f2a6 <LoRaMacMlmeRequest+0x146>
 800f3a0:	e745      	b.n	800f22e <LoRaMacMlmeRequest+0xce>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 800f3a2:	f000 fabf 	bl	800f924 <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 800f3a6:	4638      	mov	r0, r7
 800f3a8:	f000 fac4 	bl	800f934 <LoRaMacClassBBeaconTimerEvent>
 800f3ac:	e74c      	b.n	800f248 <LoRaMacMlmeRequest+0xe8>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 800f3ae:	f107 036c 	add.w	r3, r7, #108	@ 0x6c
 800f3b2:	e893 0003 	ldmia.w	r3, {r0, r1}
 800f3b6:	f107 0374 	add.w	r3, r7, #116	@ 0x74
 800f3ba:	e883 0003 	stmia.w	r3, {r0, r1}
            if( deviceClass == CLASS_C )
 800f3be:	e7c1      	b.n	800f344 <LoRaMacMlmeRequest+0x1e4>
                MacCtx.RxSlot = RX_SLOT_NONE;
 800f3c0:	2306      	movs	r3, #6
 800f3c2:	f886 3480 	strb.w	r3, [r6, #1152]	@ 0x480
                Radio.Sleep( );
 800f3c6:	4b09      	ldr	r3, [pc, #36]	@ (800f3ec <LoRaMacMlmeRequest+0x28c>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 800f3c8:	f887 5118 	strb.w	r5, [r7, #280]	@ 0x118
                Radio.Sleep( );
 800f3cc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800f3ce:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 800f3d0:	e7b8      	b.n	800f344 <LoRaMacMlmeRequest+0x1e4>
            status = LoRaMacClassBSwitchClass( deviceClass );
 800f3d2:	4628      	mov	r0, r5
 800f3d4:	f000 fac4 	bl	800f960 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 800f3d8:	2800      	cmp	r0, #0
 800f3da:	d1b3      	bne.n	800f344 <LoRaMacMlmeRequest+0x1e4>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 800f3dc:	f887 0118 	strb.w	r0, [r7, #280]	@ 0x118
 800f3e0:	e7b0      	b.n	800f344 <LoRaMacMlmeRequest+0x1e4>
 800f3e2:	bf00      	nop
 800f3e4:	20000dec 	.word	0x20000dec
 800f3e8:	20001234 	.word	0x20001234
 800f3ec:	08017658 	.word	0x08017658
 800f3f0:	20000684 	.word	0x20000684
 800f3f4:	20000dee 	.word	0x20000dee

0800f3f8 <LoRaMacMcpsRequest>:
    void* fBuffer = NULL;
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 800f3f8:	2800      	cmp	r0, #0
 800f3fa:	f000 816d 	beq.w	800f6d8 <LoRaMacMcpsRequest+0x2e0>
{
 800f3fe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( MacCtx.MacState == LORAMAC_STOPPED )
 800f402:	4db6      	ldr	r5, [pc, #728]	@ (800f6dc <LoRaMacMcpsRequest+0x2e4>)
 800f404:	f8d5 3340 	ldr.w	r3, [r5, #832]	@ 0x340
 800f408:	2b01      	cmp	r3, #1
{
 800f40a:	b097      	sub	sp, #92	@ 0x5c
 800f40c:	460f      	mov	r7, r1
 800f40e:	4604      	mov	r4, r0
    if( MacCtx.MacState == LORAMAC_STOPPED )
 800f410:	d008      	beq.n	800f424 <LoRaMacMcpsRequest+0x2c>
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 800f412:	b11b      	cbz	r3, 800f41c <LoRaMacMcpsRequest+0x24>
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    if( LoRaMacIsBusy( ) == true )
    {
        return LORAMAC_STATUS_BUSY;
 800f414:	2001      	movs	r0, #1

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 800f416:	b017      	add	sp, #92	@ 0x5c
 800f418:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 800f41c:	f895 3482 	ldrb.w	r3, [r5, #1154]	@ 0x482
 800f420:	2b01      	cmp	r3, #1
 800f422:	d1f7      	bne.n	800f414 <LoRaMacMcpsRequest+0x1c>
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 800f424:	2214      	movs	r2, #20
 800f426:	48ae      	ldr	r0, [pc, #696]	@ (800f6e0 <LoRaMacMcpsRequest+0x2e8>)
 800f428:	2100      	movs	r1, #0
 800f42a:	f002 ff87 	bl	801233c <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800f42e:	2201      	movs	r2, #1
 800f430:	f885 2435 	strb.w	r2, [r5, #1077]	@ 0x435
    MacCtx.AckTimeoutRetriesCounter = 1;
 800f434:	f885 240e 	strb.w	r2, [r5, #1038]	@ 0x40e
    switch( mcpsRequest->Type )
 800f438:	7823      	ldrb	r3, [r4, #0]
 800f43a:	4293      	cmp	r3, r2
 800f43c:	d019      	beq.n	800f472 <LoRaMacMcpsRequest+0x7a>
 800f43e:	2b03      	cmp	r3, #3
 800f440:	f000 8115 	beq.w	800f66e <LoRaMacMcpsRequest+0x276>
 800f444:	2b00      	cmp	r3, #0
 800f446:	f000 8103 	beq.w	800f650 <LoRaMacMcpsRequest+0x258>
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f44a:	4ba6      	ldr	r3, [pc, #664]	@ (800f6e4 <LoRaMacMcpsRequest+0x2ec>)
    getPhy.Attribute = PHY_MIN_TX_DR;
 800f44c:	2602      	movs	r6, #2
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f44e:	f893 207c 	ldrb.w	r2, [r3, #124]	@ 0x7c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f452:	f893 0048 	ldrb.w	r0, [r3, #72]	@ 0x48
    getPhy.Attribute = PHY_MIN_TX_DR;
 800f456:	f88d 6034 	strb.w	r6, [sp, #52]	@ 0x34
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f45a:	a90d      	add	r1, sp, #52	@ 0x34
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f45c:	f88d 2036 	strb.w	r2, [sp, #54]	@ 0x36
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f460:	f001 fa46 	bl	80108f0 <RegionGetPhyParam>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 800f464:	4630      	mov	r0, r6
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 800f466:	f8d5 3484 	ldr.w	r3, [r5, #1156]	@ 0x484
 800f46a:	6123      	str	r3, [r4, #16]
}
 800f46c:	b017      	add	sp, #92	@ 0x5c
 800f46e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 800f472:	7be3      	ldrb	r3, [r4, #15]
 800f474:	2b08      	cmp	r3, #8
 800f476:	bf28      	it	cs
 800f478:	2308      	movcs	r3, #8
 800f47a:	f885 340d 	strb.w	r3, [r5, #1037]	@ 0x40d
            fPort = mcpsRequest->Req.Confirmed.fPort;
 800f47e:	7923      	ldrb	r3, [r4, #4]
 800f480:	9304      	str	r3, [sp, #16]
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 800f482:	89a3      	ldrh	r3, [r4, #12]
 800f484:	9300      	str	r3, [sp, #0]
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 800f486:	f8d4 9008 	ldr.w	r9, [r4, #8]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 800f48a:	f994 800e 	ldrsb.w	r8, [r4, #14]
            break;
 800f48e:	2380      	movs	r3, #128	@ 0x80
 800f490:	f04f 0a04 	mov.w	sl, #4
 800f494:	9301      	str	r3, [sp, #4]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f496:	4e93      	ldr	r6, [pc, #588]	@ (800f6e4 <LoRaMacMcpsRequest+0x2ec>)
    getPhy.Attribute = PHY_MIN_TX_DR;
 800f498:	2302      	movs	r3, #2
 800f49a:	f88d 3034 	strb.w	r3, [sp, #52]	@ 0x34
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f49e:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f4a2:	f896 307c 	ldrb.w	r3, [r6, #124]	@ 0x7c
 800f4a6:	f88d 3036 	strb.w	r3, [sp, #54]	@ 0x36
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f4aa:	a90d      	add	r1, sp, #52	@ 0x34
 800f4ac:	f001 fa20 	bl	80108f0 <RegionGetPhyParam>
        if( Nvm.MacGroup2.AdrCtrlOn == false )
 800f4b0:	f896 311a 	ldrb.w	r3, [r6, #282]	@ 0x11a
 800f4b4:	2b00      	cmp	r3, #0
 800f4b6:	f000 80b0 	beq.w	800f61a <LoRaMacMcpsRequest+0x222>
    int8_t datarate = Nvm.MacGroup1.ChannelsDatarate;
 800f4ba:	f996 3039 	ldrsb.w	r3, [r6, #57]	@ 0x39
 800f4be:	9302      	str	r3, [sp, #8]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800f4c0:	f896 212c 	ldrb.w	r2, [r6, #300]	@ 0x12c
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 800f4c4:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 800f4c6:	f996 1038 	ldrsb.w	r1, [r6, #56]	@ 0x38
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 800f4ca:	9309      	str	r3, [sp, #36]	@ 0x24
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 800f4cc:	9103      	str	r1, [sp, #12]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800f4ce:	2a00      	cmp	r2, #0
 800f4d0:	f000 80eb 	beq.w	800f6aa <LoRaMacMcpsRequest+0x2b2>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 800f4d4:	f896 211b 	ldrb.w	r2, [r6, #283]	@ 0x11b
 800f4d8:	b902      	cbnz	r2, 800f4dc <LoRaMacMcpsRequest+0xe4>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 800f4da:	6332      	str	r2, [r6, #48]	@ 0x30
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 800f4dc:	9313      	str	r3, [sp, #76]	@ 0x4c
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 800f4de:	9b02      	ldr	r3, [sp, #8]
 800f4e0:	f88d 3054 	strb.w	r3, [sp, #84]	@ 0x54
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 800f4e4:	9b03      	ldr	r3, [sp, #12]
 800f4e6:	f88d 3055 	strb.w	r3, [sp, #85]	@ 0x55
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800f4ea:	f896 3118 	ldrb.w	r3, [r6, #280]	@ 0x118
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800f4ee:	4a7e      	ldr	r2, [pc, #504]	@ (800f6e8 <LoRaMacMcpsRequest+0x2f0>)
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 800f4f0:	f896 b11a 	ldrb.w	fp, [r6, #282]	@ 0x11a
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 800f4f4:	f88d b049 	strb.w	fp, [sp, #73]	@ 0x49
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800f4f8:	f1a3 0801 	sub.w	r8, r3, #1
    if( Nvm.MacGroup1.SrvAckRequested == true )
 800f4fc:	f896 303a 	ldrb.w	r3, [r6, #58]	@ 0x3a
 800f500:	9305      	str	r3, [sp, #20]
    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;
 800f502:	f8d6 3088 	ldr.w	r3, [r6, #136]	@ 0x88
 800f506:	9314      	str	r3, [sp, #80]	@ 0x50
    adrNext.UplinkDwellTime =  Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f508:	f896 307c 	ldrb.w	r3, [r6, #124]	@ 0x7c
 800f50c:	f88d 3056 	strb.w	r3, [sp, #86]	@ 0x56
    adrNext.Region = Nvm.MacGroup2.Region;
 800f510:	f896 3048 	ldrb.w	r3, [r6, #72]	@ 0x48
 800f514:	f88d 3057 	strb.w	r3, [sp, #87]	@ 0x57
    adrNext.Version = Nvm.MacGroup2.Version;
 800f518:	f8d6 3128 	ldr.w	r3, [r6, #296]	@ 0x128
 800f51c:	9311      	str	r3, [sp, #68]	@ 0x44
    adrNext.UpdateChanMask = true;
 800f51e:	2301      	movs	r3, #1
 800f520:	f88d 3048 	strb.w	r3, [sp, #72]	@ 0x48
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800f524:	fab8 f888 	clz	r8, r8
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800f528:	ab09      	add	r3, sp, #36	@ 0x24
 800f52a:	1c51      	adds	r1, r2, #1
 800f52c:	a811      	add	r0, sp, #68	@ 0x44
 800f52e:	f000 f97f 	bl	800f830 <LoRaMacAdrCalcNext>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800f532:	ea4f 1858 	mov.w	r8, r8, lsr #5
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800f536:	9b05      	ldr	r3, [sp, #20]
 800f538:	ea4f 1808 	mov.w	r8, r8, lsl #4
 800f53c:	ea48 1843 	orr.w	r8, r8, r3, lsl #5
 800f540:	ea48 1880 	orr.w	r8, r8, r0, lsl #6
    fCtrl.Value = 0;
 800f544:	2300      	movs	r3, #0
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800f546:	ea48 18cb 	orr.w	r8, r8, fp, lsl #7
    size_t macCmdsSize = 0;
 800f54a:	e9cd 330a 	strd	r3, r3, [sp, #40]	@ 0x28
    MacCtx.PktBufferLen = 0;
 800f54e:	802b      	strh	r3, [r5, #0]
    MacCtx.NodeAckRequested = false;
 800f550:	f885 3410 	strb.w	r3, [r5, #1040]	@ 0x410
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800f554:	f88d 8014 	strb.w	r8, [sp, #20]
    if( fBuffer == NULL )
 800f558:	f1b9 0f00 	cmp.w	r9, #0
 800f55c:	f000 80a1 	beq.w	800f6a2 <LoRaMacMcpsRequest+0x2aa>
    MacCtx.AppDataSize = fBufferSize;
 800f560:	f89d b000 	ldrb.w	fp, [sp]
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 800f564:	4861      	ldr	r0, [pc, #388]	@ (800f6ec <LoRaMacMcpsRequest+0x2f4>)
 800f566:	9a00      	ldr	r2, [sp, #0]
 800f568:	4649      	mov	r1, r9
 800f56a:	f002 fe8b 	bl	8012284 <memcpy1>
    MacCtx.PktBuffer[0] = macHdr->Value;
 800f56e:	9b01      	ldr	r3, [sp, #4]
    MacCtx.AppDataSize = fBufferSize;
 800f570:	f885 b237 	strb.w	fp, [r5, #567]	@ 0x237
    switch( macHdr->Bits.MType )
 800f574:	f1ba 0f04 	cmp.w	sl, #4
    MacCtx.PktBuffer[0] = macHdr->Value;
 800f578:	70ab      	strb	r3, [r5, #2]
    switch( macHdr->Bits.MType )
 800f57a:	f000 8098 	beq.w	800f6ae <LoRaMacMcpsRequest+0x2b6>
 800f57e:	f1ba 0f07 	cmp.w	sl, #7
 800f582:	f000 8098 	beq.w	800f6b6 <LoRaMacMcpsRequest+0x2be>
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 800f586:	9b01      	ldr	r3, [sp, #4]
 800f588:	f885 310d 	strb.w	r3, [r5, #269]	@ 0x10d
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 800f58c:	9b04      	ldr	r3, [sp, #16]
 800f58e:	f885 3128 	strb.w	r3, [r5, #296]	@ 0x128
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 800f592:	f8d6 30e4 	ldr.w	r3, [r6, #228]	@ 0xe4
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 800f596:	f885 8114 	strb.w	r8, [r5, #276]	@ 0x114
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 800f59a:	f8c5 3110 	str.w	r3, [r5, #272]	@ 0x110
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 800f59e:	f8df 8150 	ldr.w	r8, [pc, #336]	@ 800f6f0 <LoRaMacMcpsRequest+0x2f8>
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 800f5a2:	f885 b130 	strb.w	fp, [r5, #304]	@ 0x130
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 800f5a6:	2304      	movs	r3, #4
 800f5a8:	f885 3104 	strb.w	r3, [r5, #260]	@ 0x104
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 800f5ac:	23ff      	movs	r3, #255	@ 0xff
 800f5ae:	f885 310c 	strb.w	r3, [r5, #268]	@ 0x10c
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 800f5b2:	a80a      	add	r0, sp, #40	@ 0x28
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 800f5b4:	f508 739b 	add.w	r3, r8, #310	@ 0x136
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 800f5b8:	f8c5 8108 	str.w	r8, [r5, #264]	@ 0x108
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 800f5bc:	f8c5 312c 	str.w	r3, [r5, #300]	@ 0x12c
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 800f5c0:	f000 fda8 	bl	8010114 <LoRaMacCryptoGetFCntUp>
 800f5c4:	2800      	cmp	r0, #0
 800f5c6:	d161      	bne.n	800f68c <LoRaMacMcpsRequest+0x294>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 800f5c8:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
            MacCtx.McpsConfirm.AckReceived = false;
 800f5ca:	f8a5 0438 	strh.w	r0, [r5, #1080]	@ 0x438
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 800f5ce:	a80b      	add	r0, sp, #44	@ 0x2c
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 800f5d0:	f8a5 3116 	strh.w	r3, [r5, #278]	@ 0x116
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 800f5d4:	f8c5 3440 	str.w	r3, [r5, #1088]	@ 0x440
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 800f5d8:	f000 fae0 	bl	800fb9c <LoRaMacCommandsGetSizeSerializedCmds>
 800f5dc:	2800      	cmp	r0, #0
 800f5de:	f040 80ac 	bne.w	800f73a <LoRaMacMcpsRequest+0x342>
            if( macCmdsSize > 0 )
 800f5e2:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800f5e4:	2b00      	cmp	r3, #0
 800f5e6:	f040 8087 	bne.w	800f6f8 <LoRaMacMcpsRequest+0x300>
        status = ScheduleTx( allowDelayedTx );
 800f5ea:	4638      	mov	r0, r7
 800f5ec:	f7fd fe02 	bl	800d1f4 <ScheduleTx>
    if( status != LORAMAC_STATUS_OK )
 800f5f0:	2800      	cmp	r0, #0
 800f5f2:	d14c      	bne.n	800f68e <LoRaMacMcpsRequest+0x296>
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 800f5f4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
        Nvm.MacGroup1.SrvAckRequested = false;
 800f5f6:	f886 003a 	strb.w	r0, [r6, #58]	@ 0x3a
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 800f5fa:	62b3      	str	r3, [r6, #40]	@ 0x28
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 800f5fc:	f000 fa5c 	bl	800fab8 <LoRaMacCommandsRemoveNoneStickyCmds>
 800f600:	2800      	cmp	r0, #0
 800f602:	f040 809c 	bne.w	800f73e <LoRaMacMcpsRequest+0x346>
            MacCtx.MacFlags.Bits.McpsReq = 1;
 800f606:	f895 3481 	ldrb.w	r3, [r5, #1153]	@ 0x481
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 800f60a:	7822      	ldrb	r2, [r4, #0]
 800f60c:	f885 2434 	strb.w	r2, [r5, #1076]	@ 0x434
            MacCtx.MacFlags.Bits.McpsReq = 1;
 800f610:	f043 0301 	orr.w	r3, r3, #1
 800f614:	f885 3481 	strb.w	r3, [r5, #1153]	@ 0x481
 800f618:	e725      	b.n	800f466 <LoRaMacMcpsRequest+0x6e>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 800f61a:	b240      	sxtb	r0, r0
 800f61c:	4540      	cmp	r0, r8
 800f61e:	bfb8      	it	lt
 800f620:	4640      	movlt	r0, r8
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f622:	f896 307c 	ldrb.w	r3, [r6, #124]	@ 0x7c
            verify.DatarateParams.Datarate = datarate;
 800f626:	f88d 0020 	strb.w	r0, [sp, #32]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 800f62a:	2205      	movs	r2, #5
 800f62c:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f630:	f88d 3022 	strb.w	r3, [sp, #34]	@ 0x22
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 800f634:	a908      	add	r1, sp, #32
 800f636:	f001 f971 	bl	801091c <RegionVerify>
 800f63a:	b128      	cbz	r0, 800f648 <LoRaMacMcpsRequest+0x250>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 800f63c:	f99d 3020 	ldrsb.w	r3, [sp, #32]
 800f640:	9302      	str	r3, [sp, #8]
 800f642:	f886 3039 	strb.w	r3, [r6, #57]	@ 0x39
 800f646:	e73b      	b.n	800f4c0 <LoRaMacMcpsRequest+0xc8>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800f648:	2003      	movs	r0, #3
}
 800f64a:	b017      	add	sp, #92	@ 0x5c
 800f64c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            MacCtx.AckTimeoutRetries = 1;
 800f650:	f885 240d 	strb.w	r2, [r5, #1037]	@ 0x40d
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 800f654:	7923      	ldrb	r3, [r4, #4]
 800f656:	9304      	str	r3, [sp, #16]
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 800f658:	89a3      	ldrh	r3, [r4, #12]
 800f65a:	9300      	str	r3, [sp, #0]
            break;
 800f65c:	2340      	movs	r3, #64	@ 0x40
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 800f65e:	f8d4 9008 	ldr.w	r9, [r4, #8]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 800f662:	f994 800e 	ldrsb.w	r8, [r4, #14]
            break;
 800f666:	9301      	str	r3, [sp, #4]
 800f668:	f04f 0a02 	mov.w	sl, #2
 800f66c:	e713      	b.n	800f496 <LoRaMacMcpsRequest+0x9e>
            MacCtx.AckTimeoutRetries = 1;
 800f66e:	f885 240d 	strb.w	r2, [r5, #1037]	@ 0x40d
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 800f672:	8923      	ldrh	r3, [r4, #8]
 800f674:	9300      	str	r3, [sp, #0]
            break;
 800f676:	23e0      	movs	r3, #224	@ 0xe0
 800f678:	9301      	str	r3, [sp, #4]
    uint8_t fPort = 0;
 800f67a:	2300      	movs	r3, #0
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 800f67c:	f8d4 9004 	ldr.w	r9, [r4, #4]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 800f680:	f994 800a 	ldrsb.w	r8, [r4, #10]
    uint8_t fPort = 0;
 800f684:	9304      	str	r3, [sp, #16]
            break;
 800f686:	f04f 0a07 	mov.w	sl, #7
 800f68a:	e704      	b.n	800f496 <LoRaMacMcpsRequest+0x9e>
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 800f68c:	2012      	movs	r0, #18
        Nvm.MacGroup1.ChannelsDatarate = datarate;
 800f68e:	9b02      	ldr	r3, [sp, #8]
 800f690:	f886 3039 	strb.w	r3, [r6, #57]	@ 0x39
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 800f694:	9b03      	ldr	r3, [sp, #12]
 800f696:	f886 3038 	strb.w	r3, [r6, #56]	@ 0x38
            MacCtx.NodeAckRequested = false;
 800f69a:	2300      	movs	r3, #0
 800f69c:	f885 3410 	strb.w	r3, [r5, #1040]	@ 0x410
 800f6a0:	e6e1      	b.n	800f466 <LoRaMacMcpsRequest+0x6e>
 800f6a2:	46cb      	mov	fp, r9
        fBufferSize = 0;
 800f6a4:	f8cd 9000 	str.w	r9, [sp]
 800f6a8:	e75c      	b.n	800f564 <LoRaMacMcpsRequest+0x16c>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 800f6aa:	2007      	movs	r0, #7
 800f6ac:	e7f5      	b.n	800f69a <LoRaMacMcpsRequest+0x2a2>
            MacCtx.NodeAckRequested = true;
 800f6ae:	2201      	movs	r2, #1
 800f6b0:	f885 2410 	strb.w	r2, [r5, #1040]	@ 0x410
 800f6b4:	e767      	b.n	800f586 <LoRaMacMcpsRequest+0x18e>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 800f6b6:	f1b9 0f00 	cmp.w	r9, #0
 800f6ba:	d096      	beq.n	800f5ea <LoRaMacMcpsRequest+0x1f2>
 800f6bc:	f1bb 0f00 	cmp.w	fp, #0
 800f6c0:	d093      	beq.n	800f5ea <LoRaMacMcpsRequest+0x1f2>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 800f6c2:	f89d 2000 	ldrb.w	r2, [sp]
 800f6c6:	480b      	ldr	r0, [pc, #44]	@ (800f6f4 <LoRaMacMcpsRequest+0x2fc>)
 800f6c8:	4649      	mov	r1, r9
 800f6ca:	f002 fddb 	bl	8012284 <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 800f6ce:	f895 3237 	ldrb.w	r3, [r5, #567]	@ 0x237
 800f6d2:	3301      	adds	r3, #1
 800f6d4:	802b      	strh	r3, [r5, #0]
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 800f6d6:	e788      	b.n	800f5ea <LoRaMacMcpsRequest+0x1f2>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800f6d8:	2003      	movs	r0, #3
}
 800f6da:	4770      	bx	lr
 800f6dc:	20000dec 	.word	0x20000dec
 800f6e0:	20001220 	.word	0x20001220
 800f6e4:	20000684 	.word	0x20000684
 800f6e8:	200006bc 	.word	0x200006bc
 800f6ec:	20000f24 	.word	0x20000f24
 800f6f0:	20000dee 	.word	0x20000dee
 800f6f4:	20000def 	.word	0x20000def
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 800f6f8:	f896 308c 	ldrb.w	r3, [r6, #140]	@ 0x8c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f6fc:	f896 0048 	ldrb.w	r0, [r6, #72]	@ 0x48
 800f700:	330d      	adds	r3, #13
 800f702:	f88d 303c 	strb.w	r3, [sp, #60]	@ 0x3c
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 800f706:	f996 3039 	ldrsb.w	r3, [r6, #57]	@ 0x39
    getPhy.Datarate = datarate;
 800f70a:	f88d 303d 	strb.w	r3, [sp, #61]	@ 0x3d
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f70e:	a90f      	add	r1, sp, #60	@ 0x3c
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800f710:	f896 307c 	ldrb.w	r3, [r6, #124]	@ 0x7c
 800f714:	f88d 303e 	strb.w	r3, [sp, #62]	@ 0x3e
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800f718:	f001 f8ea 	bl	80108f0 <RegionGetPhyParam>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 800f71c:	f895 3237 	ldrb.w	r3, [r5, #567]	@ 0x237
 800f720:	b17b      	cbz	r3, 800f742 <LoRaMacMcpsRequest+0x34a>
 800f722:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800f724:	2b0f      	cmp	r3, #15
 800f726:	d91d      	bls.n	800f764 <LoRaMacMcpsRequest+0x36c>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 800f728:	f208 4286 	addw	r2, r8, #1158	@ 0x486
 800f72c:	a90b      	add	r1, sp, #44	@ 0x2c
 800f72e:	b2c0      	uxtb	r0, r0
 800f730:	f000 fa40 	bl	800fbb4 <LoRaMacCommandsSerializeCmds>
 800f734:	2800      	cmp	r0, #0
 800f736:	f43f af58 	beq.w	800f5ea <LoRaMacMcpsRequest+0x1f2>
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 800f73a:	2013      	movs	r0, #19
 800f73c:	e7a7      	b.n	800f68e <LoRaMacMcpsRequest+0x296>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 800f73e:	2013      	movs	r0, #19
 800f740:	e7ab      	b.n	800f69a <LoRaMacMcpsRequest+0x2a2>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 800f742:	f208 4886 	addw	r8, r8, #1158	@ 0x486
 800f746:	a90b      	add	r1, sp, #44	@ 0x2c
 800f748:	b2c0      	uxtb	r0, r0
 800f74a:	4642      	mov	r2, r8
 800f74c:	f000 fa32 	bl	800fbb4 <LoRaMacCommandsSerializeCmds>
 800f750:	2800      	cmp	r0, #0
 800f752:	d1f2      	bne.n	800f73a <LoRaMacMcpsRequest+0x342>
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 800f754:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 800f756:	f885 0128 	strb.w	r0, [r5, #296]	@ 0x128
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 800f75a:	f8c5 812c 	str.w	r8, [r5, #300]	@ 0x12c
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 800f75e:	f885 3130 	strb.w	r3, [r5, #304]	@ 0x130
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 800f762:	e742      	b.n	800f5ea <LoRaMacMcpsRequest+0x1f2>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 800f764:	f508 728b 	add.w	r2, r8, #278	@ 0x116
 800f768:	a90b      	add	r1, sp, #44	@ 0x2c
 800f76a:	200f      	movs	r0, #15
 800f76c:	f000 fa22 	bl	800fbb4 <LoRaMacCommandsSerializeCmds>
 800f770:	2800      	cmp	r0, #0
 800f772:	d1e2      	bne.n	800f73a <LoRaMacMcpsRequest+0x342>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 800f774:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800f776:	9a05      	ldr	r2, [sp, #20]
 800f778:	f363 0203 	bfi	r2, r3, #0, #4
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 800f77c:	f885 2114 	strb.w	r2, [r5, #276]	@ 0x114
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 800f780:	e733      	b.n	800f5ea <LoRaMacMcpsRequest+0x1f2>
 800f782:	bf00      	nop

0800f784 <LoRaMacTestSetDutyCycleOn>:
    OnMacProcessNotify( );
}
#endif /* LORAMAC_VERSION */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 800f784:	b530      	push	{r4, r5, lr}
    VerifyParams_t verify;

    verify.DutyCycle = enable;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 800f786:	4d0b      	ldr	r5, [pc, #44]	@ (800f7b4 <LoRaMacTestSetDutyCycleOn+0x30>)
{
 800f788:	b083      	sub	sp, #12
 800f78a:	4604      	mov	r4, r0
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 800f78c:	220f      	movs	r2, #15
 800f78e:	f895 0048 	ldrb.w	r0, [r5, #72]	@ 0x48
    verify.DutyCycle = enable;
 800f792:	f88d 4004 	strb.w	r4, [sp, #4]
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 800f796:	a901      	add	r1, sp, #4
 800f798:	f001 f8c0 	bl	801091c <RegionVerify>
 800f79c:	b140      	cbz	r0, 800f7b0 <LoRaMacTestSetDutyCycleOn+0x2c>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
        // Handle NVM potential changes
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 800f79e:	4a06      	ldr	r2, [pc, #24]	@ (800f7b8 <LoRaMacTestSetDutyCycleOn+0x34>)
        Nvm.MacGroup2.DutyCycleOn = enable;
 800f7a0:	f885 411c 	strb.w	r4, [r5, #284]	@ 0x11c
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 800f7a4:	f892 3481 	ldrb.w	r3, [r2, #1153]	@ 0x481
 800f7a8:	f043 0320 	orr.w	r3, r3, #32
 800f7ac:	f882 3481 	strb.w	r3, [r2, #1153]	@ 0x481
    }
}
 800f7b0:	b003      	add	sp, #12
 800f7b2:	bd30      	pop	{r4, r5, pc}
 800f7b4:	20000684 	.word	0x20000684
 800f7b8:	20000dec 	.word	0x20000dec

0800f7bc <LoRaMacDeInitialization>:

LoRaMacStatus_t LoRaMacDeInitialization( void )
{
 800f7bc:	b538      	push	{r3, r4, r5, lr}
    if( MacCtx.MacState == LORAMAC_STOPPED )
 800f7be:	4c15      	ldr	r4, [pc, #84]	@ (800f814 <LoRaMacDeInitialization+0x58>)
 800f7c0:	f8d4 3340 	ldr.w	r3, [r4, #832]	@ 0x340
 800f7c4:	2b01      	cmp	r3, #1
 800f7c6:	d006      	beq.n	800f7d6 <LoRaMacDeInitialization+0x1a>
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 800f7c8:	b91b      	cbnz	r3, 800f7d2 <LoRaMacDeInitialization+0x16>
 800f7ca:	f894 3482 	ldrb.w	r3, [r4, #1154]	@ 0x482
 800f7ce:	2b01      	cmp	r3, #1
 800f7d0:	d001      	beq.n	800f7d6 <LoRaMacDeInitialization+0x1a>
        // Return success
        return LORAMAC_STATUS_OK;
    }
    else
    {
        return LORAMAC_STATUS_BUSY;
 800f7d2:	2001      	movs	r0, #1
    }
}
 800f7d4:	bd38      	pop	{r3, r4, r5, pc}
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800f7d6:	4b10      	ldr	r3, [pc, #64]	@ (800f818 <LoRaMacDeInitialization+0x5c>)
            Radio.Sleep( );
 800f7d8:	4a10      	ldr	r2, [pc, #64]	@ (800f81c <LoRaMacDeInitialization+0x60>)
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800f7da:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
            Radio.Sleep( );
 800f7de:	6ad5      	ldr	r5, [r2, #44]	@ 0x2c
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800f7e0:	2b02      	cmp	r3, #2
 800f7e2:	d100      	bne.n	800f7e6 <LoRaMacDeInitialization+0x2a>
            Radio.Sleep( );
 800f7e4:	47a8      	blx	r5
        MacCtx.MacState = LORAMAC_STOPPED;
 800f7e6:	2301      	movs	r3, #1
        TimerStop( &MacCtx.TxDelayedTimer );
 800f7e8:	480d      	ldr	r0, [pc, #52]	@ (800f820 <LoRaMacDeInitialization+0x64>)
        MacCtx.MacState = LORAMAC_STOPPED;
 800f7ea:	f8c4 3340 	str.w	r3, [r4, #832]	@ 0x340
        TimerStop( &MacCtx.TxDelayedTimer );
 800f7ee:	f005 ff7d 	bl	80156ec <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.RxWindowTimer1 );
 800f7f2:	480c      	ldr	r0, [pc, #48]	@ (800f824 <LoRaMacDeInitialization+0x68>)
 800f7f4:	f005 ff7a 	bl	80156ec <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.RxWindowTimer2 );
 800f7f8:	480b      	ldr	r0, [pc, #44]	@ (800f828 <LoRaMacDeInitialization+0x6c>)
 800f7fa:	f005 ff77 	bl	80156ec <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.AckTimeoutTimer );
 800f7fe:	480b      	ldr	r0, [pc, #44]	@ (800f82c <LoRaMacDeInitialization+0x70>)
 800f800:	f005 ff74 	bl	80156ec <UTIL_TIMER_Stop>
        LoRaMacClassBHaltBeaconing( );
 800f804:	f000 f8a8 	bl	800f958 <LoRaMacClassBHaltBeaconing>
        ResetMacParameters( false );
 800f808:	f7fd f8bc 	bl	800c984 <ResetMacParameters.constprop.0>
        Radio.Sleep( );
 800f80c:	47a8      	blx	r5
        return LORAMAC_STATUS_OK;
 800f80e:	2000      	movs	r0, #0
}
 800f810:	bd38      	pop	{r3, r4, r5, pc}
 800f812:	bf00      	nop
 800f814:	20000dec 	.word	0x20000dec
 800f818:	20000684 	.word	0x20000684
 800f81c:	08017658 	.word	0x08017658
 800f820:	20001154 	.word	0x20001154
 800f824:	2000116c 	.word	0x2000116c
 800f828:	20001184 	.word	0x20001184
 800f82c:	200011e0 	.word	0x200011e0

0800f830 <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 800f830:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( adrNext->Version.Fields.Minor == 0 )
 800f834:	f890 8002 	ldrb.w	r8, [r0, #2]
{
 800f838:	b08b      	sub	sp, #44	@ 0x2c
    if( adrNext->Version.Fields.Minor == 0 )
 800f83a:	f1b8 0f00 	cmp.w	r8, #0
 800f83e:	d004      	beq.n	800f84a <LoRaMacAdrCalcNext+0x1a>
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
    }
    return false;
 800f840:	2300      	movs	r3, #0
}
 800f842:	4618      	mov	r0, r3
 800f844:	b00b      	add	sp, #44	@ 0x2c
 800f846:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
 800f84a:	461d      	mov	r5, r3
    if( adrNext->AdrEnabled == true )
 800f84c:	7943      	ldrb	r3, [r0, #5]
    int8_t datarate = adrNext->Datarate;
 800f84e:	f990 9010 	ldrsb.w	r9, [r0, #16]
    int8_t txPower = adrNext->TxPower;
 800f852:	f990 b011 	ldrsb.w	fp, [r0, #17]
 800f856:	4616      	mov	r6, r2
    *adrAckCounter = adrNext->AdrAckCounter;
 800f858:	6882      	ldr	r2, [r0, #8]
 800f85a:	602a      	str	r2, [r5, #0]
 800f85c:	4604      	mov	r4, r0
 800f85e:	460f      	mov	r7, r1
    if( adrNext->AdrEnabled == true )
 800f860:	b93b      	cbnz	r3, 800f872 <LoRaMacAdrCalcNext+0x42>
}
 800f862:	4618      	mov	r0, r3
    *drOut = datarate;
 800f864:	f887 9000 	strb.w	r9, [r7]
    *txPowOut = txPower;
 800f868:	f886 b000 	strb.w	fp, [r6]
}
 800f86c:	b00b      	add	sp, #44	@ 0x2c
 800f86e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 800f872:	7c83      	ldrb	r3, [r0, #18]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800f874:	7cc0      	ldrb	r0, [r0, #19]
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 800f876:	f88d 3016 	strb.w	r3, [sp, #22]
        getPhy.Attribute = PHY_MIN_TX_DR;
 800f87a:	f04f 0a02 	mov.w	sl, #2
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800f87e:	a905      	add	r1, sp, #20
        getPhy.Attribute = PHY_MIN_TX_DR;
 800f880:	f88d a014 	strb.w	sl, [sp, #20]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800f884:	f001 f834 	bl	80108f0 <RegionGetPhyParam>
        minTxDatarate = phyParam.Value;
 800f888:	b242      	sxtb	r2, r0
        datarate = MAX( datarate, minTxDatarate );
 800f88a:	4591      	cmp	r9, r2
 800f88c:	464b      	mov	r3, r9
 800f88e:	bfb8      	it	lt
 800f890:	4613      	movlt	r3, r2
        if( datarate == minTxDatarate )
 800f892:	4591      	cmp	r9, r2
        datarate = MAX( datarate, minTxDatarate );
 800f894:	9301      	str	r3, [sp, #4]
        if( datarate == minTxDatarate )
 800f896:	dd0c      	ble.n	800f8b2 <LoRaMacAdrCalcNext+0x82>
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 800f898:	89a3      	ldrh	r3, [r4, #12]
 800f89a:	68a0      	ldr	r0, [r4, #8]
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 800f89c:	89e1      	ldrh	r1, [r4, #14]
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 800f89e:	4298      	cmp	r0, r3
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 800f8a0:	4419      	add	r1, r3
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 800f8a2:	bf34      	ite	cc
 800f8a4:	2300      	movcc	r3, #0
 800f8a6:	2301      	movcs	r3, #1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 800f8a8:	4288      	cmp	r0, r1
 800f8aa:	d207      	bcs.n	800f8bc <LoRaMacAdrCalcNext+0x8c>
        datarate = MAX( datarate, minTxDatarate );
 800f8ac:	f8dd 9004 	ldr.w	r9, [sp, #4]
 800f8b0:	e7d7      	b.n	800f862 <LoRaMacAdrCalcNext+0x32>
 800f8b2:	4699      	mov	r9, r3
            *adrAckCounter = 0;
 800f8b4:	f8c5 8000 	str.w	r8, [r5]
            adrAckReq = false;
 800f8b8:	4643      	mov	r3, r8
 800f8ba:	e7d2      	b.n	800f862 <LoRaMacAdrCalcNext+0x32>
                getPhy.Attribute = PHY_MAX_TX_POWER;
 800f8bc:	2108      	movs	r1, #8
 800f8be:	f88d 1014 	strb.w	r1, [sp, #20]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800f8c2:	7ce0      	ldrb	r0, [r4, #19]
 800f8c4:	a905      	add	r1, sp, #20
 800f8c6:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800f8ca:	f001 f811 	bl	80108f0 <RegionGetPhyParam>
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 800f8ce:	68a1      	ldr	r1, [r4, #8]
 800f8d0:	9b03      	ldr	r3, [sp, #12]
                txPower = phyParam.Value;
 800f8d2:	fa4f fb80 	sxtb.w	fp, r0
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 800f8d6:	89e0      	ldrh	r0, [r4, #14]
 800f8d8:	fbb1 f5f0 	udiv	r5, r1, r0
 800f8dc:	fb00 1115 	mls	r1, r0, r5, r1
 800f8e0:	2901      	cmp	r1, #1
 800f8e2:	d1e3      	bne.n	800f8ac <LoRaMacAdrCalcNext+0x7c>
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 800f8e4:	7ca0      	ldrb	r0, [r4, #18]
                    getPhy.Datarate = datarate;
 800f8e6:	9b01      	ldr	r3, [sp, #4]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 800f8e8:	f88d 0016 	strb.w	r0, [sp, #22]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800f8ec:	a905      	add	r1, sp, #20
 800f8ee:	7ce0      	ldrb	r0, [r4, #19]
                    getPhy.Datarate = datarate;
 800f8f0:	f88d 3015 	strb.w	r3, [sp, #21]
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 800f8f4:	2522      	movs	r5, #34	@ 0x22
 800f8f6:	f88d 5014 	strb.w	r5, [sp, #20]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800f8fa:	f000 fff9 	bl	80108f0 <RegionGetPhyParam>
                    if( datarate == minTxDatarate )
 800f8fe:	9a02      	ldr	r2, [sp, #8]
 800f900:	9b03      	ldr	r3, [sp, #12]
                    datarate = phyParam.Value;
 800f902:	fa4f f980 	sxtb.w	r9, r0
                    if( datarate == minTxDatarate )
 800f906:	454a      	cmp	r2, r9
 800f908:	d1ab      	bne.n	800f862 <LoRaMacAdrCalcNext+0x32>
                        if( adrNext->UpdateChanMask == true )
 800f90a:	7923      	ldrb	r3, [r4, #4]
 800f90c:	b90b      	cbnz	r3, 800f912 <LoRaMacAdrCalcNext+0xe2>
                        adrAckReq = false;
 800f90e:	2300      	movs	r3, #0
 800f910:	e7a7      	b.n	800f862 <LoRaMacAdrCalcNext+0x32>
                            RegionInitDefaults( adrNext->Region, &params );
 800f912:	7ce0      	ldrb	r0, [r4, #19]
                            params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 800f914:	f88d a024 	strb.w	sl, [sp, #36]	@ 0x24
                            RegionInitDefaults( adrNext->Region, &params );
 800f918:	a907      	add	r1, sp, #28
 800f91a:	f000 fff9 	bl	8010910 <RegionInitDefaults>
 800f91e:	e7f6      	b.n	800f90e <LoRaMacAdrCalcNext+0xde>

0800f920 <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f920:	4770      	bx	lr
 800f922:	bf00      	nop

0800f924 <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f924:	4770      	bx	lr
 800f926:	bf00      	nop

0800f928 <LoRaMacClassBSetPingSlotState>:

void LoRaMacClassBSetPingSlotState( PingSlotState_t pingSlotState )
 800f928:	4770      	bx	lr
 800f92a:	bf00      	nop

0800f92c <LoRaMacClassBSetMulticastSlotState>:
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    Ctx.PingSlotState = pingSlotState;
#endif /* LORAMAC_CLASSB_ENABLED */
}

void LoRaMacClassBSetMulticastSlotState( PingSlotState_t multicastSlotState )
 800f92c:	4770      	bx	lr
 800f92e:	bf00      	nop

0800f930 <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f930:	2000      	movs	r0, #0
 800f932:	4770      	bx	lr

0800f934 <LoRaMacClassBBeaconTimerEvent>:
    Ctx.BeaconCtx.TimeStamp = TimerGetCurrentTime( );
    TimerStop( &Ctx.BeaconTimer );
    LoRaMacClassBEvents.Events.Beacon = 1;
    OnClassBMacProcessNotify( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f934:	4770      	bx	lr
 800f936:	bf00      	nop

0800f938 <LoRaMacClassBPingSlotTimerEvent>:
        TimerStart( &Ctx.BeaconTimer );
    }
}
#endif /* LORAMAC_CLASSB_ENABLED */

void LoRaMacClassBPingSlotTimerEvent( void* context )
 800f938:	4770      	bx	lr
 800f93a:	bf00      	nop

0800f93c <LoRaMacClassBMulticastSlotTimerEvent>:
        }
    }
}
#endif /* LORAMAC_CLASSB_ENABLED */

void LoRaMacClassBMulticastSlotTimerEvent( void* context )
 800f93c:	4770      	bx	lr
 800f93e:	bf00      	nop

0800f940 <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f940:	2000      	movs	r0, #0
 800f942:	4770      	bx	lr

0800f944 <LoRaMacClassBIsBeaconExpected>:

bool LoRaMacClassBIsBeaconExpected( void )
 800f944:	2000      	movs	r0, #0
 800f946:	4770      	bx	lr

0800f948 <LoRaMacClassBIsPingExpected>:
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}

bool LoRaMacClassBIsPingExpected( void )
 800f948:	2000      	movs	r0, #0
 800f94a:	4770      	bx	lr

0800f94c <LoRaMacClassBIsMulticastExpected>:
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}

bool LoRaMacClassBIsMulticastExpected( void )
 800f94c:	2000      	movs	r0, #0
 800f94e:	4770      	bx	lr

0800f950 <LoRaMacClassBIsBeaconModeActive>:
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}

bool LoRaMacClassBIsBeaconModeActive( void )
 800f950:	2000      	movs	r0, #0
 800f952:	4770      	bx	lr

0800f954 <LoRaMacClassBSetPingSlotInfo>:
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}

void LoRaMacClassBSetPingSlotInfo( uint8_t periodicity )
 800f954:	4770      	bx	lr
 800f956:	bf00      	nop

0800f958 <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f958:	4770      	bx	lr
 800f95a:	bf00      	nop

0800f95c <LoRaMacClassBResumeBeaconing>:

void LoRaMacClassBResumeBeaconing( void )
 800f95c:	4770      	bx	lr
 800f95e:	bf00      	nop

0800f960 <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f960:	2002      	movs	r0, #2
 800f962:	4770      	bx	lr

0800f964 <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f964:	2002      	movs	r0, #2
 800f966:	4770      	bx	lr

0800f968 <LoRaMacMibClassBSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibClassBSetRequestConfirm( MibRequestConfirm_t *mibSet )
 800f968:	2002      	movs	r0, #2
 800f96a:	4770      	bx	lr

0800f96c <LoRaMacClassBPingSlotInfoAns>:
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}

void LoRaMacClassBPingSlotInfoAns( void )
 800f96c:	4770      	bx	lr
 800f96e:	bf00      	nop

0800f970 <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f970:	2000      	movs	r0, #0
 800f972:	4770      	bx	lr

0800f974 <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f974:	4770      	bx	lr
 800f976:	bf00      	nop

0800f978 <LoRaMacClassBDeviceTimeAns>:

void LoRaMacClassBDeviceTimeAns( void )
 800f978:	4770      	bx	lr
 800f97a:	bf00      	nop

0800f97c <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f97c:	2000      	movs	r0, #0
 800f97e:	4770      	bx	lr

0800f980 <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800f980:	2000      	movs	r0, #0
 800f982:	4770      	bx	lr

0800f984 <LoRaMacClassBStopRxSlots>:

void LoRaMacClassBStopRxSlots( void )
 800f984:	4770      	bx	lr
 800f986:	bf00      	nop

0800f988 <LoRaMacClassBProcess>:
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
#endif /* LORAMAC_VERSION */

void LoRaMacClassBProcess( void )
 800f988:	4770      	bx	lr
 800f98a:	bf00      	nop

0800f98c <LoRaMacCommandsInit>:
            return false;
    }
}

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 800f98c:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 800f98e:	4c06      	ldr	r4, [pc, #24]	@ (800f9a8 <LoRaMacCommandsInit+0x1c>)
 800f990:	22fc      	movs	r2, #252	@ 0xfc
 800f992:	4620      	mov	r0, r4
 800f994:	2100      	movs	r1, #0
 800f996:	f002 fcd1 	bl	801233c <memset1>
    list->First = NULL;
 800f99a:	2200      	movs	r2, #0
 800f99c:	2300      	movs	r3, #0
 800f99e:	e9c4 2300 	strd	r2, r3, [r4]

    LinkedListInit( &CommandsCtx.MacCommandList );

    return LORAMAC_COMMANDS_SUCCESS;
}
 800f9a2:	2000      	movs	r0, #0
 800f9a4:	bd10      	pop	{r4, pc}
 800f9a6:	bf00      	nop
 800f9a8:	200012f8 	.word	0x200012f8

0800f9ac <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 800f9ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( payload == NULL )
 800f9b0:	2900      	cmp	r1, #0
 800f9b2:	d068      	beq.n	800fa86 <LoRaMacCommandsAddCmd+0xda>
 800f9b4:	4d36      	ldr	r5, [pc, #216]	@ (800fa90 <LoRaMacCommandsAddCmd+0xe4>)
 800f9b6:	4604      	mov	r4, r0
 800f9b8:	4616      	mov	r6, r2
 800f9ba:	462b      	mov	r3, r5
 800f9bc:	f105 00f0 	add.w	r0, r5, #240	@ 0xf0
        if( mem[size] != 0x00 )
 800f9c0:	7a1a      	ldrb	r2, [r3, #8]
 800f9c2:	2a00      	cmp	r2, #0
 800f9c4:	d153      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9c6:	7a5a      	ldrb	r2, [r3, #9]
 800f9c8:	2a00      	cmp	r2, #0
 800f9ca:	d150      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9cc:	7a9a      	ldrb	r2, [r3, #10]
 800f9ce:	2a00      	cmp	r2, #0
 800f9d0:	d14d      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9d2:	7ada      	ldrb	r2, [r3, #11]
 800f9d4:	2a00      	cmp	r2, #0
 800f9d6:	d14a      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9d8:	7b1a      	ldrb	r2, [r3, #12]
 800f9da:	2a00      	cmp	r2, #0
 800f9dc:	d147      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9de:	7b5a      	ldrb	r2, [r3, #13]
 800f9e0:	2a00      	cmp	r2, #0
 800f9e2:	d144      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9e4:	7b9a      	ldrb	r2, [r3, #14]
 800f9e6:	2a00      	cmp	r2, #0
 800f9e8:	d141      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9ea:	7bda      	ldrb	r2, [r3, #15]
 800f9ec:	2a00      	cmp	r2, #0
 800f9ee:	d13e      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9f0:	7c1a      	ldrb	r2, [r3, #16]
 800f9f2:	2a00      	cmp	r2, #0
 800f9f4:	d13b      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9f6:	7c5a      	ldrb	r2, [r3, #17]
 800f9f8:	2a00      	cmp	r2, #0
 800f9fa:	d138      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800f9fc:	7c9a      	ldrb	r2, [r3, #18]
 800f9fe:	2a00      	cmp	r2, #0
 800fa00:	d135      	bne.n	800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800fa02:	7cda      	ldrb	r2, [r3, #19]
 800fa04:	bb9a      	cbnz	r2, 800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800fa06:	7d1a      	ldrb	r2, [r3, #20]
 800fa08:	bb8a      	cbnz	r2, 800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800fa0a:	7d5a      	ldrb	r2, [r3, #21]
 800fa0c:	bb7a      	cbnz	r2, 800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800fa0e:	7d9a      	ldrb	r2, [r3, #22]
 800fa10:	bb6a      	cbnz	r2, 800fa6e <LoRaMacCommandsAddCmd+0xc2>
 800fa12:	7ddf      	ldrb	r7, [r3, #23]
 800fa14:	bb5f      	cbnz	r7, 800fa6e <LoRaMacCommandsAddCmd+0xc2>
    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 800fa16:	f103 0808 	add.w	r8, r3, #8
    if( list->First == NULL )
 800fa1a:	682b      	ldr	r3, [r5, #0]
 800fa1c:	b373      	cbz	r3, 800fa7c <LoRaMacCommandsAddCmd+0xd0>
    if( list->Last )
 800fa1e:	686b      	ldr	r3, [r5, #4]
 800fa20:	b10b      	cbz	r3, 800fa26 <LoRaMacCommandsAddCmd+0x7a>
        list->Last->Next = element;
 800fa22:	f8c3 8000 	str.w	r8, [r3]
    element->Next = NULL;
 800fa26:	2300      	movs	r3, #0
 800fa28:	f8c8 3000 	str.w	r3, [r8]
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
    newCmd->PayloadSize = payloadSize;
 800fa2c:	f8c8 6008 	str.w	r6, [r8, #8]
    list->Last = element;
 800fa30:	f8c5 8004 	str.w	r8, [r5, #4]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 800fa34:	b2b2      	uxth	r2, r6
    newCmd->CID = cid;
 800fa36:	f888 4004 	strb.w	r4, [r8, #4]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 800fa3a:	f108 0005 	add.w	r0, r8, #5
 800fa3e:	f002 fc21 	bl	8012284 <memcpy1>
    switch( cid )
 800fa42:	2c05      	cmp	r4, #5
 800fa44:	d01d      	beq.n	800fa82 <LoRaMacCommandsAddCmd+0xd6>
 800fa46:	f1a4 0308 	sub.w	r3, r4, #8
 800fa4a:	2b02      	cmp	r3, #2
 800fa4c:	bf8c      	ite	hi
 800fa4e:	2300      	movhi	r3, #0
 800fa50:	2301      	movls	r3, #1
    newCmd->IsSticky = IsSticky( cid );
 800fa52:	f888 300c 	strb.w	r3, [r8, #12]
    newCmd->IsConfirmationRequired = IsConfirmationRequired( cid );
 800fa56:	2300      	movs	r3, #0
 800fa58:	f888 300d 	strb.w	r3, [r8, #13]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 800fa5c:	f8d5 30f8 	ldr.w	r3, [r5, #248]	@ 0xf8
 800fa60:	3301      	adds	r3, #1
 800fa62:	4433      	add	r3, r6
 800fa64:	f8c5 30f8 	str.w	r3, [r5, #248]	@ 0xf8

    return LORAMAC_COMMANDS_SUCCESS;
}
 800fa68:	4638      	mov	r0, r7
 800fa6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( itr == NUM_OF_MAC_COMMANDS )
 800fa6e:	3310      	adds	r3, #16
 800fa70:	4298      	cmp	r0, r3
 800fa72:	d1a5      	bne.n	800f9c0 <LoRaMacCommandsAddCmd+0x14>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 800fa74:	2702      	movs	r7, #2
}
 800fa76:	4638      	mov	r0, r7
 800fa78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        list->First = element;
 800fa7c:	f8c5 8000 	str.w	r8, [r5]
 800fa80:	e7cd      	b.n	800fa1e <LoRaMacCommandsAddCmd+0x72>
            return true;
 800fa82:	2301      	movs	r3, #1
 800fa84:	e7e5      	b.n	800fa52 <LoRaMacCommandsAddCmd+0xa6>
        return LORAMAC_COMMANDS_ERROR_NPE;
 800fa86:	2701      	movs	r7, #1
}
 800fa88:	4638      	mov	r0, r7
 800fa8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fa8e:	bf00      	nop
 800fa90:	200012f8 	.word	0x200012f8

0800fa94 <LoRaMacCommandsGetCmd>:
LoRaMacCommandStatus_t LoRaMacCommandsGetCmd( uint8_t cid, MacCommand_t** macCmd )
{
    MacCommand_t* curElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 800fa94:	4b07      	ldr	r3, [pc, #28]	@ (800fab4 <LoRaMacCommandsGetCmd+0x20>)
 800fa96:	681b      	ldr	r3, [r3, #0]

    // Loop through all elements until we find the element with the given CID
    while( ( curElement != NULL ) && ( curElement->CID != cid ) )
 800fa98:	b913      	cbnz	r3, 800faa0 <LoRaMacCommandsGetCmd+0xc>
 800fa9a:	e007      	b.n	800faac <LoRaMacCommandsGetCmd+0x18>
    {
        curElement = curElement->Next;
 800fa9c:	681b      	ldr	r3, [r3, #0]
    while( ( curElement != NULL ) && ( curElement->CID != cid ) )
 800fa9e:	b12b      	cbz	r3, 800faac <LoRaMacCommandsGetCmd+0x18>
 800faa0:	791a      	ldrb	r2, [r3, #4]
 800faa2:	4282      	cmp	r2, r0
 800faa4:	d1fa      	bne.n	800fa9c <LoRaMacCommandsGetCmd+0x8>
    }

    // Update the pointer anyway
    *macCmd = curElement;
 800faa6:	600b      	str	r3, [r1, #0]
    // Handle error in case if we reached the end without finding it.
    if( curElement == NULL )
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }
    return LORAMAC_COMMANDS_SUCCESS;
 800faa8:	2000      	movs	r0, #0
}
 800faaa:	4770      	bx	lr
    *macCmd = curElement;
 800faac:	2300      	movs	r3, #0
 800faae:	600b      	str	r3, [r1, #0]
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
 800fab0:	2003      	movs	r0, #3
 800fab2:	4770      	bx	lr
 800fab4:	200012f8 	.word	0x200012f8

0800fab8 <LoRaMacCommandsRemoveNoneStickyCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 800fab8:	b570      	push	{r4, r5, r6, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 800faba:	4e1a      	ldr	r6, [pc, #104]	@ (800fb24 <LoRaMacCommandsRemoveNoneStickyCmds+0x6c>)
 800fabc:	6834      	ldr	r4, [r6, #0]

    // Loop through all elements
    while( curElement != NULL )
 800fabe:	b134      	cbz	r4, 800face <LoRaMacCommandsRemoveNoneStickyCmds+0x16>
    element->Next = NULL;
 800fac0:	2500      	movs	r5, #0
    {
        if( curElement->IsSticky == false )
 800fac2:	7b22      	ldrb	r2, [r4, #12]
 800fac4:	4620      	mov	r0, r4
        {
            nexElement = curElement->Next;
 800fac6:	6824      	ldr	r4, [r4, #0]
        if( curElement->IsSticky == false )
 800fac8:	b11a      	cbz	r2, 800fad2 <LoRaMacCommandsRemoveNoneStickyCmds+0x1a>
    while( curElement != NULL )
 800faca:	2c00      	cmp	r4, #0
 800facc:	d1f9      	bne.n	800fac2 <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
            curElement = curElement->Next;
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 800face:	2000      	movs	r0, #0
 800fad0:	bd70      	pop	{r4, r5, r6, pc}
    if( list->Last == element )
 800fad2:	e9d6 3100 	ldrd	r3, r1, [r6]
    if( element != curElement )
 800fad6:	4283      	cmp	r3, r0
 800fad8:	d01c      	beq.n	800fb14 <LoRaMacCommandsRemoveNoneStickyCmds+0x5c>
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 800fada:	b12b      	cbz	r3, 800fae8 <LoRaMacCommandsRemoveNoneStickyCmds+0x30>
 800fadc:	681a      	ldr	r2, [r3, #0]
 800fade:	4282      	cmp	r2, r0
 800fae0:	d014      	beq.n	800fb0c <LoRaMacCommandsRemoveNoneStickyCmds+0x54>
 800fae2:	4613      	mov	r3, r2
 800fae4:	2b00      	cmp	r3, #0
 800fae6:	d1f9      	bne.n	800fadc <LoRaMacCommandsRemoveNoneStickyCmds+0x24>
    if( list->Last == element )
 800fae8:	4288      	cmp	r0, r1
        list->Last = PrevElement;
 800faea:	bf08      	it	eq
 800faec:	6073      	streq	r3, [r6, #4]
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800faee:	f8d6 30f8 	ldr.w	r3, [r6, #248]	@ 0xf8
 800faf2:	6882      	ldr	r2, [r0, #8]
    element->Next = NULL;
 800faf4:	6005      	str	r5, [r0, #0]
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800faf6:	3b01      	subs	r3, #1
 800faf8:	1a9b      	subs	r3, r3, r2
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 800fafa:	2100      	movs	r1, #0
 800fafc:	2210      	movs	r2, #16
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800fafe:	f8c6 30f8 	str.w	r3, [r6, #248]	@ 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 800fb02:	f002 fc1b 	bl	801233c <memset1>
    while( curElement != NULL )
 800fb06:	2c00      	cmp	r4, #0
 800fb08:	d1db      	bne.n	800fac2 <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
 800fb0a:	e7e0      	b.n	800face <LoRaMacCommandsRemoveNoneStickyCmds+0x16>
    if( list->Last == element )
 800fb0c:	4288      	cmp	r0, r1
 800fb0e:	d006      	beq.n	800fb1e <LoRaMacCommandsRemoveNoneStickyCmds+0x66>
        PrevElement->Next = element->Next;
 800fb10:	601c      	str	r4, [r3, #0]
 800fb12:	e7ec      	b.n	800faee <LoRaMacCommandsRemoveNoneStickyCmds+0x36>
    if( list->Last == element )
 800fb14:	4288      	cmp	r0, r1
        list->First = element->Next;
 800fb16:	6034      	str	r4, [r6, #0]
    if( list->Last == element )
 800fb18:	d1e9      	bne.n	800faee <LoRaMacCommandsRemoveNoneStickyCmds+0x36>
        list->Last = PrevElement;
 800fb1a:	6072      	str	r2, [r6, #4]
    if( PrevElement != NULL )
 800fb1c:	e7e7      	b.n	800faee <LoRaMacCommandsRemoveNoneStickyCmds+0x36>
        list->Last = PrevElement;
 800fb1e:	6073      	str	r3, [r6, #4]
    if( PrevElement != NULL )
 800fb20:	e7f6      	b.n	800fb10 <LoRaMacCommandsRemoveNoneStickyCmds+0x58>
 800fb22:	bf00      	nop
 800fb24:	200012f8 	.word	0x200012f8

0800fb28 <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 800fb28:	b570      	push	{r4, r5, r6, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 800fb2a:	4e1b      	ldr	r6, [pc, #108]	@ (800fb98 <LoRaMacCommandsRemoveStickyAnsCmds+0x70>)
 800fb2c:	6834      	ldr	r4, [r6, #0]

    // Loop through all elements
    while( curElement != NULL )
 800fb2e:	b324      	cbz	r4, 800fb7a <LoRaMacCommandsRemoveStickyAnsCmds+0x52>
    element->Next = NULL;
 800fb30:	2500      	movs	r5, #0
    {
        nexElement = curElement->Next;
 800fb32:	4620      	mov	r0, r4
 800fb34:	6824      	ldr	r4, [r4, #0]
        if( ( IsSticky( curElement->CID ) == true ) &&
 800fb36:	7903      	ldrb	r3, [r0, #4]
    switch( cid )
 800fb38:	2b05      	cmp	r3, #5
 800fb3a:	d002      	beq.n	800fb42 <LoRaMacCommandsRemoveStickyAnsCmds+0x1a>
 800fb3c:	3b08      	subs	r3, #8
 800fb3e:	2b02      	cmp	r3, #2
 800fb40:	d819      	bhi.n	800fb76 <LoRaMacCommandsRemoveStickyAnsCmds+0x4e>
    if( list->Last == element )
 800fb42:	e9d6 3100 	ldrd	r3, r1, [r6]
    if( element != curElement )
 800fb46:	4283      	cmp	r3, r0
 800fb48:	d019      	beq.n	800fb7e <LoRaMacCommandsRemoveStickyAnsCmds+0x56>
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 800fb4a:	b12b      	cbz	r3, 800fb58 <LoRaMacCommandsRemoveStickyAnsCmds+0x30>
 800fb4c:	681a      	ldr	r2, [r3, #0]
 800fb4e:	4282      	cmp	r2, r0
 800fb50:	d01b      	beq.n	800fb8a <LoRaMacCommandsRemoveStickyAnsCmds+0x62>
 800fb52:	4613      	mov	r3, r2
 800fb54:	2b00      	cmp	r3, #0
 800fb56:	d1f9      	bne.n	800fb4c <LoRaMacCommandsRemoveStickyAnsCmds+0x24>
    if( list->Last == element )
 800fb58:	4281      	cmp	r1, r0
        list->Last = PrevElement;
 800fb5a:	bf08      	it	eq
 800fb5c:	6073      	streq	r3, [r6, #4]
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800fb5e:	f8d6 30f8 	ldr.w	r3, [r6, #248]	@ 0xf8
 800fb62:	6882      	ldr	r2, [r0, #8]
    element->Next = NULL;
 800fb64:	6005      	str	r5, [r0, #0]
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800fb66:	3b01      	subs	r3, #1
 800fb68:	1a9b      	subs	r3, r3, r2
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 800fb6a:	2100      	movs	r1, #0
 800fb6c:	2210      	movs	r2, #16
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800fb6e:	f8c6 30f8 	str.w	r3, [r6, #248]	@ 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 800fb72:	f002 fbe3 	bl	801233c <memset1>
    while( curElement != NULL )
 800fb76:	2c00      	cmp	r4, #0
 800fb78:	d1db      	bne.n	800fb32 <LoRaMacCommandsRemoveStickyAnsCmds+0xa>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 800fb7a:	2000      	movs	r0, #0
 800fb7c:	bd70      	pop	{r4, r5, r6, pc}
    if( list->Last == element )
 800fb7e:	4281      	cmp	r1, r0
        list->First = element->Next;
 800fb80:	6034      	str	r4, [r6, #0]
    if( list->Last == element )
 800fb82:	d1ec      	bne.n	800fb5e <LoRaMacCommandsRemoveStickyAnsCmds+0x36>
        list->Last = PrevElement;
 800fb84:	2300      	movs	r3, #0
 800fb86:	6073      	str	r3, [r6, #4]
    if( PrevElement != NULL )
 800fb88:	e7e9      	b.n	800fb5e <LoRaMacCommandsRemoveStickyAnsCmds+0x36>
    if( list->Last == element )
 800fb8a:	4281      	cmp	r1, r0
 800fb8c:	d001      	beq.n	800fb92 <LoRaMacCommandsRemoveStickyAnsCmds+0x6a>
        PrevElement->Next = element->Next;
 800fb8e:	601c      	str	r4, [r3, #0]
 800fb90:	e7e5      	b.n	800fb5e <LoRaMacCommandsRemoveStickyAnsCmds+0x36>
        list->Last = PrevElement;
 800fb92:	6073      	str	r3, [r6, #4]
    if( PrevElement != NULL )
 800fb94:	e7fb      	b.n	800fb8e <LoRaMacCommandsRemoveStickyAnsCmds+0x66>
 800fb96:	bf00      	nop
 800fb98:	200012f8 	.word	0x200012f8

0800fb9c <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 800fb9c:	4603      	mov	r3, r0
 800fb9e:	b128      	cbz	r0, 800fbac <LoRaMacCommandsGetSizeSerializedCmds+0x10>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 800fba0:	4a03      	ldr	r2, [pc, #12]	@ (800fbb0 <LoRaMacCommandsGetSizeSerializedCmds+0x14>)
 800fba2:	f8d2 20f8 	ldr.w	r2, [r2, #248]	@ 0xf8
 800fba6:	601a      	str	r2, [r3, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 800fba8:	2000      	movs	r0, #0
 800fbaa:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 800fbac:	2001      	movs	r0, #1
}
 800fbae:	4770      	bx	lr
 800fbb0:	200012f8 	.word	0x200012f8

0800fbb4 <LoRaMacCommandsSerializeCmds>:
{
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 800fbb4:	2a00      	cmp	r2, #0
 800fbb6:	d052      	beq.n	800fc5e <LoRaMacCommandsSerializeCmds+0xaa>
{
 800fbb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800fbbc:	460f      	mov	r7, r1
    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 800fbbe:	2900      	cmp	r1, #0
 800fbc0:	d04f      	beq.n	800fc62 <LoRaMacCommandsSerializeCmds+0xae>
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 800fbc2:	4e2a      	ldr	r6, [pc, #168]	@ (800fc6c <LoRaMacCommandsSerializeCmds+0xb8>)
 800fbc4:	6834      	ldr	r4, [r6, #0]
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 800fbc6:	2c00      	cmp	r4, #0
 800fbc8:	d039      	beq.n	800fc3e <LoRaMacCommandsSerializeCmds+0x8a>
 800fbca:	4680      	mov	r8, r0
 800fbcc:	4691      	mov	r9, r2
    uint8_t itr = 0;
 800fbce:	2300      	movs	r3, #0
 800fbd0:	e00a      	b.n	800fbe8 <LoRaMacCommandsSerializeCmds+0x34>
    {
        // If the next MAC command still fits into the buffer, add it.
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
        {
            buffer[itr++] = curElement->CID;
 800fbd2:	7922      	ldrb	r2, [r4, #4]
 800fbd4:	f809 2003 	strb.w	r2, [r9, r3]
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 800fbd8:	8922      	ldrh	r2, [r4, #8]
 800fbda:	f002 fb53 	bl	8012284 <memcpy1>
            itr += curElement->PayloadSize;
 800fbde:	68a3      	ldr	r3, [r4, #8]
        }
        else
        {
            break;
        }
        curElement = curElement->Next;
 800fbe0:	6824      	ldr	r4, [r4, #0]
            itr += curElement->PayloadSize;
 800fbe2:	441d      	add	r5, r3
 800fbe4:	b2eb      	uxtb	r3, r5
    while( curElement != NULL )
 800fbe6:	b354      	cbz	r4, 800fc3e <LoRaMacCommandsSerializeCmds+0x8a>
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 800fbe8:	68a2      	ldr	r2, [r4, #8]
            buffer[itr++] = curElement->CID;
 800fbea:	1c5d      	adds	r5, r3, #1
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 800fbec:	eba8 0c03 	sub.w	ip, r8, r3
 800fbf0:	3201      	adds	r2, #1
            buffer[itr++] = curElement->CID;
 800fbf2:	b2ed      	uxtb	r5, r5
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 800fbf4:	4594      	cmp	ip, r2
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 800fbf6:	f104 0105 	add.w	r1, r4, #5
 800fbfa:	eb09 0005 	add.w	r0, r9, r5
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 800fbfe:	d2e8      	bcs.n	800fbd2 <LoRaMacCommandsSerializeCmds+0x1e>
    element->Next = NULL;
 800fc00:	2500      	movs	r5, #0
    curElement = list->First;
 800fc02:	6833      	ldr	r3, [r6, #0]
    if( list->Last == element )
 800fc04:	6871      	ldr	r1, [r6, #4]
 800fc06:	4620      	mov	r0, r4
    if( element != curElement )
 800fc08:	4283      	cmp	r3, r0

    // Remove all commands which do not fit into the buffer
    while( curElement != NULL )
    {
        // Store the next element before removing the current one
        nextElement = curElement->Next;
 800fc0a:	6824      	ldr	r4, [r4, #0]
    if( element != curElement )
 800fc0c:	d01d      	beq.n	800fc4a <LoRaMacCommandsSerializeCmds+0x96>
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 800fc0e:	b12b      	cbz	r3, 800fc1c <LoRaMacCommandsSerializeCmds+0x68>
 800fc10:	681a      	ldr	r2, [r3, #0]
 800fc12:	4282      	cmp	r2, r0
 800fc14:	d01f      	beq.n	800fc56 <LoRaMacCommandsSerializeCmds+0xa2>
 800fc16:	4613      	mov	r3, r2
 800fc18:	2b00      	cmp	r3, #0
 800fc1a:	d1f9      	bne.n	800fc10 <LoRaMacCommandsSerializeCmds+0x5c>
    if( list->Last == element )
 800fc1c:	4288      	cmp	r0, r1
        list->Last = PrevElement;
 800fc1e:	bf08      	it	eq
 800fc20:	6073      	streq	r3, [r6, #4]
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800fc22:	f8d6 30f8 	ldr.w	r3, [r6, #248]	@ 0xf8
 800fc26:	6882      	ldr	r2, [r0, #8]
    element->Next = NULL;
 800fc28:	6005      	str	r5, [r0, #0]
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800fc2a:	3b01      	subs	r3, #1
 800fc2c:	1a9b      	subs	r3, r3, r2
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 800fc2e:	2100      	movs	r1, #0
 800fc30:	2210      	movs	r2, #16
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 800fc32:	f8c6 30f8 	str.w	r3, [r6, #248]	@ 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 800fc36:	f002 fb81 	bl	801233c <memset1>
    while( curElement != NULL )
 800fc3a:	2c00      	cmp	r4, #0
 800fc3c:	d1e1      	bne.n	800fc02 <LoRaMacCommandsSerializeCmds+0x4e>
    *size = CommandsCtx.SerializedCmdsSize;
 800fc3e:	f8d6 30f8 	ldr.w	r3, [r6, #248]	@ 0xf8
 800fc42:	603b      	str	r3, [r7, #0]
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );

    return LORAMAC_COMMANDS_SUCCESS;
 800fc44:	2000      	movs	r0, #0
}
 800fc46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if( list->Last == element )
 800fc4a:	4288      	cmp	r0, r1
        list->First = element->Next;
 800fc4c:	6034      	str	r4, [r6, #0]
    if( list->Last == element )
 800fc4e:	d1e8      	bne.n	800fc22 <LoRaMacCommandsSerializeCmds+0x6e>
        list->Last = PrevElement;
 800fc50:	2300      	movs	r3, #0
 800fc52:	6073      	str	r3, [r6, #4]
    if( PrevElement != NULL )
 800fc54:	e7e5      	b.n	800fc22 <LoRaMacCommandsSerializeCmds+0x6e>
    if( list->Last == element )
 800fc56:	4288      	cmp	r0, r1
 800fc58:	d006      	beq.n	800fc68 <LoRaMacCommandsSerializeCmds+0xb4>
        PrevElement->Next = element->Next;
 800fc5a:	601c      	str	r4, [r3, #0]
 800fc5c:	e7e1      	b.n	800fc22 <LoRaMacCommandsSerializeCmds+0x6e>
        return LORAMAC_COMMANDS_ERROR_NPE;
 800fc5e:	2001      	movs	r0, #1
}
 800fc60:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 800fc62:	2001      	movs	r0, #1
}
 800fc64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        list->Last = PrevElement;
 800fc68:	6073      	str	r3, [r6, #4]
    if( PrevElement != NULL )
 800fc6a:	e7f6      	b.n	800fc5a <LoRaMacCommandsSerializeCmds+0xa6>
 800fc6c:	200012f8 	.word	0x200012f8

0800fc70 <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 800fc70:	3802      	subs	r0, #2
 800fc72:	b2c0      	uxtb	r0, r0
 800fc74:	2811      	cmp	r0, #17
 800fc76:	bf9a      	itte	ls
 800fc78:	4b01      	ldrls	r3, [pc, #4]	@ (800fc80 <LoRaMacCommandsGetCmdSize+0x10>)
 800fc7a:	5c18      	ldrbls	r0, [r3, r0]
{
 800fc7c:	2000      	movhi	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 800fc7e:	4770      	bx	lr
 800fc80:	080174dc 	.word	0x080174dc

0800fc84 <LoRaMacConfirmQueueInit>:

    return NULL;
}

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 800fc84:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 800fc86:	4c09      	ldr	r4, [pc, #36]	@ (800fcac <LoRaMacConfirmQueueInit+0x28>)

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 800fc88:	2100      	movs	r1, #0

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 800fc8a:	f104 030c 	add.w	r3, r4, #12
    ConfirmQueueCtx.Primitives = primitives;
 800fc8e:	6020      	str	r0, [r4, #0]
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 800fc90:	f884 1020 	strb.w	r1, [r4, #32]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 800fc94:	4618      	mov	r0, r3
 800fc96:	2214      	movs	r2, #20
 800fc98:	21ff      	movs	r1, #255	@ 0xff
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 800fc9a:	e9c4 3301 	strd	r3, r3, [r4, #4]
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 800fc9e:	f002 fb4d 	bl	801233c <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800fca2:	2301      	movs	r3, #1
 800fca4:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
}
 800fca8:	bd10      	pop	{r4, pc}
 800fcaa:	bf00      	nop
 800fcac:	200013f4 	.word	0x200013f4

0800fcb0 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 800fcb0:	4a0f      	ldr	r2, [pc, #60]	@ (800fcf0 <LoRaMacConfirmQueueAdd+0x40>)
 800fcb2:	f892 1020 	ldrb.w	r1, [r2, #32]
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 800fcb6:	2904      	cmp	r1, #4
 800fcb8:	d818      	bhi.n	800fcec <LoRaMacConfirmQueueAdd+0x3c>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 800fcba:	6893      	ldr	r3, [r2, #8]
 800fcbc:	f8b0 c000 	ldrh.w	ip, [r0]
 800fcc0:	f8a3 c000 	strh.w	ip, [r3]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 800fcc4:	f890 c003 	ldrb.w	ip, [r0, #3]
 800fcc8:	f883 c003 	strb.w	ip, [r3, #3]
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 800fccc:	2000      	movs	r0, #0
 800fcce:	7098      	strb	r0, [r3, #2]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fcd0:	f102 001c 	add.w	r0, r2, #28
 800fcd4:	4283      	cmp	r3, r0
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = mlmeConfirm->ReadyToHandle;
#endif /* LORAMAC_VERSION */
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 800fcd6:	f101 0101 	add.w	r1, r1, #1
        bufferPointer++;
 800fcda:	bf14      	ite	ne
 800fcdc:	3304      	addne	r3, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 800fcde:	f102 030c 	addeq.w	r3, r2, #12
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 800fce2:	f882 1020 	strb.w	r1, [r2, #32]
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 800fce6:	6093      	str	r3, [r2, #8]

    return true;
 800fce8:	2001      	movs	r0, #1
 800fcea:	4770      	bx	lr
        return false;
 800fcec:	2000      	movs	r0, #0
}
 800fcee:	4770      	bx	lr
 800fcf0:	200013f4 	.word	0x200013f4

0800fcf4 <LoRaMacConfirmQueueSetStatus>:

    return true;
}

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 800fcf4:	b510      	push	{r4, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 800fcf6:	4a0c      	ldr	r2, [pc, #48]	@ (800fd28 <LoRaMacConfirmQueueSetStatus+0x34>)
 800fcf8:	f892 4020 	ldrb.w	r4, [r2, #32]
    if( count == 0 )
 800fcfc:	b19c      	cbz	r4, 800fd26 <LoRaMacConfirmQueueSetStatus+0x32>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 800fcfe:	6853      	ldr	r3, [r2, #4]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fd00:	f102 0e1c 	add.w	lr, r2, #28
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 800fd04:	2200      	movs	r2, #0
 800fd06:	e007      	b.n	800fd18 <LoRaMacConfirmQueueSetStatus+0x24>
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fd08:	4573      	cmp	r3, lr
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 800fd0a:	f102 0201 	add.w	r2, r2, #1
        bufferPointer++;
 800fd0e:	bf14      	ite	ne
 800fd10:	3304      	addne	r3, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 800fd12:	3b10      	subeq	r3, #16
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 800fd14:	4294      	cmp	r4, r2
 800fd16:	d006      	beq.n	800fd26 <LoRaMacConfirmQueueSetStatus+0x32>
        if( element->Request == request )
 800fd18:	f893 c000 	ldrb.w	ip, [r3]
 800fd1c:	458c      	cmp	ip, r1
 800fd1e:	d1f3      	bne.n	800fd08 <LoRaMacConfirmQueueSetStatus+0x14>
        if( element != NULL )
        {
            element->Status = status;
            element->ReadyToHandle = true;
 800fd20:	2201      	movs	r2, #1
            element->Status = status;
 800fd22:	7058      	strb	r0, [r3, #1]
            element->ReadyToHandle = true;
 800fd24:	709a      	strb	r2, [r3, #2]
        }
    }
}
 800fd26:	bd10      	pop	{r4, pc}
 800fd28:	200013f4 	.word	0x200013f4

0800fd2c <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 800fd2c:	b410      	push	{r4}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 800fd2e:	490d      	ldr	r1, [pc, #52]	@ (800fd64 <LoRaMacConfirmQueueGetStatus+0x38>)
 800fd30:	f891 4020 	ldrb.w	r4, [r1, #32]
    if( count == 0 )
 800fd34:	b194      	cbz	r4, 800fd5c <LoRaMacConfirmQueueGetStatus+0x30>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 800fd36:	684b      	ldr	r3, [r1, #4]
 800fd38:	2200      	movs	r2, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fd3a:	f101 0c1c 	add.w	ip, r1, #28
 800fd3e:	e007      	b.n	800fd50 <LoRaMacConfirmQueueGetStatus+0x24>
 800fd40:	4563      	cmp	r3, ip
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 800fd42:	f102 0201 	add.w	r2, r2, #1
        bufferPointer++;
 800fd46:	bf14      	ite	ne
 800fd48:	3304      	addne	r3, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 800fd4a:	3b10      	subeq	r3, #16
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 800fd4c:	4294      	cmp	r4, r2
 800fd4e:	d005      	beq.n	800fd5c <LoRaMacConfirmQueueGetStatus+0x30>
        if( element->Request == request )
 800fd50:	7819      	ldrb	r1, [r3, #0]
 800fd52:	4281      	cmp	r1, r0
 800fd54:	d1f4      	bne.n	800fd40 <LoRaMacConfirmQueueGetStatus+0x14>
        if( element != NULL )
        {
            return element->Status;
 800fd56:	7858      	ldrb	r0, [r3, #1]
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
}
 800fd58:	bc10      	pop	{r4}
 800fd5a:	4770      	bx	lr
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 800fd5c:	2001      	movs	r0, #1
}
 800fd5e:	bc10      	pop	{r4}
 800fd60:	4770      	bx	lr
 800fd62:	bf00      	nop
 800fd64:	200013f4 	.word	0x200013f4

0800fd68 <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 800fd68:	490f      	ldr	r1, [pc, #60]	@ (800fda8 <LoRaMacConfirmQueueSetStatusCmn+0x40>)
    if( count == 0 )
 800fd6a:	f891 2020 	ldrb.w	r2, [r1, #32]
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 800fd6e:	684b      	ldr	r3, [r1, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 800fd70:	f881 0021 	strb.w	r0, [r1, #33]	@ 0x21
    if( count == 0 )
 800fd74:	b1b2      	cbz	r2, 800fda4 <LoRaMacConfirmQueueSetStatusCmn+0x3c>
{
 800fd76:	b410      	push	{r4}
 800fd78:	311c      	adds	r1, #28
            if( element->RestrictCommonReadyToHandle == false )
            {
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
 800fd7a:	f851 4c14 	ldr.w	r4, [r1, #-20]
                element->ReadyToHandle = true;
 800fd7e:	f04f 0c01 	mov.w	ip, #1
            if( element->RestrictCommonReadyToHandle == false )
 800fd82:	78da      	ldrb	r2, [r3, #3]
            element->Status = status;
 800fd84:	7058      	strb	r0, [r3, #1]
            if( element->RestrictCommonReadyToHandle == false )
 800fd86:	b90a      	cbnz	r2, 800fd8c <LoRaMacConfirmQueueSetStatusCmn+0x24>
                element->ReadyToHandle = true;
 800fd88:	f883 c002 	strb.w	ip, [r3, #2]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fd8c:	428b      	cmp	r3, r1
 800fd8e:	d004      	beq.n	800fd9a <LoRaMacConfirmQueueSetStatusCmn+0x32>
        bufferPointer++;
 800fd90:	3304      	adds	r3, #4
        }while( element != ConfirmQueueCtx.BufferEnd );
 800fd92:	429c      	cmp	r4, r3
 800fd94:	d1f5      	bne.n	800fd82 <LoRaMacConfirmQueueSetStatusCmn+0x1a>
    }
}
 800fd96:	bc10      	pop	{r4}
 800fd98:	4770      	bx	lr
        }while( element != ConfirmQueueCtx.BufferEnd );
 800fd9a:	3b10      	subs	r3, #16
 800fd9c:	429c      	cmp	r4, r3
 800fd9e:	d1f0      	bne.n	800fd82 <LoRaMacConfirmQueueSetStatusCmn+0x1a>
}
 800fda0:	bc10      	pop	{r4}
 800fda2:	4770      	bx	lr
 800fda4:	4770      	bx	lr
 800fda6:	bf00      	nop
 800fda8:	200013f4 	.word	0x200013f4

0800fdac <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 800fdac:	b410      	push	{r4}
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 800fdae:	490e      	ldr	r1, [pc, #56]	@ (800fde8 <LoRaMacConfirmQueueIsCmdActive+0x3c>)
 800fdb0:	f891 4020 	ldrb.w	r4, [r1, #32]
    if( count == 0 )
 800fdb4:	b194      	cbz	r4, 800fddc <LoRaMacConfirmQueueIsCmdActive+0x30>
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 800fdb6:	684b      	ldr	r3, [r1, #4]
 800fdb8:	2200      	movs	r2, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fdba:	f101 0c1c 	add.w	ip, r1, #28
 800fdbe:	e007      	b.n	800fdd0 <LoRaMacConfirmQueueIsCmdActive+0x24>
 800fdc0:	4563      	cmp	r3, ip
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 800fdc2:	f102 0201 	add.w	r2, r2, #1
        bufferPointer++;
 800fdc6:	bf14      	ite	ne
 800fdc8:	3304      	addne	r3, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 800fdca:	3b10      	subeq	r3, #16
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 800fdcc:	42a2      	cmp	r2, r4
 800fdce:	d008      	beq.n	800fde2 <LoRaMacConfirmQueueIsCmdActive+0x36>
        if( element->Request == request )
 800fdd0:	7819      	ldrb	r1, [r3, #0]
 800fdd2:	4281      	cmp	r1, r0
 800fdd4:	d1f4      	bne.n	800fdc0 <LoRaMacConfirmQueueIsCmdActive+0x14>
 800fdd6:	2001      	movs	r0, #1
    {
        return true;
    }
    return false;
}
 800fdd8:	bc10      	pop	{r4}
 800fdda:	4770      	bx	lr
    return false;
 800fddc:	4620      	mov	r0, r4
}
 800fdde:	bc10      	pop	{r4}
 800fde0:	4770      	bx	lr
 800fde2:	2000      	movs	r0, #0
 800fde4:	bc10      	pop	{r4}
 800fde6:	4770      	bx	lr
 800fde8:	200013f4 	.word	0x200013f4

0800fdec <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 800fdec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 800fdf0:	4c2e      	ldr	r4, [pc, #184]	@ (800feac <LoRaMacConfirmQueueHandleCb+0xc0>)
{
 800fdf2:	b083      	sub	sp, #12
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 800fdf4:	f894 7020 	ldrb.w	r7, [r4, #32]
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    memset1( ( uint8_t* ) &mlmeConfirmToStore, 0, sizeof( MlmeConfirmQueue_t ) );
 800fdf8:	2204      	movs	r2, #4
{
 800fdfa:	4605      	mov	r5, r0
    memset1( ( uint8_t* ) &mlmeConfirmToStore, 0, sizeof( MlmeConfirmQueue_t ) );
 800fdfc:	2100      	movs	r1, #0
 800fdfe:	eb0d 0002 	add.w	r0, sp, r2
 800fe02:	f002 fa9b 	bl	801233c <memset1>

    for( uint8_t i = 0; i < nbElements; i++ )
 800fe06:	2f00      	cmp	r7, #0
 800fe08:	d048      	beq.n	800fe9c <LoRaMacConfirmQueueHandleCb+0xb0>
 800fe0a:	f04f 0800 	mov.w	r8, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fe0e:	f104 091c 	add.w	r9, r4, #28
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 800fe12:	4646      	mov	r6, r8
 800fe14:	e012      	b.n	800fe3c <LoRaMacConfirmQueueHandleCb+0x50>
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;

        if( readyToHandle == true )
        {
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 800fe16:	6823      	ldr	r3, [r4, #0]
 800fe18:	4628      	mov	r0, r5
 800fe1a:	689b      	ldr	r3, [r3, #8]
 800fe1c:	4798      	blx	r3
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 800fe1e:	f894 3020 	ldrb.w	r3, [r4, #32]
    if( count == 0 )
 800fe22:	b13b      	cbz	r3, 800fe34 <LoRaMacConfirmQueueHandleCb+0x48>
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 800fe24:	6862      	ldr	r2, [r4, #4]
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 800fe26:	3b01      	subs	r3, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fe28:	454a      	cmp	r2, r9
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 800fe2a:	f884 3020 	strb.w	r3, [r4, #32]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fe2e:	d03a      	beq.n	800fea6 <LoRaMacConfirmQueueHandleCb+0xba>
        bufferPointer++;
 800fe30:	3204      	adds	r2, #4
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 800fe32:	6062      	str	r2, [r4, #4]
    for( uint8_t i = 0; i < nbElements; i++ )
 800fe34:	f108 0801 	add.w	r8, r8, #1
 800fe38:	4547      	cmp	r7, r8
 800fe3a:	d02f      	beq.n	800fe9c <LoRaMacConfirmQueueHandleCb+0xb0>
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 800fe3c:	6863      	ldr	r3, [r4, #4]
 800fe3e:	8819      	ldrh	r1, [r3, #0]
 800fe40:	8029      	strh	r1, [r5, #0]
        if( readyToHandle == true )
 800fe42:	789a      	ldrb	r2, [r3, #2]
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 800fe44:	468c      	mov	ip, r1
        if( readyToHandle == true )
 800fe46:	2a00      	cmp	r2, #0
 800fe48:	d1e5      	bne.n	800fe16 <LoRaMacConfirmQueueHandleCb+0x2a>
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 800fe4a:	f894 2020 	ldrb.w	r2, [r4, #32]
        else
        {
            // The request is not processed yet. Store the state.
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 800fe4e:	78d8      	ldrb	r0, [r3, #3]
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 800fe50:	f8ad 1004 	strh.w	r1, [sp, #4]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 800fe54:	f88d 0007 	strb.w	r0, [sp, #7]
    if( count == 0 )
 800fe58:	b16a      	cbz	r2, 800fe76 <LoRaMacConfirmQueueHandleCb+0x8a>
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 800fe5a:	3a01      	subs	r2, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fe5c:	454b      	cmp	r3, r9
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 800fe5e:	b2d2      	uxtb	r2, r2
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fe60:	d01f      	beq.n	800fea2 <LoRaMacConfirmQueueHandleCb+0xb6>
        bufferPointer++;
 800fe62:	3304      	adds	r3, #4
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 800fe64:	2a04      	cmp	r2, #4
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 800fe66:	f884 2020 	strb.w	r2, [r4, #32]
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 800fe6a:	6063      	str	r3, [r4, #4]
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 800fe6c:	d8e2      	bhi.n	800fe34 <LoRaMacConfirmQueueHandleCb+0x48>
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 800fe6e:	f8bd c004 	ldrh.w	ip, [sp, #4]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 800fe72:	f89d 0007 	ldrb.w	r0, [sp, #7]
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 800fe76:	68a3      	ldr	r3, [r4, #8]
    for( uint8_t i = 0; i < nbElements; i++ )
 800fe78:	f108 0801 	add.w	r8, r8, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fe7c:	454b      	cmp	r3, r9
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 800fe7e:	f8a3 c000 	strh.w	ip, [r3]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 800fe82:	70d8      	strb	r0, [r3, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 800fe84:	709e      	strb	r6, [r3, #2]
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 800fe86:	f102 0201 	add.w	r2, r2, #1
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 800fe8a:	bf08      	it	eq
 800fe8c:	4b08      	ldreq	r3, [pc, #32]	@ (800feb0 <LoRaMacConfirmQueueHandleCb+0xc4>)
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 800fe8e:	f884 2020 	strb.w	r2, [r4, #32]
        bufferPointer++;
 800fe92:	bf18      	it	ne
 800fe94:	3304      	addne	r3, #4
    for( uint8_t i = 0; i < nbElements; i++ )
 800fe96:	4547      	cmp	r7, r8
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 800fe98:	60a3      	str	r3, [r4, #8]
    for( uint8_t i = 0; i < nbElements; i++ )
 800fe9a:	d1cf      	bne.n	800fe3c <LoRaMacConfirmQueueHandleCb+0x50>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
        }
    }
}
 800fe9c:	b003      	add	sp, #12
 800fe9e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 800fea2:	4b03      	ldr	r3, [pc, #12]	@ (800feb0 <LoRaMacConfirmQueueHandleCb+0xc4>)
 800fea4:	e7de      	b.n	800fe64 <LoRaMacConfirmQueueHandleCb+0x78>
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 800fea6:	4b02      	ldr	r3, [pc, #8]	@ (800feb0 <LoRaMacConfirmQueueHandleCb+0xc4>)
 800fea8:	6063      	str	r3, [r4, #4]
        if( readyToHandle == false )
 800feaa:	e7c3      	b.n	800fe34 <LoRaMacConfirmQueueHandleCb+0x48>
 800feac:	200013f4 	.word	0x200013f4
 800feb0:	20001400 	.word	0x20001400

0800feb4 <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 800feb4:	4b01      	ldr	r3, [pc, #4]	@ (800febc <LoRaMacConfirmQueueGetCnt+0x8>)
}
 800feb6:	f893 0020 	ldrb.w	r0, [r3, #32]
 800feba:	4770      	bx	lr
 800febc:	200013f4 	.word	0x200013f4

0800fec0 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 800fec0:	4b03      	ldr	r3, [pc, #12]	@ (800fed0 <LoRaMacConfirmQueueIsFull+0x10>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 800fec2:	f893 0020 	ldrb.w	r0, [r3, #32]
    }
    else
    {
        return false;
    }
}
 800fec6:	2804      	cmp	r0, #4
 800fec8:	bf94      	ite	ls
 800feca:	2000      	movls	r0, #0
 800fecc:	2001      	movhi	r0, #1
 800fece:	4770      	bx	lr
 800fed0:	200013f4 	.word	0x200013f4

0800fed4 <PayloadEncrypt>:
 * \param [in] size             - Size of data
 * \param [in,out] buffer       - Data buffer
 * \retval                      - Status of the operation
 */
static LoRaMacCryptoStatus_t PayloadEncrypt( uint8_t* buffer, int16_t size, KeyIdentifier_t keyID, uint32_t address, uint8_t dir, uint32_t frameCounter )
{
 800fed4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800fed8:	b088      	sub	sp, #32
 800feda:	4617      	mov	r7, r2
 800fedc:	f89d c038 	ldrb.w	ip, [sp, #56]	@ 0x38
 800fee0:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
    if( buffer == 0 )
 800fee2:	2800      	cmp	r0, #0
 800fee4:	f000 80b5 	beq.w	8010052 <PayloadEncrypt+0x17e>
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    uint8_t bufferIndex = 0;
    uint16_t ctr = 1;
    uint8_t sBlock[16] = { 0 };
 800fee8:	2600      	movs	r6, #0
 800feea:	4605      	mov	r5, r0
    uint8_t aBlock[16] = { 0 };

    aBlock[0] = 0x01;

    aBlock[5] = dir;
 800feec:	4630      	mov	r0, r6
 800feee:	f36c 0007 	bfi	r0, ip, #0, #8
 800fef2:	460c      	mov	r4, r1

    aBlock[6] = address & 0xFF;
    aBlock[7] = ( address >> 8 ) & 0xFF;
    aBlock[8] = ( address >> 16 ) & 0xFF;
    aBlock[9] = ( address >> 24 ) & 0xFF;
 800fef4:	ea4f 6c13 	mov.w	ip, r3, lsr #24
    aBlock[5] = dir;
 800fef8:	4631      	mov	r1, r6
 800fefa:	f363 200f 	bfi	r0, r3, #8, #8
 800fefe:	f36c 0107 	bfi	r1, ip, #0, #8
    aBlock[7] = ( address >> 8 ) & 0xFF;
 800ff02:	ea4f 2c13 	mov.w	ip, r3, lsr #8
    aBlock[5] = dir;
 800ff06:	f36c 4017 	bfi	r0, ip, #16, #8
    aBlock[8] = ( address >> 16 ) & 0xFF;
 800ff0a:	0c1b      	lsrs	r3, r3, #16
    aBlock[5] = dir;
 800ff0c:	f362 210f 	bfi	r1, r2, #8, #8
 800ff10:	f363 601f 	bfi	r0, r3, #24, #8

    aBlock[10] = frameCounter & 0xFF;
    aBlock[11] = ( frameCounter >> 8 ) & 0xFF;
 800ff14:	0a13      	lsrs	r3, r2, #8
    aBlock[5] = dir;
 800ff16:	f363 4117 	bfi	r1, r3, #16, #8
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 800ff1a:	0c13      	lsrs	r3, r2, #16
    aBlock[5] = dir;
 800ff1c:	f363 611f 	bfi	r1, r3, #24, #8
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 800ff20:	0e12      	lsrs	r2, r2, #24
    aBlock[0] = 0x01;
 800ff22:	2301      	movs	r3, #1
    uint8_t aBlock[16] = { 0 };
 800ff24:	e9cd 6604 	strd	r6, r6, [sp, #16]
 800ff28:	9607      	str	r6, [sp, #28]
    uint8_t sBlock[16] = { 0 };
 800ff2a:	e9cd 6600 	strd	r6, r6, [sp]
 800ff2e:	e9cd 6602 	strd	r6, r6, [sp, #8]
    aBlock[5] = dir;
 800ff32:	f8cd 0015 	str.w	r0, [sp, #21]
 800ff36:	f8cd 1019 	str.w	r1, [sp, #25]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 800ff3a:	f88d 201d 	strb.w	r2, [sp, #29]
    aBlock[0] = 0x01;
 800ff3e:	f88d 3010 	strb.w	r3, [sp, #16]

    while( size > 0 )
 800ff42:	b9e4      	cbnz	r4, 800ff7e <PayloadEncrypt+0xaa>
 800ff44:	e07b      	b.n	801003e <PayloadEncrypt+0x16a>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
        }

        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
        {
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 800ff46:	f8d2 e004 	ldr.w	lr, [r2, #4]
 800ff4a:	9801      	ldr	r0, [sp, #4]
 800ff4c:	f1bc 0f02 	cmp.w	ip, #2
 800ff50:	ea8e 0000 	eor.w	r0, lr, r0
 800ff54:	6050      	str	r0, [r2, #4]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 800ff56:	d03b      	beq.n	800ffd0 <PayloadEncrypt+0xfc>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 800ff58:	f8d2 e008 	ldr.w	lr, [r2, #8]
 800ff5c:	9802      	ldr	r0, [sp, #8]
 800ff5e:	f1bc 0f04 	cmp.w	ip, #4
 800ff62:	ea8e 0000 	eor.w	r0, lr, r0
 800ff66:	6090      	str	r0, [r2, #8]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 800ff68:	d132      	bne.n	800ffd0 <PayloadEncrypt+0xfc>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 800ff6a:	68d3      	ldr	r3, [r2, #12]
 800ff6c:	9903      	ldr	r1, [sp, #12]
 800ff6e:	404b      	eors	r3, r1
 800ff70:	60d3      	str	r3, [r2, #12]
        }
        size -= 16;
 800ff72:	3c10      	subs	r4, #16
 800ff74:	b224      	sxth	r4, r4
    while( size > 0 )
 800ff76:	2c00      	cmp	r4, #0
 800ff78:	f106 0601 	add.w	r6, r6, #1
 800ff7c:	dd5f      	ble.n	801003e <PayloadEncrypt+0x16a>
 800ff7e:	b2f3      	uxtb	r3, r6
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 800ff80:	2110      	movs	r1, #16
 800ff82:	ea4f 1803 	mov.w	r8, r3, lsl #4
        aBlock[15] = ctr & 0xFF;
 800ff86:	f103 0c01 	add.w	ip, r3, #1
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 800ff8a:	463a      	mov	r2, r7
 800ff8c:	466b      	mov	r3, sp
 800ff8e:	eb0d 0001 	add.w	r0, sp, r1
 800ff92:	fa5f f888 	uxtb.w	r8, r8
        aBlock[15] = ctr & 0xFF;
 800ff96:	f88d c01f 	strb.w	ip, [sp, #31]
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 800ff9a:	f7fb fb1f 	bl	800b5dc <SecureElementAesEncrypt>
 800ff9e:	2800      	cmp	r0, #0
 800ffa0:	d153      	bne.n	801004a <PayloadEncrypt+0x176>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 800ffa2:	2c10      	cmp	r4, #16
 800ffa4:	4621      	mov	r1, r4
 800ffa6:	bfa8      	it	ge
 800ffa8:	2110      	movge	r1, #16
 800ffaa:	2c00      	cmp	r4, #0
 800ffac:	bfcc      	ite	gt
 800ffae:	460b      	movgt	r3, r1
 800ffb0:	2301      	movle	r3, #1
 800ffb2:	2c03      	cmp	r4, #3
 800ffb4:	dd47      	ble.n	8010046 <PayloadEncrypt+0x172>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 800ffb6:	f855 2008 	ldr.w	r2, [r5, r8]
 800ffba:	9800      	ldr	r0, [sp, #0]
 800ffbc:	ea4f 0c93 	mov.w	ip, r3, lsr #2
 800ffc0:	4042      	eors	r2, r0
 800ffc2:	f1bc 0f01 	cmp.w	ip, #1
 800ffc6:	f845 2008 	str.w	r2, [r5, r8]
 800ffca:	eb05 0208 	add.w	r2, r5, r8
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 800ffce:	d1ba      	bne.n	800ff46 <PayloadEncrypt+0x72>
 800ffd0:	f023 0203 	bic.w	r2, r3, #3
 800ffd4:	f003 00fc 	and.w	r0, r3, #252	@ 0xfc
 800ffd8:	079b      	lsls	r3, r3, #30
 800ffda:	d0ca      	beq.n	800ff72 <PayloadEncrypt+0x9e>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 800ffdc:	f102 0320 	add.w	r3, r2, #32
 800ffe0:	eb02 0c08 	add.w	ip, r2, r8
 800ffe4:	eb0d 0203 	add.w	r2, sp, r3
 800ffe8:	f812 3c20 	ldrb.w	r3, [r2, #-32]
 800ffec:	f815 200c 	ldrb.w	r2, [r5, ip]
 800fff0:	405a      	eors	r2, r3
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 800fff2:	1c43      	adds	r3, r0, #1
 800fff4:	b2db      	uxtb	r3, r3
 800fff6:	4299      	cmp	r1, r3
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 800fff8:	f805 200c 	strb.w	r2, [r5, ip]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 800fffc:	ddb9      	ble.n	800ff72 <PayloadEncrypt+0x9e>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 800fffe:	eb08 0c03 	add.w	ip, r8, r3
 8010002:	3320      	adds	r3, #32
 8010004:	eb0d 0203 	add.w	r2, sp, r3
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8010008:	1c83      	adds	r3, r0, #2
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 801000a:	f812 0c20 	ldrb.w	r0, [r2, #-32]
 801000e:	f815 200c 	ldrb.w	r2, [r5, ip]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8010012:	b2db      	uxtb	r3, r3
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8010014:	4042      	eors	r2, r0
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8010016:	4299      	cmp	r1, r3
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8010018:	f805 200c 	strb.w	r2, [r5, ip]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 801001c:	dda9      	ble.n	800ff72 <PayloadEncrypt+0x9e>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 801001e:	4498      	add	r8, r3
 8010020:	3320      	adds	r3, #32
 8010022:	446b      	add	r3, sp
 8010024:	f815 2008 	ldrb.w	r2, [r5, r8]
 8010028:	f813 3c20 	ldrb.w	r3, [r3, #-32]
 801002c:	3c10      	subs	r4, #16
        size -= 16;
 801002e:	b224      	sxth	r4, r4
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8010030:	4053      	eors	r3, r2
    while( size > 0 )
 8010032:	2c00      	cmp	r4, #0
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8010034:	f805 3008 	strb.w	r3, [r5, r8]
    while( size > 0 )
 8010038:	f106 0601 	add.w	r6, r6, #1
 801003c:	dc9f      	bgt.n	800ff7e <PayloadEncrypt+0xaa>
        bufferIndex += 16;
    }

    return LORAMAC_CRYPTO_SUCCESS;
 801003e:	2000      	movs	r0, #0
}
 8010040:	b008      	add	sp, #32
 8010042:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8010046:	4602      	mov	r2, r0
 8010048:	e7c8      	b.n	800ffdc <PayloadEncrypt+0x108>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 801004a:	200f      	movs	r0, #15
}
 801004c:	b008      	add	sp, #32
 801004e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8010052:	200a      	movs	r0, #10
}
 8010054:	b008      	add	sp, #32
 8010056:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801005a:	bf00      	nop

0801005c <VerifyCmacB0.constprop.0>:
 * \param [in] expectedCmac   - Expected cmac
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
{
    if( msg == 0 )
 801005c:	b3a0      	cbz	r0, 80100c8 <VerifyCmacB0.constprop.0+0x6c>
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
 801005e:	b5f0      	push	{r4, r5, r6, r7, lr}
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8010060:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
 8010064:	b0c5      	sub	sp, #276	@ 0x114
 8010066:	460c      	mov	r4, r1
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8010068:	d82b      	bhi.n	80100c2 <VerifyCmacB0.constprop.0+0x66>
    {
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
    }

    uint8_t micBuff[CRYPTO_BUFFER_SIZE];
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 801006a:	4617      	mov	r7, r2
 801006c:	4605      	mov	r5, r0
 801006e:	f44f 7288 	mov.w	r2, #272	@ 0x110
 8010072:	2100      	movs	r1, #0
 8010074:	4668      	mov	r0, sp
 8010076:	461e      	mov	r6, r3
 8010078:	f002 f960 	bl	801233c <memset1>
    b0[14] = 0x00;
 801007c:	2300      	movs	r3, #0
    b0[6] = devAddr & 0xFF;
 801007e:	9a4a      	ldr	r2, [sp, #296]	@ 0x128
    b0[14] = 0x00;
 8010080:	f88d 300e 	strb.w	r3, [sp, #14]
    b0[0] = 0x49;
 8010084:	2349      	movs	r3, #73	@ 0x49

    // Initialize the first Block
    PrepareB0( len, keyID, isAck, dir, devAddr, fCnt, micBuff );

    // Copy the given data to the mic computation buffer
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8010086:	4629      	mov	r1, r5
    b0[6] = devAddr & 0xFF;
 8010088:	f8cd 200a 	str.w	r2, [sp, #10]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 801008c:	a804      	add	r0, sp, #16
 801008e:	4622      	mov	r2, r4
    b0[0] = 0x49;
 8010090:	9300      	str	r3, [sp, #0]
    b0[4] = 0x00;
 8010092:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8010096:	f8ad 3004 	strh.w	r3, [sp, #4]
    b0[6] = devAddr & 0xFF;
 801009a:	f8cd 6006 	str.w	r6, [sp, #6]
    b0[15] = msgLen & 0xFF;
 801009e:	f88d 400f 	strb.w	r4, [sp, #15]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 80100a2:	f002 f8ef 	bl	8012284 <memcpy1>

    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 80100a6:	f104 0110 	add.w	r1, r4, #16
 80100aa:	9a4b      	ldr	r2, [sp, #300]	@ 0x12c
 80100ac:	463b      	mov	r3, r7
 80100ae:	b289      	uxth	r1, r1
 80100b0:	4668      	mov	r0, sp
 80100b2:	f7fb fa7d 	bl	800b5b0 <SecureElementVerifyAesCmac>

    if( retval == SECURE_ELEMENT_SUCCESS )
 80100b6:	b110      	cbz	r0, 80100be <VerifyCmacB0.constprop.0+0x62>
    else if( retval == SECURE_ELEMENT_FAIL_CMAC )
    {
        return LORAMAC_CRYPTO_FAIL_MIC;
    }

    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80100b8:	2801      	cmp	r0, #1
 80100ba:	bf18      	it	ne
 80100bc:	200f      	movne	r0, #15
}
 80100be:	b045      	add	sp, #276	@ 0x114
 80100c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 80100c2:	200e      	movs	r0, #14
}
 80100c4:	b045      	add	sp, #276	@ 0x114
 80100c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80100c8:	200a      	movs	r0, #10
}
 80100ca:	4770      	bx	lr

080100cc <LoRaMacCryptoInit>:
/*
 *  API functions
 */
LoRaMacCryptoStatus_t LoRaMacCryptoInit( LoRaMacCryptoNvmData_t* nvm )
{
    if( nvm == NULL )
 80100cc:	b198      	cbz	r0, 80100f6 <LoRaMacCryptoInit+0x2a>
{
 80100ce:	b510      	push	{r4, lr}
    {
        return LORAMAC_CRYPTO_FAIL_PARAM;
    }

    // Assign non volatile context
    CryptoNvm = nvm;
 80100d0:	4c0a      	ldr	r4, [pc, #40]	@ (80100fc <LoRaMacCryptoInit+0x30>)

    // Initialize with default
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 80100d2:	2228      	movs	r2, #40	@ 0x28
 80100d4:	2100      	movs	r1, #0
    CryptoNvm = nvm;
 80100d6:	6020      	str	r0, [r4, #0]
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 80100d8:	f002 f930 	bl	801233c <memset1>

    // Set default LoRaWAN version
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 80100dc:	6823      	ldr	r3, [r4, #0]
    CryptoNvm->LrWanVersion.Fields.Minor = 1;
    CryptoNvm->LrWanVersion.Fields.Patch = 1;
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 80100de:	4908      	ldr	r1, [pc, #32]	@ (8010100 <LoRaMacCryptoInit+0x34>)
 80100e0:	6019      	str	r1, [r3, #0]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITIAL_VALUE;
 80100e2:	f04f 32ff 	mov.w	r2, #4294967295
    CryptoNvm->FCntList.FCntUp = 0;
 80100e6:	2000      	movs	r0, #0
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITIAL_VALUE;
 80100e8:	e9c3 0203 	strd	r0, r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITIAL_VALUE;
 80100ec:	e9c3 2205 	strd	r2, r2, [r3, #20]
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITIAL_VALUE;
 80100f0:	e9c3 2207 	strd	r2, r2, [r3, #28]

    // Reset frame counters
    ResetFCnts( );

    return LORAMAC_CRYPTO_SUCCESS;
}
 80100f4:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 80100f6:	2009      	movs	r0, #9
}
 80100f8:	4770      	bx	lr
 80100fa:	bf00      	nop
 80100fc:	20001418 	.word	0x20001418
 8010100:	01010100 	.word	0x01010100

08010104 <LoRaMacCryptoSetLrWanVersion>:

LoRaMacCryptoStatus_t LoRaMacCryptoSetLrWanVersion( Version_t version )
{
    CryptoNvm->LrWanVersion = version;
 8010104:	4b02      	ldr	r3, [pc, #8]	@ (8010110 <LoRaMacCryptoSetLrWanVersion+0xc>)
 8010106:	681b      	ldr	r3, [r3, #0]
{
 8010108:	4602      	mov	r2, r0
    CryptoNvm->LrWanVersion = version;
 801010a:	601a      	str	r2, [r3, #0]
    return LORAMAC_CRYPTO_SUCCESS;
}
 801010c:	2000      	movs	r0, #0
 801010e:	4770      	bx	lr
 8010110:	20001418 	.word	0x20001418

08010114 <LoRaMacCryptoGetFCntUp>:

LoRaMacCryptoStatus_t LoRaMacCryptoGetFCntUp( uint32_t* currentUp )
{
    if( currentUp == NULL )
 8010114:	4603      	mov	r3, r0
 8010116:	b130      	cbz	r0, 8010126 <LoRaMacCryptoGetFCntUp+0x12>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 8010118:	4a04      	ldr	r2, [pc, #16]	@ (801012c <LoRaMacCryptoGetFCntUp+0x18>)
 801011a:	6812      	ldr	r2, [r2, #0]
 801011c:	68d2      	ldr	r2, [r2, #12]
 801011e:	3201      	adds	r2, #1

    return LORAMAC_CRYPTO_SUCCESS;
 8010120:	2000      	movs	r0, #0
    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 8010122:	601a      	str	r2, [r3, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 8010124:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8010126:	200a      	movs	r0, #10
}
 8010128:	4770      	bx	lr
 801012a:	bf00      	nop
 801012c:	20001418 	.word	0x20001418

08010130 <LoRaMacCryptoGetFCntDown>:
{
    uint32_t lastDown = 0;
    int32_t fCntDiff = 0;
    LoRaMacCryptoStatus_t cryptoStatus = LORAMAC_CRYPTO_ERROR;

    if( currentDown == NULL )
 8010130:	2b00      	cmp	r3, #0
 8010132:	d034      	beq.n	801019e <LoRaMacCryptoGetFCntDown+0x6e>
    switch( fCntID )
 8010134:	3801      	subs	r0, #1
{
 8010136:	b410      	push	{r4}
    switch( fCntID )
 8010138:	2803      	cmp	r0, #3
 801013a:	d83e      	bhi.n	80101ba <LoRaMacCryptoGetFCntDown+0x8a>
 801013c:	e8df f000 	tbb	[pc, r0]
 8010140:	02282420 	.word	0x02282420
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 8010144:	481e      	ldr	r0, [pc, #120]	@ (80101c0 <LoRaMacCryptoGetFCntDown+0x90>)
 8010146:	6804      	ldr	r4, [r0, #0]
 8010148:	69e0      	ldr	r0, [r4, #28]
    {
        return cryptoStatus;
    }

    // For LoRaWAN 1.0.X only, allow downlink frames of 0
    if( lastDown == FCNT_DOWN_INITIAL_VALUE )
 801014a:	f1b0 3fff 	cmp.w	r0, #4294967295
 801014e:	d008      	beq.n	8010162 <LoRaMacCryptoGetFCntDown+0x32>
        *currentDown = frameFcnt;
    }
    else
    {
        // Add difference, consider roll-over
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 8010150:	fa1f fc80 	uxth.w	ip, r0
 8010154:	eba2 0c0c 	sub.w	ip, r2, ip

        if( fCntDiff > 0 )
 8010158:	f1bc 0f00 	cmp.w	ip, #0
 801015c:	dd21      	ble.n	80101a2 <LoRaMacCryptoGetFCntDown+0x72>
        {  // Positive difference
            *currentDown = lastDown + fCntDiff;
 801015e:	eb0c 0200 	add.w	r2, ip, r0
        *currentDown = frameFcnt;
 8010162:	601a      	str	r2, [r3, #0]
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
        }
    }

    // For LoRaWAN 1.0.X only, check maxFCntGap
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 8010164:	78a3      	ldrb	r3, [r4, #2]
 8010166:	b9bb      	cbnz	r3, 8010198 <LoRaMacCryptoGetFCntDown+0x68>
    {
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 8010168:	1a12      	subs	r2, r2, r0
 801016a:	eb63 0303 	sbc.w	r3, r3, r3
 801016e:	428a      	cmp	r2, r1
 8010170:	f173 0300 	sbcs.w	r3, r3, #0
 8010174:	bfac      	ite	ge
 8010176:	2001      	movge	r0, #1
 8010178:	2000      	movlt	r0, #0
 801017a:	00c0      	lsls	r0, r0, #3
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
        }
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 801017c:	bc10      	pop	{r4}
 801017e:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 8010180:	480f      	ldr	r0, [pc, #60]	@ (80101c0 <LoRaMacCryptoGetFCntDown+0x90>)
 8010182:	6804      	ldr	r4, [r0, #0]
 8010184:	6920      	ldr	r0, [r4, #16]
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8010186:	e7e0      	b.n	801014a <LoRaMacCryptoGetFCntDown+0x1a>
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 8010188:	480d      	ldr	r0, [pc, #52]	@ (80101c0 <LoRaMacCryptoGetFCntDown+0x90>)
 801018a:	6804      	ldr	r4, [r0, #0]
 801018c:	6960      	ldr	r0, [r4, #20]
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 801018e:	e7dc      	b.n	801014a <LoRaMacCryptoGetFCntDown+0x1a>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 8010190:	480b      	ldr	r0, [pc, #44]	@ (80101c0 <LoRaMacCryptoGetFCntDown+0x90>)
 8010192:	6804      	ldr	r4, [r0, #0]
 8010194:	69a0      	ldr	r0, [r4, #24]
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8010196:	e7d8      	b.n	801014a <LoRaMacCryptoGetFCntDown+0x1a>
    return LORAMAC_CRYPTO_SUCCESS;
 8010198:	2000      	movs	r0, #0
}
 801019a:	bc10      	pop	{r4}
 801019c:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 801019e:	200a      	movs	r0, #10
}
 80101a0:	4770      	bx	lr
        else if( fCntDiff == 0 )
 80101a2:	d007      	beq.n	80101b4 <LoRaMacCryptoGetFCntDown+0x84>
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 80101a4:	ea4f 4c10 	mov.w	ip, r0, lsr #16
 80101a8:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
 80101ac:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80101b0:	4462      	add	r2, ip
 80101b2:	e7d6      	b.n	8010162 <LoRaMacCryptoGetFCntDown+0x32>
            *currentDown = lastDown;
 80101b4:	6018      	str	r0, [r3, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 80101b6:	2007      	movs	r0, #7
 80101b8:	e7e0      	b.n	801017c <LoRaMacCryptoGetFCntDown+0x4c>
    switch( fCntID )
 80101ba:	2005      	movs	r0, #5
 80101bc:	e7de      	b.n	801017c <LoRaMacCryptoGetFCntDown+0x4c>
 80101be:	bf00      	nop
 80101c0:	20001418 	.word	0x20001418

080101c4 <LoRaMacCryptoSetMulticastReference>:
#endif /* LORAMAC_VERSION */
}

LoRaMacCryptoStatus_t LoRaMacCryptoSetMulticastReference( MulticastCtx_t* multicastList )
{
    if( multicastList == NULL )
 80101c4:	4603      	mov	r3, r0
 80101c6:	b128      	cbz	r0, 80101d4 <LoRaMacCryptoSetMulticastReference+0x10>
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 80101c8:	4a03      	ldr	r2, [pc, #12]	@ (80101d8 <LoRaMacCryptoSetMulticastReference+0x14>)
 80101ca:	6812      	ldr	r2, [r2, #0]
 80101cc:	321c      	adds	r2, #28
    }

    return LORAMAC_CRYPTO_SUCCESS;
 80101ce:	2000      	movs	r0, #0
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 80101d0:	625a      	str	r2, [r3, #36]	@ 0x24
    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 80101d2:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 80101d4:	200a      	movs	r0, #10
}
 80101d6:	4770      	bx	lr
 80101d8:	20001418 	.word	0x20001418

080101dc <LoRaMacCryptoSetKey>:

LoRaMacCryptoStatus_t LoRaMacCryptoSetKey( KeyIdentifier_t keyID, uint8_t* key )
{
 80101dc:	b530      	push	{r4, r5, lr}
 80101de:	b085      	sub	sp, #20
 80101e0:	4605      	mov	r5, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 80101e2:	f7fb f963 	bl	800b4ac <SecureElementSetKey>
 80101e6:	bb88      	cbnz	r0, 801024c <LoRaMacCryptoSetKey+0x70>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }
    if( keyID == APP_KEY )
 80101e8:	4604      	mov	r4, r0
 80101ea:	b115      	cbz	r5, 80101f2 <LoRaMacCryptoSetKey+0x16>
        {
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
        }
    }
    return LORAMAC_CRYPTO_SUCCESS;
}
 80101ec:	4620      	mov	r0, r4
 80101ee:	b005      	add	sp, #20
 80101f0:	bd30      	pop	{r4, r5, pc}
        if( LoRaMacCryptoDeriveLifeTimeKey( CryptoNvm->LrWanVersion.Fields.Minor, MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 80101f2:	4b17      	ldr	r3, [pc, #92]	@ (8010250 <LoRaMacCryptoSetKey+0x74>)
 80101f4:	681b      	ldr	r3, [r3, #0]
 80101f6:	789b      	ldrb	r3, [r3, #2]
    uint8_t compBase[16] = { 0 };
    KeyIdentifier_t rootKeyId = APP_KEY;
    switch( keyID )
    {
        case MC_ROOT_KEY:
            if( versionMinor == 1 )
 80101f8:	2b01      	cmp	r3, #1
    uint8_t compBase[16] = { 0 };
 80101fa:	e9cd 0000 	strd	r0, r0, [sp]
            {
                compBase[0] = 0x20;
 80101fe:	bf08      	it	eq
 8010200:	2320      	moveq	r3, #32
    uint8_t compBase[16] = { 0 };
 8010202:	e9cd 0002 	strd	r0, r0, [sp, #8]
            break;
        default:
            return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }

    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010206:	f04f 020b 	mov.w	r2, #11
 801020a:	f04f 0100 	mov.w	r1, #0
 801020e:	4668      	mov	r0, sp
                compBase[0] = 0x20;
 8010210:	bf08      	it	eq
 8010212:	f88d 3000 	strbeq.w	r3, [sp]
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010216:	f7fb fa69 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 801021a:	b9b8      	cbnz	r0, 801024c <LoRaMacCryptoSetKey+0x70>
    uint8_t compBase[16] = { 0 };
 801021c:	e9cd 0000 	strd	r0, r0, [sp]
 8010220:	e9cd 0002 	strd	r0, r0, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010224:	210b      	movs	r1, #11
 8010226:	220c      	movs	r2, #12
 8010228:	4668      	mov	r0, sp
 801022a:	f7fb fa5f 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 801022e:	4601      	mov	r1, r0
 8010230:	b960      	cbnz	r0, 801024c <LoRaMacCryptoSetKey+0x70>
            compBase[0] = 0x30;
 8010232:	2330      	movs	r3, #48	@ 0x30
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010234:	4668      	mov	r0, sp
 8010236:	220a      	movs	r2, #10
    uint8_t compBase[16] = { 0 };
 8010238:	e9cd 1100 	strd	r1, r1, [sp]
 801023c:	e9cd 1102 	strd	r1, r1, [sp, #8]
            compBase[0] = 0x30;
 8010240:	f88d 3000 	strb.w	r3, [sp]
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010244:	f7fb fa52 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 8010248:	2800      	cmp	r0, #0
 801024a:	d0cf      	beq.n	80101ec <LoRaMacCryptoSetKey+0x10>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 801024c:	240f      	movs	r4, #15
 801024e:	e7cd      	b.n	80101ec <LoRaMacCryptoSetKey+0x10>
 8010250:	20001418 	.word	0x20001418

08010254 <LoRaMacCryptoPrepareJoinRequest>:
    if( macMsg == 0 )
 8010254:	b330      	cbz	r0, 80102a4 <LoRaMacCryptoPrepareJoinRequest+0x50>
{
 8010256:	b510      	push	{r4, lr}
 8010258:	b084      	sub	sp, #16
 801025a:	4604      	mov	r4, r0
    uint32_t devNonce = 0;
 801025c:	2300      	movs	r3, #0
    SecureElementRandomNumber( &devNonce );
 801025e:	a803      	add	r0, sp, #12
    uint32_t devNonce = 0;
 8010260:	9303      	str	r3, [sp, #12]
    SecureElementRandomNumber( &devNonce );
 8010262:	f7fb fb7b 	bl	800b95c <SecureElementRandomNumber>
    CryptoNvm->DevNonce = devNonce;
 8010266:	4a10      	ldr	r2, [pc, #64]	@ (80102a8 <LoRaMacCryptoPrepareJoinRequest+0x54>)
 8010268:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801026c:	6812      	ldr	r2, [r2, #0]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 801026e:	4620      	mov	r0, r4
    CryptoNvm->DevNonce = devNonce;
 8010270:	8093      	strh	r3, [r2, #4]
    macMsg->DevNonce = CryptoNvm->DevNonce;
 8010272:	82e3      	strh	r3, [r4, #22]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8010274:	f000 fa8e 	bl	8010794 <LoRaMacSerializerJoinRequest>
 8010278:	b970      	cbnz	r0, 8010298 <LoRaMacCryptoPrepareJoinRequest+0x44>
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 801027a:	4622      	mov	r2, r4
 801027c:	2301      	movs	r3, #1
 801027e:	f852 1b18 	ldr.w	r1, [r2], #24
 8010282:	9200      	str	r2, [sp, #0]
 8010284:	2213      	movs	r2, #19
 8010286:	f7fb f987 	bl	800b598 <SecureElementComputeAesCmac>
 801028a:	b940      	cbnz	r0, 801029e <LoRaMacCryptoPrepareJoinRequest+0x4a>
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 801028c:	4620      	mov	r0, r4
 801028e:	f000 fa81 	bl	8010794 <LoRaMacSerializerJoinRequest>
 8010292:	b908      	cbnz	r0, 8010298 <LoRaMacCryptoPrepareJoinRequest+0x44>
}
 8010294:	b004      	add	sp, #16
 8010296:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 8010298:	2011      	movs	r0, #17
}
 801029a:	b004      	add	sp, #16
 801029c:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 801029e:	200f      	movs	r0, #15
}
 80102a0:	b004      	add	sp, #16
 80102a2:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80102a4:	200a      	movs	r0, #10
}
 80102a6:	4770      	bx	lr
 80102a8:	20001418 	.word	0x20001418

080102ac <LoRaMacCryptoHandleJoinAccept>:
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 80102ac:	2a00      	cmp	r2, #0
 80102ae:	f000 80c9 	beq.w	8010444 <LoRaMacCryptoHandleJoinAccept+0x198>
{
 80102b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80102b6:	460d      	mov	r5, r1
 80102b8:	b095      	sub	sp, #84	@ 0x54
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 80102ba:	2900      	cmp	r1, #0
 80102bc:	f000 80ba 	beq.w	8010434 <LoRaMacCryptoHandleJoinAccept+0x188>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 80102c0:	2700      	movs	r7, #0
    uint16_t nonce               = CryptoNvm->DevNonce;
 80102c2:	f8df 818c 	ldr.w	r8, [pc, #396]	@ 8010450 <LoRaMacCryptoHandleJoinAccept+0x1a4>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 80102c6:	970b      	str	r7, [sp, #44]	@ 0x2c
 80102c8:	4606      	mov	r6, r0
 80102ca:	4614      	mov	r4, r2
 80102cc:	4639      	mov	r1, r7
 80102ce:	221d      	movs	r2, #29
 80102d0:	a80c      	add	r0, sp, #48	@ 0x30
 80102d2:	f005 fef9 	bl	80160c8 <memset>
    uint16_t nonce               = CryptoNvm->DevNonce;
 80102d6:	f8d8 3000 	ldr.w	r3, [r8]
    uint8_t versionMinor         = 0;
 80102da:	f88d 701b 	strb.w	r7, [sp, #27]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 80102de:	4630      	mov	r0, r6
    uint16_t nonce               = CryptoNvm->DevNonce;
 80102e0:	889e      	ldrh	r6, [r3, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 80102e2:	7923      	ldrb	r3, [r4, #4]
 80102e4:	9300      	str	r3, [sp, #0]
 80102e6:	4629      	mov	r1, r5
 80102e8:	f10d 031b 	add.w	r3, sp, #27
 80102ec:	ad0b      	add	r5, sp, #44	@ 0x2c
 80102ee:	9302      	str	r3, [sp, #8]
 80102f0:	9501      	str	r5, [sp, #4]
 80102f2:	6823      	ldr	r3, [r4, #0]
 80102f4:	4632      	mov	r2, r6
 80102f6:	f7fb fa7d 	bl	800b7f4 <SecureElementProcessJoinAccept>
 80102fa:	2800      	cmp	r0, #0
 80102fc:	f040 8096 	bne.w	801042c <LoRaMacCryptoHandleJoinAccept+0x180>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 8010300:	6820      	ldr	r0, [r4, #0]
 8010302:	7922      	ldrb	r2, [r4, #4]
 8010304:	4629      	mov	r1, r5
 8010306:	f001 ffbd 	bl	8012284 <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 801030a:	4620      	mov	r0, r4
 801030c:	f000 f98c 	bl	8010628 <LoRaMacParserJoinAccept>
 8010310:	2800      	cmp	r0, #0
 8010312:	f040 8099 	bne.w	8010448 <LoRaMacCryptoHandleJoinAccept+0x19c>
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 8010316:	7a25      	ldrb	r5, [r4, #8]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 8010318:	79e2      	ldrb	r2, [r4, #7]
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 801031a:	79a3      	ldrb	r3, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 801031c:	042d      	lsls	r5, r5, #16
 801031e:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 8010322:	431d      	orrs	r5, r3
    return ( joinNonce > CryptoNvm->JoinNonce ) ? true : false;
 8010324:	f8d8 3000 	ldr.w	r3, [r8]
    if( isJoinNonceOk == true )
 8010328:	689a      	ldr	r2, [r3, #8]
 801032a:	4295      	cmp	r5, r2
 801032c:	f240 8086 	bls.w	801043c <LoRaMacCryptoHandleJoinAccept+0x190>
        CryptoNvm->JoinNonce = currentJoinNonce;
 8010330:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveLifeTimeKey( versionMinor, MC_ROOT_KEY );
 8010332:	f89d 301b 	ldrb.w	r3, [sp, #27]
            if( versionMinor == 1 )
 8010336:	2b01      	cmp	r3, #1
    uint8_t compBase[16] = { 0 };
 8010338:	e9cd 0007 	strd	r0, r0, [sp, #28]
                compBase[0] = 0x20;
 801033c:	bf08      	it	eq
 801033e:	2320      	moveq	r3, #32
    uint8_t compBase[16] = { 0 };
 8010340:	e9cd 0009 	strd	r0, r0, [sp, #36]	@ 0x24
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010344:	f04f 020b 	mov.w	r2, #11
 8010348:	f04f 0100 	mov.w	r1, #0
 801034c:	a807      	add	r0, sp, #28
                compBase[0] = 0x20;
 801034e:	bf08      	it	eq
 8010350:	f88d 301c 	strbeq.w	r3, [sp, #28]
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010354:	f7fb f9ca 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 8010358:	2800      	cmp	r0, #0
 801035a:	d167      	bne.n	801042c <LoRaMacCryptoHandleJoinAccept+0x180>
    uint8_t compBase[16] = { 0 };
 801035c:	e9cd 0007 	strd	r0, r0, [sp, #28]
 8010360:	e9cd 0009 	strd	r0, r0, [sp, #36]	@ 0x24
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010364:	220c      	movs	r2, #12
 8010366:	210b      	movs	r1, #11
 8010368:	a807      	add	r0, sp, #28
 801036a:	f7fb f9bf 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 801036e:	2800      	cmp	r0, #0
 8010370:	d15c      	bne.n	801042c <LoRaMacCryptoHandleJoinAccept+0x180>
    uint8_t compBase[16] = { 0 };
 8010372:	e9cd 0007 	strd	r0, r0, [sp, #28]
 8010376:	e9cd 0009 	strd	r0, r0, [sp, #36]	@ 0x24
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 801037a:	4601      	mov	r1, r0
            compBase[0] = 0x30;
 801037c:	2330      	movs	r3, #48	@ 0x30
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 801037e:	220a      	movs	r2, #10
 8010380:	a807      	add	r0, sp, #28
            compBase[0] = 0x30;
 8010382:	f88d 301c 	strb.w	r3, [sp, #28]
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 8010386:	f7fb f9b1 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 801038a:	2800      	cmp	r0, #0
 801038c:	d14e      	bne.n	801042c <LoRaMacCryptoHandleJoinAccept+0x180>
            compBase[0] = 0x02;
 801038e:	2302      	movs	r3, #2
    uint8_t compBase[16] = { 0 };
 8010390:	e9cd 0009 	strd	r0, r0, [sp, #36]	@ 0x24
    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 8010394:	f894 a009 	ldrb.w	sl, [r4, #9]
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
 8010398:	f894 900a 	ldrb.w	r9, [r4, #10]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 801039c:	7ae7      	ldrb	r7, [r4, #11]
            compBase[0] = 0x02;
 801039e:	f88d 301c 	strb.w	r3, [sp, #28]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 80103a2:	f3c5 2b07 	ubfx	fp, r5, #8, #8
    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 80103a6:	b2eb      	uxtb	r3, r5
    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 80103a8:	b2f4      	uxtb	r4, r6
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 80103aa:	2209      	movs	r2, #9
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 80103ac:	0c2d      	lsrs	r5, r5, #16
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 80103ae:	0a36      	lsrs	r6, r6, #8
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 80103b0:	2101      	movs	r1, #1
 80103b2:	a807      	add	r0, sp, #28
    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 80103b4:	f88d a020 	strb.w	sl, [sp, #32]
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
 80103b8:	f88d 9021 	strb.w	r9, [sp, #33]	@ 0x21
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 80103bc:	f88d 7022 	strb.w	r7, [sp, #34]	@ 0x22
    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 80103c0:	f88d 301d 	strb.w	r3, [sp, #29]
 80103c4:	9305      	str	r3, [sp, #20]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 80103c6:	f88d b01e 	strb.w	fp, [sp, #30]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 80103ca:	f88d 501f 	strb.w	r5, [sp, #31]
    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 80103ce:	f88d 4023 	strb.w	r4, [sp, #35]	@ 0x23
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 80103d2:	f88d 6024 	strb.w	r6, [sp, #36]	@ 0x24
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 80103d6:	f7fb f989 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 80103da:	4602      	mov	r2, r0
 80103dc:	bb30      	cbnz	r0, 801042c <LoRaMacCryptoHandleJoinAccept+0x180>
    uint8_t compBase[16] = { 0 };
 80103de:	e9cd 2209 	strd	r2, r2, [sp, #36]	@ 0x24
    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 80103e2:	9b05      	ldr	r3, [sp, #20]
 80103e4:	f88d 301d 	strb.w	r3, [sp, #29]
            compBase[0] = 0x01;
 80103e8:	2101      	movs	r1, #1
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 80103ea:	a807      	add	r0, sp, #28
 80103ec:	2208      	movs	r2, #8
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 80103ee:	f88d b01e 	strb.w	fp, [sp, #30]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 80103f2:	f88d 501f 	strb.w	r5, [sp, #31]
    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 80103f6:	f88d a020 	strb.w	sl, [sp, #32]
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
 80103fa:	f88d 9021 	strb.w	r9, [sp, #33]	@ 0x21
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 80103fe:	f88d 7022 	strb.w	r7, [sp, #34]	@ 0x22
    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 8010402:	f88d 4023 	strb.w	r4, [sp, #35]	@ 0x23
            compBase[0] = 0x01;
 8010406:	f88d 101c 	strb.w	r1, [sp, #28]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 801040a:	f88d 6024 	strb.w	r6, [sp, #36]	@ 0x24
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 801040e:	f7fb f96d 	bl	800b6ec <SecureElementDeriveAndStoreKey>
 8010412:	b958      	cbnz	r0, 801042c <LoRaMacCryptoHandleJoinAccept+0x180>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 8010414:	f8d8 3000 	ldr.w	r3, [r8]
 8010418:	f89d 101b 	ldrb.w	r1, [sp, #27]
 801041c:	7099      	strb	r1, [r3, #2]
    CryptoNvm->FCntList.FCntUp = 0;
 801041e:	f04f 32ff 	mov.w	r2, #4294967295
 8010422:	e9c3 0203 	strd	r0, r2, [r3, #12]
 8010426:	e9c3 2205 	strd	r2, r2, [r3, #20]
    return LORAMAC_CRYPTO_SUCCESS;
 801042a:	e000      	b.n	801042e <LoRaMacCryptoHandleJoinAccept+0x182>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 801042c:	200f      	movs	r0, #15
}
 801042e:	b015      	add	sp, #84	@ 0x54
 8010430:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8010434:	200a      	movs	r0, #10
}
 8010436:	b015      	add	sp, #84	@ 0x54
 8010438:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 801043c:	2003      	movs	r0, #3
}
 801043e:	b015      	add	sp, #84	@ 0x54
 8010440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8010444:	200a      	movs	r0, #10
}
 8010446:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_PARSER;
 8010448:	2010      	movs	r0, #16
}
 801044a:	b015      	add	sp, #84	@ 0x54
 801044c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010450:	20001418 	.word	0x20001418

08010454 <LoRaMacCryptoSecureMessage>:
    if( macMsg == NULL )
 8010454:	2b00      	cmp	r3, #0
 8010456:	d051      	beq.n	80104fc <LoRaMacCryptoSecureMessage+0xa8>
{
 8010458:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 801045a:	4e29      	ldr	r6, [pc, #164]	@ (8010500 <LoRaMacCryptoSecureMessage+0xac>)
 801045c:	461c      	mov	r4, r3
 801045e:	6833      	ldr	r3, [r6, #0]
 8010460:	68db      	ldr	r3, [r3, #12]
 8010462:	4283      	cmp	r3, r0
{
 8010464:	b087      	sub	sp, #28
 8010466:	4605      	mov	r5, r0
    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 8010468:	d841      	bhi.n	80104ee <LoRaMacCryptoSecureMessage+0x9a>
    if( macMsg->FPort == 0 )
 801046a:	f894 2020 	ldrb.w	r2, [r4, #32]
    KeyIdentifier_t payloadDecryptionKeyID = APP_S_KEY;
 801046e:	2a00      	cmp	r2, #0
 8010470:	bf0c      	ite	eq
 8010472:	2208      	moveq	r2, #8
 8010474:	2209      	movne	r2, #9
    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 8010476:	4283      	cmp	r3, r0
 8010478:	d209      	bcs.n	801048e <LoRaMacCryptoSecureMessage+0x3a>
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 801047a:	2300      	movs	r3, #0
 801047c:	e9cd 3000 	strd	r3, r0, [sp]
 8010480:	68a3      	ldr	r3, [r4, #8]
 8010482:	f894 1028 	ldrb.w	r1, [r4, #40]	@ 0x28
 8010486:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8010488:	f7ff fd24 	bl	800fed4 <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 801048c:	bb50      	cbnz	r0, 80104e4 <LoRaMacCryptoSecureMessage+0x90>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 801048e:	4620      	mov	r0, r4
 8010490:	f000 f9b6 	bl	8010800 <LoRaMacSerializerData>
 8010494:	bb28      	cbnz	r0, 80104e2 <LoRaMacCryptoSecureMessage+0x8e>
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 8010496:	7923      	ldrb	r3, [r4, #4]
 8010498:	6821      	ldr	r1, [r4, #0]
 801049a:	68a7      	ldr	r7, [r4, #8]
 801049c:	3b04      	subs	r3, #4
 801049e:	b29a      	uxth	r2, r3
    if( ( msg == 0 ) || ( cmac == 0 ) )
 80104a0:	b341      	cbz	r1, 80104f4 <LoRaMacCryptoSecureMessage+0xa0>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 80104a2:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
 80104a6:	d81f      	bhi.n	80104e8 <LoRaMacCryptoSecureMessage+0x94>
    b0[15] = msgLen & 0xFF;
 80104a8:	f88d 3017 	strb.w	r3, [sp, #23]
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 80104ac:	f104 032c 	add.w	r3, r4, #44	@ 0x2c
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 80104b0:	9300      	str	r3, [sp, #0]
    b0[0] = 0x49;
 80104b2:	2349      	movs	r3, #73	@ 0x49
 80104b4:	9302      	str	r3, [sp, #8]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 80104b6:	2308      	movs	r3, #8
    b0[4] = 0x00;
 80104b8:	f8ad 000c 	strh.w	r0, [sp, #12]
    b0[14] = 0x00;
 80104bc:	f88d 0016 	strb.w	r0, [sp, #22]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 80104c0:	eb0d 0003 	add.w	r0, sp, r3
    b0[6] = devAddr & 0xFF;
 80104c4:	f8cd 700e 	str.w	r7, [sp, #14]
 80104c8:	f8cd 5012 	str.w	r5, [sp, #18]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 80104cc:	f7fb f864 	bl	800b598 <SecureElementComputeAesCmac>
 80104d0:	b990      	cbnz	r0, 80104f8 <LoRaMacCryptoSecureMessage+0xa4>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80104d2:	4620      	mov	r0, r4
 80104d4:	f000 f994 	bl	8010800 <LoRaMacSerializerData>
 80104d8:	b918      	cbnz	r0, 80104e2 <LoRaMacCryptoSecureMessage+0x8e>
    CryptoNvm->FCntList.FCntUp = fCntUp;
 80104da:	6833      	ldr	r3, [r6, #0]
 80104dc:	60dd      	str	r5, [r3, #12]
}
 80104de:	b007      	add	sp, #28
 80104e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 80104e2:	2011      	movs	r0, #17
}
 80104e4:	b007      	add	sp, #28
 80104e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 80104e8:	200e      	movs	r0, #14
}
 80104ea:	b007      	add	sp, #28
 80104ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 80104ee:	2006      	movs	r0, #6
}
 80104f0:	b007      	add	sp, #28
 80104f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80104f4:	200a      	movs	r0, #10
 80104f6:	e7f5      	b.n	80104e4 <LoRaMacCryptoSecureMessage+0x90>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80104f8:	200f      	movs	r0, #15
 80104fa:	e7f3      	b.n	80104e4 <LoRaMacCryptoSecureMessage+0x90>
        return LORAMAC_CRYPTO_ERROR_NPE;
 80104fc:	200a      	movs	r0, #10
}
 80104fe:	4770      	bx	lr
 8010500:	20001418 	.word	0x20001418

08010504 <LoRaMacCryptoUnsecureMessage>:
{
 8010504:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010508:	b083      	sub	sp, #12
 801050a:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
    if( macMsg == 0 )
 801050e:	f1b8 0f00 	cmp.w	r8, #0
 8010512:	d06b      	beq.n	80105ec <LoRaMacCryptoUnsecureMessage+0xe8>
    switch( fCntID )
 8010514:	1e54      	subs	r4, r2, #1
 8010516:	4605      	mov	r5, r0
 8010518:	460f      	mov	r7, r1
 801051a:	461e      	mov	r6, r3
 801051c:	2c03      	cmp	r4, #3
 801051e:	d80c      	bhi.n	801053a <LoRaMacCryptoUnsecureMessage+0x36>
 8010520:	e8df f004 	tbb	[pc, r4]
 8010524:	025a540f 	.word	0x025a540f
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 8010528:	f8df 90f4 	ldr.w	r9, [pc, #244]	@ 8010620 <LoRaMacCryptoUnsecureMessage+0x11c>
 801052c:	f8d9 3000 	ldr.w	r3, [r9]
 8010530:	69db      	ldr	r3, [r3, #28]
    if( ( currentDown > lastDown ) ||
 8010532:	429e      	cmp	r6, r3
 8010534:	d80c      	bhi.n	8010550 <LoRaMacCryptoUnsecureMessage+0x4c>
 8010536:	3301      	adds	r3, #1
 8010538:	d00a      	beq.n	8010550 <LoRaMacCryptoUnsecureMessage+0x4c>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 801053a:	2006      	movs	r0, #6
}
 801053c:	b003      	add	sp, #12
 801053e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 8010542:	f8df 90dc 	ldr.w	r9, [pc, #220]	@ 8010620 <LoRaMacCryptoUnsecureMessage+0x11c>
 8010546:	f8d9 3000 	ldr.w	r3, [r9]
 801054a:	691b      	ldr	r3, [r3, #16]
    if( ( currentDown > lastDown ) ||
 801054c:	429e      	cmp	r6, r3
 801054e:	d9f2      	bls.n	8010536 <LoRaMacCryptoUnsecureMessage+0x32>
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 8010550:	4640      	mov	r0, r8
 8010552:	f000 f8bf 	bl	80106d4 <LoRaMacParserData>
 8010556:	2800      	cmp	r0, #0
 8010558:	d144      	bne.n	80105e4 <LoRaMacCryptoUnsecureMessage+0xe0>
        if( KeyAddrList[i].AddrID == addrID )
 801055a:	4b32      	ldr	r3, [pc, #200]	@ (8010624 <LoRaMacCryptoUnsecureMessage+0x120>)
 801055c:	781a      	ldrb	r2, [r3, #0]
 801055e:	42aa      	cmp	r2, r5
 8010560:	d005      	beq.n	801056e <LoRaMacCryptoUnsecureMessage+0x6a>
 8010562:	791a      	ldrb	r2, [r3, #4]
 8010564:	42aa      	cmp	r2, r5
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 8010566:	bf18      	it	ne
 8010568:	200c      	movne	r0, #12
        if( KeyAddrList[i].AddrID == addrID )
 801056a:	d1e7      	bne.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
 801056c:	2001      	movs	r0, #1
    if( address != macMsg->FHDR.DevAddr )
 801056e:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8010572:	42ba      	cmp	r2, r7
 8010574:	d151      	bne.n	801061a <LoRaMacCryptoUnsecureMessage+0x116>
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 8010576:	9600      	str	r6, [sp, #0]
 8010578:	f898 1004 	ldrb.w	r1, [r8, #4]
 801057c:	f8d8 202c 	ldr.w	r2, [r8, #44]	@ 0x2c
 8010580:	9201      	str	r2, [sp, #4]
    payloadDecryptionKeyID = curItem->AppSkey;
 8010582:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 8010586:	3904      	subs	r1, #4
 8010588:	789a      	ldrb	r2, [r3, #2]
    payloadDecryptionKeyID = curItem->AppSkey;
 801058a:	785d      	ldrb	r5, [r3, #1]
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 801058c:	f8d8 0000 	ldr.w	r0, [r8]
 8010590:	b289      	uxth	r1, r1
 8010592:	463b      	mov	r3, r7
 8010594:	f7ff fd62 	bl	801005c <VerifyCmacB0.constprop.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8010598:	2800      	cmp	r0, #0
 801059a:	d1cf      	bne.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 801059c:	9601      	str	r6, [sp, #4]
    if( macMsg->FPort == 0 )
 801059e:	f898 2020 	ldrb.w	r2, [r8, #32]
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 80105a2:	2101      	movs	r1, #1
        payloadDecryptionKeyID = NWK_S_KEY;
 80105a4:	2a00      	cmp	r2, #0
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 80105a6:	9100      	str	r1, [sp, #0]
 80105a8:	bf14      	ite	ne
 80105aa:	462a      	movne	r2, r5
 80105ac:	2208      	moveq	r2, #8
 80105ae:	f898 1028 	ldrb.w	r1, [r8, #40]	@ 0x28
 80105b2:	f8d8 0024 	ldr.w	r0, [r8, #36]	@ 0x24
 80105b6:	463b      	mov	r3, r7
 80105b8:	f7ff fc8c 	bl	800fed4 <PayloadEncrypt>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 80105bc:	2800      	cmp	r0, #0
 80105be:	d1bd      	bne.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
    switch( fCntID )
 80105c0:	2c03      	cmp	r4, #3
 80105c2:	d8bb      	bhi.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
 80105c4:	e8df f004 	tbb	[pc, r4]
 80105c8:	161a1f24 	.word	0x161a1f24
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 80105cc:	f8df 9050 	ldr.w	r9, [pc, #80]	@ 8010620 <LoRaMacCryptoUnsecureMessage+0x11c>
 80105d0:	f8d9 3000 	ldr.w	r3, [r9]
 80105d4:	695b      	ldr	r3, [r3, #20]
            break;
 80105d6:	e7ac      	b.n	8010532 <LoRaMacCryptoUnsecureMessage+0x2e>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 80105d8:	f8df 9044 	ldr.w	r9, [pc, #68]	@ 8010620 <LoRaMacCryptoUnsecureMessage+0x11c>
 80105dc:	f8d9 3000 	ldr.w	r3, [r9]
 80105e0:	699b      	ldr	r3, [r3, #24]
            break;
 80105e2:	e7a6      	b.n	8010532 <LoRaMacCryptoUnsecureMessage+0x2e>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 80105e4:	2010      	movs	r0, #16
}
 80105e6:	b003      	add	sp, #12
 80105e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80105ec:	200a      	movs	r0, #10
}
 80105ee:	b003      	add	sp, #12
 80105f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 80105f4:	f8d9 3000 	ldr.w	r3, [r9]
 80105f8:	61de      	str	r6, [r3, #28]
            break;
 80105fa:	e79f      	b.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
            CryptoNvm->FCntList.FCntDown = currentDown;
 80105fc:	f8d9 3000 	ldr.w	r3, [r9]
 8010600:	619e      	str	r6, [r3, #24]
            CryptoNvm->LastDownFCnt = currentDown;
 8010602:	621e      	str	r6, [r3, #32]
            break;
 8010604:	e79a      	b.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
            CryptoNvm->FCntList.AFCntDown = currentDown;
 8010606:	f8d9 3000 	ldr.w	r3, [r9]
 801060a:	615e      	str	r6, [r3, #20]
            CryptoNvm->LastDownFCnt = currentDown;
 801060c:	621e      	str	r6, [r3, #32]
            break;
 801060e:	e795      	b.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
            CryptoNvm->FCntList.NFCntDown = currentDown;
 8010610:	f8d9 3000 	ldr.w	r3, [r9]
 8010614:	611e      	str	r6, [r3, #16]
            CryptoNvm->LastDownFCnt = currentDown;
 8010616:	621e      	str	r6, [r3, #32]
            break;
 8010618:	e790      	b.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 801061a:	2002      	movs	r0, #2
 801061c:	e78e      	b.n	801053c <LoRaMacCryptoUnsecureMessage+0x38>
 801061e:	bf00      	nop
 8010620:	20001418 	.word	0x20001418
 8010624:	20000104 	.word	0x20000104

08010628 <LoRaMacParserJoinAccept>:
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8010628:	2800      	cmp	r0, #0
 801062a:	d051      	beq.n	80106d0 <LoRaMacParserJoinAccept+0xa8>
 801062c:	6801      	ldr	r1, [r0, #0]
{
 801062e:	b510      	push	{r4, lr}
 8010630:	4604      	mov	r4, r0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8010632:	2900      	cmp	r1, #0
 8010634:	d03d      	beq.n	80106b2 <LoRaMacParserJoinAccept+0x8a>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 8010636:	f811 3b01 	ldrb.w	r3, [r1], #1
 801063a:	7163      	strb	r3, [r4, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 801063c:	2203      	movs	r2, #3
 801063e:	3006      	adds	r0, #6
 8010640:	f001 fe20 	bl	8012284 <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 8010644:	4620      	mov	r0, r4
 8010646:	2203      	movs	r2, #3
 8010648:	f850 1b09 	ldr.w	r1, [r0], #9
 801064c:	3104      	adds	r1, #4
 801064e:	f001 fe19 	bl	8012284 <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 8010652:	6821      	ldr	r1, [r4, #0]
 8010654:	79cb      	ldrb	r3, [r1, #7]
 8010656:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8010658:	7a0a      	ldrb	r2, [r1, #8]
 801065a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 801065e:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8010660:	7a4a      	ldrb	r2, [r1, #9]
 8010662:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8010666:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8010668:	7a88      	ldrb	r0, [r1, #10]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];

    macMsg->RxDelay = macMsg->Buffer[bufItr++];

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 801066a:	7922      	ldrb	r2, [r4, #4]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 801066c:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8010670:	60e3      	str	r3, [r4, #12]
    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 8010672:	7acb      	ldrb	r3, [r1, #11]
 8010674:	7423      	strb	r3, [r4, #16]
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 8010676:	7b0b      	ldrb	r3, [r1, #12]
 8010678:	7463      	strb	r3, [r4, #17]
    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 801067a:	2a21      	cmp	r2, #33	@ 0x21
 801067c:	d01b      	beq.n	80106b6 <LoRaMacParserJoinAccept+0x8e>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
    }
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 801067e:	2a11      	cmp	r2, #17
 8010680:	dc15      	bgt.n	80106ae <LoRaMacParserJoinAccept+0x86>
 8010682:	2210      	movs	r2, #16
 8010684:	200f      	movs	r0, #15
 8010686:	f04f 0c0e 	mov.w	ip, #14
 801068a:	230d      	movs	r3, #13
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 801068c:	5ccb      	ldrb	r3, [r1, r3]
 801068e:	6263      	str	r3, [r4, #36]	@ 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8010690:	f811 c00c 	ldrb.w	ip, [r1, ip]
 8010694:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
 8010698:	6263      	str	r3, [r4, #36]	@ 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 801069a:	5c08      	ldrb	r0, [r1, r0]
 801069c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80106a0:	6263      	str	r3, [r4, #36]	@ 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80106a2:	5c8a      	ldrb	r2, [r1, r2]
 80106a4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24

    return LORAMAC_PARSER_SUCCESS;
 80106a8:	2000      	movs	r0, #0
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80106aa:	6263      	str	r3, [r4, #36]	@ 0x24
}
 80106ac:	bd10      	pop	{r4, pc}
        return LORAMAC_PARSER_FAIL;
 80106ae:	2001      	movs	r0, #1
}
 80106b0:	bd10      	pop	{r4, pc}
        return LORAMAC_PARSER_ERROR_NPE;
 80106b2:	2002      	movs	r0, #2
}
 80106b4:	bd10      	pop	{r4, pc}
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 80106b6:	310d      	adds	r1, #13
 80106b8:	2210      	movs	r2, #16
 80106ba:	f104 0012 	add.w	r0, r4, #18
 80106be:	f001 fde1 	bl	8012284 <memcpy1>
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 80106c2:	6821      	ldr	r1, [r4, #0]
 80106c4:	2220      	movs	r2, #32
 80106c6:	201f      	movs	r0, #31
 80106c8:	f04f 0c1e 	mov.w	ip, #30
 80106cc:	231d      	movs	r3, #29
 80106ce:	e7dd      	b.n	801068c <LoRaMacParserJoinAccept+0x64>
        return LORAMAC_PARSER_ERROR_NPE;
 80106d0:	2002      	movs	r0, #2
}
 80106d2:	4770      	bx	lr

080106d4 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80106d4:	2800      	cmp	r0, #0
 80106d6:	d05b      	beq.n	8010790 <LoRaMacParserData+0xbc>
 80106d8:	6801      	ldr	r1, [r0, #0]
{
 80106da:	b538      	push	{r3, r4, r5, lr}
 80106dc:	4604      	mov	r4, r0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80106de:	2900      	cmp	r1, #0
 80106e0:	d054      	beq.n	801078c <LoRaMacParserData+0xb8>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 80106e2:	780b      	ldrb	r3, [r1, #0]
 80106e4:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 80106e6:	784b      	ldrb	r3, [r1, #1]
 80106e8:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80106ea:	788a      	ldrb	r2, [r1, #2]
 80106ec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80106f0:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80106f2:	78ca      	ldrb	r2, [r1, #3]
 80106f4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80106f8:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80106fa:	790a      	ldrb	r2, [r1, #4]
 80106fc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8010700:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 8010702:	794b      	ldrb	r3, [r1, #5]
 8010704:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 8010706:	798b      	ldrb	r3, [r1, #6]
 8010708:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 801070a:	79c8      	ldrb	r0, [r1, #7]

    memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 801070c:	7b22      	ldrb	r2, [r4, #12]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 801070e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8010712:	81e3      	strh	r3, [r4, #14]
    memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8010714:	f002 020f 	and.w	r2, r2, #15
 8010718:	3108      	adds	r1, #8
 801071a:	f104 0010 	add.w	r0, r4, #16
 801071e:	f001 fdb1 	bl	8012284 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8010722:	7b22      	ldrb	r2, [r4, #12]

    // Initialize anyway with zero.
    macMsg->FPort = 0;
    macMsg->FRMPayloadSize = 0;

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 8010724:	7923      	ldrb	r3, [r4, #4]
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8010726:	f002 020f 	and.w	r2, r2, #15
    macMsg->FPort = 0;
 801072a:	2100      	movs	r1, #0
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 801072c:	f102 0008 	add.w	r0, r2, #8
    macMsg->FPort = 0;
 8010730:	f884 1020 	strb.w	r1, [r4, #32]
    macMsg->FRMPayloadSize = 0;
 8010734:	f884 1028 	strb.w	r1, [r4, #40]	@ 0x28
    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 8010738:	1a19      	subs	r1, r3, r0
 801073a:	2904      	cmp	r1, #4
 801073c:	dc15      	bgt.n	801076a <LoRaMacParserData+0x96>
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 801073e:	6822      	ldr	r2, [r4, #0]
 8010740:	441a      	add	r2, r3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );

    return LORAMAC_PARSER_SUCCESS;
 8010742:	2000      	movs	r0, #0
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8010744:	f812 3c04 	ldrb.w	r3, [r2, #-4]
 8010748:	62e3      	str	r3, [r4, #44]	@ 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 801074a:	f812 1c03 	ldrb.w	r1, [r2, #-3]
 801074e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8010752:	62e3      	str	r3, [r4, #44]	@ 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 8010754:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 8010758:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 801075c:	62e3      	str	r3, [r4, #44]	@ 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 801075e:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 8010762:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8010766:	62e3      	str	r3, [r4, #44]	@ 0x2c
}
 8010768:	bd38      	pop	{r3, r4, r5, pc}
        macMsg->FPort = macMsg->Buffer[bufItr++];
 801076a:	6825      	ldr	r5, [r4, #0]
 801076c:	f102 0109 	add.w	r1, r2, #9
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8010770:	1f1a      	subs	r2, r3, #4
 8010772:	1a52      	subs	r2, r2, r1
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8010774:	5c2b      	ldrb	r3, [r5, r0]
 8010776:	f884 3020 	strb.w	r3, [r4, #32]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 801077a:	b2d2      	uxtb	r2, r2
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 801077c:	6a60      	ldr	r0, [r4, #36]	@ 0x24
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 801077e:	f884 2028 	strb.w	r2, [r4, #40]	@ 0x28
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 8010782:	4429      	add	r1, r5
 8010784:	f001 fd7e 	bl	8012284 <memcpy1>
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8010788:	7923      	ldrb	r3, [r4, #4]
 801078a:	e7d8      	b.n	801073e <LoRaMacParserData+0x6a>
        return LORAMAC_PARSER_ERROR_NPE;
 801078c:	2002      	movs	r0, #2
}
 801078e:	bd38      	pop	{r3, r4, r5, pc}
        return LORAMAC_PARSER_ERROR_NPE;
 8010790:	2002      	movs	r0, #2
}
 8010792:	4770      	bx	lr

08010794 <LoRaMacSerializerJoinRequest>:
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8010794:	b380      	cbz	r0, 80107f8 <LoRaMacSerializerJoinRequest+0x64>
 8010796:	6803      	ldr	r3, [r0, #0]
{
 8010798:	b510      	push	{r4, lr}
 801079a:	4604      	mov	r4, r0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 801079c:	b373      	cbz	r3, 80107fc <LoRaMacSerializerJoinRequest+0x68>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 801079e:	7902      	ldrb	r2, [r0, #4]
 80107a0:	2a16      	cmp	r2, #22
 80107a2:	d927      	bls.n	80107f4 <LoRaMacSerializerJoinRequest+0x60>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 80107a4:	7942      	ldrb	r2, [r0, #5]
 80107a6:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 80107a8:	4601      	mov	r1, r0
 80107aa:	2208      	movs	r2, #8
 80107ac:	f851 0b06 	ldr.w	r0, [r1], #6
 80107b0:	3001      	adds	r0, #1
 80107b2:	f001 fdb5 	bl	8012320 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 80107b6:	4621      	mov	r1, r4
 80107b8:	2208      	movs	r2, #8
 80107ba:	f851 0b0e 	ldr.w	r0, [r1], #14
 80107be:	3009      	adds	r0, #9
 80107c0:	f001 fdae 	bl	8012320 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 80107c4:	6823      	ldr	r3, [r4, #0]
 80107c6:	8ae2      	ldrh	r2, [r4, #22]
 80107c8:	745a      	strb	r2, [r3, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 80107ca:	8ae3      	ldrh	r3, [r4, #22]
 80107cc:	6822      	ldr	r2, [r4, #0]
 80107ce:	0a1b      	lsrs	r3, r3, #8
 80107d0:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 80107d2:	6823      	ldr	r3, [r4, #0]
 80107d4:	69a2      	ldr	r2, [r4, #24]
 80107d6:	74da      	strb	r2, [r3, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 80107d8:	69a3      	ldr	r3, [r4, #24]
 80107da:	6822      	ldr	r2, [r4, #0]
 80107dc:	0a1b      	lsrs	r3, r3, #8
 80107de:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 80107e0:	6823      	ldr	r3, [r4, #0]
 80107e2:	8b62      	ldrh	r2, [r4, #26]
 80107e4:	755a      	strb	r2, [r3, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 80107e6:	6822      	ldr	r2, [r4, #0]
 80107e8:	7ee1      	ldrb	r1, [r4, #27]
 80107ea:	7591      	strb	r1, [r2, #22]

    macMsg->BufSize = bufItr;
 80107ec:	2317      	movs	r3, #23
 80107ee:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 80107f0:	2000      	movs	r0, #0
}
 80107f2:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 80107f4:	2002      	movs	r0, #2
}
 80107f6:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80107f8:	2001      	movs	r0, #1
}
 80107fa:	4770      	bx	lr
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80107fc:	2001      	movs	r0, #1
}
 80107fe:	bd10      	pop	{r4, pc}

08010800 <LoRaMacSerializerData>:
    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8010800:	2800      	cmp	r0, #0
 8010802:	d06b      	beq.n	80108dc <LoRaMacSerializerData+0xdc>
 8010804:	6801      	ldr	r1, [r0, #0]
{
 8010806:	b538      	push	{r3, r4, r5, lr}
 8010808:	4604      	mov	r4, r0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 801080a:	2900      	cmp	r1, #0
 801080c:	d068      	beq.n	80108e0 <LoRaMacSerializerData+0xe0>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 801080e:	7b03      	ldrb	r3, [r0, #12]

    if( macMsg->FRMPayloadSize > 0 )
 8010810:	f890 2028 	ldrb.w	r2, [r0, #40]	@ 0x28
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8010814:	f003 030f 	and.w	r3, r3, #15
    if( macMsg->FRMPayloadSize > 0 )
 8010818:	2a00      	cmp	r2, #0
 801081a:	d157      	bne.n	80108cc <LoRaMacSerializerData+0xcc>
    }

    computedBufSize += macMsg->FRMPayloadSize;
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;

    if( macMsg->BufSize < computedBufSize )
 801081c:	7920      	ldrb	r0, [r4, #4]
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 801081e:	3308      	adds	r3, #8
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 8010820:	3204      	adds	r2, #4
    if( macMsg->BufSize < computedBufSize )
 8010822:	4413      	add	r3, r2
 8010824:	4298      	cmp	r0, r3
 8010826:	d357      	bcc.n	80108d8 <LoRaMacSerializerData+0xd8>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 8010828:	7963      	ldrb	r3, [r4, #5]
 801082a:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 801082c:	6823      	ldr	r3, [r4, #0]
 801082e:	68a2      	ldr	r2, [r4, #8]
 8010830:	705a      	strb	r2, [r3, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 8010832:	68a3      	ldr	r3, [r4, #8]
 8010834:	6822      	ldr	r2, [r4, #0]
 8010836:	0a1b      	lsrs	r3, r3, #8
 8010838:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 801083a:	6823      	ldr	r3, [r4, #0]
 801083c:	8962      	ldrh	r2, [r4, #10]
 801083e:	70da      	strb	r2, [r3, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 8010840:	6823      	ldr	r3, [r4, #0]
 8010842:	7ae2      	ldrb	r2, [r4, #11]
 8010844:	711a      	strb	r2, [r3, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 8010846:	6823      	ldr	r3, [r4, #0]
 8010848:	7b22      	ldrb	r2, [r4, #12]
 801084a:	715a      	strb	r2, [r3, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 801084c:	6823      	ldr	r3, [r4, #0]
 801084e:	89e2      	ldrh	r2, [r4, #14]
 8010850:	719a      	strb	r2, [r3, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8010852:	89e3      	ldrh	r3, [r4, #14]
 8010854:	6822      	ldr	r2, [r4, #0]

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8010856:	4621      	mov	r1, r4
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8010858:	0a1b      	lsrs	r3, r3, #8
 801085a:	71d3      	strb	r3, [r2, #7]
    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 801085c:	f851 0b10 	ldr.w	r0, [r1], #16
 8010860:	7b22      	ldrb	r2, [r4, #12]
 8010862:	3008      	adds	r0, #8
 8010864:	f002 020f 	and.w	r2, r2, #15
 8010868:	f001 fd0c 	bl	8012284 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 801086c:	7b21      	ldrb	r1, [r4, #12]

    if( macMsg->FRMPayloadSize > 0 )
 801086e:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8010872:	f001 010f 	and.w	r1, r1, #15
 8010876:	f101 0508 	add.w	r5, r1, #8
    if( macMsg->FRMPayloadSize > 0 )
 801087a:	b13a      	cbz	r2, 801088c <LoRaMacSerializerData+0x8c>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 801087c:	6823      	ldr	r3, [r4, #0]
 801087e:	f894 2020 	ldrb.w	r2, [r4, #32]
 8010882:	555a      	strb	r2, [r3, r5]
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 8010884:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 8010888:	f101 0509 	add.w	r5, r1, #9
    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 801088c:	6820      	ldr	r0, [r4, #0]
 801088e:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8010890:	4428      	add	r0, r5
 8010892:	f001 fcf7 	bl	8012284 <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 8010896:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 801089a:	6822      	ldr	r2, [r4, #0]
 801089c:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
    bufItr = bufItr + macMsg->FRMPayloadSize;
 801089e:	442b      	add	r3, r5
    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 80108a0:	54d1      	strb	r1, [r2, r3]
 80108a2:	1c5a      	adds	r2, r3, #1
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 80108a4:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 80108a6:	6820      	ldr	r0, [r4, #0]
 80108a8:	b292      	uxth	r2, r2
 80108aa:	0a09      	lsrs	r1, r1, #8
 80108ac:	5481      	strb	r1, [r0, r2]
 80108ae:	1c9a      	adds	r2, r3, #2
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 80108b0:	6821      	ldr	r1, [r4, #0]
 80108b2:	8de0      	ldrh	r0, [r4, #46]	@ 0x2e
 80108b4:	b292      	uxth	r2, r2
 80108b6:	5488      	strb	r0, [r1, r2]
 80108b8:	1cda      	adds	r2, r3, #3
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 80108ba:	6821      	ldr	r1, [r4, #0]
 80108bc:	f894 002f 	ldrb.w	r0, [r4, #47]	@ 0x2f
 80108c0:	b292      	uxth	r2, r2
 80108c2:	3304      	adds	r3, #4
 80108c4:	5488      	strb	r0, [r1, r2]

    macMsg->BufSize = bufItr;
 80108c6:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 80108c8:	2000      	movs	r0, #0
}
 80108ca:	bd38      	pop	{r3, r4, r5, pc}
    if( macMsg->BufSize < computedBufSize )
 80108cc:	7920      	ldrb	r0, [r4, #4]
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 80108ce:	3309      	adds	r3, #9
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 80108d0:	3204      	adds	r2, #4
    if( macMsg->BufSize < computedBufSize )
 80108d2:	4413      	add	r3, r2
 80108d4:	4298      	cmp	r0, r3
 80108d6:	d2a7      	bcs.n	8010828 <LoRaMacSerializerData+0x28>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 80108d8:	2002      	movs	r0, #2
}
 80108da:	bd38      	pop	{r3, r4, r5, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80108dc:	2001      	movs	r0, #1
}
 80108de:	4770      	bx	lr
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80108e0:	2001      	movs	r0, #1
}
 80108e2:	bd38      	pop	{r3, r4, r5, pc}

080108e4 <RegionIsActive>:
        default:
        {
            return false;
        }
    }
}
 80108e4:	f1a0 0005 	sub.w	r0, r0, #5
 80108e8:	fab0 f080 	clz	r0, r0
 80108ec:	0940      	lsrs	r0, r0, #5
 80108ee:	4770      	bx	lr

080108f0 <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
    PhyParam_t phyParam = { 0 };
    switch( region )
 80108f0:	2805      	cmp	r0, #5
{
 80108f2:	b082      	sub	sp, #8
    switch( region )
 80108f4:	d002      	beq.n	80108fc <RegionGetPhyParam+0xc>
        default:
        {
            return phyParam;
        }
    }
}
 80108f6:	2000      	movs	r0, #0
 80108f8:	b002      	add	sp, #8
 80108fa:	4770      	bx	lr
        EU868_GET_PHY_PARAM( );
 80108fc:	4608      	mov	r0, r1
}
 80108fe:	b002      	add	sp, #8
        EU868_GET_PHY_PARAM( );
 8010900:	f000 bd2a 	b.w	8011358 <RegionEU868GetPhyParam>

08010904 <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
    switch( region )
 8010904:	2805      	cmp	r0, #5
 8010906:	d000      	beq.n	801090a <RegionSetBandTxDone+0x6>
        default:
        {
            return;
        }
    }
}
 8010908:	4770      	bx	lr
        EU868_SET_BAND_TX_DONE( );
 801090a:	4608      	mov	r0, r1
 801090c:	f000 bdd8 	b.w	80114c0 <RegionEU868SetBandTxDone>

08010910 <RegionInitDefaults>:

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
    switch( region )
 8010910:	2805      	cmp	r0, #5
 8010912:	d000      	beq.n	8010916 <RegionInitDefaults+0x6>
        default:
        {
            break;
        }
    }
}
 8010914:	4770      	bx	lr
        EU868_INIT_DEFAULTS( );
 8010916:	4608      	mov	r0, r1
 8010918:	f000 bdf0 	b.w	80114fc <RegionEU868InitDefaults>

0801091c <RegionVerify>:

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
    switch( region )
 801091c:	2805      	cmp	r0, #5
{
 801091e:	460b      	mov	r3, r1
    switch( region )
 8010920:	d001      	beq.n	8010926 <RegionVerify+0xa>
        default:
        {
            return false;
        }
    }
}
 8010922:	2000      	movs	r0, #0
 8010924:	4770      	bx	lr
        EU868_VERIFY( );
 8010926:	4611      	mov	r1, r2
 8010928:	4618      	mov	r0, r3
 801092a:	f000 be55 	b.w	80115d8 <RegionEU868Verify>
 801092e:	bf00      	nop

08010930 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
    switch( region )
 8010930:	2805      	cmp	r0, #5
 8010932:	d000      	beq.n	8010936 <RegionApplyCFList+0x6>
        default:
        {
            break;
        }
    }
}
 8010934:	4770      	bx	lr
        EU868_APPLY_CF_LIST( );
 8010936:	4608      	mov	r0, r1
 8010938:	f000 bea4 	b.w	8011684 <RegionEU868ApplyCFList>

0801093c <RegionChanMaskSet>:

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
    switch( region )
 801093c:	2805      	cmp	r0, #5
 801093e:	d001      	beq.n	8010944 <RegionChanMaskSet+0x8>
        default:
        {
            return false;
        }
    }
}
 8010940:	2000      	movs	r0, #0
 8010942:	4770      	bx	lr
        EU868_CHAN_MASK_SET( );
 8010944:	4608      	mov	r0, r1
 8010946:	f000 bf85 	b.w	8011854 <RegionEU868ChanMaskSet>
 801094a:	bf00      	nop

0801094c <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 801094c:	b410      	push	{r4}
    switch( region )
 801094e:	2805      	cmp	r0, #5
{
 8010950:	9c01      	ldr	r4, [sp, #4]
    switch( region )
 8010952:	d001      	beq.n	8010958 <RegionComputeRxWindowParameters+0xc>
        default:
        {
            break;
        }
    }
}
 8010954:	bc10      	pop	{r4}
 8010956:	4770      	bx	lr
 8010958:	468c      	mov	ip, r1
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 801095a:	4660      	mov	r0, ip
 801095c:	4611      	mov	r1, r2
 801095e:	461a      	mov	r2, r3
 8010960:	4623      	mov	r3, r4
}
 8010962:	bc10      	pop	{r4}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 8010964:	f000 bf92 	b.w	801188c <RegionEU868ComputeRxWindowParameters>

08010968 <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
    switch( region )
 8010968:	2805      	cmp	r0, #5
{
 801096a:	460b      	mov	r3, r1
    switch( region )
 801096c:	d001      	beq.n	8010972 <RegionRxConfig+0xa>
        default:
        {
            return false;
        }
    }
}
 801096e:	2000      	movs	r0, #0
 8010970:	4770      	bx	lr
        EU868_RX_CONFIG( );
 8010972:	4611      	mov	r1, r2
 8010974:	4618      	mov	r0, r3
 8010976:	f000 bfbd 	b.w	80118f4 <RegionEU868RxConfig>
 801097a:	bf00      	nop

0801097c <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
    switch( region )
 801097c:	2805      	cmp	r0, #5
{
 801097e:	468c      	mov	ip, r1
 8010980:	4611      	mov	r1, r2
    switch( region )
 8010982:	d001      	beq.n	8010988 <RegionTxConfig+0xc>
        default:
        {
            return false;
        }
    }
}
 8010984:	2000      	movs	r0, #0
 8010986:	4770      	bx	lr
        EU868_TX_CONFIG( );
 8010988:	461a      	mov	r2, r3
 801098a:	4660      	mov	r0, ip
 801098c:	f001 b836 	b.w	80119fc <RegionEU868TxConfig>

08010990 <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8010990:	b410      	push	{r4}
    switch( region )
 8010992:	2805      	cmp	r0, #5
{
 8010994:	468c      	mov	ip, r1
 8010996:	9c01      	ldr	r4, [sp, #4]
 8010998:	4611      	mov	r1, r2
 801099a:	461a      	mov	r2, r3
 801099c:	9b02      	ldr	r3, [sp, #8]
    switch( region )
 801099e:	d002      	beq.n	80109a6 <RegionLinkAdrReq+0x16>
        default:
        {
            return 0;
        }
    }
}
 80109a0:	2000      	movs	r0, #0
 80109a2:	bc10      	pop	{r4}
 80109a4:	4770      	bx	lr
        EU868_LINK_ADR_REQ( );
 80109a6:	9301      	str	r3, [sp, #4]
 80109a8:	4660      	mov	r0, ip
 80109aa:	4623      	mov	r3, r4
}
 80109ac:	bc10      	pop	{r4}
        EU868_LINK_ADR_REQ( );
 80109ae:	f001 b8b7 	b.w	8011b20 <RegionEU868LinkAdrReq>
 80109b2:	bf00      	nop

080109b4 <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
    switch( region )
 80109b4:	2805      	cmp	r0, #5
 80109b6:	d001      	beq.n	80109bc <RegionRxParamSetupReq+0x8>
        default:
        {
            return 0;
        }
    }
}
 80109b8:	2000      	movs	r0, #0
 80109ba:	4770      	bx	lr
        EU868_RX_PARAM_SETUP_REQ( );
 80109bc:	4608      	mov	r0, r1
 80109be:	f001 ba2b 	b.w	8011e18 <RegionEU868RxParamSetupReq>
 80109c2:	bf00      	nop

080109c4 <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
    switch( region )
 80109c4:	2805      	cmp	r0, #5
 80109c6:	d001      	beq.n	80109cc <RegionNewChannelReq+0x8>
        default:
        {
            return 0;
        }
    }
}
 80109c8:	2000      	movs	r0, #0
 80109ca:	4770      	bx	lr
        EU868_NEW_CHANNEL_REQ( );
 80109cc:	4608      	mov	r0, r1
 80109ce:	f001 ba71 	b.w	8011eb4 <RegionEU868NewChannelReq>
 80109d2:	bf00      	nop

080109d4 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
    switch( region )
 80109d4:	2805      	cmp	r0, #5
 80109d6:	d001      	beq.n	80109dc <RegionTxParamSetupReq+0x8>
        default:
        {
            return 0;
        }
    }
}
 80109d8:	2000      	movs	r0, #0
 80109da:	4770      	bx	lr
        EU868_TX_PARAM_SETUP_REQ( );
 80109dc:	4608      	mov	r0, r1
 80109de:	f001 bb17 	b.w	8012010 <RegionEU868TxParamSetupReq>
 80109e2:	bf00      	nop

080109e4 <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
    switch( region )
 80109e4:	2805      	cmp	r0, #5
 80109e6:	d001      	beq.n	80109ec <RegionDlChannelReq+0x8>
        default:
        {
            return 0;
        }
    }
}
 80109e8:	2000      	movs	r0, #0
 80109ea:	4770      	bx	lr
        EU868_DL_CHANNEL_REQ( );
 80109ec:	4608      	mov	r0, r1
 80109ee:	f001 bb13 	b.w	8012018 <RegionEU868DlChannelReq>
 80109f2:	bf00      	nop

080109f4 <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
    switch( region )
 80109f4:	2805      	cmp	r0, #5
{
 80109f6:	460b      	mov	r3, r1
    switch( region )
 80109f8:	d001      	beq.n	80109fe <RegionAlternateDr+0xa>
        default:
        {
            return 0;
        }
    }
}
 80109fa:	2000      	movs	r0, #0
 80109fc:	4770      	bx	lr
        EU868_ALTERNATE_DR( );
 80109fe:	4611      	mov	r1, r2
 8010a00:	4618      	mov	r0, r3
 8010a02:	f001 bb5b 	b.w	80120bc <RegionEU868AlternateDr>
 8010a06:	bf00      	nop

08010a08 <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 8010a08:	b410      	push	{r4}
    switch( region )
 8010a0a:	2805      	cmp	r0, #5
{
 8010a0c:	9c01      	ldr	r4, [sp, #4]
    switch( region )
 8010a0e:	d002      	beq.n	8010a16 <RegionNextChannel+0xe>
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 8010a10:	2009      	movs	r0, #9
 8010a12:	bc10      	pop	{r4}
 8010a14:	4770      	bx	lr
 8010a16:	468c      	mov	ip, r1
        EU868_NEXT_CHANNEL( );
 8010a18:	4660      	mov	r0, ip
 8010a1a:	4611      	mov	r1, r2
 8010a1c:	461a      	mov	r2, r3
 8010a1e:	4623      	mov	r3, r4
}
 8010a20:	bc10      	pop	{r4}
        EU868_NEXT_CHANNEL( );
 8010a22:	f001 bb4d 	b.w	80120c0 <RegionEU868NextChannel>
 8010a26:	bf00      	nop

08010a28 <RegionSetContinuousWave>:
}

#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
    switch( region )
 8010a28:	2805      	cmp	r0, #5
 8010a2a:	d000      	beq.n	8010a2e <RegionSetContinuousWave+0x6>
        default:
        {
            break;
        }
    }
}
 8010a2c:	4770      	bx	lr
        EU868_SET_CONTINUOUS_WAVE( );
 8010a2e:	4608      	mov	r0, r1
 8010a30:	f001 bbce 	b.w	80121d0 <RegionEU868SetContinuousWave>

08010a34 <RegionApplyDrOffset>:
#endif /* REGION_VERSION */

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
    switch( region )
 8010a34:	2805      	cmp	r0, #5
{
 8010a36:	468c      	mov	ip, r1
 8010a38:	4611      	mov	r1, r2
    switch( region )
 8010a3a:	d001      	beq.n	8010a40 <RegionApplyDrOffset+0xc>
        default:
        {
            return dr;
        }
    }
}
 8010a3c:	b2d0      	uxtb	r0, r2
 8010a3e:	4770      	bx	lr
        EU868_APPLY_DR_OFFSET( );
 8010a40:	461a      	mov	r2, r3
 8010a42:	4660      	mov	r0, ip
 8010a44:	f001 bbf2 	b.w	801222c <RegionEU868ApplyDrOffset>

08010a48 <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 8010a48:	4800      	ldr	r0, [pc, #0]	@ (8010a4c <RegionGetVersion+0x4>)
 8010a4a:	4770      	bx	lr
 8010a4c:	01010003 	.word	0x01010003

08010a50 <RegionCommonValueInRange>:
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 8010a50:	4288      	cmp	r0, r1
 8010a52:	db04      	blt.n	8010a5e <RegionCommonValueInRange+0xe>
 8010a54:	4290      	cmp	r0, r2
 8010a56:	bfcc      	ite	gt
 8010a58:	2000      	movgt	r0, #0
 8010a5a:	2001      	movle	r0, #1
 8010a5c:	4770      	bx	lr
    {
        return 1;
    }
    return 0;
 8010a5e:	2000      	movs	r0, #0
}
 8010a60:	4770      	bx	lr
 8010a62:	bf00      	nop

08010a64 <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
    uint8_t index = id / 16;

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 8010a64:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 8010a68:	ebbc 1f11 	cmp.w	ip, r1, lsr #4
    uint8_t index = id / 16;
 8010a6c:	ea4f 1311 	mov.w	r3, r1, lsr #4
    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 8010a70:	d30f      	bcc.n	8010a92 <RegionCommonChanDisable+0x2e>
 8010a72:	4291      	cmp	r1, r2
 8010a74:	d20d      	bcs.n	8010a92 <RegionCommonChanDisable+0x2e>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 8010a76:	b21a      	sxth	r2, r3
 8010a78:	f001 010f 	and.w	r1, r1, #15
 8010a7c:	f830 c012 	ldrh.w	ip, [r0, r2, lsl #1]
 8010a80:	2301      	movs	r3, #1
 8010a82:	fa03 f101 	lsl.w	r1, r3, r1
 8010a86:	ea2c 0101 	bic.w	r1, ip, r1
 8010a8a:	f820 1012 	strh.w	r1, [r0, r2, lsl #1]

    return true;
 8010a8e:	4618      	mov	r0, r3
 8010a90:	4770      	bx	lr
        return false;
 8010a92:	2000      	movs	r0, #0
}
 8010a94:	4770      	bx	lr
 8010a96:	bf00      	nop

08010a98 <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 8010a98:	2800      	cmp	r0, #0
 8010a9a:	d060      	beq.n	8010b5e <RegionCommonCountChannels+0xc6>
    {
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8010a9c:	4291      	cmp	r1, r2
 8010a9e:	d25d      	bcs.n	8010b5c <RegionCommonCountChannels+0xc4>
 8010aa0:	1e53      	subs	r3, r2, #1
 8010aa2:	1a5b      	subs	r3, r3, r1
 8010aa4:	f100 0c02 	add.w	ip, r0, #2
 8010aa8:	fa51 f383 	uxtab	r3, r1, r3
 8010aac:	eb00 0241 	add.w	r2, r0, r1, lsl #1
 8010ab0:	eb0c 0143 	add.w	r1, ip, r3, lsl #1
    uint8_t nbChannels = 0;
 8010ab4:	2000      	movs	r0, #0
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
 8010ab6:	f832 cb02 	ldrh.w	ip, [r2], #2
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010aba:	f00c 0301 	and.w	r3, ip, #1
 8010abe:	f01c 0f02 	tst.w	ip, #2
            nbActiveBits++;
 8010ac2:	bf18      	it	ne
 8010ac4:	3301      	addne	r3, #1
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010ac6:	f01c 0f04 	tst.w	ip, #4
            nbActiveBits++;
 8010aca:	bf1c      	itt	ne
 8010acc:	3301      	addne	r3, #1
 8010ace:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010ad0:	f01c 0f08 	tst.w	ip, #8
            nbActiveBits++;
 8010ad4:	bf1c      	itt	ne
 8010ad6:	3301      	addne	r3, #1
 8010ad8:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010ada:	f01c 0f10 	tst.w	ip, #16
            nbActiveBits++;
 8010ade:	bf1c      	itt	ne
 8010ae0:	3301      	addne	r3, #1
 8010ae2:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010ae4:	f01c 0f20 	tst.w	ip, #32
            nbActiveBits++;
 8010ae8:	bf1c      	itt	ne
 8010aea:	3301      	addne	r3, #1
 8010aec:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010aee:	f01c 0f40 	tst.w	ip, #64	@ 0x40
            nbActiveBits++;
 8010af2:	bf1c      	itt	ne
 8010af4:	3301      	addne	r3, #1
 8010af6:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010af8:	f01c 0f80 	tst.w	ip, #128	@ 0x80
            nbActiveBits++;
 8010afc:	bf1c      	itt	ne
 8010afe:	3301      	addne	r3, #1
 8010b00:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b02:	f41c 7f80 	tst.w	ip, #256	@ 0x100
            nbActiveBits++;
 8010b06:	bf1c      	itt	ne
 8010b08:	3301      	addne	r3, #1
 8010b0a:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b0c:	f41c 7f00 	tst.w	ip, #512	@ 0x200
            nbActiveBits++;
 8010b10:	bf1c      	itt	ne
 8010b12:	3301      	addne	r3, #1
 8010b14:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b16:	f41c 6f80 	tst.w	ip, #1024	@ 0x400
            nbActiveBits++;
 8010b1a:	bf1c      	itt	ne
 8010b1c:	3301      	addne	r3, #1
 8010b1e:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b20:	f41c 6f00 	tst.w	ip, #2048	@ 0x800
            nbActiveBits++;
 8010b24:	bf1c      	itt	ne
 8010b26:	3301      	addne	r3, #1
 8010b28:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b2a:	f41c 5f80 	tst.w	ip, #4096	@ 0x1000
            nbActiveBits++;
 8010b2e:	bf1c      	itt	ne
 8010b30:	3301      	addne	r3, #1
 8010b32:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b34:	f41c 5f00 	tst.w	ip, #8192	@ 0x2000
            nbActiveBits++;
 8010b38:	bf1c      	itt	ne
 8010b3a:	3301      	addne	r3, #1
 8010b3c:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b3e:	f41c 4f80 	tst.w	ip, #16384	@ 0x4000
            nbActiveBits++;
 8010b42:	bf1c      	itt	ne
 8010b44:	3301      	addne	r3, #1
 8010b46:	b2db      	uxtbne	r3, r3
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8010b48:	f41c 4f00 	tst.w	ip, #32768	@ 0x8000
            nbActiveBits++;
 8010b4c:	bf1c      	itt	ne
 8010b4e:	3301      	addne	r3, #1
 8010b50:	b2db      	uxtbne	r3, r3
        nbChannels += CountChannels( channelsMask[i], 16 );
 8010b52:	4403      	add	r3, r0
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8010b54:	428a      	cmp	r2, r1
        nbChannels += CountChannels( channelsMask[i], 16 );
 8010b56:	b2d8      	uxtb	r0, r3
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8010b58:	d1ad      	bne.n	8010ab6 <RegionCommonCountChannels+0x1e>
 8010b5a:	4770      	bx	lr
        return 0;
 8010b5c:	2000      	movs	r0, #0
    }

    return nbChannels;
}
 8010b5e:	4770      	bx	lr

08010b60 <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 8010b60:	b188      	cbz	r0, 8010b86 <RegionCommonChanMaskCopy+0x26>
 8010b62:	b181      	cbz	r1, 8010b86 <RegionCommonChanMaskCopy+0x26>
    {
        for( uint8_t i = 0; i < len; i++ )
 8010b64:	b17a      	cbz	r2, 8010b86 <RegionCommonChanMaskCopy+0x26>
 8010b66:	1e53      	subs	r3, r2, #1
 8010b68:	2b06      	cmp	r3, #6
 8010b6a:	d902      	bls.n	8010b72 <RegionCommonChanMaskCopy+0x12>
 8010b6c:	1c8b      	adds	r3, r1, #2
 8010b6e:	4298      	cmp	r0, r3
 8010b70:	d10a      	bne.n	8010b88 <RegionCommonChanMaskCopy+0x28>
 8010b72:	1e83      	subs	r3, r0, #2
 8010b74:	eb01 0242 	add.w	r2, r1, r2, lsl #1
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
 8010b78:	f831 0b02 	ldrh.w	r0, [r1], #2
 8010b7c:	f823 0f02 	strh.w	r0, [r3, #2]!
        for( uint8_t i = 0; i < len; i++ )
 8010b80:	4291      	cmp	r1, r2
 8010b82:	d1f9      	bne.n	8010b78 <RegionCommonChanMaskCopy+0x18>
 8010b84:	4770      	bx	lr
 8010b86:	4770      	bx	lr
{
 8010b88:	b510      	push	{r4, lr}
 8010b8a:	0854      	lsrs	r4, r2, #1
 8010b8c:	460b      	mov	r3, r1
 8010b8e:	4684      	mov	ip, r0
 8010b90:	eb01 0484 	add.w	r4, r1, r4, lsl #2
            channelsMaskDest[i] = channelsMaskSrc[i];
 8010b94:	f853 eb04 	ldr.w	lr, [r3], #4
 8010b98:	f84c eb04 	str.w	lr, [ip], #4
        for( uint8_t i = 0; i < len; i++ )
 8010b9c:	42a3      	cmp	r3, r4
 8010b9e:	d1f9      	bne.n	8010b94 <RegionCommonChanMaskCopy+0x34>
 8010ba0:	f002 03fe 	and.w	r3, r2, #254	@ 0xfe
 8010ba4:	07d2      	lsls	r2, r2, #31
 8010ba6:	d503      	bpl.n	8010bb0 <RegionCommonChanMaskCopy+0x50>
            channelsMaskDest[i] = channelsMaskSrc[i];
 8010ba8:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
 8010bac:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
        }
    }
}
 8010bb0:	bd10      	pop	{r4, pc}
 8010bb2:	bf00      	nop

08010bb4 <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 8010bb4:	b082      	sub	sp, #8
 8010bb6:	b500      	push	{lr}
    uint16_t dutyCycle = band->DCycle;
 8010bb8:	f8b0 c000 	ldrh.w	ip, [r0]
{
 8010bbc:	9302      	str	r3, [sp, #8]
    if( joined == false )
 8010bbe:	b972      	cbnz	r2, 8010bde <RegionCommonSetBandTxDone+0x2a>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8010bc0:	f5b3 6f61 	cmp.w	r3, #3600	@ 0xe10
 8010bc4:	d31c      	bcc.n	8010c00 <RegionCommonSetBandTxDone+0x4c>
        else if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_10_HOURS_IN_S )
 8010bc6:	f649 2eaf 	movw	lr, #39599	@ 0x9aaf
            joinDutyCycle = BACKOFF_DC_10_HOURS;
 8010bca:	f242 7210 	movw	r2, #10000	@ 0x2710
 8010bce:	4573      	cmp	r3, lr
 8010bd0:	bf98      	it	ls
 8010bd2:	f44f 727a 	movls.w	r2, #1000	@ 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8010bd6:	4594      	cmp	ip, r2
 8010bd8:	bf38      	it	cc
 8010bda:	4694      	movcc	ip, r2
    if( dutyCycle == 0 )
 8010bdc:	e004      	b.n	8010be8 <RegionCommonSetBandTxDone+0x34>
 8010bde:	f1bc 0f01 	cmp.w	ip, #1
 8010be2:	bf38      	it	cc
 8010be4:	f04f 0c01 	movcc.w	ip, #1
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8010be8:	68c3      	ldr	r3, [r0, #12]
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 8010bea:	f85d eb04 	ldr.w	lr, [sp], #4
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8010bee:	fb01 f10c 	mul.w	r1, r1, ip
 8010bf2:	428b      	cmp	r3, r1
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 8010bf4:	bf8c      	ite	hi
 8010bf6:	1a5b      	subhi	r3, r3, r1
        band->TimeCredits = 0;
 8010bf8:	2300      	movls	r3, #0
 8010bfa:	60c3      	str	r3, [r0, #12]
}
 8010bfc:	b002      	add	sp, #8
 8010bfe:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8010c00:	2264      	movs	r2, #100	@ 0x64
 8010c02:	e7e8      	b.n	8010bd6 <RegionCommonSetBandTxDone+0x22>

08010c04 <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 8010c04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010c08:	b091      	sub	sp, #68	@ 0x44
 8010c0a:	4682      	mov	sl, r0
 8010c0c:	f89d 4068 	ldrb.w	r4, [sp, #104]	@ 0x68
 8010c10:	9407      	str	r4, [sp, #28]
 8010c12:	f8dd 806c 	ldr.w	r8, [sp, #108]	@ 0x6c
 8010c16:	9302      	str	r3, [sp, #8]
 8010c18:	460c      	mov	r4, r1
 8010c1a:	4615      	mov	r5, r2
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8010c1c:	f004 fe4e 	bl	80158bc <UTIL_TIMER_GetCurrentTime>
 8010c20:	9003      	str	r0, [sp, #12]
    TimerTime_t creditCosts = 0;
    uint16_t dutyCycle = 1;
    uint8_t validBands = 0;

    for( uint8_t i = 0; i < nbBands; i++ )
 8010c22:	2d00      	cmp	r5, #0
 8010c24:	f000 810d 	beq.w	8010e42 <RegionCommonUpdateBandTimeOff+0x23e>
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 8010c28:	4a89      	ldr	r2, [pc, #548]	@ (8010e50 <RegionCommonUpdateBandTimeOff+0x24c>)
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8010c2a:	f5a8 33f6 	sub.w	r3, r8, #125952	@ 0x1ec00
 8010c2e:	3b30      	subs	r3, #48	@ 0x30
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 8010c30:	fba2 2303 	umull	r2, r3, r2, r3
 8010c34:	4a87      	ldr	r2, [pc, #540]	@ (8010e54 <RegionCommonUpdateBandTimeOff+0x250>)
 8010c36:	0c1b      	lsrs	r3, r3, #16
 8010c38:	fb02 fe03 	mul.w	lr, r2, r3
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8010c3c:	f50e 3cf6 	add.w	ip, lr, #125952	@ 0x1ec00
 8010c40:	2318      	movs	r3, #24
 8010c42:	fb13 4305 	smlabb	r3, r3, r5, r4
 8010c46:	f10c 0c30 	add.w	ip, ip, #48	@ 0x30
 8010c4a:	9304      	str	r3, [sp, #16]
 8010c4c:	e9cd ce08 	strd	ip, lr, [sp, #32]
 8010c50:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	@ 0x70
 8010c54:	9305      	str	r3, [sp, #20]
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 8010c56:	f04f 33ff 	mov.w	r3, #4294967295
    uint8_t validBands = 0;
 8010c5a:	f04f 0b00 	mov.w	fp, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 8010c5e:	9306      	str	r3, [sp, #24]
 8010c60:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
    {
        // Synchronization of bands and credits
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 8010c64:	9b05      	ldr	r3, [sp, #20]
 8010c66:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
 8010c6a:	f8ad 302c 	strh.w	r3, [sp, #44]	@ 0x2c
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 8010c6e:	e899 0003 	ldmia.w	r9, {r0, r1}
 8010c72:	f8cd 806c 	str.w	r8, [sp, #108]	@ 0x6c
 8010c76:	f004 f907 	bl	8014e88 <SysTimeToMs>
    uint16_t dutyCycle = band->DCycle;
 8010c7a:	8827      	ldrh	r7, [r4, #0]
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 8010c7c:	4601      	mov	r1, r0
    if( joined == false )
 8010c7e:	f1ba 0f00 	cmp.w	sl, #0
 8010c82:	d17b      	bne.n	8010d7c <RegionCommonUpdateBandTimeOff+0x178>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8010c84:	f5b8 6f61 	cmp.w	r8, #3600	@ 0xe10
 8010c88:	f0c0 80ad 	bcc.w	8010de6 <RegionCommonUpdateBandTimeOff+0x1e2>
        else if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_10_HOURS_IN_S )
 8010c8c:	f649 23af 	movw	r3, #39599	@ 0x9aaf
 8010c90:	4598      	cmp	r8, r3
 8010c92:	f200 80c6 	bhi.w	8010e22 <RegionCommonUpdateBandTimeOff+0x21e>
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8010c96:	f5b7 7f7a 	cmp.w	r7, #1000	@ 0x3e8
 8010c9a:	bf38      	it	cc
 8010c9c:	f44f 777a 	movcc.w	r7, #1000	@ 0x3e8
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 8010ca0:	f5b7 7f7a 	cmp.w	r7, #1000	@ 0x3e8
 8010ca4:	f000 80c6 	beq.w	8010e34 <RegionCommonUpdateBandTimeOff+0x230>
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8010ca8:	68a1      	ldr	r1, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 8010caa:	4e6b      	ldr	r6, [pc, #428]	@ (8010e58 <RegionCommonUpdateBandTimeOff+0x254>)
                                       lastTxIsJoinRequest, elapsedTimeSinceStartup,
                                       currentTime );

        // Calculate the credit costs for the next transmission
        // with the duty cycle and the expected time on air
        creditCosts = expectedTimeOnAir * dutyCycle;
 8010cac:	463d      	mov	r5, r7
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8010cae:	a80e      	add	r0, sp, #56	@ 0x38
 8010cb0:	f004 f90c 	bl	8014ecc <SysTimeFromMs>
 8010cb4:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8010cb6:	9300      	str	r3, [sp, #0]
 8010cb8:	e899 0006 	ldmia.w	r9, {r1, r2}
 8010cbc:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8010cbe:	a80c      	add	r0, sp, #48	@ 0x30
 8010cc0:	f004 f864 	bl	8014d8c <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 8010cc4:	9b02      	ldr	r3, [sp, #8]
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8010cc6:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 8010cc8:	a80c      	add	r0, sp, #48	@ 0x30
 8010cca:	b90b      	cbnz	r3, 8010cd0 <RegionCommonUpdateBandTimeOff+0xcc>
 8010ccc:	9b07      	ldr	r3, [sp, #28]
 8010cce:	b11b      	cbz	r3, 8010cd8 <RegionCommonUpdateBandTimeOff+0xd4>
 8010cd0:	6923      	ldr	r3, [r4, #16]
 8010cd2:	42b3      	cmp	r3, r6
 8010cd4:	f000 809d 	beq.w	8010e12 <RegionCommonUpdateBandTimeOff+0x20e>
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8010cd8:	4b60      	ldr	r3, [pc, #384]	@ (8010e5c <RegionCommonUpdateBandTimeOff+0x258>)
            band->TimeCredits = maxCredits;
 8010cda:	60e6      	str	r6, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8010cdc:	4598      	cmp	r8, r3
 8010cde:	f200 808a 	bhi.w	8010df6 <RegionCommonUpdateBandTimeOff+0x1f2>
    band->MaxTimeCredits = maxCredits;
 8010ce2:	6126      	str	r6, [r4, #16]
        band->TimeCredits = band->MaxTimeCredits;
 8010ce4:	4630      	mov	r0, r6
        creditCosts = expectedTimeOnAir * dutyCycle;
 8010ce6:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8010ce8:	fb03 f505 	mul.w	r5, r3, r5

        // Check if the band is ready for transmission. Its ready,
        // when the duty cycle is off, or the TimeCredits of the band
        // is higher than the credit costs for the transmission.
        if( ( bands[i].TimeCredits >= creditCosts ) ||
 8010cec:	4285      	cmp	r5, r0
    band->LastBandUpdateTime = currentTime;
 8010cee:	9b03      	ldr	r3, [sp, #12]
 8010cf0:	6063      	str	r3, [r4, #4]
        if( ( bands[i].TimeCredits >= creditCosts ) ||
 8010cf2:	d93c      	bls.n	8010d6e <RegionCommonUpdateBandTimeOff+0x16a>
 8010cf4:	9b02      	ldr	r3, [sp, #8]
 8010cf6:	2b00      	cmp	r3, #0
 8010cf8:	d15c      	bne.n	8010db4 <RegionCommonUpdateBandTimeOff+0x1b0>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 8010cfa:	f1ba 0f00 	cmp.w	sl, #0
 8010cfe:	d136      	bne.n	8010d6e <RegionCommonUpdateBandTimeOff+0x16a>
        {
            // In this case, the band has not enough credits
            // for the next transmission.
            bands[i].ReadyForTransmission = false;

            if( bands[i].MaxTimeCredits >= creditCosts )
 8010d00:	42b5      	cmp	r5, r6
            bands[i].ReadyForTransmission = false;
 8010d02:	f884 a014 	strb.w	sl, [r4, #20]
            if( bands[i].MaxTimeCredits >= creditCosts )
 8010d06:	d803      	bhi.n	8010d10 <RegionCommonUpdateBandTimeOff+0x10c>
                // for a transmission in the future.
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
                // This band is a potential candidate for an
                // upcoming transmission (even if its time credits are not enough
                // at the moment), so increase the counter.
                validBands++;
 8010d08:	f10b 0b01 	add.w	fp, fp, #1
 8010d0c:	fa5f fb8b 	uxtb.w	fp, fp
            }

            // Apply a special calculation if the device is not joined.
            if( joined == false )
            {
                SysTime_t backoffTimeRange = {
 8010d10:	2300      	movs	r3, #0
                    .Seconds    = 0,
                    .SubSeconds = 0,
                };
                // Get the backoff time range based on the duty cycle definition
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8010d12:	2f64      	cmp	r7, #100	@ 0x64
                SysTime_t backoffTimeRange = {
 8010d14:	f8ad 3034 	strh.w	r3, [sp, #52]	@ 0x34
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8010d18:	d062      	beq.n	8010de0 <RegionCommonUpdateBandTimeOff+0x1dc>
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_10_HOURS_IN_S;
                }
                else
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8010d1a:	4a51      	ldr	r2, [pc, #324]	@ (8010e60 <RegionCommonUpdateBandTimeOff+0x25c>)
 8010d1c:	f649 23b0 	movw	r3, #39600	@ 0x9ab0
 8010d20:	f5b7 7f7a 	cmp.w	r7, #1000	@ 0x3e8
 8010d24:	bf18      	it	ne
 8010d26:	4613      	movne	r3, r2
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8010d28:	4a4d      	ldr	r2, [pc, #308]	@ (8010e60 <RegionCommonUpdateBandTimeOff+0x25c>)
 8010d2a:	4590      	cmp	r8, r2
 8010d2c:	d905      	bls.n	8010d3a <RegionCommonUpdateBandTimeOff+0x136>
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8010d2e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8010d30:	f502 32a8 	add.w	r2, r2, #86016	@ 0x15000
 8010d34:	f502 72c0 	add.w	r2, r2, #384	@ 0x180
 8010d38:	4413      	add	r3, r2
                }
                // Calculate the time difference between now and the next range
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 8010d3a:	930c      	str	r3, [sp, #48]	@ 0x30
 8010d3c:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 8010d3e:	9300      	str	r3, [sp, #0]
 8010d40:	ad0c      	add	r5, sp, #48	@ 0x30
 8010d42:	e895 0006 	ldmia.w	r5, {r1, r2}
 8010d46:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8010d48:	4628      	mov	r0, r5
 8010d4a:	f004 f81f 	bl	8014d8c <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 8010d4e:	e895 0003 	ldmia.w	r5, {r0, r1}
 8010d52:	f004 f899 	bl	8014e88 <SysTimeToMs>
 8010d56:	9006      	str	r0, [sp, #24]
    for( uint8_t i = 0; i < nbBands; i++ )
 8010d58:	9b04      	ldr	r3, [sp, #16]
 8010d5a:	3418      	adds	r4, #24
 8010d5c:	42a3      	cmp	r3, r4
 8010d5e:	d181      	bne.n	8010c64 <RegionCommonUpdateBandTimeOff+0x60>
            }
        }
    }

    if( validBands == 0 )
 8010d60:	f1bb 0f00 	cmp.w	fp, #0
 8010d64:	d06d      	beq.n	8010e42 <RegionCommonUpdateBandTimeOff+0x23e>
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
    }
    return minTimeToWait;
}
 8010d66:	9806      	ldr	r0, [sp, #24]
 8010d68:	b011      	add	sp, #68	@ 0x44
 8010d6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            validBands++;
 8010d6e:	f10b 0b01 	add.w	fp, fp, #1
            bands[i].ReadyForTransmission = true;
 8010d72:	2301      	movs	r3, #1
            validBands++;
 8010d74:	fa5f fb8b 	uxtb.w	fp, fp
            bands[i].ReadyForTransmission = true;
 8010d78:	7523      	strb	r3, [r4, #20]
            validBands++;
 8010d7a:	e7ed      	b.n	8010d58 <RegionCommonUpdateBandTimeOff+0x154>
        if( dutyCycleEnabled == false )
 8010d7c:	9b02      	ldr	r3, [sp, #8]
    if( band->LastBandUpdateTime == 0 )
 8010d7e:	6860      	ldr	r0, [r4, #4]
        if( dutyCycleEnabled == false )
 8010d80:	b99b      	cbnz	r3, 8010daa <RegionCommonUpdateBandTimeOff+0x1a6>
            band->TimeCredits = maxCredits;
 8010d82:	4b38      	ldr	r3, [pc, #224]	@ (8010e64 <RegionCommonUpdateBandTimeOff+0x260>)
 8010d84:	60e3      	str	r3, [r4, #12]
    if( band->LastBandUpdateTime == 0 )
 8010d86:	b900      	cbnz	r0, 8010d8a <RegionCommonUpdateBandTimeOff+0x186>
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 8010d88:	2000      	movs	r0, #0
    band->MaxTimeCredits = maxCredits;
 8010d8a:	4b36      	ldr	r3, [pc, #216]	@ (8010e64 <RegionCommonUpdateBandTimeOff+0x260>)
 8010d8c:	6123      	str	r3, [r4, #16]
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 8010d8e:	f004 fd9f 	bl	80158d0 <UTIL_TIMER_GetElapsedTime>
 8010d92:	68e3      	ldr	r3, [r4, #12]
    if( band->TimeCredits > band->MaxTimeCredits )
 8010d94:	6926      	ldr	r6, [r4, #16]
 8010d96:	2f01      	cmp	r7, #1
 8010d98:	bf38      	it	cc
 8010d9a:	2701      	movcc	r7, #1
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 8010d9c:	4418      	add	r0, r3
 8010d9e:	60e0      	str	r0, [r4, #12]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8010da0:	463d      	mov	r5, r7
    if( band->TimeCredits > band->MaxTimeCredits )
 8010da2:	42b0      	cmp	r0, r6
 8010da4:	d99f      	bls.n	8010ce6 <RegionCommonUpdateBandTimeOff+0xe2>
        band->TimeCredits = band->MaxTimeCredits;
 8010da6:	60e6      	str	r6, [r4, #12]
 8010da8:	e79c      	b.n	8010ce4 <RegionCommonUpdateBandTimeOff+0xe0>
    if( band->LastBandUpdateTime == 0 )
 8010daa:	2800      	cmp	r0, #0
 8010dac:	d1ed      	bne.n	8010d8a <RegionCommonUpdateBandTimeOff+0x186>
        band->TimeCredits = maxCredits;
 8010dae:	4b2d      	ldr	r3, [pc, #180]	@ (8010e64 <RegionCommonUpdateBandTimeOff+0x260>)
 8010db0:	60e3      	str	r3, [r4, #12]
    if( joined == true )
 8010db2:	e7e9      	b.n	8010d88 <RegionCommonUpdateBandTimeOff+0x184>
            bands[i].ReadyForTransmission = false;
 8010db4:	2300      	movs	r3, #0
            if( bands[i].MaxTimeCredits >= creditCosts )
 8010db6:	42b5      	cmp	r5, r6
            bands[i].ReadyForTransmission = false;
 8010db8:	7523      	strb	r3, [r4, #20]
            if( bands[i].MaxTimeCredits >= creditCosts )
 8010dba:	d809      	bhi.n	8010dd0 <RegionCommonUpdateBandTimeOff+0x1cc>
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8010dbc:	9b06      	ldr	r3, [sp, #24]
 8010dbe:	1a2d      	subs	r5, r5, r0
 8010dc0:	42ab      	cmp	r3, r5
 8010dc2:	bf28      	it	cs
 8010dc4:	462b      	movcs	r3, r5
                validBands++;
 8010dc6:	f10b 0b01 	add.w	fp, fp, #1
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8010dca:	9306      	str	r3, [sp, #24]
                validBands++;
 8010dcc:	fa5f fb8b 	uxtb.w	fp, fp
            if( joined == false )
 8010dd0:	f1ba 0f00 	cmp.w	sl, #0
 8010dd4:	d1c0      	bne.n	8010d58 <RegionCommonUpdateBandTimeOff+0x154>
                SysTime_t backoffTimeRange = {
 8010dd6:	2300      	movs	r3, #0
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8010dd8:	2f64      	cmp	r7, #100	@ 0x64
                SysTime_t backoffTimeRange = {
 8010dda:	f8ad 3034 	strh.w	r3, [sp, #52]	@ 0x34
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8010dde:	d19c      	bne.n	8010d1a <RegionCommonUpdateBandTimeOff+0x116>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 8010de0:	f44f 6361 	mov.w	r3, #3600	@ 0xe10
 8010de4:	e7a0      	b.n	8010d28 <RegionCommonUpdateBandTimeOff+0x124>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 8010de6:	2f64      	cmp	r7, #100	@ 0x64
 8010de8:	f63f af5a 	bhi.w	8010ca0 <RegionCommonUpdateBandTimeOff+0x9c>
            band->LastMaxCreditAssignTime = elapsedTime;
 8010dec:	2564      	movs	r5, #100	@ 0x64
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8010dee:	4e1d      	ldr	r6, [pc, #116]	@ (8010e64 <RegionCommonUpdateBandTimeOff+0x260>)
            band->LastMaxCreditAssignTime = elapsedTime;
 8010df0:	60a0      	str	r0, [r4, #8]
 8010df2:	462f      	mov	r7, r5
 8010df4:	e75b      	b.n	8010cae <RegionCommonUpdateBandTimeOff+0xaa>
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 8010df6:	9b08      	ldr	r3, [sp, #32]
 8010df8:	930c      	str	r3, [sp, #48]	@ 0x30
                timeDiff.SubSeconds = 0;
 8010dfa:	2300      	movs	r3, #0
 8010dfc:	f8ad 3034 	strh.w	r3, [sp, #52]	@ 0x34
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 8010e00:	c803      	ldmia	r0, {r0, r1}
 8010e02:	f004 f841 	bl	8014e88 <SysTimeToMs>
    if( band->LastBandUpdateTime == 0 )
 8010e06:	6863      	ldr	r3, [r4, #4]
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 8010e08:	60a0      	str	r0, [r4, #8]
    if( band->LastBandUpdateTime == 0 )
 8010e0a:	b1bb      	cbz	r3, 8010e3c <RegionCommonUpdateBandTimeOff+0x238>
    band->MaxTimeCredits = maxCredits;
 8010e0c:	6126      	str	r6, [r4, #16]
    if( band->TimeCredits > band->MaxTimeCredits )
 8010e0e:	68e0      	ldr	r0, [r4, #12]
 8010e10:	e7c7      	b.n	8010da2 <RegionCommonUpdateBandTimeOff+0x19e>
            ( band->MaxTimeCredits != maxCredits ) ||
 8010e12:	4b15      	ldr	r3, [pc, #84]	@ (8010e68 <RegionCommonUpdateBandTimeOff+0x264>)
 8010e14:	429a      	cmp	r2, r3
 8010e16:	f63f af5f 	bhi.w	8010cd8 <RegionCommonUpdateBandTimeOff+0xd4>
    if( band->LastBandUpdateTime == 0 )
 8010e1a:	6863      	ldr	r3, [r4, #4]
 8010e1c:	2b00      	cmp	r3, #0
 8010e1e:	d0c2      	beq.n	8010da6 <RegionCommonUpdateBandTimeOff+0x1a2>
 8010e20:	e7f5      	b.n	8010e0e <RegionCommonUpdateBandTimeOff+0x20a>
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8010e22:	f242 7310 	movw	r3, #10000	@ 0x2710
 8010e26:	429f      	cmp	r7, r3
 8010e28:	bf38      	it	cc
 8010e2a:	461f      	movcc	r7, r3
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8010e2c:	68a1      	ldr	r1, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 8010e2e:	4e0a      	ldr	r6, [pc, #40]	@ (8010e58 <RegionCommonUpdateBandTimeOff+0x254>)
        creditCosts = expectedTimeOnAir * dutyCycle;
 8010e30:	463d      	mov	r5, r7
 8010e32:	e73c      	b.n	8010cae <RegionCommonUpdateBandTimeOff+0xaa>
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 8010e34:	4e0d      	ldr	r6, [pc, #52]	@ (8010e6c <RegionCommonUpdateBandTimeOff+0x268>)
            band->LastMaxCreditAssignTime = elapsedTime;
 8010e36:	60a1      	str	r1, [r4, #8]
 8010e38:	463d      	mov	r5, r7
 8010e3a:	e738      	b.n	8010cae <RegionCommonUpdateBandTimeOff+0xaa>
        band->TimeCredits = maxCredits;
 8010e3c:	e9c4 6603 	strd	r6, r6, [r4, #12]
    if( joined == true )
 8010e40:	e750      	b.n	8010ce4 <RegionCommonUpdateBandTimeOff+0xe0>
        return TIMERTIME_T_MAX;
 8010e42:	f04f 33ff 	mov.w	r3, #4294967295
 8010e46:	9306      	str	r3, [sp, #24]
}
 8010e48:	9806      	ldr	r0, [sp, #24]
 8010e4a:	b011      	add	sp, #68	@ 0x44
 8010e4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010e50:	c22e4507 	.word	0xc22e4507
 8010e54:	00015180 	.word	0x00015180
 8010e58:	02932e00 	.word	0x02932e00
 8010e5c:	0001ec2f 	.word	0x0001ec2f
 8010e60:	0001ec30 	.word	0x0001ec30
 8010e64:	001b7740 	.word	0x001b7740
 8010e68:	0001517f 	.word	0x0001517f
 8010e6c:	0112a880 	.word	0x0112a880

08010e70 <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 8010e70:	7803      	ldrb	r3, [r0, #0]
 8010e72:	2b03      	cmp	r3, #3
 8010e74:	d001      	beq.n	8010e7a <RegionCommonParseLinkAdrReq+0xa>
    uint8_t retIndex = 0;
 8010e76:	2000      	movs	r0, #0

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
    }
    return retIndex;
}
 8010e78:	4770      	bx	lr
        linkAdrParams->Datarate = payload[1];
 8010e7a:	7843      	ldrb	r3, [r0, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8010e7c:	f003 020f 	and.w	r2, r3, #15
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8010e80:	091b      	lsrs	r3, r3, #4
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8010e82:	708a      	strb	r2, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8010e84:	704b      	strb	r3, [r1, #1]
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 8010e86:	7883      	ldrb	r3, [r0, #2]
 8010e88:	808b      	strh	r3, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 8010e8a:	78c2      	ldrb	r2, [r0, #3]
 8010e8c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8010e90:	808b      	strh	r3, [r1, #4]
        linkAdrParams->NbRep = payload[4];
 8010e92:	7903      	ldrb	r3, [r0, #4]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8010e94:	f3c3 1202 	ubfx	r2, r3, #4, #3
        linkAdrParams->NbRep &= 0x0F;
 8010e98:	f003 030f 	and.w	r3, r3, #15
        retIndex = 5;
 8010e9c:	2005      	movs	r0, #5
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8010e9e:	70ca      	strb	r2, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 8010ea0:	700b      	strb	r3, [r1, #0]
        retIndex = 5;
 8010ea2:	4770      	bx	lr

08010ea4 <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 8010ea4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010ea8:	4684      	mov	ip, r0
 8010eaa:	b085      	sub	sp, #20
    int8_t datarate = verifyParams->Datarate;
    int8_t txPower = verifyParams->TxPower;
    int8_t nbRepetitions = verifyParams->NbRep;

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 8010eac:	f89c 4005 	ldrb.w	r4, [ip, #5]
    uint8_t status = verifyParams->Status;
 8010eb0:	7900      	ldrb	r0, [r0, #4]
    int8_t datarate = verifyParams->Datarate;
 8010eb2:	f99c e006 	ldrsb.w	lr, [ip, #6]
    int8_t txPower = verifyParams->TxPower;
 8010eb6:	f99c 5007 	ldrsb.w	r5, [ip, #7]
    if( verifyParams->AdrEnabled == false )
 8010eba:	b384      	cbz	r4, 8010f1e <RegionCommonLinkAdrReqVerifyParams+0x7a>
    int8_t nbRepetitions = verifyParams->NbRep;
 8010ebc:	f99c 4008 	ldrsb.w	r4, [ip, #8]
        nbRepetitions = verifyParams->CurrentNbRep;
        datarate =  verifyParams->CurrentDatarate;
        txPower =  verifyParams->CurrentTxPower;
    }

    if( status != 0 )
 8010ec0:	b1b0      	cbz	r0, 8010ef0 <RegionCommonLinkAdrReqVerifyParams+0x4c>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( datarate == 0x0F )
 8010ec2:	f1be 0f0f 	cmp.w	lr, #15
 8010ec6:	d11b      	bne.n	8010f00 <RegionCommonLinkAdrReqVerifyParams+0x5c>
        { // 0xF means that the device MUST ignore that field, and keep the current parameter value.
            datarate =  verifyParams->CurrentDatarate;
 8010ec8:	f99c e009 	ldrsb.w	lr, [ip, #9]
        {
            status &= 0xFD; // Datarate KO
        }

        // Verify tx power
        if( txPower == 0x0F )
 8010ecc:	2d0f      	cmp	r5, #15
 8010ece:	d023      	beq.n	8010f18 <RegionCommonLinkAdrReqVerifyParams+0x74>
        { // 0xF means that the device MUST ignore that field, and keep the current parameter value.
            txPower =  verifyParams->CurrentTxPower;
        }
        else if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 8010ed0:	f99c 601d 	ldrsb.w	r6, [ip, #29]
    if( ( value >= min ) && ( value <= max ) )
 8010ed4:	42ae      	cmp	r6, r5
 8010ed6:	dd29      	ble.n	8010f2c <RegionCommonLinkAdrReqVerifyParams+0x88>
 8010ed8:	4635      	mov	r5, r6
            }
        }
    }

    // If the status is ok, verify the NbRep
    if( status == 0x07 )
 8010eda:	2807      	cmp	r0, #7
 8010edc:	d108      	bne.n	8010ef0 <RegionCommonLinkAdrReqVerifyParams+0x4c>
    {
        if( nbRepetitions == 0 )
 8010ede:	b93c      	cbnz	r4, 8010ef0 <RegionCommonLinkAdrReqVerifyParams+0x4c>
 8010ee0:	2401      	movs	r4, #1
            nbRepetitions = 1;
        }
    }

    // Apply changes
    *dr = datarate;
 8010ee2:	f881 e000 	strb.w	lr, [r1]
    *txPow = txPower;
 8010ee6:	7015      	strb	r5, [r2, #0]
    *nbRep = nbRepetitions;
 8010ee8:	701c      	strb	r4, [r3, #0]

    return status;
}
 8010eea:	b005      	add	sp, #20
 8010eec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *nbRep = nbRepetitions;
 8010ef0:	b2e4      	uxtb	r4, r4
    *dr = datarate;
 8010ef2:	f881 e000 	strb.w	lr, [r1]
    *txPow = txPower;
 8010ef6:	7015      	strb	r5, [r2, #0]
    *nbRep = nbRepetitions;
 8010ef8:	701c      	strb	r4, [r3, #0]
}
 8010efa:	b005      	add	sp, #20
 8010efc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ( value >= min ) && ( value <= max ) )
 8010f00:	f99c 6014 	ldrsb.w	r6, [ip, #20]
 8010f04:	4576      	cmp	r6, lr
 8010f06:	dc03      	bgt.n	8010f10 <RegionCommonLinkAdrReqVerifyParams+0x6c>
 8010f08:	f99c 6015 	ldrsb.w	r6, [ip, #21]
 8010f0c:	4576      	cmp	r6, lr
 8010f0e:	da1b      	bge.n	8010f48 <RegionCommonLinkAdrReqVerifyParams+0xa4>
        if( txPower == 0x0F )
 8010f10:	2d0f      	cmp	r5, #15
            status &= 0xFD; // Datarate KO
 8010f12:	f000 00fd 	and.w	r0, r0, #253	@ 0xfd
        if( txPower == 0x0F )
 8010f16:	d1db      	bne.n	8010ed0 <RegionCommonLinkAdrReqVerifyParams+0x2c>
            txPower =  verifyParams->CurrentTxPower;
 8010f18:	f99c 500a 	ldrsb.w	r5, [ip, #10]
 8010f1c:	e7dd      	b.n	8010eda <RegionCommonLinkAdrReqVerifyParams+0x36>
        nbRepetitions = verifyParams->CurrentNbRep;
 8010f1e:	f99c 400b 	ldrsb.w	r4, [ip, #11]
        datarate =  verifyParams->CurrentDatarate;
 8010f22:	f99c e009 	ldrsb.w	lr, [ip, #9]
        txPower =  verifyParams->CurrentTxPower;
 8010f26:	f99c 500a 	ldrsb.w	r5, [ip, #10]
 8010f2a:	e7c9      	b.n	8010ec0 <RegionCommonLinkAdrReqVerifyParams+0x1c>
    if( ( value >= min ) && ( value <= max ) )
 8010f2c:	f99c 601c 	ldrsb.w	r6, [ip, #28]
 8010f30:	42ae      	cmp	r6, r5
 8010f32:	dad2      	bge.n	8010eda <RegionCommonLinkAdrReqVerifyParams+0x36>
                status &= 0xFB; // TxPower KO
 8010f34:	f000 00fb 	and.w	r0, r0, #251	@ 0xfb
    *nbRep = nbRepetitions;
 8010f38:	b2e4      	uxtb	r4, r4
    *dr = datarate;
 8010f3a:	f881 e000 	strb.w	lr, [r1]
    *txPow = txPower;
 8010f3e:	7015      	strb	r5, [r2, #0]
    *nbRep = nbRepetitions;
 8010f40:	701c      	strb	r4, [r3, #0]
}
 8010f42:	b005      	add	sp, #20
 8010f44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        else if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8010f48:	f89c a00c 	ldrb.w	sl, [ip, #12]
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8010f4c:	f1ba 0f00 	cmp.w	sl, #0
 8010f50:	d0de      	beq.n	8010f10 <RegionCommonLinkAdrReqVerifyParams+0x6c>
        else if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8010f52:	f8dc 6010 	ldr.w	r6, [ip, #16]
 8010f56:	9600      	str	r6, [sp, #0]
 8010f58:	f04f 0b00 	mov.w	fp, #0
 8010f5c:	f8dc 6018 	ldr.w	r6, [ip, #24]
 8010f60:	9601      	str	r6, [sp, #4]
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8010f62:	46d8      	mov	r8, fp
 8010f64:	f8cd a00c 	str.w	sl, [sp, #12]
 8010f68:	462f      	mov	r7, r5
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 8010f6a:	9e00      	ldr	r6, [sp, #0]
 8010f6c:	f8cd 8008 	str.w	r8, [sp, #8]
 8010f70:	fa5f f58b 	uxtb.w	r5, fp
 8010f74:	f836 9015 	ldrh.w	r9, [r6, r5, lsl #1]
 8010f78:	9d01      	ldr	r5, [sp, #4]
 8010f7a:	eb08 0648 	add.w	r6, r8, r8, lsl #1
 8010f7e:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 8010f82:	2500      	movs	r5, #0
 8010f84:	e003      	b.n	8010f8e <RegionCommonLinkAdrReqVerifyParams+0xea>
        for( uint8_t j = 0; j < 16; j++ )
 8010f86:	2d10      	cmp	r5, #16
 8010f88:	f106 060c 	add.w	r6, r6, #12
 8010f8c:	d011      	beq.n	8010fb2 <RegionCommonLinkAdrReqVerifyParams+0x10e>
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 8010f8e:	fa49 f805 	asr.w	r8, r9, r5
 8010f92:	f018 0f01 	tst.w	r8, #1
 8010f96:	f105 0501 	add.w	r5, r5, #1
 8010f9a:	d0f4      	beq.n	8010f86 <RegionCommonLinkAdrReqVerifyParams+0xe2>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 8010f9c:	f896 8008 	ldrb.w	r8, [r6, #8]
    if( ( value >= min ) && ( value <= max ) )
 8010fa0:	f008 0a0f 	and.w	sl, r8, #15
 8010fa4:	45d6      	cmp	lr, sl
 8010fa6:	dbee      	blt.n	8010f86 <RegionCommonLinkAdrReqVerifyParams+0xe2>
 8010fa8:	ebbe 1f18 	cmp.w	lr, r8, lsr #4
 8010fac:	dceb      	bgt.n	8010f86 <RegionCommonLinkAdrReqVerifyParams+0xe2>
 8010fae:	463d      	mov	r5, r7
 8010fb0:	e78c      	b.n	8010ecc <RegionCommonLinkAdrReqVerifyParams+0x28>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8010fb2:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8010fb6:	9d03      	ldr	r5, [sp, #12]
 8010fb8:	f108 0810 	add.w	r8, r8, #16
 8010fbc:	fa5f f888 	uxtb.w	r8, r8
 8010fc0:	4545      	cmp	r5, r8
 8010fc2:	f10b 0b01 	add.w	fp, fp, #1
 8010fc6:	d8d0      	bhi.n	8010f6a <RegionCommonLinkAdrReqVerifyParams+0xc6>
 8010fc8:	463d      	mov	r5, r7
 8010fca:	e7a1      	b.n	8010f10 <RegionCommonLinkAdrReqVerifyParams+0x6c>

08010fcc <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 8010fcc:	4b02      	ldr	r3, [pc, #8]	@ (8010fd8 <RegionCommonComputeSymbolTimeLoRa+0xc>)
 8010fce:	fa03 f000 	lsl.w	r0, r3, r0
}
 8010fd2:	fbb0 f0f1 	udiv	r0, r0, r1
 8010fd6:	4770      	bx	lr
 8010fd8:	000f4240 	.word	0x000f4240

08010fdc <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
 8010fdc:	f44f 53fa 	mov.w	r3, #8000	@ 0x1f40
}
 8010fe0:	fbb3 f0f0 	udiv	r0, r3, r0
 8010fe4:	4770      	bx	lr
 8010fe6:	bf00      	nop

08010fe8 <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 8010fe8:	f44f 7c7a 	mov.w	ip, #1000	@ 0x3e8
 8010fec:	fb0c f202 	mul.w	r2, ip, r2
 8010ff0:	f1a1 0c04 	sub.w	ip, r1, #4
 8010ff4:	fb00 220c 	mla	r2, r0, ip, r2
 8010ff8:	0052      	lsls	r2, r2, #1
 8010ffa:	d007      	beq.n	801100c <RegionCommonComputeRxWindowParameters+0x24>
 8010ffc:	f100 3cff 	add.w	ip, r0, #4294967295
 8011000:	4462      	add	r2, ip
 8011002:	fbb2 f2f0 	udiv	r2, r2, r0
 8011006:	4291      	cmp	r1, r2
 8011008:	bf38      	it	cc
 801100a:	4611      	movcc	r1, r2
 801100c:	9a00      	ldr	r2, [sp, #0]
 801100e:	6011      	str	r1, [r2, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 8011010:	fb00 f101 	mul.w	r1, r0, r1
 8011014:	0080      	lsls	r0, r0, #2
 8011016:	b111      	cbz	r1, 801101e <RegionCommonComputeRxWindowParameters+0x36>
 8011018:	3101      	adds	r1, #1
 801101a:	eba0 0051 	sub.w	r0, r0, r1, lsr #1
 801101e:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8011022:	fb02 0313 	mls	r3, r2, r3, r0
 8011026:	2b00      	cmp	r3, #0
 8011028:	4a08      	ldr	r2, [pc, #32]	@ (801104c <RegionCommonComputeRxWindowParameters+0x64>)
 801102a:	dd07      	ble.n	801103c <RegionCommonComputeRxWindowParameters+0x54>
 801102c:	f203 33e7 	addw	r3, r3, #999	@ 0x3e7
 8011030:	fba2 2303 	umull	r2, r3, r2, r3
 8011034:	9a01      	ldr	r2, [sp, #4]
 8011036:	099b      	lsrs	r3, r3, #6
 8011038:	6013      	str	r3, [r2, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 801103a:	4770      	bx	lr
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 801103c:	17d9      	asrs	r1, r3, #31
 801103e:	fb82 2303 	smull	r2, r3, r2, r3
 8011042:	9a01      	ldr	r2, [sp, #4]
 8011044:	ebc1 13a3 	rsb	r3, r1, r3, asr #6
 8011048:	6013      	str	r3, [r2, #0]
}
 801104a:	4770      	bx	lr
 801104c:	10624dd3 	.word	0x10624dd3

08011050 <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 8011050:	b538      	push	{r3, r4, r5, lr}
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8011052:	0040      	lsls	r0, r0, #1
{
 8011054:	4614      	mov	r4, r2
 8011056:	460d      	mov	r5, r1
    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8011058:	f7ef fbb8 	bl	80007cc <__aeabi_ui2f>
 801105c:	4601      	mov	r1, r0
 801105e:	4628      	mov	r0, r5
 8011060:	f7ef fb02 	bl	8000668 <__aeabi_fsub>
 8011064:	4621      	mov	r1, r4
 8011066:	f7ef faff 	bl	8000668 <__aeabi_fsub>
 801106a:	f7ef f9f1 	bl	8000450 <__aeabi_f2d>
 801106e:	f005 fadb 	bl	8016628 <floor>
 8011072:	f7ef facd 	bl	8000610 <__aeabi_d2iz>

    return phyTxPower;
}
 8011076:	b240      	sxtb	r0, r0
 8011078:	bd38      	pop	{r3, r4, r5, pc}
 801107a:	bf00      	nop

0801107c <RegionCommonCountNbOfEnabledChannels>:
    MW_LOG(TS_ON, VLEVEL_M, "RX_BC on freq %d Hz at DR %d\r\n", rxBeaconSetupParams->Frequency, rxBeaconSetupParams->BeaconDatarate );
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 801107c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8011080:	8a07      	ldrh	r7, [r0, #16]
{
 8011082:	4688      	mov	r8, r1
 8011084:	b083      	sub	sp, #12
 8011086:	4691      	mov	r9, r2
 8011088:	4619      	mov	r1, r3
    uint8_t nbChannelCount = 0;
 801108a:	463e      	mov	r6, r7
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 801108c:	2f00      	cmp	r7, #0
 801108e:	d03b      	beq.n	8011108 <RegionCommonCountNbOfEnabledChannels+0x8c>
 8011090:	2500      	movs	r5, #0
 8011092:	462c      	mov	r4, r5
    uint8_t nbChannelCount = 0;
 8011094:	462e      	mov	r6, r5
 8011096:	9501      	str	r5, [sp, #4]
    {
        for( uint8_t j = 0; j < 16; j++ )
        {
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 8011098:	fa5f fc85 	uxtb.w	ip, r5
 801109c:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80110a0:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80110a4:	0092      	lsls	r2, r2, #2
 80110a6:	2300      	movs	r3, #0
 80110a8:	6847      	ldr	r7, [r0, #4]
 80110aa:	f837 700c 	ldrh.w	r7, [r7, ip]
 80110ae:	411f      	asrs	r7, r3
 80110b0:	07ff      	lsls	r7, r7, #31
 80110b2:	d51c      	bpl.n	80110ee <RegionCommonCountNbOfEnabledChannels+0x72>
            {
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 80110b4:	6887      	ldr	r7, [r0, #8]
 80110b6:	eb07 0e02 	add.w	lr, r7, r2
 80110ba:	58bf      	ldr	r7, [r7, r2]
 80110bc:	b1bf      	cbz	r7, 80110ee <RegionCommonCountNbOfEnabledChannels+0x72>
                { // Check if the channel is enabled
                    continue;
                }
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 80110be:	7807      	ldrb	r7, [r0, #0]
 80110c0:	b937      	cbnz	r7, 80110d0 <RegionCommonCountNbOfEnabledChannels+0x54>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 80110c2:	6947      	ldr	r7, [r0, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 80110c4:	b127      	cbz	r7, 80110d0 <RegionCommonCountNbOfEnabledChannels+0x54>
                {
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 80110c6:	f837 700c 	ldrh.w	r7, [r7, ip]
 80110ca:	411f      	asrs	r7, r3
 80110cc:	07ff      	lsls	r7, r7, #31
 80110ce:	d50e      	bpl.n	80110ee <RegionCommonCountNbOfEnabledChannels+0x72>
                    {
                        continue;
                    }
                }
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 80110d0:	f89e 7008 	ldrb.w	r7, [lr, #8]
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 80110d4:	f990 a001 	ldrsb.w	sl, [r0, #1]
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 80110d8:	f347 0b03 	sbfx	fp, r7, #0, #4
    if( ( value >= min ) && ( value <= max ) )
 80110dc:	fa4f fb8b 	sxtb.w	fp, fp
 80110e0:	45d3      	cmp	fp, sl
 80110e2:	dc04      	bgt.n	80110ee <RegionCommonCountNbOfEnabledChannels+0x72>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 80110e4:	f347 1703 	sbfx	r7, r7, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 80110e8:	b27f      	sxtb	r7, r7
 80110ea:	4557      	cmp	r7, sl
 80110ec:	da12      	bge.n	8011114 <RegionCommonCountNbOfEnabledChannels+0x98>
        for( uint8_t j = 0; j < 16; j++ )
 80110ee:	3301      	adds	r3, #1
 80110f0:	2b10      	cmp	r3, #16
 80110f2:	f102 020c 	add.w	r2, r2, #12
 80110f6:	d1d7      	bne.n	80110a8 <RegionCommonCountNbOfEnabledChannels+0x2c>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 80110f8:	8a03      	ldrh	r3, [r0, #16]
 80110fa:	3410      	adds	r4, #16
 80110fc:	b2e4      	uxtb	r4, r4
 80110fe:	42a3      	cmp	r3, r4
 8011100:	f105 0501 	add.w	r5, r5, #1
 8011104:	d8c8      	bhi.n	8011098 <RegionCommonCountNbOfEnabledChannels+0x1c>
 8011106:	9f01      	ldr	r7, [sp, #4]
                }
                enabledChannels[nbChannelCount++] = i + j;
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 8011108:	f889 6000 	strb.w	r6, [r9]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 801110c:	700f      	strb	r7, [r1, #0]
}
 801110e:	b003      	add	sp, #12
 8011110:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 8011114:	f89e 7009 	ldrb.w	r7, [lr, #9]
 8011118:	eb07 0e47 	add.w	lr, r7, r7, lsl #1
 801111c:	68c7      	ldr	r7, [r0, #12]
 801111e:	eb07 07ce 	add.w	r7, r7, lr, lsl #3
 8011122:	7d3f      	ldrb	r7, [r7, #20]
 8011124:	b137      	cbz	r7, 8011134 <RegionCommonCountNbOfEnabledChannels+0xb8>
                enabledChannels[nbChannelCount++] = i + j;
 8011126:	1c77      	adds	r7, r6, #1
 8011128:	eb04 0e03 	add.w	lr, r4, r3
 801112c:	f808 e006 	strb.w	lr, [r8, r6]
 8011130:	b2fe      	uxtb	r6, r7
 8011132:	e7dc      	b.n	80110ee <RegionCommonCountNbOfEnabledChannels+0x72>
                    nbRestrictedChannelsCount++;
 8011134:	9f01      	ldr	r7, [sp, #4]
 8011136:	3701      	adds	r7, #1
 8011138:	b2ff      	uxtb	r7, r7
 801113a:	9701      	str	r7, [sp, #4]
                    continue;
 801113c:	e7d7      	b.n	80110ee <RegionCommonCountNbOfEnabledChannels+0x72>
 801113e:	bf00      	nop

08011140 <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 8011140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011144:	b084      	sub	sp, #16
 8011146:	4604      	mov	r4, r0
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8011148:	6840      	ldr	r0, [r0, #4]
{
 801114a:	f8dd 8030 	ldr.w	r8, [sp, #48]	@ 0x30
 801114e:	f8dd 9034 	ldr.w	r9, [sp, #52]	@ 0x34
 8011152:	461d      	mov	r5, r3
 8011154:	460f      	mov	r7, r1
 8011156:	4616      	mov	r6, r2
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8011158:	f004 fbba 	bl	80158d0 <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 801115c:	6823      	ldr	r3, [r4, #0]
 801115e:	1a1b      	subs	r3, r3, r0
 8011160:	f8c9 3000 	str.w	r3, [r9]
    *nbRestrictedChannels = 1;
 8011164:	2301      	movs	r3, #1
 8011166:	f888 3000 	strb.w	r3, [r8]
    *nbEnabledChannels = 0;
 801116a:	2300      	movs	r3, #0
 801116c:	702b      	strb	r3, [r5, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 801116e:	6863      	ldr	r3, [r4, #4]
 8011170:	b15b      	cbz	r3, 801118a <RegionCommonIdentifyChannels+0x4a>
 8011172:	6823      	ldr	r3, [r4, #0]
 8011174:	4283      	cmp	r3, r0
 8011176:	d908      	bls.n	801118a <RegionCommonIdentifyChannels+0x4a>
    if( *nbEnabledChannels > 0 )
    {
        *nextTxDelay = 0;
        return LORAMAC_STATUS_OK;
    }
    else if( *nbRestrictedChannels > 0 )
 8011178:	f898 3000 	ldrb.w	r3, [r8]
    {
        return LORAMAC_STATUS_DUTYCYCLE_RESTRICTED;
 801117c:	2b00      	cmp	r3, #0
 801117e:	bf0c      	ite	eq
 8011180:	200c      	moveq	r0, #12
 8011182:	200b      	movne	r0, #11
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 8011184:	b004      	add	sp, #16
 8011186:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        *aggregatedTimeOff = 0;
 801118a:	f04f 0a00 	mov.w	sl, #0
 801118e:	f8c7 a000 	str.w	sl, [r7]
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8011192:	69e3      	ldr	r3, [r4, #28]
 8011194:	f104 020c 	add.w	r2, r4, #12
 8011198:	e892 0003 	ldmia.w	r2, {r0, r1}
 801119c:	68df      	ldr	r7, [r3, #12]
 801119e:	781a      	ldrb	r2, [r3, #0]
 80111a0:	69a3      	ldr	r3, [r4, #24]
 80111a2:	9303      	str	r3, [sp, #12]
 80111a4:	ab01      	add	r3, sp, #4
 80111a6:	f894 c014 	ldrb.w	ip, [r4, #20]
 80111aa:	e883 0003 	stmia.w	r3, {r0, r1}
 80111ae:	f8cd c000 	str.w	ip, [sp]
 80111b2:	7a23      	ldrb	r3, [r4, #8]
 80111b4:	4639      	mov	r1, r7
 80111b6:	4610      	mov	r0, r2
 80111b8:	7a62      	ldrb	r2, [r4, #9]
 80111ba:	f7ff fd23 	bl	8010c04 <RegionCommonUpdateBandTimeOff>
        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 80111be:	4643      	mov	r3, r8
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 80111c0:	f8c9 0000 	str.w	r0, [r9]
        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 80111c4:	4631      	mov	r1, r6
 80111c6:	69e0      	ldr	r0, [r4, #28]
 80111c8:	462a      	mov	r2, r5
 80111ca:	f7ff ff57 	bl	801107c <RegionCommonCountNbOfEnabledChannels>
    if( *nbEnabledChannels > 0 )
 80111ce:	782b      	ldrb	r3, [r5, #0]
 80111d0:	2b00      	cmp	r3, #0
 80111d2:	d0d1      	beq.n	8011178 <RegionCommonIdentifyChannels+0x38>
        return LORAMAC_STATUS_OK;
 80111d4:	4650      	mov	r0, sl
        *nextTxDelay = 0;
 80111d6:	f8c9 a000 	str.w	sl, [r9]
}
 80111da:	b004      	add	sp, #16
 80111dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080111e0 <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 80111e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80111e4:	4686      	mov	lr, r0
    int8_t drLocal = params->CurrentDr;
 80111e6:	f990 0000 	ldrsb.w	r0, [r0]

    if( params->CurrentDr == params->MinDr )
 80111ea:	f99e 4002 	ldrsb.w	r4, [lr, #2]
 80111ee:	4284      	cmp	r4, r0
 80111f0:	d02e      	beq.n	8011250 <RegionCommonGetNextLowerTxDr+0x70>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 80111f2:	3801      	subs	r0, #1
 80111f4:	b240      	sxtb	r0, r0
        } while( ( drLocal != params->MinDr ) &&
 80111f6:	4284      	cmp	r4, r0
 80111f8:	d02a      	beq.n	8011250 <RegionCommonGetNextLowerTxDr+0x70>
    if( ( value >= min ) && ( value <= max ) )
 80111fa:	dcfa      	bgt.n	80111f2 <RegionCommonGetNextLowerTxDr+0x12>
 80111fc:	f99e 3001 	ldrsb.w	r3, [lr, #1]
 8011200:	4283      	cmp	r3, r0
 8011202:	dbf6      	blt.n	80111f2 <RegionCommonGetNextLowerTxDr+0x12>
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 8011204:	f89e 7003 	ldrb.w	r7, [lr, #3]
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8011208:	2f00      	cmp	r7, #0
 801120a:	d0f2      	beq.n	80111f2 <RegionCommonGetNextLowerTxDr+0x12>
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 801120c:	2600      	movs	r6, #0
 801120e:	f8de 9004 	ldr.w	r9, [lr, #4]
 8011212:	f8de 8008 	ldr.w	r8, [lr, #8]
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8011216:	4635      	mov	r5, r6
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 8011218:	b2f3      	uxtb	r3, r6
 801121a:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 801121e:	f839 c013 	ldrh.w	ip, [r9, r3, lsl #1]
 8011222:	eb08 0181 	add.w	r1, r8, r1, lsl #2
 8011226:	2200      	movs	r2, #0
 8011228:	e003      	b.n	8011232 <RegionCommonGetNextLowerTxDr+0x52>
        for( uint8_t j = 0; j < 16; j++ )
 801122a:	2a10      	cmp	r2, #16
 801122c:	f101 010c 	add.w	r1, r1, #12
 8011230:	d010      	beq.n	8011254 <RegionCommonGetNextLowerTxDr+0x74>
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 8011232:	fa4c f302 	asr.w	r3, ip, r2
 8011236:	f013 0f01 	tst.w	r3, #1
 801123a:	f102 0201 	add.w	r2, r2, #1
 801123e:	d0f4      	beq.n	801122a <RegionCommonGetNextLowerTxDr+0x4a>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 8011240:	7a0b      	ldrb	r3, [r1, #8]
    if( ( value >= min ) && ( value <= max ) )
 8011242:	f003 0a0f 	and.w	sl, r3, #15
 8011246:	4550      	cmp	r0, sl
 8011248:	dbef      	blt.n	801122a <RegionCommonGetNextLowerTxDr+0x4a>
 801124a:	ebb0 1f13 	cmp.w	r0, r3, lsr #4
 801124e:	dcec      	bgt.n	801122a <RegionCommonGetNextLowerTxDr+0x4a>

        return drLocal;
    }
}
 8011250:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8011254:	3510      	adds	r5, #16
 8011256:	b2ed      	uxtb	r5, r5
 8011258:	42af      	cmp	r7, r5
 801125a:	f106 0601 	add.w	r6, r6, #1
 801125e:	d8db      	bhi.n	8011218 <RegionCommonGetNextLowerTxDr+0x38>
 8011260:	e7c7      	b.n	80111f2 <RegionCommonGetNextLowerTxDr+0x12>
 8011262:	bf00      	nop

08011264 <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
}
 8011264:	4288      	cmp	r0, r1
 8011266:	bfb8      	it	lt
 8011268:	4608      	movlt	r0, r1
 801126a:	4770      	bx	lr

0801126c <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 801126c:	4b06      	ldr	r3, [pc, #24]	@ (8011288 <RegionCommonGetBandwidth+0x1c>)
 801126e:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8011272:	4298      	cmp	r0, r3
 8011274:	d006      	beq.n	8011284 <RegionCommonGetBandwidth+0x18>
 8011276:	4b05      	ldr	r3, [pc, #20]	@ (801128c <RegionCommonGetBandwidth+0x20>)
 8011278:	1ac0      	subs	r0, r0, r3
 801127a:	fab0 f080 	clz	r0, r0
 801127e:	0940      	lsrs	r0, r0, #5
 8011280:	0040      	lsls	r0, r0, #1
 8011282:	4770      	bx	lr
 8011284:	2001      	movs	r0, #1
        case 250000:
            return 1;
        case 500000:
            return 2;
    }
}
 8011286:	4770      	bx	lr
 8011288:	0003d090 	.word	0x0003d090
 801128c:	0007a120 	.word	0x0007a120

08011290 <RegionCommonRxConfigPrint>:

void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 8011290:	b510      	push	{r4, lr}
    if ( rxSlot < RX_SLOT_NONE )
 8011292:	2805      	cmp	r0, #5
{
 8011294:	b084      	sub	sp, #16
    if ( rxSlot < RX_SLOT_NONE )
 8011296:	d80d      	bhi.n	80112b4 <RegionCommonRxConfigPrint+0x24>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", EventRXSlotStrings[rxSlot], frequency, dr );
 8011298:	4c0b      	ldr	r4, [pc, #44]	@ (80112c8 <RegionCommonRxConfigPrint+0x38>)
 801129a:	4b0c      	ldr	r3, [pc, #48]	@ (80112cc <RegionCommonRxConfigPrint+0x3c>)
 801129c:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 80112a0:	9000      	str	r0, [sp, #0]
 80112a2:	e9cd 1201 	strd	r1, r2, [sp, #4]
 80112a6:	2002      	movs	r0, #2
 80112a8:	2201      	movs	r2, #1
 80112aa:	2100      	movs	r1, #0
 80112ac:	f004 fba2 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 80112b0:	b004      	add	sp, #16
 80112b2:	bd10      	pop	{r4, pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 80112b4:	e9cd 1200 	strd	r1, r2, [sp]
 80112b8:	4b05      	ldr	r3, [pc, #20]	@ (80112d0 <RegionCommonRxConfigPrint+0x40>)
 80112ba:	2201      	movs	r2, #1
 80112bc:	2100      	movs	r1, #0
 80112be:	2002      	movs	r0, #2
 80112c0:	f004 fb98 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 80112c4:	b004      	add	sp, #16
 80112c6:	bd10      	pop	{r4, pc}
 80112c8:	08017568 	.word	0x08017568
 80112cc:	080174f0 	.word	0x080174f0
 80112d0:	08017510 	.word	0x08017510

080112d4 <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 80112d4:	b500      	push	{lr}
 80112d6:	b083      	sub	sp, #12
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 80112d8:	e9cd 0100 	strd	r0, r1, [sp]
 80112dc:	4b04      	ldr	r3, [pc, #16]	@ (80112f0 <RegionCommonTxConfigPrint+0x1c>)
 80112de:	2201      	movs	r2, #1
 80112e0:	2100      	movs	r1, #0
 80112e2:	2002      	movs	r0, #2
 80112e4:	f004 fb86 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
}
 80112e8:	b003      	add	sp, #12
 80112ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80112ee:	bf00      	nop
 80112f0:	0801752c 	.word	0x0801752c

080112f4 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 80112f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    int8_t phyDr = DataratesEU868[datarate];
 80112f6:	4b15      	ldr	r3, [pc, #84]	@ (801134c <GetTimeOnAir+0x58>)
{
 80112f8:	460c      	mov	r4, r1
 80112fa:	b085      	sub	sp, #20
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 80112fc:	4914      	ldr	r1, [pc, #80]	@ (8011350 <GetTimeOnAir+0x5c>)
    int8_t phyDr = DataratesEU868[datarate];
 80112fe:	561e      	ldrsb	r6, [r3, r0]
{
 8011300:	4605      	mov	r5, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8011302:	f7ff ffb3 	bl	801126c <RegionCommonGetBandwidth>
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 8011306:	4b13      	ldr	r3, [pc, #76]	@ (8011354 <GetTimeOnAir+0x60>)
 8011308:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    if( datarate == DR_7 )
 801130a:	2d07      	cmp	r5, #7
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 801130c:	4601      	mov	r1, r0
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 801130e:	461f      	mov	r7, r3
 8011310:	b2e4      	uxtb	r4, r4
    if( datarate == DR_7 )
 8011312:	d00b      	beq.n	801132c <GetTimeOnAir+0x38>
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8011314:	2301      	movs	r3, #1
 8011316:	2208      	movs	r2, #8
 8011318:	2000      	movs	r0, #0
 801131a:	e9cd 2000 	strd	r2, r0, [sp]
 801131e:	e9cd 4302 	strd	r4, r3, [sp, #8]
 8011322:	4632      	mov	r2, r6
 8011324:	4618      	mov	r0, r3
 8011326:	47b8      	blx	r7
    }
    return timeOnAir;
}
 8011328:	b005      	add	sp, #20
 801132a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 801132c:	2300      	movs	r3, #0
 801132e:	9402      	str	r4, [sp, #8]
 8011330:	2005      	movs	r0, #5
 8011332:	2401      	movs	r4, #1
 8011334:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8011338:	9000      	str	r0, [sp, #0]
 801133a:	fb06 f202 	mul.w	r2, r6, r2
 801133e:	9301      	str	r3, [sp, #4]
 8011340:	4618      	mov	r0, r3
 8011342:	9403      	str	r4, [sp, #12]
 8011344:	47b8      	blx	r7
}
 8011346:	b005      	add	sp, #20
 8011348:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801134a:	bf00      	nop
 801134c:	080175b0 	.word	0x080175b0
 8011350:	08017590 	.word	0x08017590
 8011354:	08017658 	.word	0x08017658

08011358 <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 8011358:	b500      	push	{lr}
    PhyParam_t phyParam = { 0 };

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 801135a:	7803      	ldrb	r3, [r0, #0]
{
 801135c:	b085      	sub	sp, #20
    PhyParam_t phyParam = { 0 };
 801135e:	2200      	movs	r2, #0
    switch( getPhy->Attribute )
 8011360:	3b0b      	subs	r3, #11
    PhyParam_t phyParam = { 0 };
 8011362:	9200      	str	r2, [sp, #0]
    switch( getPhy->Attribute )
 8011364:	2b2e      	cmp	r3, #46	@ 0x2e
 8011366:	d81b      	bhi.n	80113a0 <RegionEU868GetPhyParam+0x48>
 8011368:	e8df f003 	tbb	[pc, r3]
 801136c:	3a40462d 	.word	0x3a40462d
 8011370:	4e525637 	.word	0x4e525637
 8011374:	5a6b6367 	.word	0x5a6b6367
 8011378:	6f1a181a 	.word	0x6f1a181a
 801137c:	1a929621 	.word	0x1a929621
 8011380:	758b8e1a 	.word	0x758b8e1a
 8011384:	1a1a1a1a 	.word	0x1a1a1a1a
 8011388:	1a1a1a1a 	.word	0x1a1a1a1a
 801138c:	1a1a1a1a 	.word	0x1a1a1a1a
 8011390:	1e49181a 	.word	0x1e49181a
 8011394:	1e181a1a 	.word	0x1e181a1a
 8011398:	271a      	.short	0x271a
 801139a:	30          	.byte	0x30
 801139b:	00          	.byte	0x00
            phyParam.Value = REGION_COMMON_DEFAULT_RX1_DR_OFFSET;
            break;
        }
        case PHY_DEF_RX2_FREQUENCY:
        {
            phyParam.Value = EU868_RX_WND_2_FREQ;
 801139c:	4b40      	ldr	r3, [pc, #256]	@ (80114a0 <RegionEU868GetPhyParam+0x148>)
 801139e:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
}
 80113a0:	9800      	ldr	r0, [sp, #0]
 80113a2:	b005      	add	sp, #20
 80113a4:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 80113a8:	2303      	movs	r3, #3
 80113aa:	9300      	str	r3, [sp, #0]
            break;
 80113ac:	e7f8      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 80113ae:	4b3d      	ldr	r3, [pc, #244]	@ (80114a4 <RegionEU868GetPhyParam+0x14c>)
 80113b0:	681b      	ldr	r3, [r3, #0]
 80113b2:	f203 438c 	addw	r3, r3, #1164	@ 0x48c
 80113b6:	9300      	str	r3, [sp, #0]
            break;
 80113b8:	e7f2      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 80113ba:	f990 3001 	ldrsb.w	r3, [r0, #1]
 80113be:	4a3a      	ldr	r2, [pc, #232]	@ (80114a8 <RegionEU868GetPhyParam+0x150>)
 80113c0:	5cd3      	ldrb	r3, [r2, r3]
 80113c2:	9300      	str	r3, [sp, #0]
            break;
 80113c4:	e7ec      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 80113c6:	2340      	movs	r3, #64	@ 0x40
 80113c8:	9300      	str	r3, [sp, #0]
            break;
 80113ca:	e7e9      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 80113cc:	4937      	ldr	r1, [pc, #220]	@ (80114ac <RegionEU868GetPhyParam+0x154>)
 80113ce:	f990 0001 	ldrsb.w	r0, [r0, #1]
 80113d2:	f7ff ff4b 	bl	801126c <RegionCommonGetBandwidth>
 80113d6:	9000      	str	r0, [sp, #0]
            break;
 80113d8:	e7e2      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 80113da:	2301      	movs	r3, #1
 80113dc:	9300      	str	r3, [sp, #0]
            break;
 80113de:	e7df      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 80113e0:	f990 3001 	ldrsb.w	r3, [r0, #1]
 80113e4:	4a32      	ldr	r2, [pc, #200]	@ (80114b0 <RegionEU868GetPhyParam+0x158>)
 80113e6:	5cd3      	ldrb	r3, [r2, r3]
 80113e8:	9300      	str	r3, [sp, #0]
            break;
 80113ea:	e7d9      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 80113ec:	f990 3001 	ldrsb.w	r3, [r0, #1]
 80113f0:	4a30      	ldr	r2, [pc, #192]	@ (80114b4 <RegionEU868GetPhyParam+0x15c>)
 80113f2:	5cd3      	ldrb	r3, [r2, r3]
 80113f4:	9300      	str	r3, [sp, #0]
            break;
 80113f6:	e7d3      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 80113f8:	2320      	movs	r3, #32
 80113fa:	9300      	str	r3, [sp, #0]
            break;
 80113fc:	e7d0      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 80113fe:	f240 2311 	movw	r3, #529	@ 0x211
 8011402:	f8ad 3000 	strh.w	r3, [sp]
            break;
 8011406:	e7cb      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 8011408:	f44f 63fa 	mov.w	r3, #2000	@ 0x7d0
 801140c:	9300      	str	r3, [sp, #0]
            break;
 801140e:	e7c7      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 8011410:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8011414:	9300      	str	r3, [sp, #0]
            break;
 8011416:	e7c3      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 8011418:	f640 33b8 	movw	r3, #3000	@ 0xbb8
 801141c:	9300      	str	r3, [sp, #0]
            break;
 801141e:	e7bf      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 8011420:	4825      	ldr	r0, [pc, #148]	@ (80114b8 <RegionEU868GetPhyParam+0x160>)
 8011422:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
 8011426:	f000 ff0d 	bl	8012244 <randr>
 801142a:	f500 60fa 	add.w	r0, r0, #2000	@ 0x7d0
 801142e:	9000      	str	r0, [sp, #0]
            break;
 8011430:	e7b6      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8011432:	f241 7370 	movw	r3, #6000	@ 0x1770
 8011436:	9300      	str	r3, [sp, #0]
            break;
 8011438:	e7b2      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 801143a:	f241 3388 	movw	r3, #5000	@ 0x1388
 801143e:	9300      	str	r3, [sp, #0]
            break;
 8011440:	e7ae      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8011442:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 8011446:	9300      	str	r3, [sp, #0]
            break;
 8011448:	e7aa      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 801144a:	4b16      	ldr	r3, [pc, #88]	@ (80114a4 <RegionEU868GetPhyParam+0x14c>)
 801144c:	681b      	ldr	r3, [r3, #0]
 801144e:	f503 6390 	add.w	r3, r3, #1152	@ 0x480
 8011452:	9300      	str	r3, [sp, #0]
            break;
 8011454:	e7a4      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8011456:	4b13      	ldr	r3, [pc, #76]	@ (80114a4 <RegionEU868GetPhyParam+0x14c>)
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8011458:	7840      	ldrb	r0, [r0, #1]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 801145a:	681b      	ldr	r3, [r3, #0]
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 801145c:	f88d 0004 	strb.w	r0, [sp, #4]
 8011460:	f04f 0c07 	mov.w	ip, #7
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8011464:	f503 6290 	add.w	r2, r3, #1152	@ 0x480
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8011468:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 801146c:	a801      	add	r0, sp, #4
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 801146e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8011472:	f88d c005 	strb.w	ip, [sp, #5]
 8011476:	f8ad 1006 	strh.w	r1, [sp, #6]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 801147a:	f7ff feb1 	bl	80111e0 <RegionCommonGetNextLowerTxDr>
 801147e:	9000      	str	r0, [sp, #0]
            break;
 8011480:	e78e      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 8011482:	4b0e      	ldr	r3, [pc, #56]	@ (80114bc <RegionEU868GetPhyParam+0x164>)
 8011484:	9300      	str	r3, [sp, #0]
            break;
 8011486:	e78b      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 8011488:	f04f 4383 	mov.w	r3, #1098907648	@ 0x41800000
 801148c:	9300      	str	r3, [sp, #0]
            break;
 801148e:	e787      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Channels = RegionNvmGroup2->Channels;
 8011490:	4b04      	ldr	r3, [pc, #16]	@ (80114a4 <RegionEU868GetPhyParam+0x14c>)
 8011492:	681b      	ldr	r3, [r3, #0]
 8011494:	9300      	str	r3, [sp, #0]
            break;
 8011496:	e783      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 8011498:	2310      	movs	r3, #16
 801149a:	9300      	str	r3, [sp, #0]
            break;
 801149c:	e780      	b.n	80113a0 <RegionEU868GetPhyParam+0x48>
 801149e:	bf00      	nop
 80114a0:	33d3e608 	.word	0x33d3e608
 80114a4:	2000141c 	.word	0x2000141c
 80114a8:	080175b0 	.word	0x080175b0
 80114ac:	08017590 	.word	0x08017590
 80114b0:	08017580 	.word	0x08017580
 80114b4:	08017588 	.word	0x08017588
 80114b8:	fffffc18 	.word	0xfffffc18
 80114bc:	4009999a 	.word	0x4009999a

080114c0 <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 80114c0:	b510      	push	{r4, lr}
#if defined( REGION_EU868 )
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 80114c2:	4a0c      	ldr	r2, [pc, #48]	@ (80114f4 <RegionEU868SetBandTxDone+0x34>)
 80114c4:	7803      	ldrb	r3, [r0, #0]
 80114c6:	6812      	ldr	r2, [r2, #0]
 80114c8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80114cc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80114d0:	4a09      	ldr	r2, [pc, #36]	@ (80114f8 <RegionEU868SetBandTxDone+0x38>)
 80114d2:	7a5b      	ldrb	r3, [r3, #9]
{
 80114d4:	4601      	mov	r1, r0
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 80114d6:	6810      	ldr	r0, [r2, #0]
 80114d8:	784a      	ldrb	r2, [r1, #1]
 80114da:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80114de:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 80114e2:	e9d1 3403 	ldrd	r3, r4, [r1, #12]
{
 80114e6:	b082      	sub	sp, #8
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 80114e8:	6889      	ldr	r1, [r1, #8]
 80114ea:	9400      	str	r4, [sp, #0]
 80114ec:	f7ff fb62 	bl	8010bb4 <RegionCommonSetBandTxDone>
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    RegionCommonSetBandTxDone( &RegionBands[RegionNvmGroup2->Channels[txDone->Channel].Band],
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_VERSION */
#endif /* REGION_EU868 */
}
 80114f0:	b002      	add	sp, #8
 80114f2:	bd10      	pop	{r4, pc}
 80114f4:	2000141c 	.word	0x2000141c
 80114f8:	20001420 	.word	0x20001420

080114fc <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 80114fc:	b530      	push	{r4, r5, lr}
 80114fe:	4604      	mov	r4, r0
 8011500:	b0a5      	sub	sp, #148	@ 0x94
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 8011502:	228e      	movs	r2, #142	@ 0x8e
 8011504:	2100      	movs	r1, #0
 8011506:	f10d 0002 	add.w	r0, sp, #2
 801150a:	f004 fddd 	bl	80160c8 <memset>
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 801150e:	7a22      	ldrb	r2, [r4, #8]
    Band_t bands[EU868_MAX_NB_BANDS] =
 8011510:	2364      	movs	r3, #100	@ 0x64
 8011512:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
 8011516:	200a      	movs	r0, #10
    switch( params->Type )
 8011518:	2a01      	cmp	r2, #1
    Band_t bands[EU868_MAX_NB_BANDS] =
 801151a:	f8ad 3000 	strh.w	r3, [sp]
 801151e:	f8ad 3018 	strh.w	r3, [sp, #24]
 8011522:	f8ad 1030 	strh.w	r1, [sp, #48]	@ 0x30
 8011526:	f8ad 0048 	strh.w	r0, [sp, #72]	@ 0x48
 801152a:	f8ad 3060 	strh.w	r3, [sp, #96]	@ 0x60
 801152e:	f8ad 1078 	strh.w	r1, [sp, #120]	@ 0x78
    switch( params->Type )
 8011532:	d004      	beq.n	801153e <RegionEU868InitDefaults+0x42>
 8011534:	2a02      	cmp	r2, #2
 8011536:	d03e      	beq.n	80115b6 <RegionEU868InitDefaults+0xba>
 8011538:	b17a      	cbz	r2, 801155a <RegionEU868InitDefaults+0x5e>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 801153a:	b025      	add	sp, #148	@ 0x94
 801153c:	bd30      	pop	{r4, r5, pc}
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 801153e:	4923      	ldr	r1, [pc, #140]	@ (80115cc <RegionEU868InitDefaults+0xd0>)
 8011540:	6808      	ldr	r0, [r1, #0]
 8011542:	2300      	movs	r3, #0
 8011544:	6043      	str	r3, [r0, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 8011546:	6103      	str	r3, [r0, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 8011548:	61c3      	str	r3, [r0, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 801154a:	f200 418c 	addw	r1, r0, #1164	@ 0x48c
 801154e:	f500 6090 	add.w	r0, r0, #1152	@ 0x480
 8011552:	f7ff fb05 	bl	8010b60 <RegionCommonChanMaskCopy>
}
 8011556:	b025      	add	sp, #148	@ 0x94
 8011558:	bd30      	pop	{r4, r5, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 801155a:	6820      	ldr	r0, [r4, #0]
 801155c:	2800      	cmp	r0, #0
 801155e:	d0ec      	beq.n	801153a <RegionEU868InitDefaults+0x3e>
 8011560:	6863      	ldr	r3, [r4, #4]
 8011562:	2b00      	cmp	r3, #0
 8011564:	d0e9      	beq.n	801153a <RegionEU868InitDefaults+0x3e>
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 8011566:	4c19      	ldr	r4, [pc, #100]	@ (80115cc <RegionEU868InitDefaults+0xd0>)
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8011568:	4d19      	ldr	r5, [pc, #100]	@ (80115d0 <RegionEU868InitDefaults+0xd4>)
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 801156a:	6023      	str	r3, [r4, #0]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 801156c:	4669      	mov	r1, sp
 801156e:	2290      	movs	r2, #144	@ 0x90
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8011570:	6028      	str	r0, [r5, #0]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 8011572:	f000 fe87 	bl	8012284 <memcpy1>
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 8011576:	4b17      	ldr	r3, [pc, #92]	@ (80115d4 <RegionEU868InitDefaults+0xd8>)
 8011578:	6824      	ldr	r4, [r4, #0]
 801157a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801157e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 8011582:	f103 020c 	add.w	r2, r3, #12
 8011586:	ca07      	ldmia	r2, {r0, r1, r2}
 8011588:	f104 0c0c 	add.w	ip, r4, #12
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 801158c:	3318      	adds	r3, #24
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 801158e:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 8011592:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8011596:	f104 0318 	add.w	r3, r4, #24
 801159a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 801159e:	2307      	movs	r3, #7
 80115a0:	f8a4 348c 	strh.w	r3, [r4, #1164]	@ 0x48c
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80115a4:	2201      	movs	r2, #1
 80115a6:	f204 418c 	addw	r1, r4, #1164	@ 0x48c
 80115aa:	f504 6090 	add.w	r0, r4, #1152	@ 0x480
 80115ae:	f7ff fad7 	bl	8010b60 <RegionCommonChanMaskCopy>
}
 80115b2:	b025      	add	sp, #148	@ 0x94
 80115b4:	bd30      	pop	{r4, r5, pc}
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 80115b6:	4b05      	ldr	r3, [pc, #20]	@ (80115cc <RegionEU868InitDefaults+0xd0>)
 80115b8:	681b      	ldr	r3, [r3, #0]
 80115ba:	f8b3 2480 	ldrh.w	r2, [r3, #1152]	@ 0x480
 80115be:	f8b3 148c 	ldrh.w	r1, [r3, #1164]	@ 0x48c
 80115c2:	430a      	orrs	r2, r1
 80115c4:	f8a3 2480 	strh.w	r2, [r3, #1152]	@ 0x480
}
 80115c8:	b025      	add	sp, #148	@ 0x94
 80115ca:	bd30      	pop	{r4, r5, pc}
 80115cc:	2000141c 	.word	0x2000141c
 80115d0:	20001420 	.word	0x20001420
 80115d4:	080167e0 	.word	0x080167e0

080115d8 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 80115d8:	b510      	push	{r4, lr}
#if defined( REGION_EU868 )
    switch( phyAttribute )
 80115da:	290f      	cmp	r1, #15
 80115dc:	d809      	bhi.n	80115f2 <RegionEU868Verify+0x1a>
 80115de:	e8df f001 	tbb	[pc, r1]
 80115e2:	081e      	.short	0x081e
 80115e4:	0a080808 	.word	0x0a080808
 80115e8:	0a080a14 	.word	0x0a080a14
 80115ec:	0808080a 	.word	0x0808080a
 80115f0:	3c08      	.short	0x3c08
    return true;
 80115f2:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 80115f4:	bd10      	pop	{r4, pc}
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 80115f6:	2207      	movs	r2, #7
 80115f8:	2100      	movs	r1, #0
 80115fa:	f990 0000 	ldrsb.w	r0, [r0]
 80115fe:	f7ff fa27 	bl	8010a50 <RegionCommonValueInRange>
 8011602:	3800      	subs	r0, #0
 8011604:	bf18      	it	ne
 8011606:	2001      	movne	r0, #1
}
 8011608:	bd10      	pop	{r4, pc}
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 801160a:	2205      	movs	r2, #5
 801160c:	2100      	movs	r1, #0
 801160e:	f990 0000 	ldrsb.w	r0, [r0]
 8011612:	f7ff fa1d 	bl	8010a50 <RegionCommonValueInRange>
 8011616:	3800      	subs	r0, #0
 8011618:	bf18      	it	ne
 801161a:	2001      	movne	r0, #1
}
 801161c:	bd10      	pop	{r4, pc}
            return VerifyRfFreq( verify->Frequency, &band );
 801161e:	6804      	ldr	r4, [r0, #0]
    if( Radio.CheckRfFrequency( freq ) == false )
 8011620:	4b0f      	ldr	r3, [pc, #60]	@ (8011660 <RegionEU868Verify+0x88>)
 8011622:	4620      	mov	r0, r4
 8011624:	6a1b      	ldr	r3, [r3, #32]
 8011626:	4798      	blx	r3
 8011628:	2800      	cmp	r0, #0
 801162a:	d0e2      	beq.n	80115f2 <RegionEU868Verify+0x1a>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 801162c:	4b0d      	ldr	r3, [pc, #52]	@ (8011664 <RegionEU868Verify+0x8c>)
 801162e:	4a0e      	ldr	r2, [pc, #56]	@ (8011668 <RegionEU868Verify+0x90>)
 8011630:	4423      	add	r3, r4
 8011632:	4293      	cmp	r3, r2
 8011634:	d911      	bls.n	801165a <RegionEU868Verify+0x82>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 8011636:	4b0d      	ldr	r3, [pc, #52]	@ (801166c <RegionEU868Verify+0x94>)
 8011638:	4a0d      	ldr	r2, [pc, #52]	@ (8011670 <RegionEU868Verify+0x98>)
 801163a:	4423      	add	r3, r4
 801163c:	4293      	cmp	r3, r2
 801163e:	d90c      	bls.n	801165a <RegionEU868Verify+0x82>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 8011640:	4b0c      	ldr	r3, [pc, #48]	@ (8011674 <RegionEU868Verify+0x9c>)
 8011642:	4a0d      	ldr	r2, [pc, #52]	@ (8011678 <RegionEU868Verify+0xa0>)
 8011644:	4423      	add	r3, r4
 8011646:	4293      	cmp	r3, r2
 8011648:	d907      	bls.n	801165a <RegionEU868Verify+0x82>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 801164a:	480c      	ldr	r0, [pc, #48]	@ (801167c <RegionEU868Verify+0xa4>)
 801164c:	4b0c      	ldr	r3, [pc, #48]	@ (8011680 <RegionEU868Verify+0xa8>)
 801164e:	4420      	add	r0, r4
 8011650:	4298      	cmp	r0, r3
 8011652:	bf8c      	ite	hi
 8011654:	2000      	movhi	r0, #0
 8011656:	2001      	movls	r0, #1
}
 8011658:	bd10      	pop	{r4, pc}
    return true;
 801165a:	2001      	movs	r0, #1
}
 801165c:	bd10      	pop	{r4, pc}
 801165e:	bf00      	nop
 8011660:	08017658 	.word	0x08017658
 8011664:	cc8faa40 	.word	0xcc8faa40
 8011668:	00557300 	.word	0x00557300
 801166c:	cc38b0a0 	.word	0xcc38b0a0
 8011670:	0007a120 	.word	0x0007a120
 8011674:	cc2e0240 	.word	0xcc2e0240
 8011678:	0003d090 	.word	0x0003d090
 801167c:	cc296e60 	.word	0xcc296e60
 8011680:	000493e0 	.word	0x000493e0

08011684 <RegionEU868ApplyCFList>:

void RegionEU868ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8011684:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    // Setup default datarate range
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;

    // Size of the optional CF list
    if( applyCFList->Size != 16 )
 8011688:	7903      	ldrb	r3, [r0, #4]
{
 801168a:	b087      	sub	sp, #28
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 801168c:	2250      	movs	r2, #80	@ 0x50
    if( applyCFList->Size != 16 )
 801168e:	2b10      	cmp	r3, #16
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 8011690:	f88d 2010 	strb.w	r2, [sp, #16]
    if( applyCFList->Size != 16 )
 8011694:	d12e      	bne.n	80116f4 <RegionEU868ApplyCFList+0x70>
    {
        return;
    }

    // Last byte CFListType must be 0 to indicate the CFList contains a list of frequencies
    if( applyCFList->Payload[15] != 0 )
 8011696:	6803      	ldr	r3, [r0, #0]
 8011698:	7bdc      	ldrb	r4, [r3, #15]
 801169a:	4681      	mov	r9, r0
 801169c:	bb54      	cbnz	r4, 80116f4 <RegionEU868ApplyCFList+0x70>
 801169e:	f8df a17c 	ldr.w	sl, [pc, #380]	@ 801181c <RegionEU868ApplyCFList+0x198>
 80116a2:	f04f 0824 	mov.w	r8, #36	@ 0x24
 80116a6:	f04f 0b03 	mov.w	fp, #3
            // Initialize alternative frequency to 0
            newChannel.Rx1Frequency = 0;
        }
        else
        {
            newChannel.Frequency = 0;
 80116aa:	2600      	movs	r6, #0
 80116ac:	2700      	movs	r7, #0
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 80116ae:	f1bb 0f07 	cmp.w	fp, #7
 80116b2:	fa5f f18b 	uxtb.w	r1, fp
 80116b6:	d920      	bls.n	80116fa <RegionEU868ApplyCFList+0x76>
            newChannel.Frequency = 0;
 80116b8:	e9cd 6702 	strd	r6, r7, [sp, #8]
            newChannel.DrRange.Value = 0;
 80116bc:	2300      	movs	r3, #0
 80116be:	f88d 3010 	strb.w	r3, [sp, #16]
    {
        return false;
    }

    // Remove the channel from the list of channels
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 80116c2:	f8da 0000 	ldr.w	r0, [sl]
 80116c6:	eb0b 054b 	add.w	r5, fp, fp, lsl #1
 80116ca:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80116ce:	2300      	movs	r3, #0
 80116d0:	f840 3025 	str.w	r3, [r0, r5, lsl #2]
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80116d4:	f10b 0b01 	add.w	fp, fp, #1
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 80116d8:	e9c2 3301 	strd	r3, r3, [r2, #4]

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 80116dc:	f500 6090 	add.w	r0, r0, #1152	@ 0x480
 80116e0:	2210      	movs	r2, #16
 80116e2:	f7ff f9bf 	bl	8010a64 <RegionCommonChanDisable>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80116e6:	f1bb 0f10 	cmp.w	fp, #16
 80116ea:	f108 080c 	add.w	r8, r8, #12
 80116ee:	f104 0403 	add.w	r4, r4, #3
 80116f2:	d1dc      	bne.n	80116ae <RegionEU868ApplyCFList+0x2a>
}
 80116f4:	b007      	add	sp, #28
 80116f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 80116fa:	f8d9 2000 	ldr.w	r2, [r9]
 80116fe:	5d13      	ldrb	r3, [r2, r4]
 8011700:	9302      	str	r3, [sp, #8]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 8011702:	4422      	add	r2, r4
            newChannel.Frequency *= 100;
 8011704:	2064      	movs	r0, #100	@ 0x64
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 8011706:	7855      	ldrb	r5, [r2, #1]
 8011708:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 801170c:	9302      	str	r3, [sp, #8]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 801170e:	7892      	ldrb	r2, [r2, #2]
 8011710:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            newChannel.Frequency *= 100;
 8011714:	fb00 f303 	mul.w	r3, r0, r3
            newChannel.Rx1Frequency = 0;
 8011718:	2500      	movs	r5, #0
            newChannel.Frequency *= 100;
 801171a:	9302      	str	r3, [sp, #8]
            newChannel.Rx1Frequency = 0;
 801171c:	9503      	str	r5, [sp, #12]
        if( newChannel.Frequency != 0 )
 801171e:	2b00      	cmp	r3, #0
 8011720:	d0cf      	beq.n	80116c2 <RegionEU868ApplyCFList+0x3e>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8011722:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8011726:	f340 0003 	sbfx	r0, r0, #0, #4
 801172a:	4629      	mov	r1, r5
 801172c:	2207      	movs	r2, #7
 801172e:	b240      	sxtb	r0, r0
 8011730:	f7ff f98e 	bl	8010a50 <RegionCommonValueInRange>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8011734:	4629      	mov	r1, r5
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8011736:	4605      	mov	r5, r0
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8011738:	f89d 0010 	ldrb.w	r0, [sp, #16]
 801173c:	f340 1003 	sbfx	r0, r0, #4, #4
 8011740:	b240      	sxtb	r0, r0
 8011742:	2207      	movs	r2, #7
 8011744:	f7ff f984 	bl	8010a50 <RegionCommonValueInRange>
 8011748:	2800      	cmp	r0, #0
 801174a:	d054      	beq.n	80117f6 <RegionEU868ApplyCFList+0x172>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 801174c:	fab5 f585 	clz	r5, r5
 8011750:	096d      	lsrs	r5, r5, #5
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8011752:	f89d 3010 	ldrb.w	r3, [sp, #16]
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8011756:	9902      	ldr	r1, [sp, #8]
    if( Radio.CheckRfFrequency( freq ) == false )
 8011758:	4a31      	ldr	r2, [pc, #196]	@ (8011820 <RegionEU868ApplyCFList+0x19c>)
 801175a:	9101      	str	r1, [sp, #4]
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 801175c:	f343 0003 	sbfx	r0, r3, #0, #4
 8011760:	f343 1303 	sbfx	r3, r3, #4, #4
 8011764:	b240      	sxtb	r0, r0
 8011766:	b25b      	sxtb	r3, r3
        drInvalid = true;
 8011768:	4298      	cmp	r0, r3
 801176a:	bfc8      	it	gt
 801176c:	2501      	movgt	r5, #1
    if( Radio.CheckRfFrequency( freq ) == false )
 801176e:	6a12      	ldr	r2, [r2, #32]
 8011770:	4608      	mov	r0, r1
 8011772:	4790      	blx	r2
 8011774:	9901      	ldr	r1, [sp, #4]
 8011776:	2800      	cmp	r0, #0
 8011778:	d03f      	beq.n	80117fa <RegionEU868ApplyCFList+0x176>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 801177a:	4a2a      	ldr	r2, [pc, #168]	@ (8011824 <RegionEU868ApplyCFList+0x1a0>)
 801177c:	4b2a      	ldr	r3, [pc, #168]	@ (8011828 <RegionEU868ApplyCFList+0x1a4>)
 801177e:	188a      	adds	r2, r1, r2
 8011780:	429a      	cmp	r2, r3
 8011782:	d940      	bls.n	8011806 <RegionEU868ApplyCFList+0x182>
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 8011784:	4a29      	ldr	r2, [pc, #164]	@ (801182c <RegionEU868ApplyCFList+0x1a8>)
 8011786:	4b2a      	ldr	r3, [pc, #168]	@ (8011830 <RegionEU868ApplyCFList+0x1ac>)
 8011788:	188a      	adds	r2, r1, r2
 801178a:	429a      	cmp	r2, r3
 801178c:	d93d      	bls.n	801180a <RegionEU868ApplyCFList+0x186>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 801178e:	4b29      	ldr	r3, [pc, #164]	@ (8011834 <RegionEU868ApplyCFList+0x1b0>)
 8011790:	4a29      	ldr	r2, [pc, #164]	@ (8011838 <RegionEU868ApplyCFList+0x1b4>)
 8011792:	440b      	add	r3, r1
 8011794:	4293      	cmp	r3, r2
 8011796:	d93a      	bls.n	801180e <RegionEU868ApplyCFList+0x18a>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 8011798:	4b28      	ldr	r3, [pc, #160]	@ (801183c <RegionEU868ApplyCFList+0x1b8>)
 801179a:	4a29      	ldr	r2, [pc, #164]	@ (8011840 <RegionEU868ApplyCFList+0x1bc>)
 801179c:	440b      	add	r3, r1
 801179e:	4293      	cmp	r3, r2
 80117a0:	d937      	bls.n	8011812 <RegionEU868ApplyCFList+0x18e>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 80117a2:	4b28      	ldr	r3, [pc, #160]	@ (8011844 <RegionEU868ApplyCFList+0x1c0>)
 80117a4:	4a28      	ldr	r2, [pc, #160]	@ (8011848 <RegionEU868ApplyCFList+0x1c4>)
 80117a6:	440b      	add	r3, r1
 80117a8:	4293      	cmp	r3, r2
 80117aa:	d934      	bls.n	8011816 <RegionEU868ApplyCFList+0x192>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 80117ac:	4b27      	ldr	r3, [pc, #156]	@ (801184c <RegionEU868ApplyCFList+0x1c8>)
 80117ae:	4a28      	ldr	r2, [pc, #160]	@ (8011850 <RegionEU868ApplyCFList+0x1cc>)
 80117b0:	440b      	add	r3, r1
 80117b2:	4293      	cmp	r3, r2
 80117b4:	d821      	bhi.n	80117fa <RegionEU868ApplyCFList+0x176>
        *band = 4;
 80117b6:	2304      	movs	r3, #4
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 80117b8:	b9fd      	cbnz	r5, 80117fa <RegionEU868ApplyCFList+0x176>
    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 80117ba:	f8da 0000 	ldr.w	r0, [sl]
 80117be:	9301      	str	r3, [sp, #4]
 80117c0:	4440      	add	r0, r8
 80117c2:	220c      	movs	r2, #12
 80117c4:	a902      	add	r1, sp, #8
 80117c6:	f000 fd5d 	bl	8012284 <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 80117ca:	f8da 2000 	ldr.w	r2, [sl]
 80117ce:	9b01      	ldr	r3, [sp, #4]
 80117d0:	eb0b 014b 	add.w	r1, fp, fp, lsl #1
 80117d4:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80117d8:	3403      	adds	r4, #3
    RegionNvmGroup2->Channels[id].Band = band;
 80117da:	724b      	strb	r3, [r1, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 80117dc:	f8b2 1480 	ldrh.w	r1, [r2, #1152]	@ 0x480
 80117e0:	2301      	movs	r3, #1
 80117e2:	fa03 f30b 	lsl.w	r3, r3, fp
 80117e6:	430b      	orrs	r3, r1
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80117e8:	f108 080c 	add.w	r8, r8, #12
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 80117ec:	f8a2 3480 	strh.w	r3, [r2, #1152]	@ 0x480
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80117f0:	f10b 0b01 	add.w	fp, fp, #1
 80117f4:	e75b      	b.n	80116ae <RegionEU868ApplyCFList+0x2a>
        drInvalid = true;
 80117f6:	2501      	movs	r5, #1
 80117f8:	e7ab      	b.n	8011752 <RegionEU868ApplyCFList+0xce>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80117fa:	f10b 0b01 	add.w	fp, fp, #1
 80117fe:	f108 080c 	add.w	r8, r8, #12
 8011802:	3403      	adds	r4, #3
 8011804:	e753      	b.n	80116ae <RegionEU868ApplyCFList+0x2a>
        *band = 2;
 8011806:	2302      	movs	r3, #2
 8011808:	e7d6      	b.n	80117b8 <RegionEU868ApplyCFList+0x134>
        *band = 0;
 801180a:	2300      	movs	r3, #0
 801180c:	e7d4      	b.n	80117b8 <RegionEU868ApplyCFList+0x134>
        *band = 1;
 801180e:	2301      	movs	r3, #1
 8011810:	e7d2      	b.n	80117b8 <RegionEU868ApplyCFList+0x134>
        *band = 5;
 8011812:	2305      	movs	r3, #5
 8011814:	e7d0      	b.n	80117b8 <RegionEU868ApplyCFList+0x134>
        *band = 3;
 8011816:	2303      	movs	r3, #3
 8011818:	e7ce      	b.n	80117b8 <RegionEU868ApplyCFList+0x134>
 801181a:	bf00      	nop
 801181c:	2000141c 	.word	0x2000141c
 8011820:	08017658 	.word	0x08017658
 8011824:	cc8faa40 	.word	0xcc8faa40
 8011828:	001e847f 	.word	0x001e847f
 801182c:	cc7125c0 	.word	0xcc7125c0
 8011830:	002dc6c0 	.word	0x002dc6c0
 8011834:	cc435eff 	.word	0xcc435eff
 8011838:	000927bf 	.word	0x000927bf
 801183c:	cc38b0a0 	.word	0xcc38b0a0
 8011840:	0007a120 	.word	0x0007a120
 8011844:	cc2e0240 	.word	0xcc2e0240
 8011848:	0003d090 	.word	0x0003d090
 801184c:	cc296e60 	.word	0xcc296e60
 8011850:	000493e0 	.word	0x000493e0

08011854 <RegionEU868ChanMaskSet>:
{
 8011854:	b508      	push	{r3, lr}
    switch( chanMaskSet->ChannelsMaskType )
 8011856:	7902      	ldrb	r2, [r0, #4]
 8011858:	b162      	cbz	r2, 8011874 <RegionEU868ChanMaskSet+0x20>
 801185a:	2a01      	cmp	r2, #1
 801185c:	d108      	bne.n	8011870 <RegionEU868ChanMaskSet+0x1c>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 801185e:	4b0a      	ldr	r3, [pc, #40]	@ (8011888 <RegionEU868ChanMaskSet+0x34>)
 8011860:	6801      	ldr	r1, [r0, #0]
 8011862:	6818      	ldr	r0, [r3, #0]
 8011864:	f200 408c 	addw	r0, r0, #1164	@ 0x48c
 8011868:	f7ff f97a 	bl	8010b60 <RegionCommonChanMaskCopy>
    return true;
 801186c:	2001      	movs	r0, #1
}
 801186e:	bd08      	pop	{r3, pc}
    switch( chanMaskSet->ChannelsMaskType )
 8011870:	2000      	movs	r0, #0
}
 8011872:	bd08      	pop	{r3, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8011874:	4b04      	ldr	r3, [pc, #16]	@ (8011888 <RegionEU868ChanMaskSet+0x34>)
 8011876:	6801      	ldr	r1, [r0, #0]
 8011878:	6818      	ldr	r0, [r3, #0]
 801187a:	2201      	movs	r2, #1
 801187c:	f500 6090 	add.w	r0, r0, #1152	@ 0x480
 8011880:	f7ff f96e 	bl	8010b60 <RegionCommonChanMaskCopy>
            break;
 8011884:	e7f2      	b.n	801186c <RegionEU868ChanMaskSet+0x18>
 8011886:	bf00      	nop
 8011888:	2000141c 	.word	0x2000141c

0801188c <RegionEU868ComputeRxWindowParameters>:
{
 801188c:	b5f0      	push	{r4, r5, r6, r7, lr}
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 801188e:	2807      	cmp	r0, #7
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 8011890:	4d15      	ldr	r5, [pc, #84]	@ (80118e8 <RegionEU868ComputeRxWindowParameters+0x5c>)
{
 8011892:	461c      	mov	r4, r3
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 8011894:	bfa8      	it	ge
 8011896:	2007      	movge	r0, #7
 8011898:	7058      	strb	r0, [r3, #1]
{
 801189a:	b083      	sub	sp, #12
 801189c:	460e      	mov	r6, r1
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 801189e:	4629      	mov	r1, r5
{
 80118a0:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80118a2:	f7ff fce3 	bl	801126c <RegionCommonGetBandwidth>
    if( rxConfigParams->Datarate == DR_7 )
 80118a6:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80118aa:	70a0      	strb	r0, [r4, #2]
    if( rxConfigParams->Datarate == DR_7 )
 80118ac:	2b07      	cmp	r3, #7
 80118ae:	d016      	beq.n	80118de <RegionEU868ComputeRxWindowParameters+0x52>
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 80118b0:	4a0e      	ldr	r2, [pc, #56]	@ (80118ec <RegionEU868ComputeRxWindowParameters+0x60>)
 80118b2:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 80118b6:	5cd0      	ldrb	r0, [r2, r3]
 80118b8:	f7ff fb88 	bl	8010fcc <RegionCommonComputeSymbolTimeLoRa>
 80118bc:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 80118be:	4b0c      	ldr	r3, [pc, #48]	@ (80118f0 <RegionEU868ComputeRxWindowParameters+0x64>)
 80118c0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80118c2:	4798      	blx	r3
 80118c4:	4603      	mov	r3, r0
 80118c6:	4628      	mov	r0, r5
 80118c8:	f104 050c 	add.w	r5, r4, #12
 80118cc:	3408      	adds	r4, #8
 80118ce:	463a      	mov	r2, r7
 80118d0:	4631      	mov	r1, r6
 80118d2:	9501      	str	r5, [sp, #4]
 80118d4:	9400      	str	r4, [sp, #0]
 80118d6:	f7ff fb87 	bl	8010fe8 <RegionCommonComputeRxWindowParameters>
}
 80118da:	b003      	add	sp, #12
 80118dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 80118de:	2032      	movs	r0, #50	@ 0x32
 80118e0:	f7ff fb7c 	bl	8010fdc <RegionCommonComputeSymbolTimeFsk>
 80118e4:	4605      	mov	r5, r0
 80118e6:	e7ea      	b.n	80118be <RegionEU868ComputeRxWindowParameters+0x32>
 80118e8:	08017590 	.word	0x08017590
 80118ec:	080175b0 	.word	0x080175b0
 80118f0:	08017658 	.word	0x08017658

080118f4 <RegionEU868RxConfig>:
{
 80118f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if( Radio.GetStatus( ) != RF_IDLE )
 80118f8:	4f3a      	ldr	r7, [pc, #232]	@ (80119e4 <RegionEU868RxConfig+0xf0>)
    int8_t dr = rxConfig->Datarate;
 80118fa:	f990 6001 	ldrsb.w	r6, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 80118fe:	687b      	ldr	r3, [r7, #4]
    uint32_t frequency = rxConfig->Frequency;
 8011900:	f8d0 9004 	ldr.w	r9, [r0, #4]
{
 8011904:	b08c      	sub	sp, #48	@ 0x30
 8011906:	4604      	mov	r4, r0
 8011908:	4688      	mov	r8, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 801190a:	4798      	blx	r3
 801190c:	2800      	cmp	r0, #0
 801190e:	d161      	bne.n	80119d4 <RegionEU868RxConfig+0xe0>
    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8011910:	7ce3      	ldrb	r3, [r4, #19]
 8011912:	4605      	mov	r5, r0
 8011914:	b963      	cbnz	r3, 8011930 <RegionEU868RxConfig+0x3c>
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 8011916:	4b34      	ldr	r3, [pc, #208]	@ (80119e8 <RegionEU868RxConfig+0xf4>)
 8011918:	681a      	ldr	r2, [r3, #0]
 801191a:	7823      	ldrb	r3, [r4, #0]
 801191c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8011920:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 8011924:	009b      	lsls	r3, r3, #2
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 8011926:	f8d1 9004 	ldr.w	r9, [r1, #4]
 801192a:	f1b9 0f00 	cmp.w	r9, #0
 801192e:	d055      	beq.n	80119dc <RegionEU868RxConfig+0xe8>
    phyDr = DataratesEU868[dr];
 8011930:	4b2e      	ldr	r3, [pc, #184]	@ (80119ec <RegionEU868RxConfig+0xf8>)
    Radio.SetChannel( frequency );
 8011932:	4648      	mov	r0, r9
    phyDr = DataratesEU868[dr];
 8011934:	f913 a006 	ldrsb.w	sl, [r3, r6]
    Radio.SetChannel( frequency );
 8011938:	68fb      	ldr	r3, [r7, #12]
 801193a:	4798      	blx	r3
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 801193c:	69bb      	ldr	r3, [r7, #24]
 801193e:	930b      	str	r3, [sp, #44]	@ 0x2c
    if( dr == DR_7 )
 8011940:	2e07      	cmp	r6, #7
 8011942:	469c      	mov	ip, r3
 8011944:	d028      	beq.n	8011998 <RegionEU868RxConfig+0xa4>
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8011946:	2300      	movs	r3, #0
 8011948:	e9cd 3306 	strd	r3, r3, [sp, #24]
 801194c:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8011950:	2501      	movs	r5, #1
 8011952:	9303      	str	r3, [sp, #12]
 8011954:	9300      	str	r3, [sp, #0]
 8011956:	9508      	str	r5, [sp, #32]
 8011958:	7ca3      	ldrb	r3, [r4, #18]
 801195a:	9309      	str	r3, [sp, #36]	@ 0x24
 801195c:	8923      	ldrh	r3, [r4, #8]
 801195e:	9302      	str	r3, [sp, #8]
 8011960:	2308      	movs	r3, #8
 8011962:	9301      	str	r3, [sp, #4]
 8011964:	78a1      	ldrb	r1, [r4, #2]
 8011966:	462b      	mov	r3, r5
 8011968:	4652      	mov	r2, sl
 801196a:	4628      	mov	r0, r5
 801196c:	47e0      	blx	ip
    if( rxConfig->RepeaterSupport == true )
 801196e:	7c63      	ldrb	r3, [r4, #17]
 8011970:	2b00      	cmp	r3, #0
 8011972:	d02c      	beq.n	80119ce <RegionEU868RxConfig+0xda>
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 8011974:	4b1e      	ldr	r3, [pc, #120]	@ (80119f0 <RegionEU868RxConfig+0xfc>)
 8011976:	5d99      	ldrb	r1, [r3, r6]
    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8011978:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801197a:	310d      	adds	r1, #13
 801197c:	4628      	mov	r0, r5
 801197e:	b2c9      	uxtb	r1, r1
 8011980:	4798      	blx	r3
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 8011982:	7ce0      	ldrb	r0, [r4, #19]
 8011984:	4632      	mov	r2, r6
 8011986:	4649      	mov	r1, r9
 8011988:	f7ff fc82 	bl	8011290 <RegionCommonRxConfigPrint>
    return true;
 801198c:	2001      	movs	r0, #1
    *datarate = (uint8_t) dr;
 801198e:	f888 6000 	strb.w	r6, [r8]
}
 8011992:	b00c      	add	sp, #48	@ 0x30
 8011994:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 8011998:	2300      	movs	r3, #0
 801199a:	e9cd 3307 	strd	r3, r3, [sp, #28]
 801199e:	e9cd 3303 	strd	r3, r3, [sp, #12]
 80119a2:	9306      	str	r3, [sp, #24]
 80119a4:	7ca2      	ldrb	r2, [r4, #18]
 80119a6:	9209      	str	r2, [sp, #36]	@ 0x24
 80119a8:	8922      	ldrh	r2, [r4, #8]
 80119aa:	9202      	str	r2, [sp, #8]
 80119ac:	2101      	movs	r1, #1
 80119ae:	4a11      	ldr	r2, [pc, #68]	@ (80119f4 <RegionEU868RxConfig+0x100>)
 80119b0:	9200      	str	r2, [sp, #0]
 80119b2:	9105      	str	r1, [sp, #20]
 80119b4:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 80119b8:	2105      	movs	r1, #5
 80119ba:	9101      	str	r1, [sp, #4]
 80119bc:	4618      	mov	r0, r3
 80119be:	fb02 f20a 	mul.w	r2, r2, sl
 80119c2:	f24c 3150 	movw	r1, #50000	@ 0xc350
 80119c6:	47e0      	blx	ip
    if( rxConfig->RepeaterSupport == true )
 80119c8:	7c63      	ldrb	r3, [r4, #17]
 80119ca:	2b00      	cmp	r3, #0
 80119cc:	d1d2      	bne.n	8011974 <RegionEU868RxConfig+0x80>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 80119ce:	4b0a      	ldr	r3, [pc, #40]	@ (80119f8 <RegionEU868RxConfig+0x104>)
 80119d0:	5d99      	ldrb	r1, [r3, r6]
 80119d2:	e7d1      	b.n	8011978 <RegionEU868RxConfig+0x84>
        return false;
 80119d4:	2000      	movs	r0, #0
}
 80119d6:	b00c      	add	sp, #48	@ 0x30
 80119d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 80119dc:	f852 9003 	ldr.w	r9, [r2, r3]
 80119e0:	e7a6      	b.n	8011930 <RegionEU868RxConfig+0x3c>
 80119e2:	bf00      	nop
 80119e4:	08017658 	.word	0x08017658
 80119e8:	2000141c 	.word	0x2000141c
 80119ec:	080175b0 	.word	0x080175b0
 80119f0:	08017580 	.word	0x08017580
 80119f4:	00014585 	.word	0x00014585
 80119f8:	08017588 	.word	0x08017588

080119fc <RegionEU868TxConfig>:
{
 80119fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011a00:	4604      	mov	r4, r0
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 8011a02:	4842      	ldr	r0, [pc, #264]	@ (8011b0c <RegionEU868TxConfig+0x110>)
 8011a04:	f994 3001 	ldrsb.w	r3, [r4, #1]
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8011a08:	f8df a104 	ldr.w	sl, [pc, #260]	@ 8011b10 <RegionEU868TxConfig+0x114>
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 8011a0c:	56c5      	ldrsb	r5, [r0, r3]
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8011a0e:	4b41      	ldr	r3, [pc, #260]	@ (8011b14 <RegionEU868TxConfig+0x118>)
 8011a10:	f994 0002 	ldrsb.w	r0, [r4, #2]
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8011a14:	f8df 8100 	ldr.w	r8, [pc, #256]	@ 8011b18 <RegionEU868TxConfig+0x11c>
{
 8011a18:	460f      	mov	r7, r1
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8011a1a:	6819      	ldr	r1, [r3, #0]
 8011a1c:	7823      	ldrb	r3, [r4, #0]
{
 8011a1e:	4691      	mov	r9, r2
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8011a20:	f8da 2000 	ldr.w	r2, [sl]
 8011a24:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8011a28:	eb02 0283 	add.w	r2, r2, r3, lsl #2
{
 8011a2c:	b08d      	sub	sp, #52	@ 0x34
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8011a2e:	7a53      	ldrb	r3, [r2, #9]
 8011a30:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8011a34:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8011a38:	f991 1002 	ldrsb.w	r1, [r1, #2]
 8011a3c:	f7ff fc12 	bl	8011264 <RegionCommonLimitTxPower>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8011a40:	4936      	ldr	r1, [pc, #216]	@ (8011b1c <RegionEU868TxConfig+0x120>)
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8011a42:	4606      	mov	r6, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8011a44:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8011a48:	f7ff fc10 	bl	801126c <RegionCommonGetBandwidth>
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8011a4c:	6861      	ldr	r1, [r4, #4]
 8011a4e:	68a2      	ldr	r2, [r4, #8]
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8011a50:	4683      	mov	fp, r0
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8011a52:	4630      	mov	r0, r6
 8011a54:	f7ff fafc 	bl	8011050 <RegionCommonComputeTxPower>
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8011a58:	7823      	ldrb	r3, [r4, #0]
 8011a5a:	f8da 2000 	ldr.w	r2, [sl]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8011a5e:	900b      	str	r0, [sp, #44]	@ 0x2c
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8011a60:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8011a64:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8011a68:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8011a6c:	4798      	blx	r3
    if( txConfig->Datarate == DR_7 )
 8011a6e:	f994 3001 	ldrsb.w	r3, [r4, #1]
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 8011a72:	f8d8 201c 	ldr.w	r2, [r8, #28]
    if( txConfig->Datarate == DR_7 )
 8011a76:	990b      	ldr	r1, [sp, #44]	@ 0x2c
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 8011a78:	920a      	str	r2, [sp, #40]	@ 0x28
    if( txConfig->Datarate == DR_7 )
 8011a7a:	2b07      	cmp	r3, #7
 8011a7c:	4694      	mov	ip, r2
 8011a7e:	d02c      	beq.n	8011ada <RegionEU868TxConfig+0xde>
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 8011a80:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 8011a84:	2200      	movs	r2, #0
 8011a86:	9500      	str	r5, [sp, #0]
 8011a88:	9008      	str	r0, [sp, #32]
 8011a8a:	2501      	movs	r5, #1
 8011a8c:	2008      	movs	r0, #8
 8011a8e:	9002      	str	r0, [sp, #8]
 8011a90:	e9cd 2206 	strd	r2, r2, [sp, #24]
 8011a94:	465b      	mov	r3, fp
 8011a96:	9205      	str	r2, [sp, #20]
 8011a98:	9203      	str	r2, [sp, #12]
 8011a9a:	9504      	str	r5, [sp, #16]
 8011a9c:	9501      	str	r5, [sp, #4]
 8011a9e:	4628      	mov	r0, r5
 8011aa0:	47e0      	blx	ip
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 8011aa2:	7823      	ldrb	r3, [r4, #0]
 8011aa4:	f8da 2000 	ldr.w	r2, [sl]
 8011aa8:	f994 1001 	ldrsb.w	r1, [r4, #1]
 8011aac:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8011ab0:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8011ab4:	f7ff fc0e 	bl	80112d4 <RegionCommonTxConfigPrint>
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8011ab8:	89a1      	ldrh	r1, [r4, #12]
 8011aba:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8011abe:	f7ff fc19 	bl	80112f4 <GetTimeOnAir>
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 8011ac2:	f8d8 3054 	ldr.w	r3, [r8, #84]	@ 0x54
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8011ac6:	f8c9 0000 	str.w	r0, [r9]
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 8011aca:	7b21      	ldrb	r1, [r4, #12]
 8011acc:	4628      	mov	r0, r5
 8011ace:	4798      	blx	r3
}
 8011ad0:	2001      	movs	r0, #1
    *txPower = txPowerLimited;
 8011ad2:	703e      	strb	r6, [r7, #0]
}
 8011ad4:	b00d      	add	sp, #52	@ 0x34
 8011ad6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 8011ada:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8011ade:	fb05 f202 	mul.w	r2, r5, r2
 8011ae2:	9200      	str	r2, [sp, #0]
 8011ae4:	f44f 627a 	mov.w	r2, #4000	@ 0xfa0
 8011ae8:	9208      	str	r2, [sp, #32]
 8011aea:	2201      	movs	r2, #1
 8011aec:	2500      	movs	r5, #0
 8011aee:	9204      	str	r2, [sp, #16]
 8011af0:	2205      	movs	r2, #5
 8011af2:	9202      	str	r2, [sp, #8]
 8011af4:	e9cd 5506 	strd	r5, r5, [sp, #24]
 8011af8:	465b      	mov	r3, fp
 8011afa:	9505      	str	r5, [sp, #20]
 8011afc:	9503      	str	r5, [sp, #12]
 8011afe:	9501      	str	r5, [sp, #4]
 8011b00:	f246 12a8 	movw	r2, #25000	@ 0x61a8
 8011b04:	4628      	mov	r0, r5
 8011b06:	47e0      	blx	ip
 8011b08:	e7cb      	b.n	8011aa2 <RegionEU868TxConfig+0xa6>
 8011b0a:	bf00      	nop
 8011b0c:	080175b0 	.word	0x080175b0
 8011b10:	2000141c 	.word	0x2000141c
 8011b14:	20001420 	.word	0x20001420
 8011b18:	08017658 	.word	0x08017658
 8011b1c:	08017590 	.word	0x08017590

08011b20 <RegionEU868LinkAdrReq>:
{
 8011b20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011b24:	b08c      	sub	sp, #48	@ 0x30
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011b26:	f890 9008 	ldrb.w	r9, [r0, #8]
{
 8011b2a:	461e      	mov	r6, r3
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8011b2c:	2300      	movs	r3, #0
{
 8011b2e:	4604      	mov	r4, r0
 8011b30:	4688      	mov	r8, r1
 8011b32:	4617      	mov	r7, r2
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8011b34:	9302      	str	r3, [sp, #8]
 8011b36:	f8ad 300c 	strh.w	r3, [sp, #12]
    uint16_t chMask = 0;
 8011b3a:	f8ad 3006 	strh.w	r3, [sp, #6]
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011b3e:	f1b9 0f00 	cmp.w	r9, #0
 8011b42:	f000 80f3 	beq.w	8011d2c <RegionEU868LinkAdrReq+0x20c>
 8011b46:	4daa      	ldr	r5, [pc, #680]	@ (8011df0 <RegionEU868LinkAdrReq+0x2d0>)
    uint8_t bytesProcessed = 0;
 8011b48:	4699      	mov	r9, r3
    uint8_t status = 0x07;
 8011b4a:	f04f 0a07 	mov.w	sl, #7
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 8011b4e:	6860      	ldr	r0, [r4, #4]
 8011b50:	a902      	add	r1, sp, #8
 8011b52:	4448      	add	r0, r9
 8011b54:	f7ff f98c 	bl	8010e70 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8011b58:	2800      	cmp	r0, #0
 8011b5a:	f000 808c 	beq.w	8011c76 <RegionEU868LinkAdrReq+0x156>
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 8011b5e:	f89d 200b 	ldrb.w	r2, [sp, #11]
        chMask = linkAdrParams.ChMask;
 8011b62:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8011b66:	f8ad 3006 	strh.w	r3, [sp, #6]
        bytesProcessed += nextIndex;
 8011b6a:	4448      	add	r0, r9
 8011b6c:	fa5f f980 	uxtb.w	r9, r0
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 8011b70:	2a00      	cmp	r2, #0
 8011b72:	f040 80c1 	bne.w	8011cf8 <RegionEU868LinkAdrReq+0x1d8>
 8011b76:	2b00      	cmp	r3, #0
 8011b78:	f000 80c1 	beq.w	8011cfe <RegionEU868LinkAdrReq+0x1de>
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011b7c:	07d9      	lsls	r1, r3, #31
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 8011b7e:	682a      	ldr	r2, [r5, #0]
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011b80:	f140 80c4 	bpl.w	8011d0c <RegionEU868LinkAdrReq+0x1ec>
 8011b84:	6811      	ldr	r1, [r2, #0]
                        status &= 0xFE; // Channel mask KO
 8011b86:	2900      	cmp	r1, #0
 8011b88:	bf14      	ite	ne
 8011b8a:	f04f 0a07 	movne.w	sl, #7
 8011b8e:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011b92:	0798      	lsls	r0, r3, #30
 8011b94:	d504      	bpl.n	8011ba0 <RegionEU868LinkAdrReq+0x80>
 8011b96:	68d1      	ldr	r1, [r2, #12]
                        status &= 0xFE; // Channel mask KO
 8011b98:	2900      	cmp	r1, #0
 8011b9a:	bf08      	it	eq
 8011b9c:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011ba0:	0759      	lsls	r1, r3, #29
 8011ba2:	d504      	bpl.n	8011bae <RegionEU868LinkAdrReq+0x8e>
 8011ba4:	6991      	ldr	r1, [r2, #24]
                        status &= 0xFE; // Channel mask KO
 8011ba6:	2900      	cmp	r1, #0
 8011ba8:	bf08      	it	eq
 8011baa:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011bae:	0718      	lsls	r0, r3, #28
 8011bb0:	d504      	bpl.n	8011bbc <RegionEU868LinkAdrReq+0x9c>
 8011bb2:	6a51      	ldr	r1, [r2, #36]	@ 0x24
                        status &= 0xFE; // Channel mask KO
 8011bb4:	2900      	cmp	r1, #0
 8011bb6:	bf08      	it	eq
 8011bb8:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011bbc:	06d9      	lsls	r1, r3, #27
 8011bbe:	d504      	bpl.n	8011bca <RegionEU868LinkAdrReq+0xaa>
 8011bc0:	6b11      	ldr	r1, [r2, #48]	@ 0x30
                        status &= 0xFE; // Channel mask KO
 8011bc2:	2900      	cmp	r1, #0
 8011bc4:	bf08      	it	eq
 8011bc6:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011bca:	0698      	lsls	r0, r3, #26
 8011bcc:	d504      	bpl.n	8011bd8 <RegionEU868LinkAdrReq+0xb8>
 8011bce:	6bd1      	ldr	r1, [r2, #60]	@ 0x3c
                        status &= 0xFE; // Channel mask KO
 8011bd0:	2900      	cmp	r1, #0
 8011bd2:	bf08      	it	eq
 8011bd4:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011bd8:	0659      	lsls	r1, r3, #25
 8011bda:	d504      	bpl.n	8011be6 <RegionEU868LinkAdrReq+0xc6>
 8011bdc:	6c91      	ldr	r1, [r2, #72]	@ 0x48
                        status &= 0xFE; // Channel mask KO
 8011bde:	2900      	cmp	r1, #0
 8011be0:	bf08      	it	eq
 8011be2:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011be6:	0618      	lsls	r0, r3, #24
 8011be8:	d504      	bpl.n	8011bf4 <RegionEU868LinkAdrReq+0xd4>
 8011bea:	6d51      	ldr	r1, [r2, #84]	@ 0x54
                        status &= 0xFE; // Channel mask KO
 8011bec:	2900      	cmp	r1, #0
 8011bee:	bf08      	it	eq
 8011bf0:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011bf4:	05d9      	lsls	r1, r3, #23
 8011bf6:	d504      	bpl.n	8011c02 <RegionEU868LinkAdrReq+0xe2>
 8011bf8:	6e11      	ldr	r1, [r2, #96]	@ 0x60
                        status &= 0xFE; // Channel mask KO
 8011bfa:	2900      	cmp	r1, #0
 8011bfc:	bf08      	it	eq
 8011bfe:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011c02:	0598      	lsls	r0, r3, #22
 8011c04:	d504      	bpl.n	8011c10 <RegionEU868LinkAdrReq+0xf0>
 8011c06:	6ed1      	ldr	r1, [r2, #108]	@ 0x6c
                        status &= 0xFE; // Channel mask KO
 8011c08:	2900      	cmp	r1, #0
 8011c0a:	bf08      	it	eq
 8011c0c:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011c10:	0559      	lsls	r1, r3, #21
 8011c12:	d504      	bpl.n	8011c1e <RegionEU868LinkAdrReq+0xfe>
 8011c14:	6f91      	ldr	r1, [r2, #120]	@ 0x78
                        status &= 0xFE; // Channel mask KO
 8011c16:	2900      	cmp	r1, #0
 8011c18:	bf08      	it	eq
 8011c1a:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011c1e:	0518      	lsls	r0, r3, #20
 8011c20:	d505      	bpl.n	8011c2e <RegionEU868LinkAdrReq+0x10e>
 8011c22:	f8d2 1084 	ldr.w	r1, [r2, #132]	@ 0x84
                        status &= 0xFE; // Channel mask KO
 8011c26:	2900      	cmp	r1, #0
 8011c28:	bf08      	it	eq
 8011c2a:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011c2e:	04d9      	lsls	r1, r3, #19
 8011c30:	d505      	bpl.n	8011c3e <RegionEU868LinkAdrReq+0x11e>
 8011c32:	f8d2 1090 	ldr.w	r1, [r2, #144]	@ 0x90
                        status &= 0xFE; // Channel mask KO
 8011c36:	2900      	cmp	r1, #0
 8011c38:	bf08      	it	eq
 8011c3a:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011c3e:	0498      	lsls	r0, r3, #18
 8011c40:	d505      	bpl.n	8011c4e <RegionEU868LinkAdrReq+0x12e>
 8011c42:	f8d2 109c 	ldr.w	r1, [r2, #156]	@ 0x9c
                        status &= 0xFE; // Channel mask KO
 8011c46:	2900      	cmp	r1, #0
 8011c48:	bf08      	it	eq
 8011c4a:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011c4e:	0459      	lsls	r1, r3, #17
 8011c50:	d505      	bpl.n	8011c5e <RegionEU868LinkAdrReq+0x13e>
 8011c52:	f8d2 10a8 	ldr.w	r1, [r2, #168]	@ 0xa8
                        status &= 0xFE; // Channel mask KO
 8011c56:	2900      	cmp	r1, #0
 8011c58:	bf08      	it	eq
 8011c5a:	f04f 0a06 	moveq.w	sl, #6
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011c5e:	041b      	lsls	r3, r3, #16
 8011c60:	d505      	bpl.n	8011c6e <RegionEU868LinkAdrReq+0x14e>
 8011c62:	f8d2 30b4 	ldr.w	r3, [r2, #180]	@ 0xb4
                        status &= 0xFE; // Channel mask KO
 8011c66:	2b00      	cmp	r3, #0
 8011c68:	bf08      	it	eq
 8011c6a:	f04f 0a06 	moveq.w	sl, #6
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011c6e:	7a23      	ldrb	r3, [r4, #8]
 8011c70:	454b      	cmp	r3, r9
 8011c72:	f63f af6c 	bhi.w	8011b4e <RegionEU868LinkAdrReq+0x2e>
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8011c76:	f8bd 3009 	ldrh.w	r3, [sp, #9]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 8011c7a:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8011c7e:	f88d 2018 	strb.w	r2, [sp, #24]
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 8011c82:	7aa2      	ldrb	r2, [r4, #10]
 8011c84:	f88d 2015 	strb.w	r2, [sp, #21]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 8011c88:	f8b4 200b 	ldrh.w	r2, [r4, #11]
 8011c8c:	f8ad 2019 	strh.w	r2, [sp, #25]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 8011c90:	7b62      	ldrb	r2, [r4, #13]
 8011c92:	f88d 201b 	strb.w	r2, [sp, #27]
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 8011c96:	6822      	ldr	r2, [r4, #0]
 8011c98:	9204      	str	r2, [sp, #16]
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8011c9a:	682a      	ldr	r2, [r5, #0]
 8011c9c:	920a      	str	r2, [sp, #40]	@ 0x28
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 8011c9e:	2210      	movs	r2, #16
 8011ca0:	f88d 201c 	strb.w	r2, [sp, #28]
    linkAdrVerifyParams.ChannelsMask = &chMask;
 8011ca4:	f10d 0206 	add.w	r2, sp, #6
 8011ca8:	9208      	str	r2, [sp, #32]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 8011caa:	f44f 62e0 	mov.w	r2, #1792	@ 0x700
 8011cae:	f8ad 2024 	strh.w	r2, [sp, #36]	@ 0x24
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 8011cb2:	2207      	movs	r2, #7
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8011cb4:	f8ad 3016 	strh.w	r3, [sp, #22]
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 8011cb8:	f8ad 202c 	strh.w	r2, [sp, #44]	@ 0x2c
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8011cbc:	ab02      	add	r3, sp, #8
 8011cbe:	f10d 020a 	add.w	r2, sp, #10
 8011cc2:	f10d 0109 	add.w	r1, sp, #9
 8011cc6:	a804      	add	r0, sp, #16
    linkAdrVerifyParams.Status = status;
 8011cc8:	f88d a014 	strb.w	sl, [sp, #20]
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8011ccc:	f7ff f8ea 	bl	8010ea4 <RegionCommonLinkAdrReqVerifyParams>
    if( status == 0x07 )
 8011cd0:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8011cd2:	4604      	mov	r4, r0
    if( status == 0x07 )
 8011cd4:	d01d      	beq.n	8011d12 <RegionEU868LinkAdrReq+0x1f2>
    *drOut = linkAdrParams.Datarate;
 8011cd6:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8011cda:	f888 3000 	strb.w	r3, [r8]
    *txPowOut = linkAdrParams.TxPower;
 8011cde:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8011ce2:	703b      	strb	r3, [r7, #0]
    *nbRepOut = linkAdrParams.NbRep;
 8011ce4:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8011ce8:	7033      	strb	r3, [r6, #0]
    *nbBytesParsed = bytesProcessed;
 8011cea:	9b14      	ldr	r3, [sp, #80]	@ 0x50
}
 8011cec:	4620      	mov	r0, r4
    *nbBytesParsed = bytesProcessed;
 8011cee:	f883 9000 	strb.w	r9, [r3]
}
 8011cf2:	b00c      	add	sp, #48	@ 0x30
 8011cf4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 8011cf8:	1e51      	subs	r1, r2, #1
 8011cfa:	2904      	cmp	r1, #4
 8011cfc:	d81c      	bhi.n	8011d38 <RegionEU868LinkAdrReq+0x218>
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011cfe:	7a23      	ldrb	r3, [r4, #8]
 8011d00:	454b      	cmp	r3, r9
            status &= 0xFE; // Channel mask KO
 8011d02:	f04f 0a06 	mov.w	sl, #6
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011d06:	f63f af22 	bhi.w	8011b4e <RegionEU868LinkAdrReq+0x2e>
 8011d0a:	e7b4      	b.n	8011c76 <RegionEU868LinkAdrReq+0x156>
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8011d0c:	f04f 0a07 	mov.w	sl, #7
 8011d10:	e73f      	b.n	8011b92 <RegionEU868LinkAdrReq+0x72>
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 8011d12:	6828      	ldr	r0, [r5, #0]
 8011d14:	220c      	movs	r2, #12
 8011d16:	f500 6090 	add.w	r0, r0, #1152	@ 0x480
 8011d1a:	2100      	movs	r1, #0
 8011d1c:	f000 fb0e 	bl	801233c <memset1>
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 8011d20:	682b      	ldr	r3, [r5, #0]
 8011d22:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8011d26:	f8a3 2480 	strh.w	r2, [r3, #1152]	@ 0x480
 8011d2a:	e7d4      	b.n	8011cd6 <RegionEU868LinkAdrReq+0x1b6>
 8011d2c:	4d30      	ldr	r5, [pc, #192]	@ (8011df0 <RegionEU868LinkAdrReq+0x2d0>)
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011d2e:	464a      	mov	r2, r9
 8011d30:	464b      	mov	r3, r9
    uint8_t status = 0x07;
 8011d32:	f04f 0a07 	mov.w	sl, #7
 8011d36:	e7a2      	b.n	8011c7e <RegionEU868LinkAdrReq+0x15e>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 8011d38:	2a06      	cmp	r2, #6
 8011d3a:	d1e0      	bne.n	8011cfe <RegionEU868LinkAdrReq+0x1de>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 8011d3c:	682a      	ldr	r2, [r5, #0]
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d3e:	6811      	ldr	r1, [r2, #0]
 8011d40:	b111      	cbz	r1, 8011d48 <RegionEU868LinkAdrReq+0x228>
                        chMask |= 1 << i;
 8011d42:	f043 0301 	orr.w	r3, r3, #1
 8011d46:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d48:	68d0      	ldr	r0, [r2, #12]
 8011d4a:	b110      	cbz	r0, 8011d52 <RegionEU868LinkAdrReq+0x232>
                        chMask |= 1 << i;
 8011d4c:	f043 0302 	orr.w	r3, r3, #2
 8011d50:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d52:	6990      	ldr	r0, [r2, #24]
 8011d54:	b110      	cbz	r0, 8011d5c <RegionEU868LinkAdrReq+0x23c>
                        chMask |= 1 << i;
 8011d56:	f043 0304 	orr.w	r3, r3, #4
 8011d5a:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d5c:	6a50      	ldr	r0, [r2, #36]	@ 0x24
 8011d5e:	b110      	cbz	r0, 8011d66 <RegionEU868LinkAdrReq+0x246>
                        chMask |= 1 << i;
 8011d60:	f043 0308 	orr.w	r3, r3, #8
 8011d64:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d66:	6b10      	ldr	r0, [r2, #48]	@ 0x30
 8011d68:	b110      	cbz	r0, 8011d70 <RegionEU868LinkAdrReq+0x250>
                        chMask |= 1 << i;
 8011d6a:	f043 0310 	orr.w	r3, r3, #16
 8011d6e:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d70:	6bd0      	ldr	r0, [r2, #60]	@ 0x3c
 8011d72:	b110      	cbz	r0, 8011d7a <RegionEU868LinkAdrReq+0x25a>
                        chMask |= 1 << i;
 8011d74:	f043 0320 	orr.w	r3, r3, #32
 8011d78:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d7a:	6c90      	ldr	r0, [r2, #72]	@ 0x48
 8011d7c:	b110      	cbz	r0, 8011d84 <RegionEU868LinkAdrReq+0x264>
                        chMask |= 1 << i;
 8011d7e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8011d82:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d84:	6d50      	ldr	r0, [r2, #84]	@ 0x54
 8011d86:	b110      	cbz	r0, 8011d8e <RegionEU868LinkAdrReq+0x26e>
                        chMask |= 1 << i;
 8011d88:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8011d8c:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d8e:	6e10      	ldr	r0, [r2, #96]	@ 0x60
 8011d90:	b110      	cbz	r0, 8011d98 <RegionEU868LinkAdrReq+0x278>
                        chMask |= 1 << i;
 8011d92:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8011d96:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011d98:	6ed0      	ldr	r0, [r2, #108]	@ 0x6c
 8011d9a:	b110      	cbz	r0, 8011da2 <RegionEU868LinkAdrReq+0x282>
                        chMask |= 1 << i;
 8011d9c:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8011da0:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011da2:	6f90      	ldr	r0, [r2, #120]	@ 0x78
 8011da4:	b110      	cbz	r0, 8011dac <RegionEU868LinkAdrReq+0x28c>
                        chMask |= 1 << i;
 8011da6:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8011daa:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011dac:	f8d2 0084 	ldr.w	r0, [r2, #132]	@ 0x84
 8011db0:	b110      	cbz	r0, 8011db8 <RegionEU868LinkAdrReq+0x298>
                        chMask |= 1 << i;
 8011db2:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8011db6:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011db8:	f8d2 0090 	ldr.w	r0, [r2, #144]	@ 0x90
 8011dbc:	b110      	cbz	r0, 8011dc4 <RegionEU868LinkAdrReq+0x2a4>
                        chMask |= 1 << i;
 8011dbe:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8011dc2:	2101      	movs	r1, #1
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011dc4:	f8d2 009c 	ldr.w	r0, [r2, #156]	@ 0x9c
 8011dc8:	b1a0      	cbz	r0, 8011df4 <RegionEU868LinkAdrReq+0x2d4>
 8011dca:	f8d2 10a8 	ldr.w	r1, [r2, #168]	@ 0xa8
                        chMask |= 1 << i;
 8011dce:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011dd2:	b991      	cbnz	r1, 8011dfa <RegionEU868LinkAdrReq+0x2da>
 8011dd4:	f8d2 20b4 	ldr.w	r2, [r2, #180]	@ 0xb4
 8011dd8:	b10a      	cbz	r2, 8011dde <RegionEU868LinkAdrReq+0x2be>
                        chMask |= 1 << i;
 8011dda:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 8011dde:	f8ad 3006 	strh.w	r3, [sp, #6]
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011de2:	7a23      	ldrb	r3, [r4, #8]
 8011de4:	454b      	cmp	r3, r9
                        chMask |= 1 << i;
 8011de6:	f04f 0a07 	mov.w	sl, #7
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8011dea:	f63f aeb0 	bhi.w	8011b4e <RegionEU868LinkAdrReq+0x2e>
 8011dee:	e742      	b.n	8011c76 <RegionEU868LinkAdrReq+0x156>
 8011df0:	2000141c 	.word	0x2000141c
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011df4:	f8d2 00a8 	ldr.w	r0, [r2, #168]	@ 0xa8
 8011df8:	b130      	cbz	r0, 8011e08 <RegionEU868LinkAdrReq+0x2e8>
 8011dfa:	f8d2 20b4 	ldr.w	r2, [r2, #180]	@ 0xb4
                        chMask |= 1 << i;
 8011dfe:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8011e02:	2a00      	cmp	r2, #0
 8011e04:	d1e9      	bne.n	8011dda <RegionEU868LinkAdrReq+0x2ba>
 8011e06:	e7ea      	b.n	8011dde <RegionEU868LinkAdrReq+0x2be>
 8011e08:	f8d2 20b4 	ldr.w	r2, [r2, #180]	@ 0xb4
 8011e0c:	2a00      	cmp	r2, #0
 8011e0e:	d1e4      	bne.n	8011dda <RegionEU868LinkAdrReq+0x2ba>
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 8011e10:	2900      	cmp	r1, #0
 8011e12:	d1e4      	bne.n	8011dde <RegionEU868LinkAdrReq+0x2be>
 8011e14:	e7e5      	b.n	8011de2 <RegionEU868LinkAdrReq+0x2c2>
 8011e16:	bf00      	nop

08011e18 <RegionEU868RxParamSetupReq>:
{
 8011e18:	b570      	push	{r4, r5, r6, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 8011e1a:	4b1d      	ldr	r3, [pc, #116]	@ (8011e90 <RegionEU868RxParamSetupReq+0x78>)
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 8011e1c:	6845      	ldr	r5, [r0, #4]
    if( Radio.CheckRfFrequency( freq ) == false )
 8011e1e:	6a1b      	ldr	r3, [r3, #32]
{
 8011e20:	4604      	mov	r4, r0
    if( Radio.CheckRfFrequency( freq ) == false )
 8011e22:	4628      	mov	r0, r5
 8011e24:	4798      	blx	r3
 8011e26:	2800      	cmp	r0, #0
 8011e28:	d02f      	beq.n	8011e8a <RegionEU868RxParamSetupReq+0x72>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 8011e2a:	4b1a      	ldr	r3, [pc, #104]	@ (8011e94 <RegionEU868RxParamSetupReq+0x7c>)
 8011e2c:	4a1a      	ldr	r2, [pc, #104]	@ (8011e98 <RegionEU868RxParamSetupReq+0x80>)
 8011e2e:	442b      	add	r3, r5
 8011e30:	4293      	cmp	r3, r2
 8011e32:	d816      	bhi.n	8011e62 <RegionEU868RxParamSetupReq+0x4a>
 8011e34:	2505      	movs	r5, #5
    uint8_t status = 0x07;
 8011e36:	2607      	movs	r6, #7
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8011e38:	2207      	movs	r2, #7
 8011e3a:	2100      	movs	r1, #0
 8011e3c:	f994 0000 	ldrsb.w	r0, [r4]
 8011e40:	f7fe fe06 	bl	8010a50 <RegionCommonValueInRange>
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 8011e44:	2205      	movs	r2, #5
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8011e46:	4603      	mov	r3, r0
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 8011e48:	2100      	movs	r1, #0
 8011e4a:	f994 0001 	ldrsb.w	r0, [r4, #1]
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8011e4e:	2b00      	cmp	r3, #0
 8011e50:	bf18      	it	ne
 8011e52:	4635      	movne	r5, r6
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 8011e54:	f7fe fdfc 	bl	8010a50 <RegionCommonValueInRange>
 8011e58:	b908      	cbnz	r0, 8011e5e <RegionEU868RxParamSetupReq+0x46>
        status &= 0xFB; // Rx1DrOffset range KO
 8011e5a:	f005 05fb 	and.w	r5, r5, #251	@ 0xfb
}
 8011e5e:	4628      	mov	r0, r5
 8011e60:	bd70      	pop	{r4, r5, r6, pc}
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 8011e62:	4b0e      	ldr	r3, [pc, #56]	@ (8011e9c <RegionEU868RxParamSetupReq+0x84>)
 8011e64:	4a0e      	ldr	r2, [pc, #56]	@ (8011ea0 <RegionEU868RxParamSetupReq+0x88>)
 8011e66:	442b      	add	r3, r5
 8011e68:	4293      	cmp	r3, r2
 8011e6a:	d9e3      	bls.n	8011e34 <RegionEU868RxParamSetupReq+0x1c>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 8011e6c:	4b0d      	ldr	r3, [pc, #52]	@ (8011ea4 <RegionEU868RxParamSetupReq+0x8c>)
 8011e6e:	4a0e      	ldr	r2, [pc, #56]	@ (8011ea8 <RegionEU868RxParamSetupReq+0x90>)
 8011e70:	442b      	add	r3, r5
 8011e72:	4293      	cmp	r3, r2
 8011e74:	d9de      	bls.n	8011e34 <RegionEU868RxParamSetupReq+0x1c>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 8011e76:	4b0d      	ldr	r3, [pc, #52]	@ (8011eac <RegionEU868RxParamSetupReq+0x94>)
 8011e78:	4a0d      	ldr	r2, [pc, #52]	@ (8011eb0 <RegionEU868RxParamSetupReq+0x98>)
 8011e7a:	442b      	add	r3, r5
 8011e7c:	4293      	cmp	r3, r2
 8011e7e:	bf8b      	itete	hi
 8011e80:	2504      	movhi	r5, #4
 8011e82:	2505      	movls	r5, #5
 8011e84:	2606      	movhi	r6, #6
 8011e86:	2607      	movls	r6, #7
 8011e88:	e7d6      	b.n	8011e38 <RegionEU868RxParamSetupReq+0x20>
 8011e8a:	2504      	movs	r5, #4
        status &= 0xFE; // Channel frequency KO
 8011e8c:	2606      	movs	r6, #6
 8011e8e:	e7d3      	b.n	8011e38 <RegionEU868RxParamSetupReq+0x20>
 8011e90:	08017658 	.word	0x08017658
 8011e94:	cc8faa40 	.word	0xcc8faa40
 8011e98:	00557300 	.word	0x00557300
 8011e9c:	cc38b0a0 	.word	0xcc38b0a0
 8011ea0:	0007a120 	.word	0x0007a120
 8011ea4:	cc2e0240 	.word	0xcc2e0240
 8011ea8:	0003d090 	.word	0x0003d090
 8011eac:	cc296e60 	.word	0xcc296e60
 8011eb0:	000493e0 	.word	0x000493e0

08011eb4 <RegionEU868NewChannelReq>:
{
 8011eb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( newChannelReq->NewChannel->Frequency == 0 )
 8011eb6:	6806      	ldr	r6, [r0, #0]
        channelRemove.ChannelId = newChannelReq->ChannelId;
 8011eb8:	7905      	ldrb	r5, [r0, #4]
    if( newChannelReq->NewChannel->Frequency == 0 )
 8011eba:	6833      	ldr	r3, [r6, #0]
 8011ebc:	b91b      	cbnz	r3, 8011ec6 <RegionEU868NewChannelReq+0x12>
    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 8011ebe:	2d02      	cmp	r5, #2
 8011ec0:	d84d      	bhi.n	8011f5e <RegionEU868NewChannelReq+0xaa>
        *band = 2;
 8011ec2:	2000      	movs	r0, #0
}
 8011ec4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 8011ec6:	1eeb      	subs	r3, r5, #3
 8011ec8:	2b0c      	cmp	r3, #12
 8011eca:	d8fa      	bhi.n	8011ec2 <RegionEU868NewChannelReq+0xe>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8011ecc:	7a30      	ldrb	r0, [r6, #8]
 8011ece:	f340 0003 	sbfx	r0, r0, #0, #4
 8011ed2:	2207      	movs	r2, #7
 8011ed4:	2100      	movs	r1, #0
 8011ed6:	b240      	sxtb	r0, r0
 8011ed8:	f7fe fdba 	bl	8010a50 <RegionCommonValueInRange>
 8011edc:	4604      	mov	r4, r0
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8011ede:	7a30      	ldrb	r0, [r6, #8]
 8011ee0:	f340 1003 	sbfx	r0, r0, #4, #4
 8011ee4:	2207      	movs	r2, #7
 8011ee6:	b240      	sxtb	r0, r0
 8011ee8:	2100      	movs	r1, #0
 8011eea:	f7fe fdb1 	bl	8010a50 <RegionCommonValueInRange>
 8011eee:	2800      	cmp	r0, #0
 8011ef0:	d049      	beq.n	8011f86 <RegionEU868NewChannelReq+0xd2>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8011ef2:	fab4 f484 	clz	r4, r4
 8011ef6:	0964      	lsrs	r4, r4, #5
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8011ef8:	7a33      	ldrb	r3, [r6, #8]
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8011efa:	6837      	ldr	r7, [r6, #0]
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8011efc:	f343 0203 	sbfx	r2, r3, #0, #4
 8011f00:	f343 1303 	sbfx	r3, r3, #4, #4
 8011f04:	b25b      	sxtb	r3, r3
 8011f06:	b252      	sxtb	r2, r2
        drInvalid = true;
 8011f08:	429a      	cmp	r2, r3
 8011f0a:	bfc8      	it	gt
 8011f0c:	2401      	movgt	r4, #1
    if( Radio.CheckRfFrequency( freq ) == false )
 8011f0e:	4b32      	ldr	r3, [pc, #200]	@ (8011fd8 <RegionEU868NewChannelReq+0x124>)
 8011f10:	4638      	mov	r0, r7
 8011f12:	6a1b      	ldr	r3, [r3, #32]
 8011f14:	4798      	blx	r3
 8011f16:	2800      	cmp	r0, #0
 8011f18:	d037      	beq.n	8011f8a <RegionEU868NewChannelReq+0xd6>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 8011f1a:	4b30      	ldr	r3, [pc, #192]	@ (8011fdc <RegionEU868NewChannelReq+0x128>)
 8011f1c:	4a30      	ldr	r2, [pc, #192]	@ (8011fe0 <RegionEU868NewChannelReq+0x12c>)
 8011f1e:	443b      	add	r3, r7
 8011f20:	4293      	cmp	r3, r2
 8011f22:	d937      	bls.n	8011f94 <RegionEU868NewChannelReq+0xe0>
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 8011f24:	4b2f      	ldr	r3, [pc, #188]	@ (8011fe4 <RegionEU868NewChannelReq+0x130>)
 8011f26:	4a30      	ldr	r2, [pc, #192]	@ (8011fe8 <RegionEU868NewChannelReq+0x134>)
 8011f28:	443b      	add	r3, r7
 8011f2a:	4293      	cmp	r3, r2
 8011f2c:	d94c      	bls.n	8011fc8 <RegionEU868NewChannelReq+0x114>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 8011f2e:	4b2f      	ldr	r3, [pc, #188]	@ (8011fec <RegionEU868NewChannelReq+0x138>)
 8011f30:	4a2f      	ldr	r2, [pc, #188]	@ (8011ff0 <RegionEU868NewChannelReq+0x13c>)
 8011f32:	443b      	add	r3, r7
 8011f34:	4293      	cmp	r3, r2
 8011f36:	d949      	bls.n	8011fcc <RegionEU868NewChannelReq+0x118>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 8011f38:	4b2e      	ldr	r3, [pc, #184]	@ (8011ff4 <RegionEU868NewChannelReq+0x140>)
 8011f3a:	4a2f      	ldr	r2, [pc, #188]	@ (8011ff8 <RegionEU868NewChannelReq+0x144>)
 8011f3c:	443b      	add	r3, r7
 8011f3e:	4293      	cmp	r3, r2
 8011f40:	d946      	bls.n	8011fd0 <RegionEU868NewChannelReq+0x11c>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 8011f42:	4b2e      	ldr	r3, [pc, #184]	@ (8011ffc <RegionEU868NewChannelReq+0x148>)
 8011f44:	4a2e      	ldr	r2, [pc, #184]	@ (8012000 <RegionEU868NewChannelReq+0x14c>)
 8011f46:	443b      	add	r3, r7
 8011f48:	4293      	cmp	r3, r2
 8011f4a:	d943      	bls.n	8011fd4 <RegionEU868NewChannelReq+0x120>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 8011f4c:	4b2d      	ldr	r3, [pc, #180]	@ (8012004 <RegionEU868NewChannelReq+0x150>)
 8011f4e:	4a2e      	ldr	r2, [pc, #184]	@ (8012008 <RegionEU868NewChannelReq+0x154>)
 8011f50:	443b      	add	r3, r7
 8011f52:	4293      	cmp	r3, r2
 8011f54:	d819      	bhi.n	8011f8a <RegionEU868NewChannelReq+0xd6>
        *band = 4;
 8011f56:	2704      	movs	r7, #4
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 8011f58:	b1f4      	cbz	r4, 8011f98 <RegionEU868NewChannelReq+0xe4>
 8011f5a:	2001      	movs	r0, #1
}
 8011f5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 8011f5e:	492b      	ldr	r1, [pc, #172]	@ (801200c <RegionEU868NewChannelReq+0x158>)
 8011f60:	6808      	ldr	r0, [r1, #0]
 8011f62:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 8011f66:	eb00 0482 	add.w	r4, r0, r2, lsl #2
 8011f6a:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 8011f6e:	4629      	mov	r1, r5
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 8011f70:	e9c4 3301 	strd	r3, r3, [r4, #4]
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 8011f74:	2210      	movs	r2, #16
 8011f76:	f500 6090 	add.w	r0, r0, #1152	@ 0x480
 8011f7a:	f7fe fd73 	bl	8010a64 <RegionCommonChanDisable>
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8011f7e:	2800      	cmp	r0, #0
 8011f80:	d09f      	beq.n	8011ec2 <RegionEU868NewChannelReq+0xe>
        *band = 2;
 8011f82:	2003      	movs	r0, #3
}
 8011f84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        drInvalid = true;
 8011f86:	2401      	movs	r4, #1
 8011f88:	e7b6      	b.n	8011ef8 <RegionEU868NewChannelReq+0x44>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 8011f8a:	f084 0001 	eor.w	r0, r4, #1
    return status;
 8011f8e:	0040      	lsls	r0, r0, #1
 8011f90:	b240      	sxtb	r0, r0
}
 8011f92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        *band = 2;
 8011f94:	2702      	movs	r7, #2
 8011f96:	e7df      	b.n	8011f58 <RegionEU868NewChannelReq+0xa4>
    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 8011f98:	4c1c      	ldr	r4, [pc, #112]	@ (801200c <RegionEU868NewChannelReq+0x158>)
 8011f9a:	6823      	ldr	r3, [r4, #0]
 8011f9c:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 8011fa0:	4631      	mov	r1, r6
 8011fa2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8011fa6:	220c      	movs	r2, #12
 8011fa8:	f000 f96c 	bl	8012284 <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 8011fac:	6822      	ldr	r2, [r4, #0]
 8011fae:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 8011fb2:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 8011fb6:	2301      	movs	r3, #1
    RegionNvmGroup2->Channels[id].Band = band;
 8011fb8:	724f      	strb	r7, [r1, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 8011fba:	f8b2 1480 	ldrh.w	r1, [r2, #1152]	@ 0x480
 8011fbe:	40ab      	lsls	r3, r5
 8011fc0:	430b      	orrs	r3, r1
 8011fc2:	f8a2 3480 	strh.w	r3, [r2, #1152]	@ 0x480
    return LORAMAC_STATUS_OK;
 8011fc6:	e7dc      	b.n	8011f82 <RegionEU868NewChannelReq+0xce>
        *band = 0;
 8011fc8:	2700      	movs	r7, #0
 8011fca:	e7c5      	b.n	8011f58 <RegionEU868NewChannelReq+0xa4>
        *band = 1;
 8011fcc:	2701      	movs	r7, #1
 8011fce:	e7c3      	b.n	8011f58 <RegionEU868NewChannelReq+0xa4>
        *band = 5;
 8011fd0:	2705      	movs	r7, #5
 8011fd2:	e7c1      	b.n	8011f58 <RegionEU868NewChannelReq+0xa4>
        *band = 3;
 8011fd4:	2703      	movs	r7, #3
 8011fd6:	e7bf      	b.n	8011f58 <RegionEU868NewChannelReq+0xa4>
 8011fd8:	08017658 	.word	0x08017658
 8011fdc:	cc8faa40 	.word	0xcc8faa40
 8011fe0:	001e847f 	.word	0x001e847f
 8011fe4:	cc7125c0 	.word	0xcc7125c0
 8011fe8:	002dc6c0 	.word	0x002dc6c0
 8011fec:	cc435eff 	.word	0xcc435eff
 8011ff0:	000927bf 	.word	0x000927bf
 8011ff4:	cc38b0a0 	.word	0xcc38b0a0
 8011ff8:	0007a120 	.word	0x0007a120
 8011ffc:	cc2e0240 	.word	0xcc2e0240
 8012000:	0003d090 	.word	0x0003d090
 8012004:	cc296e60 	.word	0xcc296e60
 8012008:	000493e0 	.word	0x000493e0
 801200c:	2000141c 	.word	0x2000141c

08012010 <RegionEU868TxParamSetupReq>:
}
 8012010:	f04f 30ff 	mov.w	r0, #4294967295
 8012014:	4770      	bx	lr
 8012016:	bf00      	nop

08012018 <RegionEU868DlChannelReq>:
{
 8012018:	b538      	push	{r3, r4, r5, lr}
    if( dlChannelReq->ChannelId >= ( CHANNELS_MASK_SIZE * 16 ) )
 801201a:	7803      	ldrb	r3, [r0, #0]
 801201c:	2b0f      	cmp	r3, #15
 801201e:	d901      	bls.n	8012024 <RegionEU868DlChannelReq+0xc>
        return 0;
 8012020:	2000      	movs	r0, #0
}
 8012022:	bd38      	pop	{r3, r4, r5, pc}
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 8012024:	6845      	ldr	r5, [r0, #4]
    if( Radio.CheckRfFrequency( freq ) == false )
 8012026:	4b1b      	ldr	r3, [pc, #108]	@ (8012094 <RegionEU868DlChannelReq+0x7c>)
 8012028:	4604      	mov	r4, r0
 801202a:	6a1b      	ldr	r3, [r3, #32]
 801202c:	4628      	mov	r0, r5
 801202e:	4798      	blx	r3
 8012030:	b1f8      	cbz	r0, 8012072 <RegionEU868DlChannelReq+0x5a>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 8012032:	4b19      	ldr	r3, [pc, #100]	@ (8012098 <RegionEU868DlChannelReq+0x80>)
 8012034:	4a19      	ldr	r2, [pc, #100]	@ (801209c <RegionEU868DlChannelReq+0x84>)
 8012036:	442b      	add	r3, r5
 8012038:	4293      	cmp	r3, r2
 801203a:	d909      	bls.n	8012050 <RegionEU868DlChannelReq+0x38>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 801203c:	4b18      	ldr	r3, [pc, #96]	@ (80120a0 <RegionEU868DlChannelReq+0x88>)
 801203e:	4a19      	ldr	r2, [pc, #100]	@ (80120a4 <RegionEU868DlChannelReq+0x8c>)
 8012040:	442b      	add	r3, r5
 8012042:	4293      	cmp	r3, r2
 8012044:	d904      	bls.n	8012050 <RegionEU868DlChannelReq+0x38>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 8012046:	4b18      	ldr	r3, [pc, #96]	@ (80120a8 <RegionEU868DlChannelReq+0x90>)
 8012048:	4a18      	ldr	r2, [pc, #96]	@ (80120ac <RegionEU868DlChannelReq+0x94>)
 801204a:	442b      	add	r3, r5
 801204c:	4293      	cmp	r3, r2
 801204e:	d80b      	bhi.n	8012068 <RegionEU868DlChannelReq+0x50>
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 8012050:	4a17      	ldr	r2, [pc, #92]	@ (80120b0 <RegionEU868DlChannelReq+0x98>)
 8012052:	7823      	ldrb	r3, [r4, #0]
 8012054:	6812      	ldr	r2, [r2, #0]
 8012056:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801205a:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 801205e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012062:	b993      	cbnz	r3, 801208a <RegionEU868DlChannelReq+0x72>
 8012064:	2001      	movs	r0, #1
}
 8012066:	bd38      	pop	{r3, r4, r5, pc}
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 8012068:	4b12      	ldr	r3, [pc, #72]	@ (80120b4 <RegionEU868DlChannelReq+0x9c>)
 801206a:	4a13      	ldr	r2, [pc, #76]	@ (80120b8 <RegionEU868DlChannelReq+0xa0>)
 801206c:	442b      	add	r3, r5
 801206e:	4293      	cmp	r3, r2
 8012070:	d9ee      	bls.n	8012050 <RegionEU868DlChannelReq+0x38>
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 8012072:	7823      	ldrb	r3, [r4, #0]
 8012074:	4a0e      	ldr	r2, [pc, #56]	@ (80120b0 <RegionEU868DlChannelReq+0x98>)
 8012076:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801207a:	6812      	ldr	r2, [r2, #0]
 801207c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012080:	2b00      	cmp	r3, #0
 8012082:	bf0c      	ite	eq
 8012084:	2000      	moveq	r0, #0
 8012086:	2002      	movne	r0, #2
}
 8012088:	bd38      	pop	{r3, r4, r5, pc}
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 801208a:	6863      	ldr	r3, [r4, #4]
 801208c:	604b      	str	r3, [r1, #4]
 801208e:	2003      	movs	r0, #3
}
 8012090:	bd38      	pop	{r3, r4, r5, pc}
 8012092:	bf00      	nop
 8012094:	08017658 	.word	0x08017658
 8012098:	cc8faa40 	.word	0xcc8faa40
 801209c:	00557300 	.word	0x00557300
 80120a0:	cc38b0a0 	.word	0xcc38b0a0
 80120a4:	0007a120 	.word	0x0007a120
 80120a8:	cc2e0240 	.word	0xcc2e0240
 80120ac:	0003d090 	.word	0x0003d090
 80120b0:	2000141c 	.word	0x2000141c
 80120b4:	cc296e60 	.word	0xcc296e60
 80120b8:	000493e0 	.word	0x000493e0

080120bc <RegionEU868AlternateDr>:
}
 80120bc:	4770      	bx	lr
 80120be:	bf00      	nop

080120c0 <RegionEU868NextChannel>:
{
 80120c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80120c4:	b096      	sub	sp, #88	@ 0x58
    uint8_t nbEnabledChannels = 0;
 80120c6:	2500      	movs	r5, #0
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 80120c8:	e9cd 5504 	strd	r5, r5, [sp, #16]
 80120cc:	e9cd 5506 	strd	r5, r5, [sp, #24]
{
 80120d0:	460f      	mov	r7, r1
    uint8_t nbEnabledChannels = 0;
 80120d2:	f88d 500c 	strb.w	r5, [sp, #12]
    uint8_t nbRestrictedChannels = 0;
 80120d6:	f88d 500d 	strb.w	r5, [sp, #13]
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80120da:	4629      	mov	r1, r5
 80120dc:	4d3a      	ldr	r5, [pc, #232]	@ (80121c8 <RegionEU868NextChannel+0x108>)
{
 80120de:	4604      	mov	r4, r0
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80120e0:	6828      	ldr	r0, [r5, #0]
{
 80120e2:	4690      	mov	r8, r2
 80120e4:	461e      	mov	r6, r3
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80120e6:	f500 6090 	add.w	r0, r0, #1152	@ 0x480
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 80120ea:	2307      	movs	r3, #7
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80120ec:	2201      	movs	r2, #1
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 80120ee:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80120f2:	f7fe fcd1 	bl	8010a98 <RegionCommonCountChannels>
 80120f6:	2800      	cmp	r0, #0
 80120f8:	d04d      	beq.n	8012196 <RegionEU868NextChannel+0xd6>
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 80120fa:	6828      	ldr	r0, [r5, #0]
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 80120fc:	900a      	str	r0, [sp, #40]	@ 0x28
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80120fe:	f104 030c 	add.w	r3, r4, #12
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8012102:	f500 6090 	add.w	r0, r0, #1152	@ 0x480
 8012106:	9009      	str	r0, [sp, #36]	@ 0x24
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8012108:	e893 0003 	ldmia.w	r3, {r0, r1}
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 801210c:	4b2f      	ldr	r3, [pc, #188]	@ (80121cc <RegionEU868NextChannel+0x10c>)
    countChannelsParams.Datarate = nextChanParams->Datarate;
 801210e:	f994 2008 	ldrsb.w	r2, [r4, #8]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 8012112:	681b      	ldr	r3, [r3, #0]
 8012114:	930b      	str	r3, [sp, #44]	@ 0x2c
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8012116:	ab11      	add	r3, sp, #68	@ 0x44
 8012118:	e883 0003 	stmia.w	r3, {r0, r1}
    countChannelsParams.Joined = nextChanParams->Joined;
 801211c:	7a63      	ldrb	r3, [r4, #9]
 801211e:	f88d 3020 	strb.w	r3, [sp, #32]
    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 8012122:	6863      	ldr	r3, [r4, #4]
 8012124:	930f      	str	r3, [sp, #60]	@ 0x3c
 8012126:	6823      	ldr	r3, [r4, #0]
 8012128:	930e      	str	r3, [sp, #56]	@ 0x38
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 801212a:	7aa3      	ldrb	r3, [r4, #10]
 801212c:	f88d 3040 	strb.w	r3, [sp, #64]	@ 0x40
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8012130:	7d23      	ldrb	r3, [r4, #20]
 8012132:	f88d 304c 	strb.w	r3, [sp, #76]	@ 0x4c
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 8012136:	2310      	movs	r3, #16
 8012138:	f8ad 3030 	strh.w	r3, [sp, #48]	@ 0x30
    countChannelsParams.JoinChannels = &joinChannels;
 801213c:	f10d 030e 	add.w	r3, sp, #14
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8012140:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.JoinChannels = &joinChannels;
 8012142:	930d      	str	r3, [sp, #52]	@ 0x34
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8012144:	4610      	mov	r0, r2
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 8012146:	2306      	movs	r3, #6
    countChannelsParams.Datarate = nextChanParams->Datarate;
 8012148:	f88d 2021 	strb.w	r2, [sp, #33]	@ 0x21
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 801214c:	f88d 3041 	strb.w	r3, [sp, #65]	@ 0x41
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8012150:	f7ff f8d0 	bl	80112f4 <GetTimeOnAir>
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8012154:	f10d 030d 	add.w	r3, sp, #13
    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 8012158:	aa08      	add	r2, sp, #32
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 801215a:	9300      	str	r3, [sp, #0]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 801215c:	9014      	str	r0, [sp, #80]	@ 0x50
    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 801215e:	9215      	str	r2, [sp, #84]	@ 0x54
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8012160:	f8cd 8004 	str.w	r8, [sp, #4]
 8012164:	ab03      	add	r3, sp, #12
 8012166:	4631      	mov	r1, r6
 8012168:	aa04      	add	r2, sp, #16
 801216a:	a80e      	add	r0, sp, #56	@ 0x38
 801216c:	f7fe ffe8 	bl	8011140 <RegionCommonIdentifyChannels>
    if( status == LORAMAC_STATUS_OK )
 8012170:	4604      	mov	r4, r0
 8012172:	b1c0      	cbz	r0, 80121a6 <RegionEU868NextChannel+0xe6>
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 8012174:	280c      	cmp	r0, #12
 8012176:	d003      	beq.n	8012180 <RegionEU868NextChannel+0xc0>
}
 8012178:	4620      	mov	r0, r4
 801217a:	b016      	add	sp, #88	@ 0x58
 801217c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8012180:	682a      	ldr	r2, [r5, #0]
 8012182:	f8b2 3480 	ldrh.w	r3, [r2, #1152]	@ 0x480
}
 8012186:	4620      	mov	r0, r4
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8012188:	f043 0307 	orr.w	r3, r3, #7
 801218c:	f8a2 3480 	strh.w	r3, [r2, #1152]	@ 0x480
}
 8012190:	b016      	add	sp, #88	@ 0x58
 8012192:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8012196:	6828      	ldr	r0, [r5, #0]
 8012198:	f8b0 3480 	ldrh.w	r3, [r0, #1152]	@ 0x480
 801219c:	f043 0307 	orr.w	r3, r3, #7
 80121a0:	f8a0 3480 	strh.w	r3, [r0, #1152]	@ 0x480
 80121a4:	e7aa      	b.n	80120fc <RegionEU868NextChannel+0x3c>
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 80121a6:	f89d 100c 	ldrb.w	r1, [sp, #12]
 80121aa:	3901      	subs	r1, #1
 80121ac:	f000 f84a 	bl	8012244 <randr>
 80121b0:	f100 0358 	add.w	r3, r0, #88	@ 0x58
 80121b4:	eb0d 0003 	add.w	r0, sp, r3
 80121b8:	f810 3c48 	ldrb.w	r3, [r0, #-72]
 80121bc:	703b      	strb	r3, [r7, #0]
}
 80121be:	4620      	mov	r0, r4
 80121c0:	b016      	add	sp, #88	@ 0x58
 80121c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80121c6:	bf00      	nop
 80121c8:	2000141c 	.word	0x2000141c
 80121cc:	20001420 	.word	0x20001420

080121d0 <RegionEU868SetContinuousWave>:
#endif /* REGION_EU868 */
}

#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 80121d0:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 80121d2:	4d13      	ldr	r5, [pc, #76]	@ (8012220 <RegionEU868SetContinuousWave+0x50>)
 80121d4:	7803      	ldrb	r3, [r0, #0]
 80121d6:	682a      	ldr	r2, [r5, #0]
 80121d8:	4912      	ldr	r1, [pc, #72]	@ (8012224 <RegionEU868SetContinuousWave+0x54>)
 80121da:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80121de:	eb02 0283 	add.w	r2, r2, r3, lsl #2
{
 80121e2:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 80121e4:	7a53      	ldrb	r3, [r2, #9]
 80121e6:	680a      	ldr	r2, [r1, #0]
 80121e8:	f990 0002 	ldrsb.w	r0, [r0, #2]
 80121ec:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80121f0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80121f4:	f993 1002 	ldrsb.w	r1, [r3, #2]
 80121f8:	f7ff f834 	bl	8011264 <RegionCommonLimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 80121fc:	7823      	ldrb	r3, [r4, #0]
 80121fe:	6829      	ldr	r1, [r5, #0]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8012200:	68a2      	ldr	r2, [r4, #8]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8012202:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8012206:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 801220a:	6861      	ldr	r1, [r4, #4]
 801220c:	f7fe ff20 	bl	8011050 <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8012210:	4b05      	ldr	r3, [pc, #20]	@ (8012228 <RegionEU868SetContinuousWave+0x58>)
 8012212:	89a2      	ldrh	r2, [r4, #12]
 8012214:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8012216:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8012218:	4628      	mov	r0, r5
#endif /* REGION_EU868 */
}
 801221a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 801221e:	4718      	bx	r3
 8012220:	2000141c 	.word	0x2000141c
 8012224:	20001420 	.word	0x20001420
 8012228:	08017658 	.word	0x08017658

0801222c <RegionEU868ApplyDrOffset>:
#endif /* REGION_VERSION */

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 801222c:	1a88      	subs	r0, r1, r2

    if( datarate < 0 )
 801222e:	b240      	sxtb	r0, r0
 8012230:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    }
    return datarate;
#else
    return 0;
#endif /* REGION_EU868 */
}
 8012234:	b2c0      	uxtb	r0, r0
 8012236:	4770      	bx	lr

08012238 <srand1>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
}

void srand1( uint32_t seed )
{
    next = seed;
 8012238:	4b01      	ldr	r3, [pc, #4]	@ (8012240 <srand1+0x8>)
 801223a:	6018      	str	r0, [r3, #0]
}
 801223c:	4770      	bx	lr
 801223e:	bf00      	nop
 8012240:	2000010c 	.word	0x2000010c

08012244 <randr>:
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 8012244:	b430      	push	{r4, r5}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8012246:	4c0d      	ldr	r4, [pc, #52]	@ (801227c <randr+0x38>)
 8012248:	4d0d      	ldr	r5, [pc, #52]	@ (8012280 <randr+0x3c>)
 801224a:	6822      	ldr	r2, [r4, #0]
 801224c:	f243 0339 	movw	r3, #12345	@ 0x3039
 8012250:	fb05 3302 	mla	r3, r5, r2, r3
 8012254:	2203      	movs	r2, #3
 8012256:	fba2 5203 	umull	r5, r2, r2, r3
 801225a:	6023      	str	r3, [r4, #0]
 801225c:	1a9c      	subs	r4, r3, r2
 801225e:	eb02 0254 	add.w	r2, r2, r4, lsr #1
 8012262:	0f92      	lsrs	r2, r2, #30
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8012264:	1a09      	subs	r1, r1, r0
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8012266:	ebc2 72c2 	rsb	r2, r2, r2, lsl #31
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 801226a:	3101      	adds	r1, #1
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 801226c:	1a9b      	subs	r3, r3, r2
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 801226e:	fb93 f2f1 	sdiv	r2, r3, r1
 8012272:	fb01 3312 	mls	r3, r1, r2, r3
}
 8012276:	4418      	add	r0, r3
 8012278:	bc30      	pop	{r4, r5}
 801227a:	4770      	bx	lr
 801227c:	2000010c 	.word	0x2000010c
 8012280:	41c64e6d 	.word	0x41c64e6d

08012284 <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 8012284:	2a00      	cmp	r2, #0
 8012286:	d049      	beq.n	801231c <memcpy1+0x98>
 8012288:	f102 3cff 	add.w	ip, r2, #4294967295
 801228c:	fa1f fc8c 	uxth.w	ip, ip
 8012290:	f1bc 0f05 	cmp.w	ip, #5
 8012294:	d935      	bls.n	8012302 <memcpy1+0x7e>
 8012296:	1c4b      	adds	r3, r1, #1
{
 8012298:	b530      	push	{r4, r5, lr}
 801229a:	1ac4      	subs	r4, r0, r3
 801229c:	2c02      	cmp	r4, #2
 801229e:	d80c      	bhi.n	80122ba <memcpy1+0x36>
 80122a0:	f10c 0c01 	add.w	ip, ip, #1
 80122a4:	3801      	subs	r0, #1
 80122a6:	4461      	add	r1, ip
 80122a8:	e000      	b.n	80122ac <memcpy1+0x28>
 80122aa:	3301      	adds	r3, #1
    {
        *dst++ = *src++;
 80122ac:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 80122b0:	f800 2f01 	strb.w	r2, [r0, #1]!
    while( size-- )
 80122b4:	4299      	cmp	r1, r3
 80122b6:	d1f8      	bne.n	80122aa <memcpy1+0x26>
    }
}
 80122b8:	bd30      	pop	{r4, r5, pc}
 80122ba:	0895      	lsrs	r5, r2, #2
 80122bc:	460b      	mov	r3, r1
 80122be:	eb01 0585 	add.w	r5, r1, r5, lsl #2
 80122c2:	4686      	mov	lr, r0
        *dst++ = *src++;
 80122c4:	f853 4b04 	ldr.w	r4, [r3], #4
 80122c8:	f84e 4b04 	str.w	r4, [lr], #4
    while( size-- )
 80122cc:	42ab      	cmp	r3, r5
 80122ce:	d1f9      	bne.n	80122c4 <memcpy1+0x40>
 80122d0:	f022 0403 	bic.w	r4, r2, #3
 80122d4:	ebac 0c04 	sub.w	ip, ip, r4
 80122d8:	0792      	lsls	r2, r2, #30
 80122da:	fa1f f38c 	uxth.w	r3, ip
 80122de:	b2a5      	uxth	r5, r4
 80122e0:	eb00 0c04 	add.w	ip, r0, r4
 80122e4:	440c      	add	r4, r1
 80122e6:	d0e7      	beq.n	80122b8 <memcpy1+0x34>
        *dst++ = *src++;
 80122e8:	5d4a      	ldrb	r2, [r1, r5]
 80122ea:	5542      	strb	r2, [r0, r5]
    while( size-- )
 80122ec:	2b00      	cmp	r3, #0
 80122ee:	d0e3      	beq.n	80122b8 <memcpy1+0x34>
        *dst++ = *src++;
 80122f0:	7862      	ldrb	r2, [r4, #1]
 80122f2:	f88c 2001 	strb.w	r2, [ip, #1]
    while( size-- )
 80122f6:	2b01      	cmp	r3, #1
 80122f8:	d0de      	beq.n	80122b8 <memcpy1+0x34>
        *dst++ = *src++;
 80122fa:	78a3      	ldrb	r3, [r4, #2]
 80122fc:	f88c 3002 	strb.w	r3, [ip, #2]
}
 8012300:	bd30      	pop	{r4, r5, pc}
 8012302:	f10c 0c01 	add.w	ip, ip, #1
 8012306:	1c4b      	adds	r3, r1, #1
 8012308:	3801      	subs	r0, #1
 801230a:	4461      	add	r1, ip
 801230c:	e000      	b.n	8012310 <memcpy1+0x8c>
 801230e:	3301      	adds	r3, #1
        *dst++ = *src++;
 8012310:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 8012314:	f800 2f01 	strb.w	r2, [r0, #1]!
    while( size-- )
 8012318:	4299      	cmp	r1, r3
 801231a:	d1f8      	bne.n	801230e <memcpy1+0x8a>
 801231c:	4770      	bx	lr
 801231e:	bf00      	nop

08012320 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
    while( size-- )
 8012320:	1e53      	subs	r3, r2, #1
 8012322:	b29b      	uxth	r3, r3
 8012324:	b142      	cbz	r2, 8012338 <memcpyr+0x18>
 8012326:	3301      	adds	r3, #1
 8012328:	4410      	add	r0, r2
 801232a:	18ca      	adds	r2, r1, r3
    {
        *dst-- = *src++;
 801232c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8012330:	f800 3d01 	strb.w	r3, [r0, #-1]!
    while( size-- )
 8012334:	4291      	cmp	r1, r2
 8012336:	d1f9      	bne.n	801232c <memcpyr+0xc>
    }
}
 8012338:	4770      	bx	lr
 801233a:	bf00      	nop

0801233c <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 801233c:	b10a      	cbz	r2, 8012342 <memset1+0x6>
    {
        *dst++ = value;
 801233e:	f003 bec3 	b.w	80160c8 <memset>
    }
}
 8012342:	4770      	bx	lr

08012344 <Crc32>:
uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 8012344:	b3a8      	cbz	r0, 80123b2 <Crc32+0x6e>
    {
        return 0;
    }

    for( uint16_t i = 0; i < length; ++i )
 8012346:	b399      	cbz	r1, 80123b0 <Crc32+0x6c>
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8012348:	4b1a      	ldr	r3, [pc, #104]	@ (80123b4 <Crc32+0x70>)
 801234a:	eb00 0c01 	add.w	ip, r0, r1
    uint32_t crc = 0xFFFFFFFF;
 801234e:	f04f 32ff 	mov.w	r2, #4294967295
        crc ^= ( uint32_t )buffer[i];
 8012352:	f810 1b01 	ldrb.w	r1, [r0], #1
 8012356:	4051      	eors	r1, r2
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8012358:	f341 0200 	sbfx	r2, r1, #0, #1
 801235c:	401a      	ands	r2, r3
 801235e:	ea82 0251 	eor.w	r2, r2, r1, lsr #1
 8012362:	f342 0100 	sbfx	r1, r2, #0, #1
 8012366:	4019      	ands	r1, r3
 8012368:	ea81 0152 	eor.w	r1, r1, r2, lsr #1
 801236c:	f341 0200 	sbfx	r2, r1, #0, #1
 8012370:	401a      	ands	r2, r3
 8012372:	ea82 0251 	eor.w	r2, r2, r1, lsr #1
 8012376:	f342 0100 	sbfx	r1, r2, #0, #1
 801237a:	4019      	ands	r1, r3
 801237c:	ea81 0152 	eor.w	r1, r1, r2, lsr #1
 8012380:	f341 0200 	sbfx	r2, r1, #0, #1
 8012384:	401a      	ands	r2, r3
 8012386:	ea82 0251 	eor.w	r2, r2, r1, lsr #1
 801238a:	f342 0100 	sbfx	r1, r2, #0, #1
 801238e:	4019      	ands	r1, r3
 8012390:	ea81 0152 	eor.w	r1, r1, r2, lsr #1
 8012394:	f341 0200 	sbfx	r2, r1, #0, #1
 8012398:	401a      	ands	r2, r3
 801239a:	ea82 0251 	eor.w	r2, r2, r1, lsr #1
 801239e:	f342 0100 	sbfx	r1, r2, #0, #1
 80123a2:	4019      	ands	r1, r3
    for( uint16_t i = 0; i < length; ++i )
 80123a4:	4584      	cmp	ip, r0
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 80123a6:	ea81 0252 	eor.w	r2, r1, r2, lsr #1
    for( uint16_t i = 0; i < length; ++i )
 80123aa:	d1d2      	bne.n	8012352 <Crc32+0xe>
        }
    }

    return ~crc;
 80123ac:	43d0      	mvns	r0, r2
 80123ae:	4770      	bx	lr
    for( uint16_t i = 0; i < length; ++i )
 80123b0:	4608      	mov	r0, r1
}
 80123b2:	4770      	bx	lr
 80123b4:	edb88320 	.word	0xedb88320

080123b8 <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 80123b8:	2001      	movs	r0, #1
 80123ba:	4770      	bx	lr

080123bc <RadioTimeOnAir>:

static uint32_t RadioTimeOnAir( RadioModems_t modem, uint32_t bandwidth,
                                uint32_t datarate, uint8_t coderate,
                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                bool crcOn )
{
 80123bc:	b530      	push	{r4, r5, lr}
 80123be:	f8bd c00c 	ldrh.w	ip, [sp, #12]
 80123c2:	f89d 5010 	ldrb.w	r5, [sp, #16]
 80123c6:	f89d 4014 	ldrb.w	r4, [sp, #20]
 80123ca:	f89d e018 	ldrb.w	lr, [sp, #24]
    uint32_t numerator = 0;
    uint32_t denominator = 1;

    switch( modem )
 80123ce:	b380      	cbz	r0, 8012432 <RadioTimeOnAir+0x76>
 80123d0:	2801      	cmp	r0, #1
 80123d2:	d12c      	bne.n	801242e <RadioTimeOnAir+0x72>
                            ( crcOn ? 16 : 0 ) -
 80123d4:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 80123d8:	1f50      	subs	r0, r2, #5
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 80123da:	eb0e 0ec4 	add.w	lr, lr, r4, lsl #3
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 80123de:	2801      	cmp	r0, #1
    int32_t crDenom           = coderate + 4;
 80123e0:	f103 0304 	add.w	r3, r3, #4
                            ( crcOn ? 16 : 0 ) -
 80123e4:	ebae 0e82 	sub.w	lr, lr, r2, lsl #2
                            ( 4 * datarate ) +
 80123e8:	ea4f 0482 	mov.w	r4, r2, lsl #2
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 80123ec:	d935      	bls.n	801245a <RadioTimeOnAir+0x9e>
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80123ee:	2900      	cmp	r1, #0
 80123f0:	d158      	bne.n	80124a4 <RadioTimeOnAir+0xe8>
 80123f2:	f1a2 000b 	sub.w	r0, r2, #11
 80123f6:	2801      	cmp	r0, #1
 80123f8:	bf8c      	ite	hi
 80123fa:	2000      	movhi	r0, #0
 80123fc:	2001      	movls	r0, #1
                            ( fixLen ? 0 : 20 );
 80123fe:	b90d      	cbnz	r5, 8012404 <RadioTimeOnAir+0x48>
                            ( 4 * datarate ) +
 8012400:	f10e 0e14 	add.w	lr, lr, #20
    if( datarate <= 6 )
 8012404:	2a06      	cmp	r2, #6
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 8012406:	4675      	mov	r5, lr
    if( datarate <= 6 )
 8012408:	d92f      	bls.n	801246a <RadioTimeOnAir+0xae>
            ceilDenominator = 4 * ( datarate - 2 );
 801240a:	3a02      	subs	r2, #2
        ceilNumerator += 8;
 801240c:	f10e 0e08 	add.w	lr, lr, #8
        if( lowDatareOptimize == true )
 8012410:	b100      	cbz	r0, 8012414 <RadioTimeOnAir+0x58>
            ceilDenominator = 4 * ( datarate - 2 );
 8012412:	0094      	lsls	r4, r2, #2
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 8012414:	f1be 0f00 	cmp.w	lr, #0
 8012418:	bfac      	ite	ge
 801241a:	eb04 000e 	addge.w	r0, r4, lr
 801241e:	1c20      	addlt	r0, r4, #0
 8012420:	3801      	subs	r0, #1
 8012422:	fb90 f0f4 	sdiv	r0, r0, r4
 8012426:	fb03 c300 	mla	r3, r3, r0, ip
    int32_t intermediate =
 801242a:	330c      	adds	r3, #12
    if( datarate <= 6 )
 801242c:	e028      	b.n	8012480 <RadioTimeOnAir+0xc4>
    switch( modem )
 801242e:	2000      	movs	r0, #0
    default:
        break;
    }
    // Perform integral ceil()
    return DIVC( numerator, denominator );
}
 8012430:	bd30      	pop	{r4, r5, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8012432:	f085 0501 	eor.w	r5, r5, #1
    return ( preambleLen << 3 ) +
 8012436:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801243a:	eb0c 0cc5 	add.w	ip, ip, r5, lsl #3
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 801243e:	eb04 044e 	add.w	r4, r4, lr, lsl #1
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8012442:	f10c 0c18 	add.w	ip, ip, #24
 8012446:	eb0c 0cc4 	add.w	ip, ip, r4, lsl #3
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 801244a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
    return DIVC( numerator, denominator );
 801244e:	1e50      	subs	r0, r2, #1
 8012450:	fb03 000c 	mla	r0, r3, ip, r0
 8012454:	fbb0 f0f2 	udiv	r0, r0, r2
}
 8012458:	bd30      	pop	{r4, r5, pc}
        if( preambleLen < 12 )
 801245a:	f1bc 0f0c 	cmp.w	ip, #12
 801245e:	bf38      	it	cc
 8012460:	f04f 0c0c 	movcc.w	ip, #12
                            ( fixLen ? 0 : 20 );
 8012464:	bb3d      	cbnz	r5, 80124b6 <RadioTimeOnAir+0xfa>
                            ( 4 * datarate ) +
 8012466:	f10e 0514 	add.w	r5, lr, #20
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 801246a:	2d00      	cmp	r5, #0
 801246c:	bfac      	ite	ge
 801246e:	1960      	addge	r0, r4, r5
 8012470:	1c20      	addlt	r0, r4, #0
 8012472:	3801      	subs	r0, #1
 8012474:	fb90 f0f4 	sdiv	r0, r0, r4
 8012478:	fb03 c300 	mla	r3, r3, r0, ip
        intermediate += 2;
 801247c:	330e      	adds	r3, #14
            ceilDenominator = 4 * ( datarate - 2 );
 801247e:	3a02      	subs	r2, #2
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 8012480:	480e      	ldr	r0, [pc, #56]	@ (80124bc <RadioTimeOnAir+0x100>)
 8012482:	5c41      	ldrb	r1, [r0, r1]
    switch( bw )
 8012484:	290a      	cmp	r1, #10
 8012486:	d818      	bhi.n	80124ba <RadioTimeOnAir+0xfe>
 8012488:	480d      	ldr	r0, [pc, #52]	@ (80124c0 <RadioTimeOnAir+0x104>)
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 801248a:	009b      	lsls	r3, r3, #2
 801248c:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 8012490:	3301      	adds	r3, #1
 8012492:	4093      	lsls	r3, r2
    return DIVC( numerator, denominator );
 8012494:	1e48      	subs	r0, r1, #1
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 8012496:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
    return DIVC( numerator, denominator );
 801249a:	fb02 0003 	mla	r0, r2, r3, r0
 801249e:	fbb0 f0f1 	udiv	r0, r0, r1
}
 80124a2:	bd30      	pop	{r4, r5, pc}
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80124a4:	2901      	cmp	r1, #1
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 80124a6:	bf03      	ittte	eq
 80124a8:	f1a2 000c 	subeq.w	r0, r2, #12
 80124ac:	fab0 f080 	clzeq	r0, r0
 80124b0:	0940      	lsreq	r0, r0, #5
    bool    lowDatareOptimize = false;
 80124b2:	2000      	movne	r0, #0
 80124b4:	e7a3      	b.n	80123fe <RadioTimeOnAir+0x42>
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 80124b6:	4675      	mov	r5, lr
    if( datarate <= 6 )
 80124b8:	e7d7      	b.n	801246a <RadioTimeOnAir+0xae>
    return DIVC( numerator, denominator );
 80124ba:	deff      	udf	#255	@ 0xff
 80124bc:	08017654 	.word	0x08017654
 80124c0:	08017628 	.word	0x08017628

080124c4 <RadioOnTxTimeoutIrq>:

static void RadioOnTxTimeoutProcess( void )
{
    DBG_GPIO_RADIO_TX( RST );

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 80124c4:	4b03      	ldr	r3, [pc, #12]	@ (80124d4 <RadioOnTxTimeoutIrq+0x10>)
 80124c6:	681b      	ldr	r3, [r3, #0]
 80124c8:	b113      	cbz	r3, 80124d0 <RadioOnTxTimeoutIrq+0xc>
 80124ca:	685b      	ldr	r3, [r3, #4]
 80124cc:	b103      	cbz	r3, 80124d0 <RadioOnTxTimeoutIrq+0xc>
    {
        RadioEvents->TxTimeout( );
 80124ce:	4718      	bx	r3
}
 80124d0:	4770      	bx	lr
 80124d2:	bf00      	nop
 80124d4:	200014b0 	.word	0x200014b0

080124d8 <RadioOnRxTimeoutIrq>:

static void RadioOnRxTimeoutProcess( void )
{
    DBG_GPIO_RADIO_RX( RST );

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 80124d8:	4b03      	ldr	r3, [pc, #12]	@ (80124e8 <RadioOnRxTimeoutIrq+0x10>)
 80124da:	681b      	ldr	r3, [r3, #0]
 80124dc:	b113      	cbz	r3, 80124e4 <RadioOnRxTimeoutIrq+0xc>
 80124de:	68db      	ldr	r3, [r3, #12]
 80124e0:	b103      	cbz	r3, 80124e4 <RadioOnRxTimeoutIrq+0xc>
    {
        RadioEvents->RxTimeout( );
 80124e2:	4718      	bx	r3
}
 80124e4:	4770      	bx	lr
 80124e6:	bf00      	nop
 80124e8:	200014b0 	.word	0x200014b0

080124ec <RadioLrFhssSetCfg>:
        return status;
    }
    SubgRf.lr_fhss.is_lr_fhss_on = true;
#endif /* RADIO_LR_FHSS_IS_ON == 1 */
    return  status;
}
 80124ec:	2001      	movs	r0, #1
 80124ee:	4770      	bx	lr

080124f0 <RadioLrFhssGetTimeOnAirInMs>:

    return RADIO_STATUS_OK;
#else
    return RADIO_STATUS_UNSUPPORTED_FEATURE;
#endif /* RADIO_LR_FHSS_IS_ON */
 80124f0:	2001      	movs	r0, #1
 80124f2:	4770      	bx	lr

080124f4 <RadioRead>:
    return SUBGRF_ReadRegister( addr );
 80124f4:	f002 ba20 	b.w	8014938 <SUBGRF_ReadRegister>

080124f8 <RadioWrite>:
    SUBGRF_WriteRegister( addr, data );
 80124f8:	f002 ba0c 	b.w	8014914 <SUBGRF_WriteRegister>

080124fc <RadioTxCw>:
{
 80124fc:	b510      	push	{r4, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 80124fe:	f002 fa83 	bl	8014a08 <SUBGRF_SetRfTxPower>
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8012502:	210e      	movs	r1, #14
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 8012504:	4604      	mov	r4, r0
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8012506:	f640 101f 	movw	r0, #2335	@ 0x91f
 801250a:	f002 fa03 	bl	8014914 <SUBGRF_WriteRegister>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 801250e:	4620      	mov	r0, r4
 8012510:	2101      	movs	r1, #1
 8012512:	f002 fa41 	bl	8014998 <SUBGRF_SetSwitch>
}
 8012516:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_SetTxContinuousWave( );
 801251a:	f001 bdfd 	b.w	8014118 <SUBGRF_SetTxContinuousWave>
 801251e:	bf00      	nop

08012520 <RadioSetRxDutyCycle>:
{
 8012520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012522:	4604      	mov	r4, r0
 8012524:	460d      	mov	r5, r1
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8012526:	2300      	movs	r3, #0
    SubgRf.RxDcPreambleDetectTimeout = 2 * rxTime + sleepTime;
 8012528:	4e0a      	ldr	r6, [pc, #40]	@ (8012554 <RadioSetRxDutyCycle+0x34>)
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 801252a:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 801252e:	4608      	mov	r0, r1
 8012530:	461a      	mov	r2, r3
    SubgRf.RxDcPreambleDetectTimeout = 2 * rxTime + sleepTime;
 8012532:	eb05 0744 	add.w	r7, r5, r4, lsl #1
 8012536:	65b7      	str	r7, [r6, #88]	@ 0x58
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8012538:	f001 fe66 	bl	8014208 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 801253c:	f896 0056 	ldrb.w	r0, [r6, #86]	@ 0x56
 8012540:	2100      	movs	r1, #0
 8012542:	f002 fa29 	bl	8014998 <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8012546:	4629      	mov	r1, r5
 8012548:	4620      	mov	r0, r4
}
 801254a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 801254e:	f001 bda9 	b.w	80140a4 <SUBGRF_SetRxDutyCycle>
 8012552:	bf00      	nop
 8012554:	20001454 	.word	0x20001454

08012558 <RadioStandby>:
    SUBGRF_SetStandby( STDBY_RC );
 8012558:	2000      	movs	r0, #0
 801255a:	f001 bd1f 	b.w	8013f9c <SUBGRF_SetStandby>
 801255e:	bf00      	nop

08012560 <RadioGetStatus>:
{
 8012560:	b508      	push	{r3, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 8012562:	f001 fb91 	bl	8013c88 <SUBGRF_GetOperatingMode>
 8012566:	3804      	subs	r0, #4
 8012568:	b2c0      	uxtb	r0, r0
 801256a:	2803      	cmp	r0, #3
 801256c:	bf96      	itet	ls
 801256e:	4b02      	ldrls	r3, [pc, #8]	@ (8012578 <RadioGetStatus+0x18>)
 8012570:	2000      	movhi	r0, #0
 8012572:	5c18      	ldrbls	r0, [r3, r0]
}
 8012574:	bd08      	pop	{r3, pc}
 8012576:	bf00      	nop
 8012578:	08017624 	.word	0x08017624

0801257c <RadioGetWakeupTime>:
{
 801257c:	b508      	push	{r3, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 801257e:	f002 fa5f 	bl	8014a40 <SUBGRF_GetRadioWakeUpTime>
}
 8012582:	3003      	adds	r0, #3
 8012584:	bd08      	pop	{r3, pc}
 8012586:	bf00      	nop

08012588 <RadioReadRegisters>:
    SUBGRF_ReadRegisters( addr, buffer, size );
 8012588:	f002 b9f6 	b.w	8014978 <SUBGRF_ReadRegisters>

0801258c <RadioWriteRegisters>:
    SUBGRF_WriteRegisters( addr, buffer, size );
 801258c:	f002 b9e4 	b.w	8014958 <SUBGRF_WriteRegisters>

08012590 <RadioRssi>:
{
 8012590:	b508      	push	{r3, lr}
    return SUBGRF_GetRssiInst( );
 8012592:	f002 f961 	bl	8014858 <SUBGRF_GetRssiInst>
}
 8012596:	bd08      	pop	{r3, pc}

08012598 <RadioSetTxContinuousWave>:
{
 8012598:	b570      	push	{r4, r5, r6, lr}
 801259a:	460d      	mov	r5, r1
 801259c:	4614      	mov	r4, r2
    SUBGRF_SetRfFrequency( freq );
 801259e:	f001 fe5f 	bl	8014260 <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 80125a2:	4628      	mov	r0, r5
 80125a4:	f002 fa30 	bl	8014a08 <SUBGRF_SetRfTxPower>
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 80125a8:	210e      	movs	r1, #14
    antswitchpow = SUBGRF_SetRfTxPower( power );
 80125aa:	4605      	mov	r5, r0
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 80125ac:	f640 101f 	movw	r0, #2335	@ 0x91f
 80125b0:	f002 f9b0 	bl	8014914 <SUBGRF_WriteRegister>
    TimerSetValue( &TxTimeoutTimer, timeout );
 80125b4:	4e09      	ldr	r6, [pc, #36]	@ (80125dc <RadioSetTxContinuousWave+0x44>)
    SUBGRF_SetSwitch( antswitchpow, RFSWITCH_TX );
 80125b6:	4628      	mov	r0, r5
 80125b8:	2101      	movs	r1, #1
 80125ba:	f002 f9ed 	bl	8014998 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 80125be:	f001 fdab 	bl	8014118 <SUBGRF_SetTxContinuousWave>
    uint32_t timeout = ( uint32_t )time * 1000;
 80125c2:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
    TimerSetValue( &TxTimeoutTimer, timeout );
 80125c6:	fb04 f101 	mul.w	r1, r4, r1
 80125ca:	4630      	mov	r0, r6
 80125cc:	f003 f8d8 	bl	8015780 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 80125d0:	4630      	mov	r0, r6
}
 80125d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TimerStart( &TxTimeoutTimer );
 80125d6:	f003 b877 	b.w	80156c8 <UTIL_TIMER_Start>
 80125da:	bf00      	nop
 80125dc:	2000143c 	.word	0x2000143c

080125e0 <RadioSetChannel>:
    SUBGRF_SetRfFrequency( freq );
 80125e0:	f001 be3e 	b.w	8014260 <SUBGRF_SetRfFrequency>

080125e4 <RadioStartCad>:
{
 80125e4:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 80125e6:	4b08      	ldr	r3, [pc, #32]	@ (8012608 <RadioStartCad+0x24>)
 80125e8:	2100      	movs	r1, #0
 80125ea:	f893 0056 	ldrb.w	r0, [r3, #86]	@ 0x56
 80125ee:	f002 f9d3 	bl	8014998 <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 80125f2:	2300      	movs	r3, #0
 80125f4:	f44f 71c0 	mov.w	r1, #384	@ 0x180
 80125f8:	461a      	mov	r2, r3
 80125fa:	4608      	mov	r0, r1
 80125fc:	f001 fe04 	bl	8014208 <SUBGRF_SetDioIrqParams>
}
 8012600:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetCad( );
 8012604:	f001 bd74 	b.w	80140f0 <SUBGRF_SetCad>
 8012608:	20001454 	.word	0x20001454

0801260c <RadioSleep>:
{
 801260c:	b508      	push	{r3, lr}
    SUBGRF_SetSleep( params );
 801260e:	f04f 0004 	mov.w	r0, #4
 8012612:	f001 fc85 	bl	8013f20 <SUBGRF_SetSleep>
}
 8012616:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RADIO_DELAY_MS( 2 );
 801261a:	2002      	movs	r0, #2
 801261c:	f7ef badc 	b.w	8001bd8 <HAL_Delay>

08012620 <RadioRandom>:
{
 8012620:	b508      	push	{r3, lr}
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8012622:	2300      	movs	r3, #0
 8012624:	461a      	mov	r2, r3
 8012626:	4619      	mov	r1, r3
 8012628:	4618      	mov	r0, r3
 801262a:	f001 fded 	bl	8014208 <SUBGRF_SetDioIrqParams>
}
 801262e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    rnd = SUBGRF_GetRandom();
 8012632:	f001 bbf9 	b.w	8013e28 <SUBGRF_GetRandom>
 8012636:	bf00      	nop

08012638 <RadioSetMaxPayloadLength>:
    if( modem == MODEM_LORA )
 8012638:	2801      	cmp	r0, #1
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 801263a:	4b0a      	ldr	r3, [pc, #40]	@ (8012664 <RadioSetMaxPayloadLength+0x2c>)
    if( modem == MODEM_LORA )
 801263c:	d003      	beq.n	8012646 <RadioSetMaxPayloadLength+0xe>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 801263e:	7d5a      	ldrb	r2, [r3, #21]
 8012640:	2a01      	cmp	r2, #1
 8012642:	d007      	beq.n	8012654 <RadioSetMaxPayloadLength+0x1c>
}
 8012644:	4770      	bx	lr
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 8012646:	4a08      	ldr	r2, [pc, #32]	@ (8012668 <RadioSetMaxPayloadLength+0x30>)
 8012648:	77d9      	strb	r1, [r3, #31]
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 801264a:	f103 000e 	add.w	r0, r3, #14
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 801264e:	7011      	strb	r1, [r2, #0]
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8012650:	f002 b818 	b.w	8014684 <SUBGRF_SetPacketParams>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 8012654:	4a04      	ldr	r2, [pc, #16]	@ (8012668 <RadioSetMaxPayloadLength+0x30>)
 8012656:	7599      	strb	r1, [r3, #22]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8012658:	f103 000e 	add.w	r0, r3, #14
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 801265c:	7011      	strb	r1, [r2, #0]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 801265e:	f002 b811 	b.w	8014684 <SUBGRF_SetPacketParams>
 8012662:	bf00      	nop
 8012664:	20001454 	.word	0x20001454
 8012668:	20000110 	.word	0x20000110

0801266c <RadioRxBoosted>:
{
 801266c:	b510      	push	{r4, lr}
 801266e:	4604      	mov	r4, r0
    if( 1UL == RFW_Is_Init() )
 8012670:	f002 faa8 	bl	8014bc4 <RFW_Is_Init>
 8012674:	2801      	cmp	r0, #1
 8012676:	d01c      	beq.n	80126b2 <RadioRxBoosted+0x46>
        SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8012678:	2300      	movs	r3, #0
 801267a:	f240 2162 	movw	r1, #610	@ 0x262
 801267e:	461a      	mov	r2, r3
 8012680:	4608      	mov	r0, r1
 8012682:	f001 fdc1 	bl	8014208 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 8012686:	b9c4      	cbnz	r4, 80126ba <RadioRxBoosted+0x4e>
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8012688:	4c10      	ldr	r4, [pc, #64]	@ (80126cc <RadioRxBoosted+0x60>)
 801268a:	2100      	movs	r1, #0
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 801268c:	f894 0056 	ldrb.w	r0, [r4, #86]	@ 0x56
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8012690:	65a1      	str	r1, [r4, #88]	@ 0x58
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 8012692:	f002 f981 	bl	8014998 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8012696:	7863      	ldrb	r3, [r4, #1]
 8012698:	b12b      	cbz	r3, 80126a6 <RadioRxBoosted+0x3a>
}
 801269a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 801269e:	f06f 407f 	mvn.w	r0, #4278190080	@ 0xff000000
 80126a2:	f001 bcd5 	b.w	8014050 <SUBGRF_SetRxBoosted>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 80126a6:	68a0      	ldr	r0, [r4, #8]
}
 80126a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 80126ac:	0180      	lsls	r0, r0, #6
 80126ae:	f001 bccf 	b.w	8014050 <SUBGRF_SetRxBoosted>
        RFW_ReceiveInit();
 80126b2:	f002 fa91 	bl	8014bd8 <RFW_ReceiveInit>
    if( timeout != 0 )
 80126b6:	2c00      	cmp	r4, #0
 80126b8:	d0e6      	beq.n	8012688 <RadioRxBoosted+0x1c>
        TimerSetValue( &RxTimeoutTimer, timeout );
 80126ba:	4621      	mov	r1, r4
 80126bc:	4804      	ldr	r0, [pc, #16]	@ (80126d0 <RadioRxBoosted+0x64>)
 80126be:	f003 f85f 	bl	8015780 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 80126c2:	4803      	ldr	r0, [pc, #12]	@ (80126d0 <RadioRxBoosted+0x64>)
 80126c4:	f003 f800 	bl	80156c8 <UTIL_TIMER_Start>
 80126c8:	e7de      	b.n	8012688 <RadioRxBoosted+0x1c>
 80126ca:	bf00      	nop
 80126cc:	20001454 	.word	0x20001454
 80126d0:	20001424 	.word	0x20001424

080126d4 <RadioRx>:
{
 80126d4:	b510      	push	{r4, lr}
 80126d6:	4604      	mov	r4, r0
    if( 1UL == RFW_Is_Init( ) )
 80126d8:	f002 fa74 	bl	8014bc4 <RFW_Is_Init>
 80126dc:	2801      	cmp	r0, #1
 80126de:	d01c      	beq.n	801271a <RadioRx+0x46>
        SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 80126e0:	2300      	movs	r3, #0
 80126e2:	f240 2162 	movw	r1, #610	@ 0x262
 80126e6:	461a      	mov	r2, r3
 80126e8:	4608      	mov	r0, r1
 80126ea:	f001 fd8d 	bl	8014208 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 80126ee:	b9c4      	cbnz	r4, 8012722 <RadioRx+0x4e>
    SubgRf.RxDcPreambleDetectTimeout = 0;
 80126f0:	4c10      	ldr	r4, [pc, #64]	@ (8012734 <RadioRx+0x60>)
 80126f2:	2100      	movs	r1, #0
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 80126f4:	f894 0056 	ldrb.w	r0, [r4, #86]	@ 0x56
    SubgRf.RxDcPreambleDetectTimeout = 0;
 80126f8:	65a1      	str	r1, [r4, #88]	@ 0x58
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 80126fa:	f002 f94d 	bl	8014998 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 80126fe:	7863      	ldrb	r3, [r4, #1]
 8012700:	b12b      	cbz	r3, 801270e <RadioRx+0x3a>
}
 8012702:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8012706:	f06f 407f 	mvn.w	r0, #4278190080	@ 0xff000000
 801270a:	f001 bc83 	b.w	8014014 <SUBGRF_SetRx>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 801270e:	68a0      	ldr	r0, [r4, #8]
}
 8012710:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 8012714:	0180      	lsls	r0, r0, #6
 8012716:	f001 bc7d 	b.w	8014014 <SUBGRF_SetRx>
        RFW_ReceiveInit( );
 801271a:	f002 fa5d 	bl	8014bd8 <RFW_ReceiveInit>
    if( timeout != 0 )
 801271e:	2c00      	cmp	r4, #0
 8012720:	d0e6      	beq.n	80126f0 <RadioRx+0x1c>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8012722:	4621      	mov	r1, r4
 8012724:	4804      	ldr	r0, [pc, #16]	@ (8012738 <RadioRx+0x64>)
 8012726:	f003 f82b 	bl	8015780 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 801272a:	4803      	ldr	r0, [pc, #12]	@ (8012738 <RadioRx+0x64>)
 801272c:	f002 ffcc 	bl	80156c8 <UTIL_TIMER_Start>
 8012730:	e7de      	b.n	80126f0 <RadioRx+0x1c>
 8012732:	bf00      	nop
 8012734:	20001454 	.word	0x20001454
 8012738:	20001424 	.word	0x20001424

0801273c <RadioSend>:
{
 801273c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8012740:	2300      	movs	r3, #0
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 8012742:	4c8b      	ldr	r4, [pc, #556]	@ (8012970 <RadioSend+0x234>)
{
 8012744:	460d      	mov	r5, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8012746:	f240 2101 	movw	r1, #513	@ 0x201
 801274a:	461a      	mov	r2, r3
{
 801274c:	b082      	sub	sp, #8
 801274e:	4606      	mov	r6, r0
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8012750:	4608      	mov	r0, r1
 8012752:	f001 fd59 	bl	8014208 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 8012756:	f894 0056 	ldrb.w	r0, [r4, #86]	@ 0x56
 801275a:	2101      	movs	r1, #1
 801275c:	f002 f91c 	bl	8014998 <SUBGRF_SetSwitch>
    if( ( SubgRf.Modem == MODEM_LORA ) && ( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ) )
 8012760:	7823      	ldrb	r3, [r4, #0]
 8012762:	2b01      	cmp	r3, #1
        SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) & ~( 1 << 2 ) );
 8012764:	f640 0089 	movw	r0, #2185	@ 0x889
    if( ( SubgRf.Modem == MODEM_LORA ) && ( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ) )
 8012768:	d104      	bne.n	8012774 <RadioSend+0x38>
 801276a:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 801276e:	2b06      	cmp	r3, #6
 8012770:	f000 80a2 	beq.w	80128b8 <RadioSend+0x17c>
        SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) | ( 1 << 2 ) );
 8012774:	f002 f8e0 	bl	8014938 <SUBGRF_ReadRegister>
 8012778:	f040 0104 	orr.w	r1, r0, #4
 801277c:	b2c9      	uxtb	r1, r1
 801277e:	f640 0089 	movw	r0, #2185	@ 0x889
 8012782:	f002 f8c7 	bl	8014914 <SUBGRF_WriteRegister>
        switch( SubgRf.Modem )
 8012786:	7823      	ldrb	r3, [r4, #0]
 8012788:	2b04      	cmp	r3, #4
 801278a:	d80f      	bhi.n	80127ac <RadioSend+0x70>
 801278c:	e8df f003 	tbb	[pc, r3]
 8012790:	03199119 	.word	0x03199119
 8012794:	21          	.byte	0x21
 8012795:	00          	.byte	0x00
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8012796:	2302      	movs	r3, #2
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8012798:	4876      	ldr	r0, [pc, #472]	@ (8012974 <RadioSend+0x238>)
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 801279a:	73a3      	strb	r3, [r4, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 801279c:	76a5      	strb	r5, [r4, #26]
                SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 801279e:	f001 ff71 	bl	8014684 <SUBGRF_SetPacketParams>
                SUBGRF_SendPayload( buffer, size, 0 );
 80127a2:	2200      	movs	r2, #0
 80127a4:	4629      	mov	r1, r5
 80127a6:	4630      	mov	r0, r6
 80127a8:	f001 fab4 	bl	8013d14 <SUBGRF_SendPayload>
        TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 80127ac:	6861      	ldr	r1, [r4, #4]
 80127ae:	4872      	ldr	r0, [pc, #456]	@ (8012978 <RadioSend+0x23c>)
 80127b0:	f002 ffe6 	bl	8015780 <UTIL_TIMER_SetPeriod>
        TimerStart( &TxTimeoutTimer );
 80127b4:	4870      	ldr	r0, [pc, #448]	@ (8012978 <RadioSend+0x23c>)
 80127b6:	f002 ff87 	bl	80156c8 <UTIL_TIMER_Start>
    return RADIO_STATUS_OK;
 80127ba:	2000      	movs	r0, #0
}
 80127bc:	b002      	add	sp, #8
 80127be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if ( 1UL == RFW_Is_Init( ) )
 80127c2:	f002 f9ff 	bl	8014bc4 <RFW_Is_Init>
 80127c6:	2801      	cmp	r0, #1
 80127c8:	4607      	mov	r7, r0
 80127ca:	d07e      	beq.n	80128ca <RadioSend+0x18e>
                SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80127cc:	4869      	ldr	r0, [pc, #420]	@ (8012974 <RadioSend+0x238>)
                SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 80127ce:	75a5      	strb	r5, [r4, #22]
 80127d0:	e7e5      	b.n	801279e <RadioSend+0x62>
    for( i = 0; i < size; i++ )
 80127d2:	2d00      	cmp	r5, #0
 80127d4:	f000 80c1 	beq.w	801295a <RadioSend+0x21e>
 80127d8:	1e6b      	subs	r3, r5, #1
 80127da:	2b03      	cmp	r3, #3
 80127dc:	4f67      	ldr	r7, [pc, #412]	@ (801297c <RadioSend+0x240>)
 80127de:	d904      	bls.n	80127ea <RadioSend+0xae>
 80127e0:	1c73      	adds	r3, r6, #1
 80127e2:	1afb      	subs	r3, r7, r3
 80127e4:	2b02      	cmp	r3, #2
 80127e6:	f200 8086 	bhi.w	80128f6 <RadioSend+0x1ba>
 80127ea:	4964      	ldr	r1, [pc, #400]	@ (801297c <RadioSend+0x240>)
 80127ec:	4633      	mov	r3, r6
 80127ee:	eb06 0c05 	add.w	ip, r6, r5
        outBuffer[i] = 0;
 80127f2:	2000      	movs	r0, #0
        inBuffer[i] = ~inBuffer[i];
 80127f4:	781a      	ldrb	r2, [r3, #0]
 80127f6:	43d2      	mvns	r2, r2
 80127f8:	f803 2b01 	strb.w	r2, [r3], #1
    for( i = 0; i < size; i++ )
 80127fc:	459c      	cmp	ip, r3
        outBuffer[i] = 0;
 80127fe:	f801 0b01 	strb.w	r0, [r1], #1
    for( i = 0; i < size; i++ )
 8012802:	d1f7      	bne.n	80127f4 <RadioSend+0xb8>
    uint8_t prevInt = 0;
 8012804:	2000      	movs	r0, #0
    for( i = 0; i < ( size * 8 ); i++ )
 8012806:	ea4f 0ec5 	mov.w	lr, r5, lsl #3
 801280a:	4601      	mov	r1, r0
 801280c:	4602      	mov	r2, r0
 801280e:	4684      	mov	ip, r0
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 8012810:	f816 300c 	ldrb.w	r3, [r6, ip]
        index_bit = 7 - ( i % 8 );
 8012814:	f1c2 0207 	rsb	r2, r2, #7
 8012818:	b2d2      	uxtb	r2, r2
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 801281a:	3101      	adds	r1, #1
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 801281c:	4113      	asrs	r3, r2
        index_byte_out = ( i + 1 ) / 8;
 801281e:	ea4f 0ce1 	mov.w	ip, r1, asr #3
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 8012822:	f003 0301 	and.w	r3, r3, #1
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 8012826:	f001 0207 	and.w	r2, r1, #7
        prevInt ^= currBit;
 801282a:	4058      	eors	r0, r3
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 801282c:	f1c2 0307 	rsb	r3, r2, #7
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 8012830:	f817 800c 	ldrb.w	r8, [r7, ip]
 8012834:	b2db      	uxtb	r3, r3
 8012836:	fa00 f303 	lsl.w	r3, r0, r3
 801283a:	ea43 0308 	orr.w	r3, r3, r8
    for( i = 0; i < ( size * 8 ); i++ )
 801283e:	4571      	cmp	r1, lr
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 8012840:	f807 300c 	strb.w	r3, [r7, ip]
    for( i = 0; i < ( size * 8 ); i++ )
 8012844:	d1e4      	bne.n	8012810 <RadioSend+0xd4>
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8012846:	0183      	lsls	r3, r0, #6
 8012848:	ea43 13c0 	orr.w	r3, r3, r0, lsl #7
 801284c:	0140      	lsls	r0, r0, #5
 801284e:	f080 0020 	eor.w	r0, r0, #32
 8012852:	4303      	orrs	r3, r0
 8012854:	b2db      	uxtb	r3, r3
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8012856:	1c6e      	adds	r6, r5, #1
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8012858:	557b      	strb	r3, [r7, r5]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 801285a:	2202      	movs	r2, #2
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 801285c:	4845      	ldr	r0, [pc, #276]	@ (8012974 <RadioSend+0x238>)
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 801285e:	73a2      	strb	r2, [r4, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8012860:	b2f6      	uxtb	r6, r6
 8012862:	76a6      	strb	r6, [r4, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8012864:	f001 ff0e 	bl	8014684 <SUBGRF_SetPacketParams>
    SUBGRF_WriteRegister( addr, data );
 8012868:	2100      	movs	r1, #0
 801286a:	20f1      	movs	r0, #241	@ 0xf1
 801286c:	f002 f852 	bl	8014914 <SUBGRF_WriteRegister>
 8012870:	2100      	movs	r1, #0
 8012872:	20f0      	movs	r0, #240	@ 0xf0
 8012874:	f002 f84e 	bl	8014914 <SUBGRF_WriteRegister>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 8012878:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 801287a:	2b64      	cmp	r3, #100	@ 0x64
 801287c:	d064      	beq.n	8012948 <RadioSend+0x20c>
    SUBGRF_WriteRegister( addr, data );
 801287e:	21e1      	movs	r1, #225	@ 0xe1
 8012880:	20f3      	movs	r0, #243	@ 0xf3
 8012882:	f002 f847 	bl	8014914 <SUBGRF_WriteRegister>
 8012886:	2104      	movs	r1, #4
 8012888:	20f2      	movs	r0, #242	@ 0xf2
 801288a:	f002 f843 	bl	8014914 <SUBGRF_WriteRegister>
            uint16_t bitNum = ( size * 8 ) + 2;
 801288e:	00e9      	lsls	r1, r5, #3
 8012890:	1c8d      	adds	r5, r1, #2
    SUBGRF_WriteRegister( addr, data );
 8012892:	20f4      	movs	r0, #244	@ 0xf4
 8012894:	0a09      	lsrs	r1, r1, #8
 8012896:	f002 f83d 	bl	8014914 <SUBGRF_WriteRegister>
 801289a:	f005 01fe 	and.w	r1, r5, #254	@ 0xfe
 801289e:	20f5      	movs	r0, #245	@ 0xf5
 80128a0:	f002 f838 	bl	8014914 <SUBGRF_WriteRegister>
            SUBGRF_SendPayload( RadioBuffer, size + 1, 0xFFFFFF );
 80128a4:	4835      	ldr	r0, [pc, #212]	@ (801297c <RadioSend+0x240>)
 80128a6:	f06f 427f 	mvn.w	r2, #4278190080	@ 0xff000000
 80128aa:	4631      	mov	r1, r6
 80128ac:	f001 fa32 	bl	8013d14 <SUBGRF_SendPayload>
            break;
 80128b0:	e77c      	b.n	80127ac <RadioSend+0x70>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80128b2:	4830      	ldr	r0, [pc, #192]	@ (8012974 <RadioSend+0x238>)
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 80128b4:	77e5      	strb	r5, [r4, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80128b6:	e772      	b.n	801279e <RadioSend+0x62>
        SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) & ~( 1 << 2 ) );
 80128b8:	f002 f83e 	bl	8014938 <SUBGRF_ReadRegister>
 80128bc:	f000 01fb 	and.w	r1, r0, #251	@ 0xfb
 80128c0:	f640 0089 	movw	r0, #2185	@ 0x889
 80128c4:	f002 f826 	bl	8014914 <SUBGRF_WriteRegister>
 80128c8:	e75d      	b.n	8012786 <RadioSend+0x4a>
                if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 80128ca:	4629      	mov	r1, r5
 80128cc:	f10d 0207 	add.w	r2, sp, #7
 80128d0:	4630      	mov	r0, r6
 80128d2:	f002 f97d 	bl	8014bd0 <RFW_TransmitInit>
 80128d6:	4605      	mov	r5, r0
 80128d8:	2800      	cmp	r0, #0
 80128da:	d141      	bne.n	8012960 <RadioSend+0x224>
                    SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 80128dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
                    SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80128e0:	4824      	ldr	r0, [pc, #144]	@ (8012974 <RadioSend+0x238>)
                    SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 80128e2:	75a3      	strb	r3, [r4, #22]
                    SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80128e4:	f001 fece 	bl	8014684 <SUBGRF_SetPacketParams>
                    SUBGRF_SendPayload( buffer, outsize, 0 );
 80128e8:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80128ec:	462a      	mov	r2, r5
 80128ee:	4630      	mov	r0, r6
 80128f0:	f001 fa10 	bl	8013d14 <SUBGRF_SendPayload>
 80128f4:	e75a      	b.n	80127ac <RadioSend+0x70>
 80128f6:	f005 0cfc 	and.w	ip, r5, #252	@ 0xfc
 80128fa:	4633      	mov	r3, r6
 80128fc:	44b4      	add	ip, r6
    for( i = 0; i < size; i++ )
 80128fe:	4639      	mov	r1, r7
        outBuffer[i] = 0;
 8012900:	2000      	movs	r0, #0
        inBuffer[i] = ~inBuffer[i];
 8012902:	681a      	ldr	r2, [r3, #0]
 8012904:	43d2      	mvns	r2, r2
 8012906:	f843 2b04 	str.w	r2, [r3], #4
        outBuffer[i] = 0;
 801290a:	459c      	cmp	ip, r3
 801290c:	f841 0b04 	str.w	r0, [r1], #4
    for( i = 0; i < size; i++ )
 8012910:	d1f7      	bne.n	8012902 <RadioSend+0x1c6>
 8012912:	07ab      	lsls	r3, r5, #30
 8012914:	f43f af76 	beq.w	8012804 <RadioSend+0xc8>
 8012918:	f025 0303 	bic.w	r3, r5, #3
 801291c:	1c5a      	adds	r2, r3, #1
        inBuffer[i] = ~inBuffer[i];
 801291e:	5cf1      	ldrb	r1, [r6, r3]
    for( i = 0; i < size; i++ )
 8012920:	4295      	cmp	r5, r2
        inBuffer[i] = ~inBuffer[i];
 8012922:	ea6f 0101 	mvn.w	r1, r1
 8012926:	54f1      	strb	r1, [r6, r3]
        outBuffer[i] = 0;
 8012928:	54f8      	strb	r0, [r7, r3]
    for( i = 0; i < size; i++ )
 801292a:	f77f af6b 	ble.w	8012804 <RadioSend+0xc8>
        inBuffer[i] = ~inBuffer[i];
 801292e:	5cb1      	ldrb	r1, [r6, r2]
    for( i = 0; i < size; i++ )
 8012930:	3302      	adds	r3, #2
        inBuffer[i] = ~inBuffer[i];
 8012932:	43c9      	mvns	r1, r1
    for( i = 0; i < size; i++ )
 8012934:	42ab      	cmp	r3, r5
        inBuffer[i] = ~inBuffer[i];
 8012936:	54b1      	strb	r1, [r6, r2]
        outBuffer[i] = 0;
 8012938:	54b8      	strb	r0, [r7, r2]
    for( i = 0; i < size; i++ )
 801293a:	f6bf af63 	bge.w	8012804 <RadioSend+0xc8>
        inBuffer[i] = ~inBuffer[i];
 801293e:	5cf2      	ldrb	r2, [r6, r3]
 8012940:	43d2      	mvns	r2, r2
 8012942:	54f2      	strb	r2, [r6, r3]
        outBuffer[i] = 0;
 8012944:	54f8      	strb	r0, [r7, r3]
    for( i = 0; i < size; i++ )
 8012946:	e75d      	b.n	8012804 <RadioSend+0xc8>
    SUBGRF_WriteRegister( addr, data );
 8012948:	2170      	movs	r1, #112	@ 0x70
 801294a:	20f3      	movs	r0, #243	@ 0xf3
 801294c:	f001 ffe2 	bl	8014914 <SUBGRF_WriteRegister>
 8012950:	211d      	movs	r1, #29
 8012952:	20f2      	movs	r0, #242	@ 0xf2
 8012954:	f001 ffde 	bl	8014914 <SUBGRF_WriteRegister>
}
 8012958:	e799      	b.n	801288e <RadioSend+0x152>
 801295a:	4f08      	ldr	r7, [pc, #32]	@ (801297c <RadioSend+0x240>)
    for( i = 0; i < size; i++ )
 801295c:	2320      	movs	r3, #32
 801295e:	e77a      	b.n	8012856 <RadioSend+0x11a>
                    MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n" );
 8012960:	4b07      	ldr	r3, [pc, #28]	@ (8012980 <RadioSend+0x244>)
 8012962:	463a      	mov	r2, r7
 8012964:	2100      	movs	r1, #0
 8012966:	2002      	movs	r0, #2
 8012968:	f003 f844 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
                    return RADIO_STATUS_ERROR;
 801296c:	2003      	movs	r0, #3
 801296e:	e725      	b.n	80127bc <RadioSend+0x80>
 8012970:	20001454 	.word	0x20001454
 8012974:	20001462 	.word	0x20001462
 8012978:	2000143c 	.word	0x2000143c
 801297c:	200014b4 	.word	0x200014b4
 8012980:	080175b8 	.word	0x080175b8

08012984 <RadioTxPrbs>:
{
 8012984:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 8012986:	4b09      	ldr	r3, [pc, #36]	@ (80129ac <RadioTxPrbs+0x28>)
 8012988:	2101      	movs	r1, #1
 801298a:	f893 0056 	ldrb.w	r0, [r3, #86]	@ 0x56
 801298e:	f002 f803 	bl	8014998 <SUBGRF_SetSwitch>
    SUBGRF_WriteRegister( addr, data );
 8012992:	f44f 60d7 	mov.w	r0, #1720	@ 0x6b8
 8012996:	212d      	movs	r1, #45	@ 0x2d
 8012998:	f001 ffbc 	bl	8014914 <SUBGRF_WriteRegister>
    SUBGRF_SetTxInfinitePreamble( );
 801299c:	f001 fbcc 	bl	8014138 <SUBGRF_SetTxInfinitePreamble>
}
 80129a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTx( 0x0fffff );
 80129a4:	4802      	ldr	r0, [pc, #8]	@ (80129b0 <RadioTxPrbs+0x2c>)
 80129a6:	f001 bb17 	b.w	8013fd8 <SUBGRF_SetTx>
 80129aa:	bf00      	nop
 80129ac:	20001454 	.word	0x20001454
 80129b0:	000fffff 	.word	0x000fffff

080129b4 <RadioIrqProcess>:
{
 80129b4:	b570      	push	{r4, r5, r6, lr}
    switch( SubgRf.RadioIrq )
 80129b6:	4d9a      	ldr	r5, [pc, #616]	@ (8012c20 <RadioIrqProcess+0x26c>)
 80129b8:	f8b5 3054 	ldrh.w	r3, [r5, #84]	@ 0x54
{
 80129bc:	b082      	sub	sp, #8
    uint8_t size = 0;
 80129be:	2400      	movs	r4, #0
    switch( SubgRf.RadioIrq )
 80129c0:	2b20      	cmp	r3, #32
    uint8_t size = 0;
 80129c2:	f88d 4003 	strb.w	r4, [sp, #3]
    int32_t cfo = 0;
 80129c6:	9401      	str	r4, [sp, #4]
    switch( SubgRf.RadioIrq )
 80129c8:	d827      	bhi.n	8012a1a <RadioIrqProcess+0x66>
 80129ca:	b323      	cbz	r3, 8012a16 <RadioIrqProcess+0x62>
 80129cc:	3b01      	subs	r3, #1
 80129ce:	2b1f      	cmp	r3, #31
 80129d0:	d821      	bhi.n	8012a16 <RadioIrqProcess+0x62>
 80129d2:	e8df f003 	tbb	[pc, r3]
 80129d6:	9582      	.short	0x9582
 80129d8:	2020bb20 	.word	0x2020bb20
 80129dc:	20206e20 	.word	0x20206e20
 80129e0:	20202020 	.word	0x20202020
 80129e4:	20207b20 	.word	0x20207b20
 80129e8:	20202020 	.word	0x20202020
 80129ec:	20202020 	.word	0x20202020
 80129f0:	20202020 	.word	0x20202020
 80129f4:	5820      	.short	0x5820
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 80129f6:	4b8b      	ldr	r3, [pc, #556]	@ (8012c24 <RadioIrqProcess+0x270>)
 80129f8:	2201      	movs	r2, #1
 80129fa:	4621      	mov	r1, r4
 80129fc:	2002      	movs	r0, #2
 80129fe:	f002 fff9 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 8012a02:	7868      	ldrb	r0, [r5, #1]
 8012a04:	2800      	cmp	r0, #0
 8012a06:	f000 80f3 	beq.w	8012bf0 <RadioIrqProcess+0x23c>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 8012a0a:	4b87      	ldr	r3, [pc, #540]	@ (8012c28 <RadioIrqProcess+0x274>)
 8012a0c:	681b      	ldr	r3, [r3, #0]
 8012a0e:	b113      	cbz	r3, 8012a16 <RadioIrqProcess+0x62>
 8012a10:	691b      	ldr	r3, [r3, #16]
 8012a12:	b103      	cbz	r3, 8012a16 <RadioIrqProcess+0x62>
            RadioEvents->RxError( );
 8012a14:	4798      	blx	r3
}
 8012a16:	b002      	add	sp, #8
 8012a18:	bd70      	pop	{r4, r5, r6, pc}
    switch( SubgRf.RadioIrq )
 8012a1a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8012a1e:	f000 80c5 	beq.w	8012bac <RadioIrqProcess+0x1f8>
 8012a22:	d91f      	bls.n	8012a64 <RadioIrqProcess+0xb0>
 8012a24:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012a28:	d1f5      	bne.n	8012a16 <RadioIrqProcess+0x62>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 8012a2a:	4b80      	ldr	r3, [pc, #512]	@ (8012c2c <RadioIrqProcess+0x278>)
 8012a2c:	2201      	movs	r2, #1
 8012a2e:	4621      	mov	r1, r4
 8012a30:	2002      	movs	r0, #2
 8012a32:	f002 ffdf 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 8012a36:	f001 f927 	bl	8013c88 <SUBGRF_GetOperatingMode>
 8012a3a:	2804      	cmp	r0, #4
 8012a3c:	f000 80c5 	beq.w	8012bca <RadioIrqProcess+0x216>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 8012a40:	f001 f922 	bl	8013c88 <SUBGRF_GetOperatingMode>
 8012a44:	2805      	cmp	r0, #5
 8012a46:	d1e6      	bne.n	8012a16 <RadioIrqProcess+0x62>
            TimerStop( &RxTimeoutTimer );
 8012a48:	4879      	ldr	r0, [pc, #484]	@ (8012c30 <RadioIrqProcess+0x27c>)
 8012a4a:	f002 fe4f 	bl	80156ec <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8012a4e:	4620      	mov	r0, r4
 8012a50:	f001 faa4 	bl	8013f9c <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8012a54:	4b74      	ldr	r3, [pc, #464]	@ (8012c28 <RadioIrqProcess+0x274>)
 8012a56:	681b      	ldr	r3, [r3, #0]
 8012a58:	2b00      	cmp	r3, #0
 8012a5a:	d0dc      	beq.n	8012a16 <RadioIrqProcess+0x62>
 8012a5c:	68db      	ldr	r3, [r3, #12]
 8012a5e:	2b00      	cmp	r3, #0
 8012a60:	d1d8      	bne.n	8012a14 <RadioIrqProcess+0x60>
 8012a62:	e7d8      	b.n	8012a16 <RadioIrqProcess+0x62>
    switch( SubgRf.RadioIrq )
 8012a64:	2b40      	cmp	r3, #64	@ 0x40
 8012a66:	d0c6      	beq.n	80129f6 <RadioIrqProcess+0x42>
 8012a68:	2b80      	cmp	r3, #128	@ 0x80
 8012a6a:	d1d4      	bne.n	8012a16 <RadioIrqProcess+0x62>
        SUBGRF_SetStandby( STDBY_RC );
 8012a6c:	4620      	mov	r0, r4
 8012a6e:	f001 fa95 	bl	8013f9c <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8012a72:	4b6d      	ldr	r3, [pc, #436]	@ (8012c28 <RadioIrqProcess+0x274>)
 8012a74:	681b      	ldr	r3, [r3, #0]
 8012a76:	2b00      	cmp	r3, #0
 8012a78:	d0cd      	beq.n	8012a16 <RadioIrqProcess+0x62>
 8012a7a:	699b      	ldr	r3, [r3, #24]
 8012a7c:	2b00      	cmp	r3, #0
 8012a7e:	d0ca      	beq.n	8012a16 <RadioIrqProcess+0x62>
            RadioEvents->CadDone( false );
 8012a80:	4620      	mov	r0, r4
 8012a82:	4798      	blx	r3
 8012a84:	e7c7      	b.n	8012a16 <RadioIrqProcess+0x62>
        TimerStop( &RxTimeoutTimer );
 8012a86:	486a      	ldr	r0, [pc, #424]	@ (8012c30 <RadioIrqProcess+0x27c>)
 8012a88:	f002 fe30 	bl	80156ec <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 8012a8c:	7868      	ldrb	r0, [r5, #1]
 8012a8e:	2800      	cmp	r0, #0
 8012a90:	f000 80ab 	beq.w	8012bea <RadioIrqProcess+0x236>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8012a94:	4b64      	ldr	r3, [pc, #400]	@ (8012c28 <RadioIrqProcess+0x274>)
 8012a96:	681b      	ldr	r3, [r3, #0]
 8012a98:	2b00      	cmp	r3, #0
 8012a9a:	d0bc      	beq.n	8012a16 <RadioIrqProcess+0x62>
 8012a9c:	68db      	ldr	r3, [r3, #12]
 8012a9e:	2b00      	cmp	r3, #0
 8012aa0:	d0b9      	beq.n	8012a16 <RadioIrqProcess+0x62>
            RadioEvents->RxTimeout( );
 8012aa2:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 8012aa4:	4b63      	ldr	r3, [pc, #396]	@ (8012c34 <RadioIrqProcess+0x280>)
 8012aa6:	2201      	movs	r2, #1
 8012aa8:	2100      	movs	r1, #0
 8012aaa:	2002      	movs	r0, #2
 8012aac:	f002 ffa2 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
 8012ab0:	e7b1      	b.n	8012a16 <RadioIrqProcess+0x62>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 8012ab2:	4b61      	ldr	r3, [pc, #388]	@ (8012c38 <RadioIrqProcess+0x284>)
 8012ab4:	2201      	movs	r2, #1
 8012ab6:	2100      	movs	r1, #0
 8012ab8:	2002      	movs	r0, #2
 8012aba:	f002 ff9b 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
        if( 1UL == RFW_Is_Init( ) )
 8012abe:	f002 f881 	bl	8014bc4 <RFW_Is_Init>
 8012ac2:	2801      	cmp	r0, #1
 8012ac4:	d1a7      	bne.n	8012a16 <RadioIrqProcess+0x62>
            RFW_ReceivePayload( );
 8012ac6:	f002 f88d 	bl	8014be4 <RFW_ReceivePayload>
 8012aca:	e7a4      	b.n	8012a16 <RadioIrqProcess+0x62>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 8012acc:	4b5b      	ldr	r3, [pc, #364]	@ (8012c3c <RadioIrqProcess+0x288>)
 8012ace:	2201      	movs	r2, #1
 8012ad0:	2100      	movs	r1, #0
 8012ad2:	2002      	movs	r0, #2
 8012ad4:	f002 ff8e 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
        break;
 8012ad8:	e79d      	b.n	8012a16 <RadioIrqProcess+0x62>
        TimerStop( &TxTimeoutTimer );
 8012ada:	4859      	ldr	r0, [pc, #356]	@ (8012c40 <RadioIrqProcess+0x28c>)
 8012adc:	f002 fe06 	bl	80156ec <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 8012ae0:	2000      	movs	r0, #0
 8012ae2:	f001 fa5b 	bl	8013f9c <SUBGRF_SetStandby>
        if( RFW_Is_LongPacketModeEnabled() == 1 )
 8012ae6:	f002 f86f 	bl	8014bc8 <RFW_Is_LongPacketModeEnabled>
 8012aea:	2801      	cmp	r0, #1
 8012aec:	f000 80c7 	beq.w	8012c7e <RadioIrqProcess+0x2ca>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 8012af0:	4b4d      	ldr	r3, [pc, #308]	@ (8012c28 <RadioIrqProcess+0x274>)
 8012af2:	681b      	ldr	r3, [r3, #0]
 8012af4:	2b00      	cmp	r3, #0
 8012af6:	d08e      	beq.n	8012a16 <RadioIrqProcess+0x62>
 8012af8:	681b      	ldr	r3, [r3, #0]
 8012afa:	2b00      	cmp	r3, #0
 8012afc:	d18a      	bne.n	8012a14 <RadioIrqProcess+0x60>
 8012afe:	e78a      	b.n	8012a16 <RadioIrqProcess+0x62>
        TimerStop( &RxTimeoutTimer );
 8012b00:	484b      	ldr	r0, [pc, #300]	@ (8012c30 <RadioIrqProcess+0x27c>)
 8012b02:	f002 fdf3 	bl	80156ec <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 8012b06:	786c      	ldrb	r4, [r5, #1]
 8012b08:	2c00      	cmp	r4, #0
 8012b0a:	d074      	beq.n	8012bf6 <RadioIrqProcess+0x242>
        SUBGRF_GetPayload( RadioBuffer, &size, 255 );
 8012b0c:	22ff      	movs	r2, #255	@ 0xff
 8012b0e:	f10d 0103 	add.w	r1, sp, #3
 8012b12:	484c      	ldr	r0, [pc, #304]	@ (8012c44 <RadioIrqProcess+0x290>)
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 8012b14:	4c44      	ldr	r4, [pc, #272]	@ (8012c28 <RadioIrqProcess+0x274>)
        SUBGRF_GetPayload( RadioBuffer, &size, 255 );
 8012b16:	f001 f8bd 	bl	8013c94 <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &( SubgRf.PacketStatus ) );
 8012b1a:	484b      	ldr	r0, [pc, #300]	@ (8012c48 <RadioIrqProcess+0x294>)
 8012b1c:	f001 feb2 	bl	8014884 <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 8012b20:	6823      	ldr	r3, [r4, #0]
 8012b22:	2b00      	cmp	r3, #0
 8012b24:	f43f af77 	beq.w	8012a16 <RadioIrqProcess+0x62>
 8012b28:	689e      	ldr	r6, [r3, #8]
 8012b2a:	2e00      	cmp	r6, #0
 8012b2c:	f43f af73 	beq.w	8012a16 <RadioIrqProcess+0x62>
            switch( SubgRf.PacketStatus.packetType )
 8012b30:	f895 3024 	ldrb.w	r3, [r5, #36]	@ 0x24
 8012b34:	2b01      	cmp	r3, #1
 8012b36:	f040 808b 	bne.w	8012c50 <RadioIrqProcess+0x29c>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt,
 8012b3a:	f995 3031 	ldrsb.w	r3, [r5, #49]	@ 0x31
 8012b3e:	f995 2030 	ldrsb.w	r2, [r5, #48]	@ 0x30
 8012b42:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8012b46:	483f      	ldr	r0, [pc, #252]	@ (8012c44 <RadioIrqProcess+0x290>)
 8012b48:	47b0      	blx	r6
                break;
 8012b4a:	e764      	b.n	8012a16 <RadioIrqProcess+0x62>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 8012b4c:	2100      	movs	r1, #0
 8012b4e:	4b3f      	ldr	r3, [pc, #252]	@ (8012c4c <RadioIrqProcess+0x298>)
 8012b50:	2201      	movs	r2, #1
 8012b52:	2002      	movs	r0, #2
 8012b54:	f002 ff4e 	bl	80159f4 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxDcPreambleDetectTimeout != 0 )
 8012b58:	6da9      	ldr	r1, [r5, #88]	@ 0x58
 8012b5a:	2900      	cmp	r1, #0
 8012b5c:	f43f af5b 	beq.w	8012a16 <RadioIrqProcess+0x62>
    SUBGRF_WriteRegister( addr, data );
 8012b60:	f3c1 4107 	ubfx	r1, r1, #16, #8
 8012b64:	f640 1003 	movw	r0, #2307	@ 0x903
 8012b68:	f001 fed4 	bl	8014914 <SUBGRF_WriteRegister>
 8012b6c:	f895 1059 	ldrb.w	r1, [r5, #89]	@ 0x59
 8012b70:	f640 1004 	movw	r0, #2308	@ 0x904
 8012b74:	f001 fece 	bl	8014914 <SUBGRF_WriteRegister>
 8012b78:	f895 1058 	ldrb.w	r1, [r5, #88]	@ 0x58
 8012b7c:	f640 1005 	movw	r0, #2309	@ 0x905
 8012b80:	f001 fec8 	bl	8014914 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister( addr );
 8012b84:	f640 1002 	movw	r0, #2306	@ 0x902
 8012b88:	f001 fed6 	bl	8014938 <SUBGRF_ReadRegister>
            Radio.Write( SUBGHZ_RTCCTLR, Radio.Read( SUBGHZ_RTCCTLR ) | 0x1 ); /*restart Radio RTC*/
 8012b8c:	f040 0101 	orr.w	r1, r0, #1
    SUBGRF_WriteRegister( addr, data );
 8012b90:	b2c9      	uxtb	r1, r1
 8012b92:	f640 1002 	movw	r0, #2306	@ 0x902
 8012b96:	f001 febd 	bl	8014914 <SUBGRF_WriteRegister>
            SubgRf.RxDcPreambleDetectTimeout = 0;
 8012b9a:	2300      	movs	r3, #0
            SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8012b9c:	f240 2162 	movw	r1, #610	@ 0x262
 8012ba0:	461a      	mov	r2, r3
 8012ba2:	4608      	mov	r0, r1
            SubgRf.RxDcPreambleDetectTimeout = 0;
 8012ba4:	65ab      	str	r3, [r5, #88]	@ 0x58
            SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8012ba6:	f001 fb2f 	bl	8014208 <SUBGRF_SetDioIrqParams>
 8012baa:	e734      	b.n	8012a16 <RadioIrqProcess+0x62>
        SUBGRF_SetStandby( STDBY_RC );
 8012bac:	4620      	mov	r0, r4
 8012bae:	f001 f9f5 	bl	8013f9c <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8012bb2:	4b1d      	ldr	r3, [pc, #116]	@ (8012c28 <RadioIrqProcess+0x274>)
 8012bb4:	681b      	ldr	r3, [r3, #0]
 8012bb6:	2b00      	cmp	r3, #0
 8012bb8:	f43f af2d 	beq.w	8012a16 <RadioIrqProcess+0x62>
 8012bbc:	699b      	ldr	r3, [r3, #24]
 8012bbe:	2b00      	cmp	r3, #0
 8012bc0:	f43f af29 	beq.w	8012a16 <RadioIrqProcess+0x62>
            RadioEvents->CadDone( true );
 8012bc4:	2001      	movs	r0, #1
 8012bc6:	4798      	blx	r3
 8012bc8:	e725      	b.n	8012a16 <RadioIrqProcess+0x62>
            TimerStop( &TxTimeoutTimer );
 8012bca:	481d      	ldr	r0, [pc, #116]	@ (8012c40 <RadioIrqProcess+0x28c>)
 8012bcc:	f002 fd8e 	bl	80156ec <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8012bd0:	4620      	mov	r0, r4
 8012bd2:	f001 f9e3 	bl	8013f9c <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8012bd6:	4b14      	ldr	r3, [pc, #80]	@ (8012c28 <RadioIrqProcess+0x274>)
 8012bd8:	681b      	ldr	r3, [r3, #0]
 8012bda:	2b00      	cmp	r3, #0
 8012bdc:	f43f af1b 	beq.w	8012a16 <RadioIrqProcess+0x62>
 8012be0:	685b      	ldr	r3, [r3, #4]
 8012be2:	2b00      	cmp	r3, #0
 8012be4:	f47f af16 	bne.w	8012a14 <RadioIrqProcess+0x60>
 8012be8:	e715      	b.n	8012a16 <RadioIrqProcess+0x62>
            SUBGRF_SetStandby( STDBY_RC );
 8012bea:	f001 f9d7 	bl	8013f9c <SUBGRF_SetStandby>
 8012bee:	e751      	b.n	8012a94 <RadioIrqProcess+0xe0>
            SUBGRF_SetStandby( STDBY_RC );
 8012bf0:	f001 f9d4 	bl	8013f9c <SUBGRF_SetStandby>
 8012bf4:	e709      	b.n	8012a0a <RadioIrqProcess+0x56>
            SUBGRF_SetStandby( STDBY_RC );
 8012bf6:	4620      	mov	r0, r4
 8012bf8:	f001 f9d0 	bl	8013f9c <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( SUBGHZ_RTCCTLR, 0x00 );
 8012bfc:	4621      	mov	r1, r4
 8012bfe:	f640 1002 	movw	r0, #2306	@ 0x902
 8012c02:	f001 fe87 	bl	8014914 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( SUBGHZ_EVENTMASKR, SUBGRF_ReadRegister( SUBGHZ_EVENTMASKR ) | ( 1 << 1 ) );
 8012c06:	f640 1044 	movw	r0, #2372	@ 0x944
 8012c0a:	f001 fe95 	bl	8014938 <SUBGRF_ReadRegister>
 8012c0e:	f040 0102 	orr.w	r1, r0, #2
 8012c12:	b2c9      	uxtb	r1, r1
 8012c14:	f640 1044 	movw	r0, #2372	@ 0x944
 8012c18:	f001 fe7c 	bl	8014914 <SUBGRF_WriteRegister>
 8012c1c:	e776      	b.n	8012b0c <RadioIrqProcess+0x158>
 8012c1e:	bf00      	nop
 8012c20:	20001454 	.word	0x20001454
 8012c24:	08017614 	.word	0x08017614
 8012c28:	200014b0 	.word	0x200014b0
 8012c2c:	080175d0 	.word	0x080175d0
 8012c30:	20001424 	.word	0x20001424
 8012c34:	08017608 	.word	0x08017608
 8012c38:	080175f0 	.word	0x080175f0
 8012c3c:	080175fc 	.word	0x080175fc
 8012c40:	2000143c 	.word	0x2000143c
 8012c44:	200014b4 	.word	0x200014b4
 8012c48:	20001478 	.word	0x20001478
 8012c4c:	080175e4 	.word	0x080175e4
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 8012c50:	6be8      	ldr	r0, [r5, #60]	@ 0x3c
 8012c52:	a901      	add	r1, sp, #4
 8012c54:	f001 ff56 	bl	8014b04 <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, ( int8_t ) DIVR( cfo, 1000 ) );
 8012c58:	9b01      	ldr	r3, [sp, #4]
 8012c5a:	4a0a      	ldr	r2, [pc, #40]	@ (8012c84 <RadioIrqProcess+0x2d0>)
 8012c5c:	6821      	ldr	r1, [r4, #0]
 8012c5e:	f503 73fa 	add.w	r3, r3, #500	@ 0x1f4
 8012c62:	fb82 0203 	smull	r0, r2, r2, r3
 8012c66:	17db      	asrs	r3, r3, #31
 8012c68:	ebc3 13a2 	rsb	r3, r3, r2, asr #6
 8012c6c:	688c      	ldr	r4, [r1, #8]
 8012c6e:	f995 2029 	ldrsb.w	r2, [r5, #41]	@ 0x29
 8012c72:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8012c76:	4804      	ldr	r0, [pc, #16]	@ (8012c88 <RadioIrqProcess+0x2d4>)
 8012c78:	b25b      	sxtb	r3, r3
 8012c7a:	47a0      	blx	r4
                break;
 8012c7c:	e6cb      	b.n	8012a16 <RadioIrqProcess+0x62>
            RFW_DeInit_TxLongPacket( );
 8012c7e:	f001 ffaf 	bl	8014be0 <RFW_DeInit_TxLongPacket>
 8012c82:	e735      	b.n	8012af0 <RadioIrqProcess+0x13c>
 8012c84:	10624dd3 	.word	0x10624dd3
 8012c88:	200014b4 	.word	0x200014b4

08012c8c <RadioOnDioIrq>:
    SubgRf.RadioIrq = radioIrq;
 8012c8c:	4b02      	ldr	r3, [pc, #8]	@ (8012c98 <RadioOnDioIrq+0xc>)
 8012c8e:	f8a3 0054 	strh.w	r0, [r3, #84]	@ 0x54
    RADIO_IRQ_PROCESS();
 8012c92:	f7ff be8f 	b.w	80129b4 <RadioIrqProcess>
 8012c96:	bf00      	nop
 8012c98:	20001454 	.word	0x20001454

08012c9c <RadioInit>:
{
 8012c9c:	b570      	push	{r4, r5, r6, lr}
    RadioEvents = events;
 8012c9e:	4b21      	ldr	r3, [pc, #132]	@ (8012d24 <RadioInit+0x88>)
    SubgRf.RxContinuous = false;
 8012ca0:	4d21      	ldr	r5, [pc, #132]	@ (8012d28 <RadioInit+0x8c>)
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8012ca2:	4e22      	ldr	r6, [pc, #136]	@ (8012d2c <RadioInit+0x90>)
{
 8012ca4:	b082      	sub	sp, #8
    SubgRf.RxContinuous = false;
 8012ca6:	2400      	movs	r4, #0
{
 8012ca8:	4602      	mov	r2, r0
    SUBGRF_Init( RadioOnDioIrq );
 8012caa:	4821      	ldr	r0, [pc, #132]	@ (8012d30 <RadioInit+0x94>)
    RadioEvents = events;
 8012cac:	601a      	str	r2, [r3, #0]
    SubgRf.RxTimeout = 0;
 8012cae:	e9c5 4401 	strd	r4, r4, [r5, #4]
    SubgRf.RxContinuous = false;
 8012cb2:	706c      	strb	r4, [r5, #1]
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8012cb4:	65ac      	str	r4, [r5, #88]	@ 0x58
    SUBGRF_Init( RadioOnDioIrq );
 8012cb6:	f000 ff51 	bl	8013b5c <SUBGRF_Init>
    SubgRf.PublicNetwork.Previous = false;
 8012cba:	81ac      	strh	r4, [r5, #12]
    SUBGRF_SetRegulatorMode( );
 8012cbc:	f001 fa88 	bl	80141d0 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 8012cc0:	4621      	mov	r1, r4
 8012cc2:	4620      	mov	r0, r4
 8012cc4:	f001 fdb2 	bl	801482c <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams( RFO_LP, 0, RADIO_RAMP_200_US );
 8012cc8:	4621      	mov	r1, r4
 8012cca:	2001      	movs	r0, #1
 8012ccc:	2204      	movs	r2, #4
 8012cce:	f001 fb4b 	bl	8014368 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8012cd2:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 8012cd6:	4623      	mov	r3, r4
 8012cd8:	4622      	mov	r2, r4
 8012cda:	4608      	mov	r0, r1
 8012cdc:	f001 fa94 	bl	8014208 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSleep( params );
 8012ce0:	f04f 0004 	mov.w	r0, #4
 8012ce4:	f001 f91c 	bl	8013f20 <SUBGRF_SetSleep>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8012ce8:	4d12      	ldr	r5, [pc, #72]	@ (8012d34 <RadioInit+0x98>)
    RADIO_DELAY_MS( 2 );
 8012cea:	2002      	movs	r0, #2
 8012cec:	f7ee ff74 	bl	8001bd8 <HAL_Delay>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8012cf0:	4622      	mov	r2, r4
 8012cf2:	4b11      	ldr	r3, [pc, #68]	@ (8012d38 <RadioInit+0x9c>)
 8012cf4:	9400      	str	r4, [sp, #0]
 8012cf6:	f04f 31ff 	mov.w	r1, #4294967295
 8012cfa:	4630      	mov	r0, r6
 8012cfc:	f002 fcca 	bl	8015694 <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8012d00:	4b0e      	ldr	r3, [pc, #56]	@ (8012d3c <RadioInit+0xa0>)
 8012d02:	9400      	str	r4, [sp, #0]
 8012d04:	4622      	mov	r2, r4
 8012d06:	f04f 31ff 	mov.w	r1, #4294967295
 8012d0a:	4628      	mov	r0, r5
 8012d0c:	f002 fcc2 	bl	8015694 <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 8012d10:	4630      	mov	r0, r6
 8012d12:	f002 fceb 	bl	80156ec <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8012d16:	4628      	mov	r0, r5
}
 8012d18:	b002      	add	sp, #8
 8012d1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TimerStop( &RxTimeoutTimer );
 8012d1e:	f002 bce5 	b.w	80156ec <UTIL_TIMER_Stop>
 8012d22:	bf00      	nop
 8012d24:	200014b0 	.word	0x200014b0
 8012d28:	20001454 	.word	0x20001454
 8012d2c:	2000143c 	.word	0x2000143c
 8012d30:	08012c8d 	.word	0x08012c8d
 8012d34:	20001424 	.word	0x20001424
 8012d38:	080124c5 	.word	0x080124c5
 8012d3c:	080124d9 	.word	0x080124d9

08012d40 <RadioSetPublicNetwork>:
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 8012d40:	f04f 0300 	mov.w	r3, #0
{
 8012d44:	b570      	push	{r4, r5, r6, lr}
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 8012d46:	f360 0307 	bfi	r3, r0, #0, #8
 8012d4a:	4d17      	ldr	r5, [pc, #92]	@ (8012da8 <RadioSetPublicNetwork+0x68>)
    SubgRf.Modem = modem;
 8012d4c:	2601      	movs	r6, #1
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 8012d4e:	f360 230f 	bfi	r3, r0, #8, #8
{
 8012d52:	4604      	mov	r4, r0
    RFW_SetRadioModem( modem );
 8012d54:	4630      	mov	r0, r6
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 8012d56:	81ab      	strh	r3, [r5, #12]
    SubgRf.Modem = modem;
 8012d58:	702e      	strb	r6, [r5, #0]
    RFW_SetRadioModem( modem );
 8012d5a:	f001 ff45 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012d5e:	4630      	mov	r0, r6
 8012d60:	f001 fadc 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012d64:	7b28      	ldrb	r0, [r5, #12]
 8012d66:	7b6b      	ldrb	r3, [r5, #13]
 8012d68:	4283      	cmp	r3, r0
 8012d6a:	d118      	bne.n	8012d9e <RadioSetPublicNetwork+0x5e>
    if( enable == true )
 8012d6c:	b15c      	cbz	r4, 8012d86 <RadioSetPublicNetwork+0x46>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8012d6e:	2134      	movs	r1, #52	@ 0x34
 8012d70:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012d74:	f001 fdce 	bl	8014914 <SUBGRF_WriteRegister>
}
 8012d78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8012d7c:	2144      	movs	r1, #68	@ 0x44
 8012d7e:	f240 7041 	movw	r0, #1857	@ 0x741
 8012d82:	f001 bdc7 	b.w	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8012d86:	2114      	movs	r1, #20
 8012d88:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012d8c:	f001 fdc2 	bl	8014914 <SUBGRF_WriteRegister>
}
 8012d90:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8012d94:	2124      	movs	r1, #36	@ 0x24
 8012d96:	f240 7041 	movw	r0, #1857	@ 0x741
 8012d9a:	f001 bdbb 	b.w	8014914 <SUBGRF_WriteRegister>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012d9e:	7368      	strb	r0, [r5, #13]
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 8012da0:	f7ff ffce 	bl	8012d40 <RadioSetPublicNetwork>
 8012da4:	e7e2      	b.n	8012d6c <RadioSetPublicNetwork+0x2c>
 8012da6:	bf00      	nop
 8012da8:	20001454 	.word	0x20001454

08012dac <RadioSetModem>:
{
 8012dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    SubgRf.Modem = modem;
 8012dae:	4d3a      	ldr	r5, [pc, #232]	@ (8012e98 <RadioSetModem+0xec>)
{
 8012db0:	4604      	mov	r4, r0
    SubgRf.Modem = modem;
 8012db2:	7028      	strb	r0, [r5, #0]
    RFW_SetRadioModem( modem );
 8012db4:	f001 ff18 	bl	8014be8 <RFW_SetRadioModem>
    switch( modem )
 8012db8:	2c05      	cmp	r4, #5
 8012dba:	d831      	bhi.n	8012e20 <RadioSetModem+0x74>
 8012dbc:	e8df f004 	tbb	[pc, r4]
 8012dc0:	03300f09 	.word	0x03300f09
 8012dc4:	0903      	.short	0x0903
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 8012dc6:	2002      	movs	r0, #2
 8012dc8:	f001 faa8 	bl	801431c <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8012dcc:	2300      	movs	r3, #0
 8012dce:	736b      	strb	r3, [r5, #13]
}
 8012dd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8012dd2:	2000      	movs	r0, #0
 8012dd4:	f001 faa2 	bl	801431c <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8012dd8:	2300      	movs	r3, #0
 8012dda:	736b      	strb	r3, [r5, #13]
}
 8012ddc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012dde:	2001      	movs	r0, #1
 8012de0:	f001 fa9c 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012de4:	7b2c      	ldrb	r4, [r5, #12]
 8012de6:	7b6b      	ldrb	r3, [r5, #13]
 8012de8:	42a3      	cmp	r3, r4
 8012dea:	d0f1      	beq.n	8012dd0 <RadioSetModem+0x24>
    SubgRf.Modem = modem;
 8012dec:	2601      	movs	r6, #1
    RFW_SetRadioModem( modem );
 8012dee:	4630      	mov	r0, r6
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012df0:	736c      	strb	r4, [r5, #13]
    SubgRf.Modem = modem;
 8012df2:	702e      	strb	r6, [r5, #0]
    RFW_SetRadioModem( modem );
 8012df4:	f001 fef8 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012df8:	4630      	mov	r0, r6
 8012dfa:	f001 fa8f 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012dfe:	7b2f      	ldrb	r7, [r5, #12]
 8012e00:	7b6b      	ldrb	r3, [r5, #13]
 8012e02:	42bb      	cmp	r3, r7
 8012e04:	d11e      	bne.n	8012e44 <RadioSetModem+0x98>
    if( enable == true )
 8012e06:	b18c      	cbz	r4, 8012e2c <RadioSetModem+0x80>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8012e08:	2134      	movs	r1, #52	@ 0x34
 8012e0a:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012e0e:	f001 fd81 	bl	8014914 <SUBGRF_WriteRegister>
}
 8012e12:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8012e16:	2144      	movs	r1, #68	@ 0x44
 8012e18:	f240 7041 	movw	r0, #1857	@ 0x741
 8012e1c:	f001 bd7a 	b.w	8014914 <SUBGRF_WriteRegister>
        SUBGRF_SetPacketType( PACKET_TYPE_GMSK );
 8012e20:	2003      	movs	r0, #3
 8012e22:	f001 fa7b 	bl	801431c <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8012e26:	2300      	movs	r3, #0
 8012e28:	736b      	strb	r3, [r5, #13]
}
 8012e2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8012e2c:	2114      	movs	r1, #20
 8012e2e:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012e32:	f001 fd6f 	bl	8014914 <SUBGRF_WriteRegister>
}
 8012e36:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8012e3a:	2124      	movs	r1, #36	@ 0x24
 8012e3c:	f240 7041 	movw	r0, #1857	@ 0x741
 8012e40:	f001 bd68 	b.w	8014914 <SUBGRF_WriteRegister>
    RFW_SetRadioModem( modem );
 8012e44:	4630      	mov	r0, r6
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012e46:	736f      	strb	r7, [r5, #13]
    SubgRf.Modem = modem;
 8012e48:	702e      	strb	r6, [r5, #0]
    RFW_SetRadioModem( modem );
 8012e4a:	f001 fecd 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012e4e:	4630      	mov	r0, r6
 8012e50:	f001 fa64 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012e54:	7b28      	ldrb	r0, [r5, #12]
 8012e56:	7b6b      	ldrb	r3, [r5, #13]
 8012e58:	4283      	cmp	r3, r0
 8012e5a:	d002      	beq.n	8012e62 <RadioSetModem+0xb6>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012e5c:	7368      	strb	r0, [r5, #13]
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 8012e5e:	f7ff ff6f 	bl	8012d40 <RadioSetPublicNetwork>
    if( enable == true )
 8012e62:	b167      	cbz	r7, 8012e7e <RadioSetModem+0xd2>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8012e64:	2134      	movs	r1, #52	@ 0x34
 8012e66:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012e6a:	f001 fd53 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8012e6e:	2144      	movs	r1, #68	@ 0x44
 8012e70:	f240 7041 	movw	r0, #1857	@ 0x741
 8012e74:	f001 fd4e 	bl	8014914 <SUBGRF_WriteRegister>
    if( enable == true )
 8012e78:	2c00      	cmp	r4, #0
 8012e7a:	d0d7      	beq.n	8012e2c <RadioSetModem+0x80>
 8012e7c:	e7c4      	b.n	8012e08 <RadioSetModem+0x5c>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8012e7e:	2114      	movs	r1, #20
 8012e80:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012e84:	f001 fd46 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8012e88:	2124      	movs	r1, #36	@ 0x24
 8012e8a:	f240 7041 	movw	r0, #1857	@ 0x741
 8012e8e:	f001 fd41 	bl	8014914 <SUBGRF_WriteRegister>
    if( enable == true )
 8012e92:	2c00      	cmp	r4, #0
 8012e94:	d0ca      	beq.n	8012e2c <RadioSetModem+0x80>
 8012e96:	e7b7      	b.n	8012e08 <RadioSetModem+0x5c>
 8012e98:	20001454 	.word	0x20001454

08012e9c <RadioSetModem.part.0>:
static void RadioSetModem( RadioModems_t modem )
 8012e9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012ea0:	4c3f      	ldr	r4, [pc, #252]	@ (8012fa0 <RadioSetModem.part.0+0x104>)
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012ea2:	2001      	movs	r0, #1
 8012ea4:	f001 fa3a 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012ea8:	7b26      	ldrb	r6, [r4, #12]
 8012eaa:	7b63      	ldrb	r3, [r4, #13]
 8012eac:	42b3      	cmp	r3, r6
 8012eae:	d101      	bne.n	8012eb4 <RadioSetModem.part.0+0x18>
}
 8012eb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SubgRf.Modem = modem;
 8012eb4:	2501      	movs	r5, #1
    RFW_SetRadioModem( modem );
 8012eb6:	4628      	mov	r0, r5
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012eb8:	7366      	strb	r6, [r4, #13]
    SubgRf.Modem = modem;
 8012eba:	7025      	strb	r5, [r4, #0]
    RFW_SetRadioModem( modem );
 8012ebc:	f001 fe94 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012ec0:	4628      	mov	r0, r5
 8012ec2:	f001 fa2b 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012ec6:	7b27      	ldrb	r7, [r4, #12]
 8012ec8:	7b63      	ldrb	r3, [r4, #13]
 8012eca:	42bb      	cmp	r3, r7
 8012ecc:	d017      	beq.n	8012efe <RadioSetModem.part.0+0x62>
    RFW_SetRadioModem( modem );
 8012ece:	4628      	mov	r0, r5
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012ed0:	7367      	strb	r7, [r4, #13]
    SubgRf.Modem = modem;
 8012ed2:	7025      	strb	r5, [r4, #0]
    RFW_SetRadioModem( modem );
 8012ed4:	f001 fe88 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012ed8:	4628      	mov	r0, r5
 8012eda:	f001 fa1f 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012ede:	f894 800c 	ldrb.w	r8, [r4, #12]
 8012ee2:	7b63      	ldrb	r3, [r4, #13]
 8012ee4:	4543      	cmp	r3, r8
 8012ee6:	d12e      	bne.n	8012f46 <RadioSetModem.part.0+0xaa>
    if( enable == true )
 8012ee8:	b317      	cbz	r7, 8012f30 <RadioSetModem.part.0+0x94>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8012eea:	2134      	movs	r1, #52	@ 0x34
 8012eec:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012ef0:	f001 fd10 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8012ef4:	2144      	movs	r1, #68	@ 0x44
 8012ef6:	f240 7041 	movw	r0, #1857	@ 0x741
 8012efa:	f001 fd0b 	bl	8014914 <SUBGRF_WriteRegister>
    if( enable == true )
 8012efe:	b15e      	cbz	r6, 8012f18 <RadioSetModem.part.0+0x7c>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8012f00:	2134      	movs	r1, #52	@ 0x34
 8012f02:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012f06:	f001 fd05 	bl	8014914 <SUBGRF_WriteRegister>
}
 8012f0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8012f0e:	2144      	movs	r1, #68	@ 0x44
 8012f10:	f240 7041 	movw	r0, #1857	@ 0x741
 8012f14:	f001 bcfe 	b.w	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8012f18:	2114      	movs	r1, #20
 8012f1a:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012f1e:	f001 fcf9 	bl	8014914 <SUBGRF_WriteRegister>
}
 8012f22:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8012f26:	2124      	movs	r1, #36	@ 0x24
 8012f28:	f240 7041 	movw	r0, #1857	@ 0x741
 8012f2c:	f001 bcf2 	b.w	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8012f30:	2114      	movs	r1, #20
 8012f32:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012f36:	f001 fced 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8012f3a:	2124      	movs	r1, #36	@ 0x24
 8012f3c:	f240 7041 	movw	r0, #1857	@ 0x741
 8012f40:	f001 fce8 	bl	8014914 <SUBGRF_WriteRegister>
 8012f44:	e7db      	b.n	8012efe <RadioSetModem.part.0+0x62>
    RFW_SetRadioModem( modem );
 8012f46:	4628      	mov	r0, r5
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012f48:	f884 800d 	strb.w	r8, [r4, #13]
    SubgRf.Modem = modem;
 8012f4c:	7025      	strb	r5, [r4, #0]
    RFW_SetRadioModem( modem );
 8012f4e:	f001 fe4b 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8012f52:	4628      	mov	r0, r5
 8012f54:	f001 f9e2 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8012f58:	7b20      	ldrb	r0, [r4, #12]
 8012f5a:	7b63      	ldrb	r3, [r4, #13]
 8012f5c:	4283      	cmp	r3, r0
 8012f5e:	d002      	beq.n	8012f66 <RadioSetModem.part.0+0xca>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8012f60:	7360      	strb	r0, [r4, #13]
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 8012f62:	f7ff feed 	bl	8012d40 <RadioSetPublicNetwork>
    if( enable == true )
 8012f66:	f1b8 0f00 	cmp.w	r8, #0
 8012f6a:	d00c      	beq.n	8012f86 <RadioSetModem.part.0+0xea>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8012f6c:	2134      	movs	r1, #52	@ 0x34
 8012f6e:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012f72:	f001 fccf 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8012f76:	2144      	movs	r1, #68	@ 0x44
 8012f78:	f240 7041 	movw	r0, #1857	@ 0x741
 8012f7c:	f001 fcca 	bl	8014914 <SUBGRF_WriteRegister>
    if( enable == true )
 8012f80:	2f00      	cmp	r7, #0
 8012f82:	d0d5      	beq.n	8012f30 <RadioSetModem.part.0+0x94>
 8012f84:	e7b1      	b.n	8012eea <RadioSetModem.part.0+0x4e>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8012f86:	2114      	movs	r1, #20
 8012f88:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8012f8c:	f001 fcc2 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8012f90:	2124      	movs	r1, #36	@ 0x24
 8012f92:	f240 7041 	movw	r0, #1857	@ 0x741
 8012f96:	f001 fcbd 	bl	8014914 <SUBGRF_WriteRegister>
    if( enable == true )
 8012f9a:	2f00      	cmp	r7, #0
 8012f9c:	d0c8      	beq.n	8012f30 <RadioSetModem.part.0+0x94>
 8012f9e:	e7a4      	b.n	8012eea <RadioSetModem.part.0+0x4e>
 8012fa0:	20001454 	.word	0x20001454

08012fa4 <RadioSetTxGenericConfig>:
{
 8012fa4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint8_t syncword[8] = {0};
 8012fa8:	2600      	movs	r6, #0
{
 8012faa:	b086      	sub	sp, #24
 8012fac:	4604      	mov	r4, r0
    uint8_t syncword[8] = {0};
 8012fae:	e9cd 6601 	strd	r6, r6, [sp, #4]
{
 8012fb2:	460d      	mov	r5, r1
 8012fb4:	4690      	mov	r8, r2
 8012fb6:	461f      	mov	r7, r3
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8012fb8:	f001 fe02 	bl	8014bc0 <RFW_DeInit>
    switch( modem )
 8012fbc:	2c03      	cmp	r4, #3
 8012fbe:	f200 8141 	bhi.w	8013244 <RadioSetTxGenericConfig+0x2a0>
 8012fc2:	e8df f004 	tbb	[pc, r4]
 8012fc6:	5a96      	.short	0x5a96
 8012fc8:	023d      	.short	0x023d
        if( config->msk.SyncWordLength > 8 )
 8012fca:	7caa      	ldrb	r2, [r5, #18]
 8012fcc:	2a08      	cmp	r2, #8
 8012fce:	f200 8136 	bhi.w	801323e <RadioSetTxGenericConfig+0x29a>
            RADIO_MEMCPY8( syncword, config->msk.SyncWord, config->msk.SyncWordLength );
 8012fd2:	ae01      	add	r6, sp, #4
 8012fd4:	68a9      	ldr	r1, [r5, #8]
 8012fd6:	4630      	mov	r0, r6
 8012fd8:	f001 fe6a 	bl	8014cb0 <UTIL_MEM_cpy_8>
        if( ( config->msk.BitRate == 0 ) )
 8012fdc:	682b      	ldr	r3, [r5, #0]
 8012fde:	2b00      	cmp	r3, #0
 8012fe0:	f000 812d 	beq.w	801323e <RadioSetTxGenericConfig+0x29a>
        else if( config->msk.BitRate <= 10000 )
 8012fe4:	f242 7210 	movw	r2, #10000	@ 0x2710
 8012fe8:	4293      	cmp	r3, r2
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->msk.ModulationShaping;
 8012fea:	7ce9      	ldrb	r1, [r5, #19]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GMSK;
 8012fec:	4c96      	ldr	r4, [pc, #600]	@ (8013248 <RadioSetTxGenericConfig+0x2a4>)
        else if( config->msk.BitRate <= 10000 )
 8012fee:	f200 8117 	bhi.w	8013220 <RadioSetTxGenericConfig+0x27c>
            SubgRf.ModulationParams.Params.Gfsk.BitRate = config->msk.BitRate;
 8012ff2:	63e3      	str	r3, [r4, #60]	@ 0x3c
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GMSK;
 8012ff4:	2303      	movs	r3, #3
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->msk.ModulationShaping;
 8012ff6:	f884 1044 	strb.w	r1, [r4, #68]	@ 0x44
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GMSK;
 8012ffa:	73a3      	strb	r3, [r4, #14]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GMSK;
 8012ffc:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
            radio_modem = MODEM_MSK;
 8013000:	f04f 0902 	mov.w	r9, #2
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->msk.PreambleLen ) << 3; // convert byte into bit
 8013004:	686b      	ldr	r3, [r5, #4]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 8013006:	2204      	movs	r2, #4
 8013008:	74a2      	strb	r2, [r4, #18]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->msk.PreambleLen ) << 3; // convert byte into bit
 801300a:	00db      	lsls	r3, r3, #3
 801300c:	8223      	strh	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->msk.SyncWordLength ) << 3; // convert byte into bit
 801300e:	7cab      	ldrb	r3, [r5, #18]
 8013010:	00db      	lsls	r3, r3, #3
 8013012:	74e3      	strb	r3, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->msk.CrcLength;
 8013014:	f8b5 3015 	ldrh.w	r3, [r5, #21]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 8013018:	2200      	movs	r2, #0
 801301a:	7522      	strb	r2, [r4, #20]
        if( ( config->msk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 801301c:	0a1a      	lsrs	r2, r3, #8
 801301e:	2a02      	cmp	r2, #2
 8013020:	f000 80e6 	beq.w	80131f0 <RadioSetTxGenericConfig+0x24c>
            || ( config->msk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8013024:	7d2a      	ldrb	r2, [r5, #20]
 8013026:	2a02      	cmp	r2, #2
 8013028:	f000 80e2 	beq.w	80131f0 <RadioSetTxGenericConfig+0x24c>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->msk.CrcLength;
 801302c:	f8a4 3017 	strh.w	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->msk.HeaderType;
 8013030:	7562      	strb	r2, [r4, #21]
    SUBGRF_SetStandby( STDBY_RC );
 8013032:	2000      	movs	r0, #0
 8013034:	f000 ffb2 	bl	8013f9c <SUBGRF_SetStandby>
        RadioSetModem( radio_modem );
 8013038:	4648      	mov	r0, r9
 801303a:	f7ff feb7 	bl	8012dac <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 801303e:	e093      	b.n	8013168 <RadioSetTxGenericConfig+0x1c4>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 8013040:	682b      	ldr	r3, [r5, #0]
 8013042:	3b01      	subs	r3, #1
 8013044:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8013048:	f080 80f9 	bcs.w	801323e <RadioSetTxGenericConfig+0x29a>
    SubgRf.Modem = modem;
 801304c:	4c7e      	ldr	r4, [pc, #504]	@ (8013248 <RadioSetTxGenericConfig+0x2a4>)
 801304e:	2003      	movs	r0, #3
 8013050:	7020      	strb	r0, [r4, #0]
    RFW_SetRadioModem( modem );
 8013052:	f001 fdc9 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 8013056:	2002      	movs	r0, #2
 8013058:	f001 f960 	bl	801431c <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 801305c:	2300      	movs	r3, #0
 801305e:	7363      	strb	r3, [r4, #13]
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8013060:	2302      	movs	r3, #2
 8013062:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 8013066:	682a      	ldr	r2, [r5, #0]
 8013068:	64a2      	str	r2, [r4, #72]	@ 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 801306a:	2316      	movs	r3, #22
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 801306c:	f104 0038 	add.w	r0, r4, #56	@ 0x38
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8013070:	f884 304c 	strb.w	r3, [r4, #76]	@ 0x4c
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013074:	f001 fa62 	bl	801453c <SUBGRF_SetModulationParams>
        break;
 8013078:	e085      	b.n	8013186 <RadioSetTxGenericConfig+0x1e2>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 801307a:	4c73      	ldr	r4, [pc, #460]	@ (8013248 <RadioSetTxGenericConfig+0x2a4>)
 801307c:	2101      	movs	r1, #1
 801307e:	f884 1038 	strb.w	r1, [r4, #56]	@ 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 8013082:	882a      	ldrh	r2, [r5, #0]
 8013084:	f8a4 2050 	strh.w	r2, [r4, #80]	@ 0x50
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 8013088:	78ab      	ldrb	r3, [r5, #2]
 801308a:	f884 3052 	strb.w	r3, [r4, #82]	@ 0x52
        switch( config->lora.LowDatarateOptimize )
 801308e:	78eb      	ldrb	r3, [r5, #3]
 8013090:	428b      	cmp	r3, r1
 8013092:	f000 8092 	beq.w	80131ba <RadioSetTxGenericConfig+0x216>
 8013096:	2b02      	cmp	r3, #2
 8013098:	f000 808a 	beq.w	80131b0 <RadioSetTxGenericConfig+0x20c>
 801309c:	2b00      	cmp	r3, #0
 801309e:	f000 808c 	beq.w	80131ba <RadioSetTxGenericConfig+0x216>
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80130a2:	2601      	movs	r6, #1
 80130a4:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 80130a6:	79aa      	ldrb	r2, [r5, #6]
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 80130a8:	88ab      	ldrh	r3, [r5, #4]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 80130aa:	77a2      	strb	r2, [r4, #30]
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 80130ac:	83a3      	strh	r3, [r4, #28]
    SUBGRF_SetStandby( STDBY_RC );
 80130ae:	2000      	movs	r0, #0
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 80130b0:	f8b5 3007 	ldrh.w	r3, [r5, #7]
 80130b4:	8423      	strh	r3, [r4, #32]
    SUBGRF_SetStandby( STDBY_RC );
 80130b6:	f000 ff71 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 80130ba:	4630      	mov	r0, r6
    SubgRf.Modem = modem;
 80130bc:	7026      	strb	r6, [r4, #0]
    RFW_SetRadioModem( modem );
 80130be:	f001 fd93 	bl	8014be8 <RFW_SetRadioModem>
    switch( modem )
 80130c2:	f7ff feeb 	bl	8012e9c <RadioSetModem.part.0>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80130c6:	4861      	ldr	r0, [pc, #388]	@ (801324c <RadioSetTxGenericConfig+0x2a8>)
 80130c8:	f001 fa38 	bl	801453c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80130cc:	4860      	ldr	r0, [pc, #384]	@ (8013250 <RadioSetTxGenericConfig+0x2ac>)
 80130ce:	f001 fad9 	bl	8014684 <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 80130d2:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 80130d6:	2b06      	cmp	r3, #6
            SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) & ~( 1 << 2 ) );
 80130d8:	f640 0089 	movw	r0, #2185	@ 0x889
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 80130dc:	d05f      	beq.n	801319e <RadioSetTxGenericConfig+0x1fa>
            SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) | ( 1 << 2 ) );
 80130de:	f001 fc2b 	bl	8014938 <SUBGRF_ReadRegister>
 80130e2:	f040 0104 	orr.w	r1, r0, #4
 80130e6:	b2c9      	uxtb	r1, r1
 80130e8:	f640 0089 	movw	r0, #2185	@ 0x889
 80130ec:	f001 fc12 	bl	8014914 <SUBGRF_WriteRegister>
 80130f0:	e049      	b.n	8013186 <RadioSetTxGenericConfig+0x1e2>
        if( config->fsk.BitRate == 0 )
 80130f2:	682b      	ldr	r3, [r5, #0]
 80130f4:	2b00      	cmp	r3, #0
 80130f6:	f000 80a2 	beq.w	801323e <RadioSetTxGenericConfig+0x29a>
        if( config->fsk.SyncWordLength > 8 )
 80130fa:	7caa      	ldrb	r2, [r5, #18]
 80130fc:	2a08      	cmp	r2, #8
 80130fe:	f200 809e 	bhi.w	801323e <RadioSetTxGenericConfig+0x29a>
            RADIO_MEMCPY8( syncword, config->fsk.SyncWord, config->fsk.SyncWordLength );
 8013102:	ae01      	add	r6, sp, #4
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8013104:	4c50      	ldr	r4, [pc, #320]	@ (8013248 <RadioSetTxGenericConfig+0x2a4>)
            RADIO_MEMCPY8( syncword, config->fsk.SyncWord, config->fsk.SyncWordLength );
 8013106:	68a9      	ldr	r1, [r5, #8]
 8013108:	4630      	mov	r0, r6
 801310a:	f001 fdd1 	bl	8014cb0 <UTIL_MEM_cpy_8>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 801310e:	2200      	movs	r2, #0
 8013110:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8013114:	682b      	ldr	r3, [r5, #0]
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 8013116:	7ce8      	ldrb	r0, [r5, #19]
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8013118:	69a9      	ldr	r1, [r5, #24]
 801311a:	6421      	str	r1, [r4, #64]	@ 0x40
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 801311c:	f884 0044 	strb.w	r0, [r4, #68]	@ 0x44
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8013120:	63e3      	str	r3, [r4, #60]	@ 0x3c
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8013122:	73a2      	strb	r2, [r4, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 8013124:	686b      	ldr	r3, [r5, #4]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 8013126:	2104      	movs	r1, #4
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 8013128:	00db      	lsls	r3, r3, #3
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 801312a:	74a1      	strb	r1, [r4, #18]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 801312c:	8223      	strh	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 801312e:	7cab      	ldrb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 8013130:	7522      	strb	r2, [r4, #20]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 8013132:	00db      	lsls	r3, r3, #3
 8013134:	74e3      	strb	r3, [r4, #19]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 8013136:	7dab      	ldrb	r3, [r5, #22]
 8013138:	2b02      	cmp	r3, #2
 801313a:	d041      	beq.n	80131c0 <RadioSetTxGenericConfig+0x21c>
            || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 801313c:	7d2a      	ldrb	r2, [r5, #20]
 801313e:	2a02      	cmp	r2, #2
 8013140:	d03e      	beq.n	80131c0 <RadioSetTxGenericConfig+0x21c>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8013142:	7d69      	ldrb	r1, [r5, #21]
 8013144:	75e1      	strb	r1, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8013146:	7623      	strb	r3, [r4, #24]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 8013148:	7562      	strb	r2, [r4, #21]
    SubgRf.Modem = modem;
 801314a:	f04f 0900 	mov.w	r9, #0
    SUBGRF_SetStandby( STDBY_RC );
 801314e:	4648      	mov	r0, r9
 8013150:	f000 ff24 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 8013154:	4648      	mov	r0, r9
    SubgRf.Modem = modem;
 8013156:	f884 9000 	strb.w	r9, [r4]
    RFW_SetRadioModem( modem );
 801315a:	f001 fd45 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 801315e:	4648      	mov	r0, r9
 8013160:	f001 f8dc 	bl	801431c <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8013164:	f884 900d 	strb.w	r9, [r4, #13]
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013168:	4838      	ldr	r0, [pc, #224]	@ (801324c <RadioSetTxGenericConfig+0x2a8>)
 801316a:	f001 f9e7 	bl	801453c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 801316e:	4838      	ldr	r0, [pc, #224]	@ (8013250 <RadioSetTxGenericConfig+0x2ac>)
 8013170:	f001 fa88 	bl	8014684 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 8013174:	4630      	mov	r0, r6
 8013176:	f000 fdf9 	bl	8013d6c <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 801317a:	8a28      	ldrh	r0, [r5, #16]
 801317c:	f000 fe24 	bl	8013dc8 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 8013180:	89a8      	ldrh	r0, [r5, #12]
 8013182:	f000 fe05 	bl	8013d90 <SUBGRF_SetCrcPolynomial>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8013186:	4640      	mov	r0, r8
 8013188:	f001 fc3e 	bl	8014a08 <SUBGRF_SetRfTxPower>
 801318c:	f884 0056 	strb.w	r0, [r4, #86]	@ 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 8013190:	f001 fd1c 	bl	8014bcc <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8013194:	6067      	str	r7, [r4, #4]
    return 0;
 8013196:	2000      	movs	r0, #0
}
 8013198:	b006      	add	sp, #24
 801319a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) & ~( 1 << 2 ) );
 801319e:	f001 fbcb 	bl	8014938 <SUBGRF_ReadRegister>
 80131a2:	f000 01fb 	and.w	r1, r0, #251	@ 0xfb
 80131a6:	f640 0089 	movw	r0, #2185	@ 0x889
 80131aa:	f001 fbb3 	bl	8014914 <SUBGRF_WriteRegister>
 80131ae:	e7ea      	b.n	8013186 <RadioSetTxGenericConfig+0x1e2>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 80131b0:	3a0b      	subs	r2, #11
 80131b2:	b2d2      	uxtb	r2, r2
 80131b4:	2a01      	cmp	r2, #1
 80131b6:	d93f      	bls.n	8013238 <RadioSetTxGenericConfig+0x294>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 80131b8:	2300      	movs	r3, #0
 80131ba:	f884 3053 	strb.w	r3, [r4, #83]	@ 0x53
 80131be:	e770      	b.n	80130a2 <RadioSetTxGenericConfig+0xfe>
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT )
 80131c0:	7d6a      	ldrb	r2, [r5, #21]
 80131c2:	f102 030f 	add.w	r3, r2, #15
 80131c6:	b2db      	uxtb	r3, r3
 80131c8:	2b01      	cmp	r3, #1
 80131ca:	d901      	bls.n	80131d0 <RadioSetTxGenericConfig+0x22c>
                && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80131cc:	2a01      	cmp	r2, #1
 80131ce:	d136      	bne.n	801323e <RadioSetTxGenericConfig+0x29a>
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80131d0:	4b20      	ldr	r3, [pc, #128]	@ (8013254 <RadioSetTxGenericConfig+0x2b0>)
 80131d2:	4a21      	ldr	r2, [pc, #132]	@ (8013258 <RadioSetTxGenericConfig+0x2b4>)
 80131d4:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.TxConfig = config;
 80131d6:	9503      	str	r5, [sp, #12]
            ConfigGeneric.rtx = CONFIG_TX;
 80131d8:	f04f 0901 	mov.w	r9, #1
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80131dc:	a803      	add	r0, sp, #12
            ConfigGeneric.rtx = CONFIG_TX;
 80131de:	f88d 9014 	strb.w	r9, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80131e2:	f001 fce9 	bl	8014bb8 <RFW_Init>
 80131e6:	bb50      	cbnz	r0, 801323e <RadioSetTxGenericConfig+0x29a>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 80131e8:	f8a4 9017 	strh.w	r9, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 80131ec:	7560      	strb	r0, [r4, #21]
        {
 80131ee:	e7ac      	b.n	801314a <RadioSetTxGenericConfig+0x1a6>
 80131f0:	b2db      	uxtb	r3, r3
            if( ( config->msk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->msk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT )
 80131f2:	f103 020f 	add.w	r2, r3, #15
 80131f6:	b2d2      	uxtb	r2, r2
 80131f8:	2a01      	cmp	r2, #1
 80131fa:	d901      	bls.n	8013200 <RadioSetTxGenericConfig+0x25c>
                && ( config->msk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80131fc:	2b01      	cmp	r3, #1
 80131fe:	d11e      	bne.n	801323e <RadioSetTxGenericConfig+0x29a>
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8013200:	4b14      	ldr	r3, [pc, #80]	@ (8013254 <RadioSetTxGenericConfig+0x2b0>)
 8013202:	4a15      	ldr	r2, [pc, #84]	@ (8013258 <RadioSetTxGenericConfig+0x2b4>)
 8013204:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.TxConfig = config;
 8013206:	9503      	str	r5, [sp, #12]
            ConfigGeneric.rtx = CONFIG_TX;
 8013208:	f04f 0a01 	mov.w	sl, #1
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 801320c:	a803      	add	r0, sp, #12
            ConfigGeneric.rtx = CONFIG_TX;
 801320e:	f88d a014 	strb.w	sl, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8013212:	f001 fcd1 	bl	8014bb8 <RFW_Init>
 8013216:	b990      	cbnz	r0, 801323e <RadioSetTxGenericConfig+0x29a>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8013218:	f8a4 a017 	strh.w	sl, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 801321c:	7560      	strb	r0, [r4, #21]
        {
 801321e:	e708      	b.n	8013032 <RadioSetTxGenericConfig+0x8e>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8013220:	f04f 0900 	mov.w	r9, #0
            SubgRf.ModulationParams.Params.Gfsk.BitRate = config->msk.BitRate;
 8013224:	63e3      	str	r3, [r4, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Fdev = config->msk.BitRate / 4;
 8013226:	089b      	lsrs	r3, r3, #2
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->msk.ModulationShaping;
 8013228:	f884 1044 	strb.w	r1, [r4, #68]	@ 0x44
            SubgRf.ModulationParams.Params.Gfsk.Fdev = config->msk.BitRate / 4;
 801322c:	6423      	str	r3, [r4, #64]	@ 0x40
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 801322e:	f884 900e 	strb.w	r9, [r4, #14]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8013232:	f884 9038 	strb.w	r9, [r4, #56]	@ 0x38
            SubgRf.ModulationParams.Params.Gfsk.Fdev = config->msk.BitRate / 4;
 8013236:	e6e5      	b.n	8013004 <RadioSetTxGenericConfig+0x60>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8013238:	f884 1053 	strb.w	r1, [r4, #83]	@ 0x53
 801323c:	e731      	b.n	80130a2 <RadioSetTxGenericConfig+0xfe>
            return -1;
 801323e:	f04f 30ff 	mov.w	r0, #4294967295
 8013242:	e7a9      	b.n	8013198 <RadioSetTxGenericConfig+0x1f4>
 8013244:	4c00      	ldr	r4, [pc, #0]	@ (8013248 <RadioSetTxGenericConfig+0x2a4>)
 8013246:	e79e      	b.n	8013186 <RadioSetTxGenericConfig+0x1e2>
 8013248:	20001454 	.word	0x20001454
 801324c:	2000148c 	.word	0x2000148c
 8013250:	20001462 	.word	0x20001462
 8013254:	200014b0 	.word	0x200014b0
 8013258:	2000143c 	.word	0x2000143c

0801325c <RadioSetRxGenericConfig>:
{
 801325c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013260:	4616      	mov	r6, r2
 8013262:	b086      	sub	sp, #24
    uint8_t syncword[8] = {0};
 8013264:	2200      	movs	r2, #0
 8013266:	e9cd 2201 	strd	r2, r2, [sp, #4]
{
 801326a:	4698      	mov	r8, r3
 801326c:	4605      	mov	r5, r0
 801326e:	460c      	mov	r4, r1
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8013270:	f001 fca6 	bl	8014bc0 <RFW_DeInit>
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 8013274:	4f87      	ldr	r7, [pc, #540]	@ (8013494 <RadioSetRxGenericConfig+0x238>)
        symbTimeout = 0;
 8013276:	2e00      	cmp	r6, #0
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 8013278:	bf16      	itet	ne
 801327a:	2201      	movne	r2, #1
 801327c:	2200      	moveq	r2, #0
        symbTimeout = 0;
 801327e:	f04f 0800 	movne.w	r8, #0
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 8013282:	707a      	strb	r2, [r7, #1]
    switch( modem )
 8013284:	b12d      	cbz	r5, 8013292 <RadioSetRxGenericConfig+0x36>
 8013286:	2d01      	cmp	r5, #1
 8013288:	d05a      	beq.n	8013340 <RadioSetRxGenericConfig+0xe4>
    return status;
 801328a:	2000      	movs	r0, #0
}
 801328c:	b006      	add	sp, #24
 801328e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 8013292:	68a3      	ldr	r3, [r4, #8]
 8013294:	2b00      	cmp	r3, #0
 8013296:	f000 80f9 	beq.w	801348c <RadioSetRxGenericConfig+0x230>
 801329a:	68e3      	ldr	r3, [r4, #12]
 801329c:	2b00      	cmp	r3, #0
 801329e:	f000 80f5 	beq.w	801348c <RadioSetRxGenericConfig+0x230>
        if( config->fsk.SyncWordLength > 8 )
 80132a2:	7fa2      	ldrb	r2, [r4, #30]
 80132a4:	2a08      	cmp	r2, #8
 80132a6:	f200 80f1 	bhi.w	801348c <RadioSetRxGenericConfig+0x230>
            RADIO_MEMCPY8( syncword, config->fsk.SyncWord, config->fsk.SyncWordLength );
 80132aa:	6921      	ldr	r1, [r4, #16]
 80132ac:	a801      	add	r0, sp, #4
 80132ae:	f001 fcff 	bl	8014cb0 <UTIL_MEM_cpy_8>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 80132b2:	6820      	ldr	r0, [r4, #0]
 80132b4:	3800      	subs	r0, #0
 80132b6:	bf18      	it	ne
 80132b8:	2001      	movne	r0, #1
 80132ba:	f000 ff4d 	bl	8014158 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80132be:	f887 5038 	strb.w	r5, [r7, #56]	@ 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 80132c2:	68a3      	ldr	r3, [r4, #8]
 80132c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 80132c6:	f894 3020 	ldrb.w	r3, [r4, #32]
 80132ca:	f887 3044 	strb.w	r3, [r7, #68]	@ 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 80132ce:	6860      	ldr	r0, [r4, #4]
 80132d0:	f001 fc02 	bl	8014ad8 <SUBGRF_GetFskBandwidthRegValue>
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80132d4:	73bd      	strb	r5, [r7, #14]
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 80132d6:	f887 0045 	strb.w	r0, [r7, #69]	@ 0x45
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 80132da:	68e3      	ldr	r3, [r4, #12]
 80132dc:	00db      	lsls	r3, r3, #3
 80132de:	823b      	strh	r3, [r7, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 80132e0:	7fe3      	ldrb	r3, [r4, #31]
 80132e2:	74bb      	strb	r3, [r7, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80132e4:	7fa3      	ldrb	r3, [r4, #30]
 80132e6:	00db      	lsls	r3, r3, #3
 80132e8:	74fb      	strb	r3, [r7, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 80132ea:	f894 3021 	ldrb.w	r3, [r4, #33]	@ 0x21
 80132ee:	753b      	strb	r3, [r7, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 80132f0:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 80132f4:	2b00      	cmp	r3, #0
 80132f6:	f040 8088 	bne.w	801340a <RadioSetRxGenericConfig+0x1ae>
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 80132fa:	f894 2024 	ldrb.w	r2, [r4, #36]	@ 0x24
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 80132fe:	6961      	ldr	r1, [r4, #20]
 8013300:	75b9      	strb	r1, [r7, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 8013302:	2a02      	cmp	r2, #2
 8013304:	f040 808a 	bne.w	801341c <RadioSetRxGenericConfig+0x1c0>
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT )
 8013308:	f894 2023 	ldrb.w	r2, [r4, #35]	@ 0x23
 801330c:	f102 030f 	add.w	r3, r2, #15
 8013310:	b2db      	uxtb	r3, r3
 8013312:	2b01      	cmp	r3, #1
 8013314:	d902      	bls.n	801331c <RadioSetRxGenericConfig+0xc0>
                && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 8013316:	2a01      	cmp	r2, #1
 8013318:	f040 80b8 	bne.w	801348c <RadioSetRxGenericConfig+0x230>
            ConfigGeneric.rtx = CONFIG_RX;
 801331c:	2300      	movs	r3, #0
 801331e:	f88d 3014 	strb.w	r3, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 8013322:	4b5d      	ldr	r3, [pc, #372]	@ (8013498 <RadioSetRxGenericConfig+0x23c>)
 8013324:	4a5d      	ldr	r2, [pc, #372]	@ (801349c <RadioSetRxGenericConfig+0x240>)
 8013326:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.RxConfig = config;
 8013328:	9404      	str	r4, [sp, #16]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 801332a:	a803      	add	r0, sp, #12
 801332c:	f001 fc44 	bl	8014bb8 <RFW_Init>
 8013330:	2800      	cmp	r0, #0
 8013332:	f040 80ab 	bne.w	801348c <RadioSetRxGenericConfig+0x230>
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8013336:	2301      	movs	r3, #1
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 8013338:	7578      	strb	r0, [r7, #21]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 801333a:	f8a7 3017 	strh.w	r3, [r7, #23]
        {
 801333e:	e072      	b.n	8013426 <RadioSetRxGenericConfig+0x1ca>
        if( config->lora.PreambleLen == 0 )
 8013340:	8e23      	ldrh	r3, [r4, #48]	@ 0x30
 8013342:	2b00      	cmp	r3, #0
 8013344:	f000 80a2 	beq.w	801348c <RadioSetRxGenericConfig+0x230>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8013348:	f894 3032 	ldrb.w	r3, [r4, #50]	@ 0x32
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 801334c:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 801334e:	2b01      	cmp	r3, #1
            MaxPayloadLength = config->fsk.MaxPayloadLength;
 8013350:	bf0c      	ite	eq
 8013352:	7d26      	ldrbeq	r6, [r4, #20]
            MaxPayloadLength = 0xFF;
 8013354:	26ff      	movne	r6, #255	@ 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8013356:	3800      	subs	r0, #0
 8013358:	bf18      	it	ne
 801335a:	2001      	movne	r0, #1
 801335c:	f000 fefc 	bl	8014158 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8013360:	fa5f f088 	uxtb.w	r0, r8
 8013364:	f000 ff0c 	bl	8014180 <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8013368:	2101      	movs	r1, #1
 801336a:	f887 1038 	strb.w	r1, [r7, #56]	@ 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 801336e:	8da2      	ldrh	r2, [r4, #44]	@ 0x2c
 8013370:	f8a7 2050 	strh.w	r2, [r7, #80]	@ 0x50
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 8013374:	f894 302e 	ldrb.w	r3, [r4, #46]	@ 0x2e
 8013378:	f887 3052 	strb.w	r3, [r7, #82]	@ 0x52
        switch( config->lora.LowDatarateOptimize )
 801337c:	f894 302f 	ldrb.w	r3, [r4, #47]	@ 0x2f
 8013380:	428b      	cmp	r3, r1
 8013382:	d03f      	beq.n	8013404 <RadioSetRxGenericConfig+0x1a8>
 8013384:	2b02      	cmp	r3, #2
 8013386:	d038      	beq.n	80133fa <RadioSetRxGenericConfig+0x19e>
 8013388:	2b00      	cmp	r3, #0
 801338a:	d03b      	beq.n	8013404 <RadioSetRxGenericConfig+0x1a8>
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 801338c:	8e23      	ldrh	r3, [r4, #48]	@ 0x30
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 801338e:	f894 2032 	ldrb.w	r2, [r4, #50]	@ 0x32
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 8013392:	83bb      	strh	r3, [r7, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 8013394:	2300      	movs	r3, #0
 8013396:	f894 1034 	ldrb.w	r1, [r4, #52]	@ 0x34
 801339a:	f362 0307 	bfi	r3, r2, #0, #8
 801339e:	f366 230f 	bfi	r3, r6, #8, #8
 80133a2:	f894 2035 	ldrb.w	r2, [r4, #53]	@ 0x35
 80133a6:	f361 4317 	bfi	r3, r1, #16, #8
 80133aa:	f362 631f 	bfi	r3, r2, #24, #8
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80133ae:	2501      	movs	r5, #1
    SUBGRF_SetStandby( STDBY_RC );
 80133b0:	2000      	movs	r0, #0
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 80133b2:	f8c7 301e 	str.w	r3, [r7, #30]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80133b6:	73bd      	strb	r5, [r7, #14]
    SUBGRF_SetStandby( STDBY_RC );
 80133b8:	f000 fdf0 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 80133bc:	4628      	mov	r0, r5
    SubgRf.Modem = modem;
 80133be:	703d      	strb	r5, [r7, #0]
    RFW_SetRadioModem( modem );
 80133c0:	f001 fc12 	bl	8014be8 <RFW_SetRadioModem>
    switch( modem )
 80133c4:	f7ff fd6a 	bl	8012e9c <RadioSetModem.part.0>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80133c8:	4835      	ldr	r0, [pc, #212]	@ (80134a0 <RadioSetRxGenericConfig+0x244>)
 80133ca:	f001 f8b7 	bl	801453c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80133ce:	4835      	ldr	r0, [pc, #212]	@ (80134a4 <RadioSetRxGenericConfig+0x248>)
 80133d0:	f001 f958 	bl	8014684 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 80133d4:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 80133d8:	42ab      	cmp	r3, r5
            SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) & ~( 1 << 2 ) );
 80133da:	f240 7036 	movw	r0, #1846	@ 0x736
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 80133de:	d046      	beq.n	801346e <RadioSetRxGenericConfig+0x212>
            SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) | ( 1 << 2 ) );
 80133e0:	f001 faaa 	bl	8014938 <SUBGRF_ReadRegister>
 80133e4:	f040 0104 	orr.w	r1, r0, #4
 80133e8:	b2c9      	uxtb	r1, r1
 80133ea:	f240 7036 	movw	r0, #1846	@ 0x736
 80133ee:	f001 fa91 	bl	8014914 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 80133f2:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80133f6:	60bb      	str	r3, [r7, #8]
        break;
 80133f8:	e747      	b.n	801328a <RadioSetRxGenericConfig+0x2e>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 80133fa:	3a0b      	subs	r2, #11
 80133fc:	b2d2      	uxtb	r2, r2
 80133fe:	2a01      	cmp	r2, #1
 8013400:	d941      	bls.n	8013486 <RadioSetRxGenericConfig+0x22a>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8013402:	2300      	movs	r3, #0
 8013404:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
 8013408:	e7c0      	b.n	801338c <RadioSetRxGenericConfig+0x130>
        else if( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH )
 801340a:	2b02      	cmp	r3, #2
 801340c:	d038      	beq.n	8013480 <RadioSetRxGenericConfig+0x224>
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 801340e:	f894 2024 	ldrb.w	r2, [r4, #36]	@ 0x24
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 8013412:	21ff      	movs	r1, #255	@ 0xff
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 8013414:	2a02      	cmp	r2, #2
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 8013416:	75b9      	strb	r1, [r7, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 8013418:	f43f af76 	beq.w	8013308 <RadioSetRxGenericConfig+0xac>
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 801341c:	757b      	strb	r3, [r7, #21]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 801341e:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8013422:	763a      	strb	r2, [r7, #24]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8013424:	75fb      	strb	r3, [r7, #23]
    SubgRf.Modem = modem;
 8013426:	2500      	movs	r5, #0
    SUBGRF_SetStandby( STDBY_RC );
 8013428:	2000      	movs	r0, #0
 801342a:	f000 fdb7 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 801342e:	4628      	mov	r0, r5
    SubgRf.Modem = modem;
 8013430:	703d      	strb	r5, [r7, #0]
    RFW_SetRadioModem( modem );
 8013432:	f001 fbd9 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8013436:	4628      	mov	r0, r5
 8013438:	f000 ff70 	bl	801431c <SUBGRF_SetPacketType>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 801343c:	4818      	ldr	r0, [pc, #96]	@ (80134a0 <RadioSetRxGenericConfig+0x244>)
        SubgRf.PublicNetwork.Current = false;
 801343e:	737d      	strb	r5, [r7, #13]
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013440:	f001 f87c 	bl	801453c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8013444:	4817      	ldr	r0, [pc, #92]	@ (80134a4 <RadioSetRxGenericConfig+0x248>)
 8013446:	f001 f91d 	bl	8014684 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 801344a:	a801      	add	r0, sp, #4
 801344c:	f000 fc8e 	bl	8013d6c <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 8013450:	8ba0      	ldrh	r0, [r4, #28]
 8013452:	f000 fcb9 	bl	8013dc8 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 8013456:	8b20      	ldrh	r0, [r4, #24]
 8013458:	f000 fc9a 	bl	8013d90 <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 801345c:	f44f 53fa 	mov.w	r3, #8000	@ 0x1f40
 8013460:	68a2      	ldr	r2, [r4, #8]
 8013462:	fb03 f308 	mul.w	r3, r3, r8
 8013466:	fbb3 f3f2 	udiv	r3, r3, r2
 801346a:	60bb      	str	r3, [r7, #8]
        break;
 801346c:	e70d      	b.n	801328a <RadioSetRxGenericConfig+0x2e>
            SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) & ~( 1 << 2 ) );
 801346e:	f001 fa63 	bl	8014938 <SUBGRF_ReadRegister>
 8013472:	f000 01fb 	and.w	r1, r0, #251	@ 0xfb
 8013476:	f240 7036 	movw	r0, #1846	@ 0x736
 801347a:	f001 fa4b 	bl	8014914 <SUBGRF_WriteRegister>
 801347e:	e7b8      	b.n	80133f2 <RadioSetRxGenericConfig+0x196>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 8013480:	23ff      	movs	r3, #255	@ 0xff
 8013482:	75bb      	strb	r3, [r7, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING )
 8013484:	e740      	b.n	8013308 <RadioSetRxGenericConfig+0xac>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8013486:	f887 1053 	strb.w	r1, [r7, #83]	@ 0x53
 801348a:	e77f      	b.n	801338c <RadioSetRxGenericConfig+0x130>
            return -1;
 801348c:	f04f 30ff 	mov.w	r0, #4294967295
 8013490:	e6fc      	b.n	801328c <RadioSetRxGenericConfig+0x30>
 8013492:	bf00      	nop
 8013494:	20001454 	.word	0x20001454
 8013498:	200014b0 	.word	0x200014b0
 801349c:	20001424 	.word	0x20001424
 80134a0:	2000148c 	.word	0x2000148c
 80134a4:	20001462 	.word	0x20001462

080134a8 <RadioSetRxConfig>:
{
 80134a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80134ac:	b087      	sub	sp, #28
    SubgRf.RxContinuous = rxContinuous;
 80134ae:	f8df b314 	ldr.w	fp, [pc, #788]	@ 80137c4 <RadioSetRxConfig+0x31c>
{
 80134b2:	f89d 9064 	ldrb.w	r9, [sp, #100]	@ 0x64
 80134b6:	9302      	str	r3, [sp, #8]
 80134b8:	f89d 3054 	ldrb.w	r3, [sp, #84]	@ 0x54
 80134bc:	f8bd 4044 	ldrh.w	r4, [sp, #68]	@ 0x44
 80134c0:	f89d 804c 	ldrb.w	r8, [sp, #76]	@ 0x4c
 80134c4:	9301      	str	r3, [sp, #4]
 80134c6:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 80134ca:	f89d 7050 	ldrb.w	r7, [sp, #80]	@ 0x50
 80134ce:	f8bd 6048 	ldrh.w	r6, [sp, #72]	@ 0x48
 80134d2:	9400      	str	r4, [sp, #0]
 80134d4:	4682      	mov	sl, r0
 80134d6:	460d      	mov	r5, r1
 80134d8:	4614      	mov	r4, r2
    SubgRf.RxContinuous = rxContinuous;
 80134da:	f88b 9001 	strb.w	r9, [fp, #1]
{
 80134de:	9303      	str	r3, [sp, #12]
    RFW_DeInit();
 80134e0:	f001 fb6e 	bl	8014bc0 <RFW_DeInit>
        symbTimeout = 0;
 80134e4:	f1b9 0f00 	cmp.w	r9, #0
 80134e8:	49b7      	ldr	r1, [pc, #732]	@ (80137c8 <RadioSetRxConfig+0x320>)
 80134ea:	bf18      	it	ne
 80134ec:	2600      	movne	r6, #0
        MaxPayloadLength = 0xFF;
 80134ee:	f1b8 0f00 	cmp.w	r8, #0
 80134f2:	bf08      	it	eq
 80134f4:	27ff      	moveq	r7, #255	@ 0xff
    switch( modem )
 80134f6:	f1ba 0f01 	cmp.w	sl, #1
 80134fa:	700f      	strb	r7, [r1, #0]
 80134fc:	d009      	beq.n	8013512 <RadioSetRxConfig+0x6a>
 80134fe:	f1ba 0f05 	cmp.w	sl, #5
 8013502:	f000 80cc 	beq.w	801369e <RadioSetRxConfig+0x1f6>
 8013506:	f1ba 0f00 	cmp.w	sl, #0
 801350a:	d06e      	beq.n	80135ea <RadioSetRxConfig+0x142>
}
 801350c:	b007      	add	sp, #28
 801350e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8013512:	2000      	movs	r0, #0
 8013514:	f000 fe20 	bl	8014158 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8013518:	4aac      	ldr	r2, [pc, #688]	@ (80137cc <RadioSetRxConfig+0x324>)
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 801351a:	49ab      	ldr	r1, [pc, #684]	@ (80137c8 <RadioSetRxConfig+0x320>)
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 801351c:	5d50      	ldrb	r0, [r2, r5]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 801351e:	f88b a038 	strb.w	sl, [fp, #56]	@ 0x38
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8013522:	b2e2      	uxtb	r2, r4
 8013524:	f88b 2050 	strb.w	r2, [fp, #80]	@ 0x50
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8013528:	2d00      	cmp	r5, #0
 801352a:	f000 813b 	beq.w	80137a4 <RadioSetRxConfig+0x2fc>
 801352e:	2d01      	cmp	r5, #1
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 8013530:	bf03      	ittte	eq
 8013532:	3c0c      	subeq	r4, #12
 8013534:	fab4 f484 	clzeq	r4, r4
 8013538:	0964      	lsreq	r4, r4, #5
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 801353a:	2400      	movne	r4, #0
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 801353c:	3a05      	subs	r2, #5
 801353e:	2a01      	cmp	r2, #1
 8013540:	d804      	bhi.n	801354c <RadioSetRxConfig+0xa4>
                if( preambleLen < 12 )
 8013542:	9b00      	ldr	r3, [sp, #0]
 8013544:	2b0c      	cmp	r3, #12
 8013546:	bf38      	it	cc
 8013548:	230c      	movcc	r3, #12
 801354a:	9300      	str	r3, [sp, #0]
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 801354c:	9b02      	ldr	r3, [sp, #8]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 801354e:	7809      	ldrb	r1, [r1, #0]
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8013550:	f88b 3052 	strb.w	r3, [fp, #82]	@ 0x52
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8013554:	2200      	movs	r2, #0
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8013556:	9b00      	ldr	r3, [sp, #0]
 8013558:	f8ab 301c 	strh.w	r3, [fp, #28]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 801355c:	f368 0207 	bfi	r2, r8, #0, #8
 8013560:	9b01      	ldr	r3, [sp, #4]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8013562:	f88b 0051 	strb.w	r0, [fp, #81]	@ 0x51
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8013566:	f361 220f 	bfi	r2, r1, #8, #8
 801356a:	f363 4217 	bfi	r2, r3, #16, #8
 801356e:	9b03      	ldr	r3, [sp, #12]
 8013570:	f88b 4053 	strb.w	r4, [fp, #83]	@ 0x53
 8013574:	f363 621f 	bfi	r2, r3, #24, #8
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8013578:	2401      	movs	r4, #1
    SUBGRF_SetStandby( STDBY_RC );
 801357a:	2000      	movs	r0, #0
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 801357c:	f8cb 201e 	str.w	r2, [fp, #30]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8013580:	f88b 400e 	strb.w	r4, [fp, #14]
    SUBGRF_SetStandby( STDBY_RC );
 8013584:	f000 fd0a 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 8013588:	4620      	mov	r0, r4
    SubgRf.Modem = modem;
 801358a:	f88b 4000 	strb.w	r4, [fp]
    RFW_SetRadioModem( modem );
 801358e:	f001 fb2b 	bl	8014be8 <RFW_SetRadioModem>
    switch( modem )
 8013592:	f7ff fc83 	bl	8012e9c <RadioSetModem.part.0>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013596:	488e      	ldr	r0, [pc, #568]	@ (80137d0 <RadioSetRxConfig+0x328>)
 8013598:	f000 ffd0 	bl	801453c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 801359c:	488d      	ldr	r0, [pc, #564]	@ (80137d4 <RadioSetRxConfig+0x32c>)
 801359e:	f001 f871 	bl	8014684 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 80135a2:	b2f0      	uxtb	r0, r6
 80135a4:	f000 fdec 	bl	8014180 <SUBGRF_SetLoRaSymbNumTimeout>
            SUBGRF_WriteRegister(SUBGHZ_AGCCFG,SUBGRF_ReadRegister(SUBGHZ_AGCCFG)&0x1);
 80135a8:	f640 00a3 	movw	r0, #2211	@ 0x8a3
 80135ac:	f001 f9c4 	bl	8014938 <SUBGRF_ReadRegister>
 80135b0:	ea00 0104 	and.w	r1, r0, r4
 80135b4:	f640 00a3 	movw	r0, #2211	@ 0x8a3
 80135b8:	f001 f9ac 	bl	8014914 <SUBGRF_WriteRegister>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 80135bc:	f89b 2021 	ldrb.w	r2, [fp, #33]	@ 0x21
 80135c0:	42a2      	cmp	r2, r4
                SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) & ~( 1 << 2 ) );
 80135c2:	f240 7036 	movw	r0, #1846	@ 0x736
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 80135c6:	f000 80f3 	beq.w	80137b0 <RadioSetRxConfig+0x308>
                SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) | ( 1 << 2 ) );
 80135ca:	f001 f9b5 	bl	8014938 <SUBGRF_ReadRegister>
 80135ce:	f040 0104 	orr.w	r1, r0, #4
 80135d2:	b2c9      	uxtb	r1, r1
 80135d4:	f240 7036 	movw	r0, #1846	@ 0x736
 80135d8:	f001 f99c 	bl	8014914 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 80135dc:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80135e0:	f8cb 2008 	str.w	r2, [fp, #8]
}
 80135e4:	b007      	add	sp, #28
 80135e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 80135ea:	4650      	mov	r0, sl
 80135ec:	f000 fdb4 	bl	8014158 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 80135f0:	4628      	mov	r0, r5
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 80135f2:	250b      	movs	r5, #11
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80135f4:	f88b a038 	strb.w	sl, [fp, #56]	@ 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 80135f8:	f8cb 403c 	str.w	r4, [fp, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 80135fc:	f88b 5044 	strb.w	r5, [fp, #68]	@ 0x44
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8013600:	f001 fa6a 	bl	8014ad8 <SUBGRF_GetFskBandwidthRegValue>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 8013604:	9b01      	ldr	r3, [sp, #4]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8013606:	4970      	ldr	r1, [pc, #448]	@ (80137c8 <RadioSetRxConfig+0x320>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8013608:	f88b 0045 	strb.w	r0, [fp, #69]	@ 0x45
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 801360c:	2b00      	cmp	r3, #0
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 801360e:	7809      	ldrb	r1, [r1, #0]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8013610:	9b00      	ldr	r3, [sp, #0]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8013612:	f88b 1016 	strb.w	r1, [fp, #22]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 8013616:	bf0c      	ite	eq
 8013618:	2101      	moveq	r1, #1
 801361a:	21f2      	movne	r1, #242	@ 0xf2
 801361c:	f88b 1017 	strb.w	r1, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8013620:	2101      	movs	r1, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8013622:	ea4f 09c3 	mov.w	r9, r3, lsl #3
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8013626:	f88b 1018 	strb.w	r1, [fp, #24]
    SUBGRF_SetStandby( STDBY_RC );
 801362a:	4650      	mov	r0, sl
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 801362c:	f641 0104 	movw	r1, #6148	@ 0x1804
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8013630:	f088 0801 	eor.w	r8, r8, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8013634:	f8ab 1012 	strh.w	r1, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8013638:	f8ab 9010 	strh.w	r9, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 801363c:	f88b 8015 	strb.w	r8, [fp, #21]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8013640:	f88b a00e 	strb.w	sl, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8013644:	f88b a014 	strb.w	sl, [fp, #20]
    SUBGRF_SetStandby( STDBY_RC );
 8013648:	f000 fca8 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 801364c:	4650      	mov	r0, sl
    SubgRf.Modem = modem;
 801364e:	f88b a000 	strb.w	sl, [fp]
    RFW_SetRadioModem( modem );
 8013652:	f001 fac9 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8013656:	4650      	mov	r0, sl
 8013658:	f000 fe60 	bl	801431c <SUBGRF_SetPacketType>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 801365c:	f10b 0038 	add.w	r0, fp, #56	@ 0x38
        SubgRf.PublicNetwork.Current = false;
 8013660:	f88b a00d 	strb.w	sl, [fp, #13]
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013664:	f000 ff6a 	bl	801453c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8013668:	f10b 000e 	add.w	r0, fp, #14
 801366c:	f001 f80a 	bl	8014684 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8013670:	4959      	ldr	r1, [pc, #356]	@ (80137d8 <RadioSetRxConfig+0x330>)
 8013672:	c903      	ldmia	r1, {r0, r1}
 8013674:	aa04      	add	r2, sp, #16
 8013676:	e882 0003 	stmia.w	r2, {r0, r1}
 801367a:	4610      	mov	r0, r2
 801367c:	f000 fb76 	bl	8013d6c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8013680:	f240 10ff 	movw	r0, #511	@ 0x1ff
 8013684:	f000 fba0 	bl	8013dc8 <SUBGRF_SetWhiteningSeed>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8013688:	f44f 52fa 	mov.w	r2, #8000	@ 0x1f40
 801368c:	fb06 f202 	mul.w	r2, r6, r2
 8013690:	fbb2 f2f4 	udiv	r2, r2, r4
 8013694:	f8cb 2008 	str.w	r2, [fp, #8]
}
 8013698:	b007      	add	sp, #28
 801369a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 801369e:	2001      	movs	r0, #1
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 80136a0:	2709      	movs	r7, #9
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 80136a2:	f000 fd59 	bl	8014158 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 80136a6:	f88b 7044 	strb.w	r7, [fp, #68]	@ 0x44
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 80136aa:	4628      	mov	r0, r5
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 80136ac:	f44f 7748 	mov.w	r7, #800	@ 0x320
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80136b0:	2500      	movs	r5, #0
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 80136b2:	f8cb 403c 	str.w	r4, [fp, #60]	@ 0x3c
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80136b6:	f88b 5038 	strb.w	r5, [fp, #56]	@ 0x38
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 80136ba:	f8cb 7040 	str.w	r7, [fp, #64]	@ 0x40
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 80136be:	f001 fa0b 	bl	8014ad8 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 80136c2:	9b00      	ldr	r3, [sp, #0]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 80136c4:	4940      	ldr	r1, [pc, #256]	@ (80137c8 <RadioSetRxConfig+0x320>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 80136c6:	f88b 0045 	strb.w	r0, [fp, #69]	@ 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 80136ca:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 80136ce:	ea4f 09c3 	mov.w	r9, r3, lsl #3
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 80136d2:	7809      	ldrb	r1, [r1, #0]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 80136d4:	f8cb 2012 	str.w	r2, [fp, #18]
    RFW_SetRadioModem( modem );
 80136d8:	4650      	mov	r0, sl
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 80136da:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 80136dc:	f88b 1016 	strb.w	r1, [fp, #22]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 80136e0:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 80136e4:	f8ab 9010 	strh.w	r9, [fp, #16]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80136e8:	f88b 500e 	strb.w	r5, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 80136ec:	f88b 5018 	strb.w	r5, [fp, #24]
    SubgRf.Modem = modem;
 80136f0:	f88b a000 	strb.w	sl, [fp]
    RFW_SetRadioModem( modem );
 80136f4:	f001 fa78 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 80136f8:	4628      	mov	r0, r5
 80136fa:	f000 fe0f 	bl	801431c <SUBGRF_SetPacketType>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80136fe:	f10b 0038 	add.w	r0, fp, #56	@ 0x38
        SubgRf.PublicNetwork.Current = false;
 8013702:	f88b 500d 	strb.w	r5, [fp, #13]
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013706:	f000 ff19 	bl	801453c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 801370a:	f10b 000e 	add.w	r0, fp, #14
 801370e:	f000 ffb9 	bl	8014684 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8013712:	4932      	ldr	r1, [pc, #200]	@ (80137dc <RadioSetRxConfig+0x334>)
 8013714:	c903      	ldmia	r1, {r0, r1}
 8013716:	aa04      	add	r2, sp, #16
 8013718:	e882 0003 	stmia.w	r2, {r0, r1}
 801371c:	4610      	mov	r0, r2
 801371e:	f000 fb25 	bl	8013d6c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8013722:	f240 10ff 	movw	r0, #511	@ 0x1ff
 8013726:	f000 fb4f 	bl	8013dc8 <SUBGRF_SetWhiteningSeed>
    return SUBGRF_ReadRegister( addr );
 801372a:	f640 00b8 	movw	r0, #2232	@ 0x8b8
 801372e:	f001 f903 	bl	8014938 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( addr, data );
 8013732:	f000 01ef 	and.w	r1, r0, #239	@ 0xef
 8013736:	f640 00b8 	movw	r0, #2232	@ 0x8b8
 801373a:	f001 f8eb 	bl	8014914 <SUBGRF_WriteRegister>
 801373e:	2104      	movs	r1, #4
 8013740:	f640 00b9 	movw	r0, #2233	@ 0x8b9
 8013744:	f001 f8e6 	bl	8014914 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister( addr );
 8013748:	f640 009b 	movw	r0, #2203	@ 0x89b
 801374c:	f001 f8f4 	bl	8014938 <SUBGRF_ReadRegister>
            RadioWrite(SUBGHZ_AGCRSSICTL0R, (modReg| (0x1<<3) ) );
 8013750:	f000 01e3 	and.w	r1, r0, #227	@ 0xe3
    SUBGRF_WriteRegister( addr, data );
 8013754:	f041 0108 	orr.w	r1, r1, #8
 8013758:	f640 009b 	movw	r0, #2203	@ 0x89b
 801375c:	f001 f8da 	bl	8014914 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister( addr );
 8013760:	f240 60d1 	movw	r0, #1745	@ 0x6d1
 8013764:	f001 f8e8 	bl	8014938 <SUBGRF_ReadRegister>
            RadioWrite(SUBGHZ_GAFCR, (modReg| (0x3<<3) ));
 8013768:	f040 0118 	orr.w	r1, r0, #24
    SUBGRF_WriteRegister( addr, data );
 801376c:	b2c9      	uxtb	r1, r1
 801376e:	f240 60d1 	movw	r0, #1745	@ 0x6d1
 8013772:	f001 f8cf 	bl	8014914 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister( addr );
 8013776:	f240 60ac 	movw	r0, #1708	@ 0x6ac
 801377a:	f001 f8dd 	bl	8014938 <SUBGRF_ReadRegister>
            RadioWrite(SUBGHZ_GBSYNCR, (modReg| (0x5<<4) ));
 801377e:	f000 018f 	and.w	r1, r0, #143	@ 0x8f
    SUBGRF_WriteRegister( addr, data );
 8013782:	f041 0150 	orr.w	r1, r1, #80	@ 0x50
 8013786:	f240 60ac 	movw	r0, #1708	@ 0x6ac
 801378a:	f001 f8c3 	bl	8014914 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 801378e:	f44f 52fa 	mov.w	r2, #8000	@ 0x1f40
 8013792:	fb06 f202 	mul.w	r2, r6, r2
 8013796:	fbb2 f2f4 	udiv	r2, r2, r4
 801379a:	f8cb 2008 	str.w	r2, [fp, #8]
}
 801379e:	b007      	add	sp, #28
 80137a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80137a4:	3c0b      	subs	r4, #11
 80137a6:	2c01      	cmp	r4, #1
 80137a8:	bf8c      	ite	hi
 80137aa:	2400      	movhi	r4, #0
 80137ac:	2401      	movls	r4, #1
 80137ae:	e6c5      	b.n	801353c <RadioSetRxConfig+0x94>
                SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) & ~( 1 << 2 ) );
 80137b0:	f001 f8c2 	bl	8014938 <SUBGRF_ReadRegister>
 80137b4:	f000 01fb 	and.w	r1, r0, #251	@ 0xfb
 80137b8:	f240 7036 	movw	r0, #1846	@ 0x736
 80137bc:	f001 f8aa 	bl	8014914 <SUBGRF_WriteRegister>
 80137c0:	e70c      	b.n	80135dc <RadioSetRxConfig+0x134>
 80137c2:	bf00      	nop
 80137c4:	20001454 	.word	0x20001454
 80137c8:	20000110 	.word	0x20000110
 80137cc:	08017654 	.word	0x08017654
 80137d0:	2000148c 	.word	0x2000148c
 80137d4:	20001462 	.word	0x20001462
 80137d8:	0801680c 	.word	0x0801680c
 80137dc:	08016804 	.word	0x08016804

080137e0 <RadioIsChannelFree>:
{
 80137e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    SubgRf.Modem = modem;
 80137e4:	2400      	movs	r4, #0
{
 80137e6:	b08b      	sub	sp, #44	@ 0x2c
    SubgRf.Modem = modem;
 80137e8:	4f30      	ldr	r7, [pc, #192]	@ (80138ac <RadioIsChannelFree+0xcc>)
{
 80137ea:	4681      	mov	r9, r0
    SUBGRF_SetStandby( STDBY_RC );
 80137ec:	2000      	movs	r0, #0
{
 80137ee:	4688      	mov	r8, r1
 80137f0:	4616      	mov	r6, r2
 80137f2:	461d      	mov	r5, r3
    SUBGRF_SetStandby( STDBY_RC );
 80137f4:	f000 fbd2 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 80137f8:	4620      	mov	r0, r4
    SubgRf.Modem = modem;
 80137fa:	703c      	strb	r4, [r7, #0]
    RFW_SetRadioModem( modem );
 80137fc:	f001 f9f4 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8013800:	4620      	mov	r0, r4
 8013802:	f000 fd8b 	bl	801431c <SUBGRF_SetPacketType>
    SUBGRF_SetRfFrequency( freq );
 8013806:	4648      	mov	r0, r9
        SubgRf.PublicNetwork.Current = false;
 8013808:	737c      	strb	r4, [r7, #13]
    SUBGRF_SetRfFrequency( freq );
 801380a:	f000 fd29 	bl	8014260 <SUBGRF_SetRfFrequency>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 801380e:	2301      	movs	r3, #1
 8013810:	9309      	str	r3, [sp, #36]	@ 0x24
 8013812:	2303      	movs	r3, #3
 8013814:	4641      	mov	r1, r8
 8013816:	9301      	str	r3, [sp, #4]
 8013818:	f44f 7216 	mov.w	r2, #600	@ 0x258
 801381c:	4623      	mov	r3, r4
 801381e:	4620      	mov	r0, r4
 8013820:	e9cd 4407 	strd	r4, r4, [sp, #28]
 8013824:	e9cd 4405 	strd	r4, r4, [sp, #20]
 8013828:	e9cd 4403 	strd	r4, r4, [sp, #12]
 801382c:	9402      	str	r4, [sp, #8]
 801382e:	f8cd 8000 	str.w	r8, [sp]
 8013832:	f7ff fe39 	bl	80134a8 <RadioSetRxConfig>
    if( 1UL == RFW_Is_Init( ) )
 8013836:	f001 f9c5 	bl	8014bc4 <RFW_Is_Init>
 801383a:	2801      	cmp	r0, #1
 801383c:	d033      	beq.n	80138a6 <RadioIsChannelFree+0xc6>
        SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 801383e:	f240 2162 	movw	r1, #610	@ 0x262
 8013842:	4623      	mov	r3, r4
 8013844:	4622      	mov	r2, r4
 8013846:	4608      	mov	r0, r1
 8013848:	f000 fcde 	bl	8014208 <SUBGRF_SetDioIrqParams>
    SubgRf.RxDcPreambleDetectTimeout = 0;
 801384c:	2100      	movs	r1, #0
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 801384e:	f897 0056 	ldrb.w	r0, [r7, #86]	@ 0x56
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8013852:	65b9      	str	r1, [r7, #88]	@ 0x58
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 8013854:	f001 f8a0 	bl	8014998 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8013858:	787b      	ldrb	r3, [r7, #1]
 801385a:	b1eb      	cbz	r3, 8013898 <RadioIsChannelFree+0xb8>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 801385c:	f06f 407f 	mvn.w	r0, #4278190080	@ 0xff000000
 8013860:	f000 fbd8 	bl	8014014 <SUBGRF_SetRx>
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 8013864:	f001 f8ec 	bl	8014a40 <SUBGRF_GetRadioWakeUpTime>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8013868:	3003      	adds	r0, #3
 801386a:	f7ee f9b5 	bl	8001bd8 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 801386e:	f002 f825 	bl	80158bc <UTIL_TIMER_GetCurrentTime>
 8013872:	4604      	mov	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8013874:	e003      	b.n	801387e <RadioIsChannelFree+0x9e>
    return SUBGRF_GetRssiInst( );
 8013876:	f000 ffef 	bl	8014858 <SUBGRF_GetRssiInst>
        if( rssi > rssiThresh )
 801387a:	4286      	cmp	r6, r0
 801387c:	db11      	blt.n	80138a2 <RadioIsChannelFree+0xc2>
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 801387e:	4620      	mov	r0, r4
 8013880:	f002 f826 	bl	80158d0 <UTIL_TIMER_GetElapsedTime>
 8013884:	42a8      	cmp	r0, r5
 8013886:	d3f6      	bcc.n	8013876 <RadioIsChannelFree+0x96>
    bool status = true;
 8013888:	2401      	movs	r4, #1
    SUBGRF_SetStandby( STDBY_RC );
 801388a:	2000      	movs	r0, #0
 801388c:	f000 fb86 	bl	8013f9c <SUBGRF_SetStandby>
}
 8013890:	4620      	mov	r0, r4
 8013892:	b00b      	add	sp, #44	@ 0x2c
 8013894:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 8013898:	68b8      	ldr	r0, [r7, #8]
 801389a:	0180      	lsls	r0, r0, #6
 801389c:	f000 fbba 	bl	8014014 <SUBGRF_SetRx>
}
 80138a0:	e7e0      	b.n	8013864 <RadioIsChannelFree+0x84>
            status = false;
 80138a2:	2400      	movs	r4, #0
 80138a4:	e7f1      	b.n	801388a <RadioIsChannelFree+0xaa>
        RFW_ReceiveInit( );
 80138a6:	f001 f997 	bl	8014bd8 <RFW_ReceiveInit>
 80138aa:	e7cf      	b.n	801384c <RadioIsChannelFree+0x6c>
 80138ac:	20001454 	.word	0x20001454

080138b0 <RadioSetTxConfig>:
{
 80138b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80138b4:	b085      	sub	sp, #20
 80138b6:	4604      	mov	r4, r0
 80138b8:	461e      	mov	r6, r3
 80138ba:	f89d 003c 	ldrb.w	r0, [sp, #60]	@ 0x3c
 80138be:	f89d 3054 	ldrb.w	r3, [sp, #84]	@ 0x54
 80138c2:	f8bd 8040 	ldrh.w	r8, [sp, #64]	@ 0x40
 80138c6:	f89d 9044 	ldrb.w	r9, [sp, #68]	@ 0x44
 80138ca:	f89d a048 	ldrb.w	sl, [sp, #72]	@ 0x48
 80138ce:	9000      	str	r0, [sp, #0]
 80138d0:	460d      	mov	r5, r1
 80138d2:	4617      	mov	r7, r2
 80138d4:	9301      	str	r3, [sp, #4]
    RFW_DeInit();
 80138d6:	f001 f973 	bl	8014bc0 <RFW_DeInit>
    switch( modem )
 80138da:	2c01      	cmp	r4, #1
 80138dc:	d01c      	beq.n	8013918 <RadioSetTxConfig+0x68>
 80138de:	2c04      	cmp	r4, #4
 80138e0:	f000 80f0 	beq.w	8013ac4 <RadioSetTxConfig+0x214>
 80138e4:	2c00      	cmp	r4, #0
 80138e6:	f000 80a0 	beq.w	8013a2a <RadioSetTxConfig+0x17a>
 80138ea:	f8df b258 	ldr.w	fp, [pc, #600]	@ 8013b44 <RadioSetTxConfig+0x294>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 80138ee:	4628      	mov	r0, r5
 80138f0:	f001 f88a 	bl	8014a08 <SUBGRF_SetRfTxPower>
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 80138f4:	210e      	movs	r1, #14
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 80138f6:	4602      	mov	r2, r0
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 80138f8:	f640 101f 	movw	r0, #2335	@ 0x91f
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 80138fc:	f88b 2056 	strb.w	r2, [fp, #86]	@ 0x56
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8013900:	f001 f808 	bl	8014914 <SUBGRF_WriteRegister>
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 8013904:	f89b 0056 	ldrb.w	r0, [fp, #86]	@ 0x56
 8013908:	f001 f960 	bl	8014bcc <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 801390c:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 801390e:	f8cb 3004 	str.w	r3, [fp, #4]
}
 8013912:	b005      	add	sp, #20
 8013914:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8013918:	4a8b      	ldr	r2, [pc, #556]	@ (8013b48 <RadioSetTxConfig+0x298>)
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 801391a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 801391c:	f8df b224 	ldr.w	fp, [pc, #548]	@ 8013b44 <RadioSetTxConfig+0x294>
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8013920:	5d90      	ldrb	r0, [r2, r6]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8013922:	f88b 4038 	strb.w	r4, [fp, #56]	@ 0x38
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 8013926:	b2da      	uxtb	r2, r3
 8013928:	f88b 2050 	strb.w	r2, [fp, #80]	@ 0x50
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 801392c:	2e00      	cmp	r6, #0
 801392e:	f000 80e4 	beq.w	8013afa <RadioSetTxConfig+0x24a>
 8013932:	2e01      	cmp	r6, #1
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 8013934:	bf03      	ittte	eq
 8013936:	f1a3 010c 	subeq.w	r1, r3, #12
 801393a:	fab1 f181 	clzeq	r1, r1
 801393e:	0949      	lsreq	r1, r1, #5
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8013940:	2100      	movne	r1, #0
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8013942:	3a05      	subs	r2, #5
 8013944:	2a01      	cmp	r2, #1
 8013946:	d804      	bhi.n	8013952 <RadioSetTxConfig+0xa2>
                if( preambleLen < 12 )
 8013948:	f1b8 0f0c 	cmp.w	r8, #12
 801394c:	bf38      	it	cc
 801394e:	f04f 080c 	movcc.w	r8, #12
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8013952:	4a7e      	ldr	r2, [pc, #504]	@ (8013b4c <RadioSetTxConfig+0x29c>)
 8013954:	f88b 1053 	strb.w	r1, [fp, #83]	@ 0x53
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8013958:	7811      	ldrb	r1, [r2, #0]
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 801395a:	9b00      	ldr	r3, [sp, #0]
 801395c:	f88b 3052 	strb.w	r3, [fp, #82]	@ 0x52
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8013960:	2200      	movs	r2, #0
 8013962:	f369 0207 	bfi	r2, r9, #0, #8
 8013966:	9b01      	ldr	r3, [sp, #4]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8013968:	f88b 0051 	strb.w	r0, [fp, #81]	@ 0x51
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 801396c:	f361 220f 	bfi	r2, r1, #8, #8
 8013970:	f36a 4217 	bfi	r2, sl, #16, #8
 8013974:	f363 621f 	bfi	r2, r3, #24, #8
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8013978:	2401      	movs	r4, #1
    SUBGRF_SetStandby( STDBY_RC );
 801397a:	2000      	movs	r0, #0
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 801397c:	f8cb 201e 	str.w	r2, [fp, #30]
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8013980:	f8ab 801c 	strh.w	r8, [fp, #28]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8013984:	f88b 400e 	strb.w	r4, [fp, #14]
    SUBGRF_SetStandby( STDBY_RC );
 8013988:	f000 fb08 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 801398c:	4620      	mov	r0, r4
    SubgRf.Modem = modem;
 801398e:	f88b 4000 	strb.w	r4, [fp]
    RFW_SetRadioModem( modem );
 8013992:	f001 f929 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8013996:	4620      	mov	r0, r4
 8013998:	f000 fcc0 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 801399c:	f89b 600c 	ldrb.w	r6, [fp, #12]
 80139a0:	f89b 200d 	ldrb.w	r2, [fp, #13]
 80139a4:	42b2      	cmp	r2, r6
 80139a6:	d039      	beq.n	8013a1c <RadioSetTxConfig+0x16c>
    RFW_SetRadioModem( modem );
 80139a8:	4620      	mov	r0, r4
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 80139aa:	f88b 600d 	strb.w	r6, [fp, #13]
    SubgRf.Modem = modem;
 80139ae:	f88b 4000 	strb.w	r4, [fp]
    RFW_SetRadioModem( modem );
 80139b2:	f001 f919 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 80139b6:	4620      	mov	r0, r4
 80139b8:	f000 fcb0 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 80139bc:	f89b 700c 	ldrb.w	r7, [fp, #12]
 80139c0:	f89b 200d 	ldrb.w	r2, [fp, #13]
 80139c4:	42ba      	cmp	r2, r7
 80139c6:	d01d      	beq.n	8013a04 <RadioSetTxConfig+0x154>
    RFW_SetRadioModem( modem );
 80139c8:	4620      	mov	r0, r4
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 80139ca:	f88b 700d 	strb.w	r7, [fp, #13]
    SubgRf.Modem = modem;
 80139ce:	f88b 4000 	strb.w	r4, [fp]
    RFW_SetRadioModem( modem );
 80139d2:	f001 f909 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 80139d6:	4620      	mov	r0, r4
 80139d8:	f000 fca0 	bl	801431c <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 80139dc:	f89b 000c 	ldrb.w	r0, [fp, #12]
 80139e0:	f89b 200d 	ldrb.w	r2, [fp, #13]
 80139e4:	4282      	cmp	r2, r0
 80139e6:	f040 80a5 	bne.w	8013b34 <RadioSetTxConfig+0x284>
    if( enable == true )
 80139ea:	2f00      	cmp	r7, #0
 80139ec:	f000 8097 	beq.w	8013b1e <RadioSetTxConfig+0x26e>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 80139f0:	2134      	movs	r1, #52	@ 0x34
 80139f2:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 80139f6:	f000 ff8d 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 80139fa:	2144      	movs	r1, #68	@ 0x44
 80139fc:	f240 7041 	movw	r0, #1857	@ 0x741
 8013a00:	f000 ff88 	bl	8014914 <SUBGRF_WriteRegister>
    if( enable == true )
 8013a04:	2e00      	cmp	r6, #0
 8013a06:	d07f      	beq.n	8013b08 <RadioSetTxConfig+0x258>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8013a08:	2134      	movs	r1, #52	@ 0x34
 8013a0a:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8013a0e:	f000 ff81 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8013a12:	2144      	movs	r1, #68	@ 0x44
 8013a14:	f240 7041 	movw	r0, #1857	@ 0x741
 8013a18:	f000 ff7c 	bl	8014914 <SUBGRF_WriteRegister>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013a1c:	484c      	ldr	r0, [pc, #304]	@ (8013b50 <RadioSetTxConfig+0x2a0>)
 8013a1e:	f000 fd8d 	bl	801453c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8013a22:	484c      	ldr	r0, [pc, #304]	@ (8013b54 <RadioSetTxConfig+0x2a4>)
 8013a24:	f000 fe2e 	bl	8014684 <SUBGRF_SetPacketParams>
            break;
 8013a28:	e761      	b.n	80138ee <RadioSetTxConfig+0x3e>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8013a2a:	f8df b118 	ldr.w	fp, [pc, #280]	@ 8013b44 <RadioSetTxConfig+0x294>
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8013a2e:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8013a30:	f8cb 303c 	str.w	r3, [fp, #60]	@ 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8013a34:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8013a36:	4630      	mov	r0, r6
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8013a38:	f88b 2044 	strb.w	r2, [fp, #68]	@ 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8013a3c:	f88b 4038 	strb.w	r4, [fp, #56]	@ 0x38
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8013a40:	f001 f84a 	bl	8014ad8 <SUBGRF_GetFskBandwidthRegValue>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 8013a44:	f1ba 0f00 	cmp.w	sl, #0
 8013a48:	bf0c      	ite	eq
 8013a4a:	2201      	moveq	r2, #1
 8013a4c:	22f2      	movne	r2, #242	@ 0xf2
 8013a4e:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8013a52:	2201      	movs	r2, #1
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8013a54:	f88b 0045 	strb.w	r0, [fp, #69]	@ 0x45
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8013a58:	f88b 2018 	strb.w	r2, [fp, #24]
    SUBGRF_SetStandby( STDBY_RC );
 8013a5c:	4620      	mov	r0, r4
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8013a5e:	f641 0204 	movw	r2, #6148	@ 0x1804
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8013a62:	ea4f 08c8 	mov.w	r8, r8, lsl #3
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8013a66:	f089 0901 	eor.w	r9, r9, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8013a6a:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 8013a6e:	f8cb 7040 	str.w	r7, [fp, #64]	@ 0x40
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8013a72:	f8ab 8010 	strh.w	r8, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8013a76:	f88b 9015 	strb.w	r9, [fp, #21]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8013a7a:	f88b 400e 	strb.w	r4, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8013a7e:	f88b 4014 	strb.w	r4, [fp, #20]
    SUBGRF_SetStandby( STDBY_RC );
 8013a82:	f000 fa8b 	bl	8013f9c <SUBGRF_SetStandby>
    RFW_SetRadioModem( modem );
 8013a86:	4620      	mov	r0, r4
    SubgRf.Modem = modem;
 8013a88:	f88b 4000 	strb.w	r4, [fp]
    RFW_SetRadioModem( modem );
 8013a8c:	f001 f8ac 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8013a90:	4620      	mov	r0, r4
 8013a92:	f000 fc43 	bl	801431c <SUBGRF_SetPacketType>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013a96:	f10b 0038 	add.w	r0, fp, #56	@ 0x38
        SubgRf.PublicNetwork.Current = false;
 8013a9a:	f88b 400d 	strb.w	r4, [fp, #13]
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013a9e:	f000 fd4d 	bl	801453c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8013aa2:	f10b 000e 	add.w	r0, fp, #14
 8013aa6:	f000 fded 	bl	8014684 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8013aaa:	492b      	ldr	r1, [pc, #172]	@ (8013b58 <RadioSetTxConfig+0x2a8>)
 8013aac:	c903      	ldmia	r1, {r0, r1}
 8013aae:	aa02      	add	r2, sp, #8
 8013ab0:	e882 0003 	stmia.w	r2, {r0, r1}
 8013ab4:	4610      	mov	r0, r2
 8013ab6:	f000 f959 	bl	8013d6c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8013aba:	f240 10ff 	movw	r0, #511	@ 0x1ff
 8013abe:	f000 f983 	bl	8013dc8 <SUBGRF_SetWhiteningSeed>
            break;
 8013ac2:	e714      	b.n	80138ee <RadioSetTxConfig+0x3e>
    SubgRf.Modem = modem;
 8013ac4:	f8df b07c 	ldr.w	fp, [pc, #124]	@ 8013b44 <RadioSetTxConfig+0x294>
    RFW_SetRadioModem( modem );
 8013ac8:	4620      	mov	r0, r4
    SubgRf.Modem = modem;
 8013aca:	f88b 4000 	strb.w	r4, [fp]
    RFW_SetRadioModem( modem );
 8013ace:	f001 f88b 	bl	8014be8 <RFW_SetRadioModem>
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 8013ad2:	2002      	movs	r0, #2
 8013ad4:	f000 fc22 	bl	801431c <SUBGRF_SetPacketType>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8013ad8:	2202      	movs	r2, #2
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 8013ada:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8013adc:	f88b 2038 	strb.w	r2, [fp, #56]	@ 0x38
        SubgRf.PublicNetwork.Current = false;
 8013ae0:	2100      	movs	r1, #0
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8013ae2:	2216      	movs	r2, #22
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013ae4:	f10b 0038 	add.w	r0, fp, #56	@ 0x38
        SubgRf.PublicNetwork.Current = false;
 8013ae8:	f88b 100d 	strb.w	r1, [fp, #13]
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 8013aec:	f8cb 3048 	str.w	r3, [fp, #72]	@ 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8013af0:	f88b 204c 	strb.w	r2, [fp, #76]	@ 0x4c
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8013af4:	f000 fd22 	bl	801453c <SUBGRF_SetModulationParams>
            break;
 8013af8:	e6f9      	b.n	80138ee <RadioSetTxConfig+0x3e>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8013afa:	f1a3 010b 	sub.w	r1, r3, #11
 8013afe:	2901      	cmp	r1, #1
 8013b00:	bf8c      	ite	hi
 8013b02:	2100      	movhi	r1, #0
 8013b04:	2101      	movls	r1, #1
 8013b06:	e71c      	b.n	8013942 <RadioSetTxConfig+0x92>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8013b08:	2114      	movs	r1, #20
 8013b0a:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8013b0e:	f000 ff01 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8013b12:	2124      	movs	r1, #36	@ 0x24
 8013b14:	f240 7041 	movw	r0, #1857	@ 0x741
 8013b18:	f000 fefc 	bl	8014914 <SUBGRF_WriteRegister>
 8013b1c:	e77e      	b.n	8013a1c <RadioSetTxConfig+0x16c>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8013b1e:	2114      	movs	r1, #20
 8013b20:	f44f 60e8 	mov.w	r0, #1856	@ 0x740
 8013b24:	f000 fef6 	bl	8014914 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8013b28:	2124      	movs	r1, #36	@ 0x24
 8013b2a:	f240 7041 	movw	r0, #1857	@ 0x741
 8013b2e:	f000 fef1 	bl	8014914 <SUBGRF_WriteRegister>
 8013b32:	e767      	b.n	8013a04 <RadioSetTxConfig+0x154>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8013b34:	f88b 000d 	strb.w	r0, [fp, #13]
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 8013b38:	f7ff f902 	bl	8012d40 <RadioSetPublicNetwork>
    if( enable == true )
 8013b3c:	2f00      	cmp	r7, #0
 8013b3e:	d0ee      	beq.n	8013b1e <RadioSetTxConfig+0x26e>
 8013b40:	e756      	b.n	80139f0 <RadioSetTxConfig+0x140>
 8013b42:	bf00      	nop
 8013b44:	20001454 	.word	0x20001454
 8013b48:	08017654 	.word	0x08017654
 8013b4c:	20000110 	.word	0x20000110
 8013b50:	2000148c 	.word	0x2000148c
 8013b54:	20001462 	.word	0x20001462
 8013b58:	0801680c 	.word	0x0801680c

08013b5c <SUBGRF_Init>:
 */
static DioIrqHandler RadioOnDioIrqCb;

/* Exported functions ---------------------------------------------------------*/
void SUBGRF_Init( DioIrqHandler dioIrq )
{
 8013b5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013b60:	b082      	sub	sp, #8
    if ( dioIrq != NULL)
 8013b62:	b108      	cbz	r0, 8013b68 <SUBGRF_Init+0xc>
    {
        RadioOnDioIrqCb = dioIrq;
 8013b64:	4b43      	ldr	r3, [pc, #268]	@ (8013c74 <SUBGRF_Init+0x118>)
 8013b66:	6018      	str	r0, [r3, #0]
    }

    RADIO_INIT();
 8013b68:	f7ed ff30 	bl	80019cc <MX_SUBGHZ_Init>
    RadioOnDioIrqCb( IRQ_LR_FHSS_HOP );
}

static void Radio_SMPS_Set(uint8_t level)
{
  if ( 1U == RBI_IsDCDC() )
 8013b6c:	f7f6 fb1a 	bl	800a1a4 <RBI_IsDCDC>
 8013b70:	2801      	cmp	r0, #1
 8013b72:	4605      	mov	r5, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013b74:	ac01      	add	r4, sp, #4
  if ( 1U == RBI_IsDCDC() )
 8013b76:	d065      	beq.n	8013c44 <SUBGRF_Init+0xe8>
    ImageCalibrated = false;
 8013b78:	4b3f      	ldr	r3, [pc, #252]	@ (8013c78 <SUBGRF_Init+0x11c>)
 8013b7a:	2600      	movs	r6, #0
 8013b7c:	701e      	strb	r6, [r3, #0]
    SUBGRF_SetStandby( STDBY_RC );
 8013b7e:	f88d 6004 	strb.w	r6, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013b82:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013b86:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013b88:	2301      	movs	r3, #1
 8013b8a:	4622      	mov	r2, r4
 8013b8c:	2180      	movs	r1, #128	@ 0x80
 8013b8e:	483b      	ldr	r0, [pc, #236]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013b90:	f7f4 fd0c 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013b94:	f385 8810 	msr	PRIMASK, r5
    if( standbyConfig == STDBY_RC )
 8013b98:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8013b9c:	4f38      	ldr	r7, [pc, #224]	@ (8013c80 <SUBGRF_Init+0x124>)
        OperatingMode = MODE_STDBY_RC;
 8013b9e:	42b3      	cmp	r3, r6
 8013ba0:	bf14      	ite	ne
 8013ba2:	2302      	movne	r3, #2
 8013ba4:	2301      	moveq	r3, #1
 8013ba6:	703b      	strb	r3, [r7, #0]
    if (1U == RBI_IsTCXO() )
 8013ba8:	f7f6 fafa 	bl	800a1a0 <RBI_IsTCXO>
 8013bac:	2801      	cmp	r0, #1
 8013bae:	4605      	mov	r5, r0
 8013bb0:	d023      	beq.n	8013bfa <SUBGRF_Init+0x9e>
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 8013bb2:	2520      	movs	r5, #32
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013bb4:	2301      	movs	r3, #1
 8013bb6:	4622      	mov	r2, r4
 8013bb8:	f640 1111 	movw	r1, #2321	@ 0x911
 8013bbc:	482f      	ldr	r0, [pc, #188]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013bbe:	f88d 5004 	strb.w	r5, [sp, #4]
 8013bc2:	f7f4 fd5b 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 8013bc6:	482d      	ldr	r0, [pc, #180]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013bc8:	f88d 5004 	strb.w	r5, [sp, #4]
 8013bcc:	2301      	movs	r3, #1
 8013bce:	4622      	mov	r2, r4
 8013bd0:	f640 1112 	movw	r1, #2322	@ 0x912
 8013bd4:	f7f4 fd52 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 8013bd8:	4622      	mov	r2, r4
 8013bda:	2301      	movs	r3, #1
 8013bdc:	f640 111f 	movw	r1, #2335	@ 0x91f
 8013be0:	240e      	movs	r4, #14
 8013be2:	4826      	ldr	r0, [pc, #152]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013be4:	f88d 4004 	strb.w	r4, [sp, #4]
 8013be8:	f7f4 fd48 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
    RBI_Init();
 8013bec:	f7f6 fa96 	bl	800a11c <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 8013bf0:	2301      	movs	r3, #1
 8013bf2:	703b      	strb	r3, [r7, #0]
}
 8013bf4:	b002      	add	sp, #8
 8013bf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    buf[0] = tcxoVoltage & 0x07;
 8013bfa:	4b22      	ldr	r3, [pc, #136]	@ (8013c84 <SUBGRF_Init+0x128>)
 8013bfc:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013bfe:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013c02:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013c04:	2304      	movs	r3, #4
 8013c06:	4622      	mov	r2, r4
 8013c08:	2197      	movs	r1, #151	@ 0x97
 8013c0a:	481c      	ldr	r0, [pc, #112]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013c0c:	f7f4 fcce 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013c10:	f388 8810 	msr	PRIMASK, r8
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013c14:	f640 1111 	movw	r1, #2321	@ 0x911
 8013c18:	462b      	mov	r3, r5
 8013c1a:	4622      	mov	r2, r4
 8013c1c:	4817      	ldr	r0, [pc, #92]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013c1e:	f88d 6004 	strb.w	r6, [sp, #4]
 8013c22:	f7f4 fd2b 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8013c26:	237f      	movs	r3, #127	@ 0x7f
 8013c28:	f88d 3004 	strb.w	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013c2c:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013c30:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013c32:	2189      	movs	r1, #137	@ 0x89
 8013c34:	462b      	mov	r3, r5
 8013c36:	4622      	mov	r2, r4
 8013c38:	4810      	ldr	r0, [pc, #64]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013c3a:	f7f4 fcb7 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013c3e:	f386 8810 	msr	PRIMASK, r6
 8013c42:	e7c9      	b.n	8013bd8 <SUBGRF_Init+0x7c>
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013c44:	4603      	mov	r3, r0
 8013c46:	4622      	mov	r2, r4
 8013c48:	f640 1123 	movw	r1, #2339	@ 0x923
 8013c4c:	480b      	ldr	r0, [pc, #44]	@ (8013c7c <SUBGRF_Init+0x120>)
 8013c4e:	f7f4 fd7d 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8013c52:	f89d 1004 	ldrb.w	r1, [sp, #4]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013c56:	4809      	ldr	r0, [pc, #36]	@ (8013c7c <SUBGRF_Init+0x120>)
  {
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
    modReg&= (~SMPS_DRV_MASK);
 8013c58:	f021 0106 	bic.w	r1, r1, #6
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 8013c5c:	f041 0102 	orr.w	r1, r1, #2
 8013c60:	f88d 1004 	strb.w	r1, [sp, #4]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013c64:	462b      	mov	r3, r5
 8013c66:	4622      	mov	r2, r4
 8013c68:	f640 1123 	movw	r1, #2339	@ 0x923
 8013c6c:	f7f4 fd06 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  }
}
 8013c70:	e782      	b.n	8013b78 <SUBGRF_Init+0x1c>
 8013c72:	bf00      	nop
 8013c74:	200015b4 	.word	0x200015b4
 8013c78:	200015b8 	.word	0x200015b8
 8013c7c:	20000318 	.word	0x20000318
 8013c80:	200015c2 	.word	0x200015c2
 8013c84:	40000001 	.word	0x40000001

08013c88 <SUBGRF_GetOperatingMode>:
    return OperatingMode;
 8013c88:	4b01      	ldr	r3, [pc, #4]	@ (8013c90 <SUBGRF_GetOperatingMode+0x8>)
}
 8013c8a:	7818      	ldrb	r0, [r3, #0]
 8013c8c:	4770      	bx	lr
 8013c8e:	bf00      	nop
 8013c90:	200015c2 	.word	0x200015c2

08013c94 <SUBGRF_GetPayload>:
{
 8013c94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013c96:	4607      	mov	r7, r0
 8013c98:	b083      	sub	sp, #12
 8013c9a:	460e      	mov	r6, r1
 8013c9c:	4614      	mov	r4, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013c9e:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013ca2:	b672      	cpsid	i
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 8013ca4:	2302      	movs	r3, #2
 8013ca6:	aa01      	add	r2, sp, #4
 8013ca8:	2113      	movs	r1, #19
 8013caa:	4817      	ldr	r0, [pc, #92]	@ (8013d08 <SUBGRF_GetPayload+0x74>)
 8013cac:	f7f4 fc20 	bl	80084f0 <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013cb0:	f385 8810 	msr	PRIMASK, r5
    return PacketType;
 8013cb4:	4b15      	ldr	r3, [pc, #84]	@ (8013d0c <SUBGRF_GetPayload+0x78>)
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 8013cb6:	781b      	ldrb	r3, [r3, #0]
 8013cb8:	2b01      	cmp	r3, #1
 8013cba:	d015      	beq.n	8013ce8 <SUBGRF_GetPayload+0x54>
        *payloadLength = status[0];
 8013cbc:	f89d 3004 	ldrb.w	r3, [sp, #4]
    *rxStartBufferPointer = status[1];
 8013cc0:	f89d 1005 	ldrb.w	r1, [sp, #5]
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 8013cc4:	7033      	strb	r3, [r6, #0]
    if( *size > maxSize )
 8013cc6:	429c      	cmp	r4, r3
 8013cc8:	d202      	bcs.n	8013cd0 <SUBGRF_GetPayload+0x3c>
        return 1;
 8013cca:	2001      	movs	r0, #1
}
 8013ccc:	b003      	add	sp, #12
 8013cce:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013cd0:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013cd4:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 8013cd6:	480c      	ldr	r0, [pc, #48]	@ (8013d08 <SUBGRF_GetPayload+0x74>)
 8013cd8:	463a      	mov	r2, r7
 8013cda:	f7f4 faa9 	bl	8008230 <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013cde:	f384 8810 	msr	PRIMASK, r4
    return 0;
 8013ce2:	2000      	movs	r0, #0
}
 8013ce4:	b003      	add	sp, #12
 8013ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 8013ce8:	4b09      	ldr	r3, [pc, #36]	@ (8013d10 <SUBGRF_GetPayload+0x7c>)
 8013cea:	781a      	ldrb	r2, [r3, #0]
 8013cec:	2a01      	cmp	r2, #1
 8013cee:	b2d3      	uxtb	r3, r2
 8013cf0:	d1e4      	bne.n	8013cbc <SUBGRF_GetPayload+0x28>
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013cf2:	4805      	ldr	r0, [pc, #20]	@ (8013d08 <SUBGRF_GetPayload+0x74>)
 8013cf4:	f10d 0203 	add.w	r2, sp, #3
 8013cf8:	f240 7102 	movw	r1, #1794	@ 0x702
 8013cfc:	f7f4 fd26 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8013d00:	f89d 3003 	ldrb.w	r3, [sp, #3]
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 8013d04:	e7dc      	b.n	8013cc0 <SUBGRF_GetPayload+0x2c>
 8013d06:	bf00      	nop
 8013d08:	20000318 	.word	0x20000318
 8013d0c:	200015c1 	.word	0x200015c1
 8013d10:	200015c0 	.word	0x200015c0

08013d14 <SUBGRF_SendPayload>:
{
 8013d14:	b570      	push	{r4, r5, r6, lr}
 8013d16:	460b      	mov	r3, r1
 8013d18:	b082      	sub	sp, #8
 8013d1a:	4614      	mov	r4, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013d1c:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013d20:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 8013d22:	4d10      	ldr	r5, [pc, #64]	@ (8013d64 <SUBGRF_SendPayload+0x50>)
 8013d24:	4602      	mov	r2, r0
 8013d26:	2100      	movs	r1, #0
 8013d28:	4628      	mov	r0, r5
 8013d2a:	f7f4 fa1f 	bl	800816c <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013d2e:	f386 8810 	msr	PRIMASK, r6
    OperatingMode = MODE_TX;
 8013d32:	4b0d      	ldr	r3, [pc, #52]	@ (8013d68 <SUBGRF_SendPayload+0x54>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8013d34:	f88d 4006 	strb.w	r4, [sp, #6]
    OperatingMode = MODE_TX;
 8013d38:	2104      	movs	r1, #4
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8013d3a:	0c22      	lsrs	r2, r4, #16
    OperatingMode = MODE_TX;
 8013d3c:	7019      	strb	r1, [r3, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8013d3e:	0a23      	lsrs	r3, r4, #8
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8013d40:	f88d 2004 	strb.w	r2, [sp, #4]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8013d44:	f88d 3005 	strb.w	r3, [sp, #5]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013d48:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013d4c:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013d4e:	2303      	movs	r3, #3
 8013d50:	eb0d 0201 	add.w	r2, sp, r1
 8013d54:	4628      	mov	r0, r5
 8013d56:	2183      	movs	r1, #131	@ 0x83
 8013d58:	f7f4 fc28 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013d5c:	f384 8810 	msr	PRIMASK, r4
}
 8013d60:	b002      	add	sp, #8
 8013d62:	bd70      	pop	{r4, r5, r6, pc}
 8013d64:	20000318 	.word	0x20000318
 8013d68:	200015c2 	.word	0x200015c2

08013d6c <SUBGRF_SetSyncWord>:
{
 8013d6c:	b510      	push	{r4, lr}
 8013d6e:	4602      	mov	r2, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013d70:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013d74:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 8013d76:	2308      	movs	r3, #8
 8013d78:	f44f 61d8 	mov.w	r1, #1728	@ 0x6c0
 8013d7c:	4803      	ldr	r0, [pc, #12]	@ (8013d8c <SUBGRF_SetSyncWord+0x20>)
 8013d7e:	f7f4 fc7d 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013d82:	f384 8810 	msr	PRIMASK, r4
}
 8013d86:	2000      	movs	r0, #0
 8013d88:	bd10      	pop	{r4, pc}
 8013d8a:	bf00      	nop
 8013d8c:	20000318 	.word	0x20000318

08013d90 <SUBGRF_SetCrcPolynomial>:
{
 8013d90:	b510      	push	{r4, lr}
    return PacketType;
 8013d92:	4b0b      	ldr	r3, [pc, #44]	@ (8013dc0 <SUBGRF_SetCrcPolynomial+0x30>)
{
 8013d94:	b082      	sub	sp, #8
    switch( SUBGRF_GetPacketType( ) )
 8013d96:	781b      	ldrb	r3, [r3, #0]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 8013d98:	ba40      	rev16	r0, r0
 8013d9a:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 8013d9e:	b10b      	cbz	r3, 8013da4 <SUBGRF_SetCrcPolynomial+0x14>
}
 8013da0:	b002      	add	sp, #8
 8013da2:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013da4:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013da8:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 8013daa:	2302      	movs	r3, #2
 8013dac:	aa01      	add	r2, sp, #4
 8013dae:	f240 61be 	movw	r1, #1726	@ 0x6be
 8013db2:	4804      	ldr	r0, [pc, #16]	@ (8013dc4 <SUBGRF_SetCrcPolynomial+0x34>)
 8013db4:	f7f4 fc62 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013db8:	f384 8810 	msr	PRIMASK, r4
}
 8013dbc:	b002      	add	sp, #8
 8013dbe:	bd10      	pop	{r4, pc}
 8013dc0:	200015c1 	.word	0x200015c1
 8013dc4:	20000318 	.word	0x20000318

08013dc8 <SUBGRF_SetWhiteningSeed>:
    return PacketType;
 8013dc8:	4b15      	ldr	r3, [pc, #84]	@ (8013e20 <SUBGRF_SetWhiteningSeed+0x58>)
    switch( SUBGRF_GetPacketType( ) )
 8013dca:	781b      	ldrb	r3, [r3, #0]
 8013dcc:	b103      	cbz	r3, 8013dd0 <SUBGRF_SetWhiteningSeed+0x8>
 8013dce:	4770      	bx	lr
{
 8013dd0:	b510      	push	{r4, lr}
 8013dd2:	b082      	sub	sp, #8
 8013dd4:	4604      	mov	r4, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013dd6:	f10d 0207 	add.w	r2, sp, #7
 8013dda:	2301      	movs	r3, #1
 8013ddc:	f44f 61d7 	mov.w	r1, #1720	@ 0x6b8
 8013de0:	4810      	ldr	r0, [pc, #64]	@ (8013e24 <SUBGRF_SetWhiteningSeed+0x5c>)
 8013de2:	f7f4 fcb3 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8013de6:	f89d 1007 	ldrb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013dea:	480e      	ldr	r0, [pc, #56]	@ (8013e24 <SUBGRF_SetWhiteningSeed+0x5c>)
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 8013dec:	f3c4 2300 	ubfx	r3, r4, #8, #1
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 8013df0:	f001 01fe 	and.w	r1, r1, #254	@ 0xfe
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 8013df4:	4319      	orrs	r1, r3
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013df6:	f10d 0207 	add.w	r2, sp, #7
 8013dfa:	f88d 1007 	strb.w	r1, [sp, #7]
 8013dfe:	2301      	movs	r3, #1
 8013e00:	f44f 61d7 	mov.w	r1, #1720	@ 0x6b8
 8013e04:	f7f4 fc3a 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 8013e08:	2301      	movs	r3, #1
 8013e0a:	f10d 0207 	add.w	r2, sp, #7
 8013e0e:	f240 61b9 	movw	r1, #1721	@ 0x6b9
 8013e12:	4804      	ldr	r0, [pc, #16]	@ (8013e24 <SUBGRF_SetWhiteningSeed+0x5c>)
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 8013e14:	f88d 4007 	strb.w	r4, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013e18:	f7f4 fc30 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
}
 8013e1c:	b002      	add	sp, #8
 8013e1e:	bd10      	pop	{r4, pc}
 8013e20:	200015c1 	.word	0x200015c1
 8013e24:	20000318 	.word	0x20000318

08013e28 <SUBGRF_GetRandom>:
{
 8013e28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013e2c:	b082      	sub	sp, #8
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013e2e:	466a      	mov	r2, sp
    uint32_t number = 0;
 8013e30:	2700      	movs	r7, #0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013e32:	2301      	movs	r3, #1
 8013e34:	f640 01e2 	movw	r1, #2274	@ 0x8e2
 8013e38:	4837      	ldr	r0, [pc, #220]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
    uint32_t number = 0;
 8013e3a:	9701      	str	r7, [sp, #4]
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013e3c:	f7f4 fc86 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8013e40:	f89d 6000 	ldrb.w	r6, [sp]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013e44:	4834      	ldr	r0, [pc, #208]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
    OperatingMode = MODE_RX;
 8013e46:	4d35      	ldr	r5, [pc, #212]	@ (8013f1c <SUBGRF_GetRandom+0xf4>)
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 8013e48:	f026 0301 	bic.w	r3, r6, #1
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013e4c:	466a      	mov	r2, sp
 8013e4e:	f88d 3000 	strb.w	r3, [sp]
 8013e52:	f640 01e2 	movw	r1, #2274	@ 0x8e2
 8013e56:	2301      	movs	r3, #1
 8013e58:	f7f4 fc10 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013e5c:	466a      	mov	r2, sp
 8013e5e:	2301      	movs	r3, #1
 8013e60:	f640 01e5 	movw	r1, #2277	@ 0x8e5
 8013e64:	482c      	ldr	r0, [pc, #176]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
 8013e66:	f7f4 fc71 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8013e6a:	f89d 4000 	ldrb.w	r4, [sp]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013e6e:	482a      	ldr	r0, [pc, #168]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 8013e70:	f004 037f 	and.w	r3, r4, #127	@ 0x7f
 8013e74:	f88d 3000 	strb.w	r3, [sp]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013e78:	466a      	mov	r2, sp
 8013e7a:	2301      	movs	r3, #1
 8013e7c:	f640 01e5 	movw	r1, #2277	@ 0x8e5
 8013e80:	f7f4 fbfc 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8013e84:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8013e88:	f8ad 3000 	strh.w	r3, [sp]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8013e8c:	f88d 3002 	strb.w	r3, [sp, #2]
    OperatingMode = MODE_RX;
 8013e90:	2305      	movs	r3, #5
 8013e92:	702b      	strb	r3, [r5, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013e94:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013e98:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013e9a:	2303      	movs	r3, #3
 8013e9c:	466a      	mov	r2, sp
 8013e9e:	2182      	movs	r1, #130	@ 0x82
 8013ea0:	481d      	ldr	r0, [pc, #116]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
 8013ea2:	f7f4 fb83 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013ea6:	f388 8810 	msr	PRIMASK, r8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013eaa:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013eae:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 8013eb0:	2304      	movs	r3, #4
 8013eb2:	eb0d 0203 	add.w	r2, sp, r3
 8013eb6:	f640 0119 	movw	r1, #2073	@ 0x819
 8013eba:	4817      	ldr	r0, [pc, #92]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
 8013ebc:	f7f4 fc46 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013ec0:	f388 8810 	msr	PRIMASK, r8
    SUBGRF_SetStandby( STDBY_RC );
 8013ec4:	f88d 7000 	strb.w	r7, [sp]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013ec8:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013ecc:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013ece:	2301      	movs	r3, #1
 8013ed0:	466a      	mov	r2, sp
 8013ed2:	2180      	movs	r1, #128	@ 0x80
 8013ed4:	4810      	ldr	r0, [pc, #64]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
 8013ed6:	f7f4 fb69 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013eda:	f387 8810 	msr	PRIMASK, r7
    if( standbyConfig == STDBY_RC )
 8013ede:	f89d 3000 	ldrb.w	r3, [sp]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013ee2:	480d      	ldr	r0, [pc, #52]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
 8013ee4:	f88d 6000 	strb.w	r6, [sp]
        OperatingMode = MODE_STDBY_RC;
 8013ee8:	2b00      	cmp	r3, #0
 8013eea:	bf14      	ite	ne
 8013eec:	2202      	movne	r2, #2
 8013eee:	2201      	moveq	r2, #1
 8013ef0:	702a      	strb	r2, [r5, #0]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013ef2:	2301      	movs	r3, #1
 8013ef4:	466a      	mov	r2, sp
 8013ef6:	f640 01e2 	movw	r1, #2274	@ 0x8e2
 8013efa:	f7f4 fbbf 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 8013efe:	2301      	movs	r3, #1
 8013f00:	466a      	mov	r2, sp
 8013f02:	f640 01e5 	movw	r1, #2277	@ 0x8e5
 8013f06:	4804      	ldr	r0, [pc, #16]	@ (8013f18 <SUBGRF_GetRandom+0xf0>)
 8013f08:	f88d 4000 	strb.w	r4, [sp]
 8013f0c:	f7f4 fbb6 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
}
 8013f10:	9801      	ldr	r0, [sp, #4]
 8013f12:	b002      	add	sp, #8
 8013f14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013f18:	20000318 	.word	0x20000318
 8013f1c:	200015c2 	.word	0x200015c2

08013f20 <SUBGRF_SetSleep>:
{
 8013f20:	b570      	push	{r4, r5, r6, lr}
 8013f22:	4604      	mov	r4, r0
 8013f24:	b082      	sub	sp, #8
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 8013f26:	2000      	movs	r0, #0
 8013f28:	f7f6 f920 	bl	800a16c <RBI_ConfigRFSwitch>
  if ( 1U == RBI_IsDCDC() )
 8013f2c:	f7f6 f93a 	bl	800a1a4 <RBI_IsDCDC>
 8013f30:	2801      	cmp	r0, #1
 8013f32:	d015      	beq.n	8013f60 <SUBGRF_SetSleep+0x40>
 8013f34:	f10d 0607 	add.w	r6, sp, #7
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 8013f38:	f004 0407 	and.w	r4, r4, #7
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8013f3c:	f88d 4007 	strb.w	r4, [sp, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013f40:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013f44:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013f46:	2301      	movs	r3, #1
 8013f48:	4632      	mov	r2, r6
 8013f4a:	2184      	movs	r1, #132	@ 0x84
 8013f4c:	4811      	ldr	r0, [pc, #68]	@ (8013f94 <SUBGRF_SetSleep+0x74>)
 8013f4e:	f7f4 fb2d 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013f52:	f384 8810 	msr	PRIMASK, r4
    OperatingMode = MODE_SLEEP;
 8013f56:	4b10      	ldr	r3, [pc, #64]	@ (8013f98 <SUBGRF_SetSleep+0x78>)
 8013f58:	2200      	movs	r2, #0
 8013f5a:	701a      	strb	r2, [r3, #0]
}
 8013f5c:	b002      	add	sp, #8
 8013f5e:	bd70      	pop	{r4, r5, r6, pc}
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8013f60:	f10d 0607 	add.w	r6, sp, #7
 8013f64:	4605      	mov	r5, r0
 8013f66:	4603      	mov	r3, r0
 8013f68:	4632      	mov	r2, r6
 8013f6a:	f640 1123 	movw	r1, #2339	@ 0x923
 8013f6e:	4809      	ldr	r0, [pc, #36]	@ (8013f94 <SUBGRF_SetSleep+0x74>)
 8013f70:	f7f4 fbec 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8013f74:	f89d 1007 	ldrb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013f78:	4806      	ldr	r0, [pc, #24]	@ (8013f94 <SUBGRF_SetSleep+0x74>)
    modReg&= (~SMPS_DRV_MASK);
 8013f7a:	f021 0106 	bic.w	r1, r1, #6
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 8013f7e:	f041 0102 	orr.w	r1, r1, #2
 8013f82:	f88d 1007 	strb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8013f86:	462b      	mov	r3, r5
 8013f88:	4632      	mov	r2, r6
 8013f8a:	f640 1123 	movw	r1, #2339	@ 0x923
 8013f8e:	f7f4 fb75 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
}
 8013f92:	e7d1      	b.n	8013f38 <SUBGRF_SetSleep+0x18>
 8013f94:	20000318 	.word	0x20000318
 8013f98:	200015c2 	.word	0x200015c2

08013f9c <SUBGRF_SetStandby>:
{
 8013f9c:	b510      	push	{r4, lr}
 8013f9e:	b082      	sub	sp, #8
 8013fa0:	f88d 0007 	strb.w	r0, [sp, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013fa4:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013fa8:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013faa:	2301      	movs	r3, #1
 8013fac:	f10d 0207 	add.w	r2, sp, #7
 8013fb0:	2180      	movs	r1, #128	@ 0x80
 8013fb2:	4807      	ldr	r0, [pc, #28]	@ (8013fd0 <SUBGRF_SetStandby+0x34>)
 8013fb4:	f7f4 fafa 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013fb8:	f384 8810 	msr	PRIMASK, r4
    if( standbyConfig == STDBY_RC )
 8013fbc:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8013fc0:	4b04      	ldr	r3, [pc, #16]	@ (8013fd4 <SUBGRF_SetStandby+0x38>)
        OperatingMode = MODE_STDBY_RC;
 8013fc2:	2a00      	cmp	r2, #0
 8013fc4:	bf14      	ite	ne
 8013fc6:	2202      	movne	r2, #2
 8013fc8:	2201      	moveq	r2, #1
 8013fca:	701a      	strb	r2, [r3, #0]
}
 8013fcc:	b002      	add	sp, #8
 8013fce:	bd10      	pop	{r4, pc}
 8013fd0:	20000318 	.word	0x20000318
 8013fd4:	200015c2 	.word	0x200015c2

08013fd8 <SUBGRF_SetTx>:
{
 8013fd8:	b510      	push	{r4, lr}
    OperatingMode = MODE_TX;
 8013fda:	490c      	ldr	r1, [pc, #48]	@ (801400c <SUBGRF_SetTx+0x34>)
{
 8013fdc:	b082      	sub	sp, #8
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8013fde:	0c02      	lsrs	r2, r0, #16
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8013fe0:	0a03      	lsrs	r3, r0, #8
    OperatingMode = MODE_TX;
 8013fe2:	2404      	movs	r4, #4
 8013fe4:	700c      	strb	r4, [r1, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8013fe6:	f88d 2004 	strb.w	r2, [sp, #4]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8013fea:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8013fee:	f88d 0006 	strb.w	r0, [sp, #6]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013ff2:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8013ff6:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8013ff8:	2303      	movs	r3, #3
 8013ffa:	aa01      	add	r2, sp, #4
 8013ffc:	2183      	movs	r1, #131	@ 0x83
 8013ffe:	4804      	ldr	r0, [pc, #16]	@ (8014010 <SUBGRF_SetTx+0x38>)
 8014000:	f7f4 fad4 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014004:	f384 8810 	msr	PRIMASK, r4
}
 8014008:	b002      	add	sp, #8
 801400a:	bd10      	pop	{r4, pc}
 801400c:	200015c2 	.word	0x200015c2
 8014010:	20000318 	.word	0x20000318

08014014 <SUBGRF_SetRx>:
{
 8014014:	b510      	push	{r4, lr}
    OperatingMode = MODE_RX;
 8014016:	490c      	ldr	r1, [pc, #48]	@ (8014048 <SUBGRF_SetRx+0x34>)
{
 8014018:	b082      	sub	sp, #8
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 801401a:	0c02      	lsrs	r2, r0, #16
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 801401c:	0a03      	lsrs	r3, r0, #8
    OperatingMode = MODE_RX;
 801401e:	2405      	movs	r4, #5
 8014020:	700c      	strb	r4, [r1, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8014022:	f88d 2004 	strb.w	r2, [sp, #4]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8014026:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 801402a:	f88d 0006 	strb.w	r0, [sp, #6]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801402e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014032:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014034:	2303      	movs	r3, #3
 8014036:	aa01      	add	r2, sp, #4
 8014038:	2182      	movs	r1, #130	@ 0x82
 801403a:	4804      	ldr	r0, [pc, #16]	@ (801404c <SUBGRF_SetRx+0x38>)
 801403c:	f7f4 fab6 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014040:	f384 8810 	msr	PRIMASK, r4
}
 8014044:	b002      	add	sp, #8
 8014046:	bd10      	pop	{r4, pc}
 8014048:	200015c2 	.word	0x200015c2
 801404c:	20000318 	.word	0x20000318

08014050 <SUBGRF_SetRxBoosted>:
{
 8014050:	b530      	push	{r4, r5, lr}
    OperatingMode = MODE_RX;
 8014052:	4b12      	ldr	r3, [pc, #72]	@ (801409c <SUBGRF_SetRxBoosted+0x4c>)
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8014054:	4d12      	ldr	r5, [pc, #72]	@ (80140a0 <SUBGRF_SetRxBoosted+0x50>)
{
 8014056:	b083      	sub	sp, #12
    OperatingMode = MODE_RX;
 8014058:	2205      	movs	r2, #5
 801405a:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 801405c:	2297      	movs	r2, #151	@ 0x97
{
 801405e:	4604      	mov	r4, r0
 8014060:	f88d 2004 	strb.w	r2, [sp, #4]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8014064:	2301      	movs	r3, #1
 8014066:	aa01      	add	r2, sp, #4
 8014068:	f640 01ac 	movw	r1, #2220	@ 0x8ac
 801406c:	4628      	mov	r0, r5
 801406e:	f7f4 fb05 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8014072:	0c22      	lsrs	r2, r4, #16
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8014074:	0a23      	lsrs	r3, r4, #8
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8014076:	f88d 2004 	strb.w	r2, [sp, #4]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 801407a:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 801407e:	f88d 4006 	strb.w	r4, [sp, #6]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014082:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014086:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014088:	2303      	movs	r3, #3
 801408a:	aa01      	add	r2, sp, #4
 801408c:	2182      	movs	r1, #130	@ 0x82
 801408e:	4628      	mov	r0, r5
 8014090:	f7f4 fa8c 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014094:	f384 8810 	msr	PRIMASK, r4
}
 8014098:	b003      	add	sp, #12
 801409a:	bd30      	pop	{r4, r5, pc}
 801409c:	200015c2 	.word	0x200015c2
 80140a0:	20000318 	.word	0x20000318

080140a4 <SUBGRF_SetRxDutyCycle>:
{
 80140a4:	b510      	push	{r4, lr}
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 80140a6:	0c02      	lsrs	r2, r0, #16
 80140a8:	2300      	movs	r3, #0
 80140aa:	f362 0307 	bfi	r3, r2, #0, #8
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 80140ae:	0a02      	lsrs	r2, r0, #8
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 80140b0:	f362 230f 	bfi	r3, r2, #8, #8
{
 80140b4:	b082      	sub	sp, #8
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 80140b6:	0c0a      	lsrs	r2, r1, #16
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 80140b8:	f360 4317 	bfi	r3, r0, #16, #8
 80140bc:	f362 631f 	bfi	r3, r2, #24, #8
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 80140c0:	ba49      	rev16	r1, r1
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 80140c2:	9300      	str	r3, [sp, #0]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 80140c4:	f8ad 1004 	strh.w	r1, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80140c8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80140cc:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80140ce:	2306      	movs	r3, #6
 80140d0:	466a      	mov	r2, sp
 80140d2:	2194      	movs	r1, #148	@ 0x94
 80140d4:	4804      	ldr	r0, [pc, #16]	@ (80140e8 <SUBGRF_SetRxDutyCycle+0x44>)
 80140d6:	f7f4 fa69 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80140da:	f384 8810 	msr	PRIMASK, r4
    OperatingMode = MODE_RX_DC;
 80140de:	4b03      	ldr	r3, [pc, #12]	@ (80140ec <SUBGRF_SetRxDutyCycle+0x48>)
 80140e0:	2206      	movs	r2, #6
 80140e2:	701a      	strb	r2, [r3, #0]
}
 80140e4:	b002      	add	sp, #8
 80140e6:	bd10      	pop	{r4, pc}
 80140e8:	20000318 	.word	0x20000318
 80140ec:	200015c2 	.word	0x200015c2

080140f0 <SUBGRF_SetCad>:
{
 80140f0:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80140f2:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80140f6:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80140f8:	2300      	movs	r3, #0
 80140fa:	461a      	mov	r2, r3
 80140fc:	21c5      	movs	r1, #197	@ 0xc5
 80140fe:	4804      	ldr	r0, [pc, #16]	@ (8014110 <SUBGRF_SetCad+0x20>)
 8014100:	f7f4 fa54 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014104:	f384 8810 	msr	PRIMASK, r4
    OperatingMode = MODE_CAD;
 8014108:	4b02      	ldr	r3, [pc, #8]	@ (8014114 <SUBGRF_SetCad+0x24>)
 801410a:	2207      	movs	r2, #7
 801410c:	701a      	strb	r2, [r3, #0]
}
 801410e:	bd10      	pop	{r4, pc}
 8014110:	20000318 	.word	0x20000318
 8014114:	200015c2 	.word	0x200015c2

08014118 <SUBGRF_SetTxContinuousWave>:
{
 8014118:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801411a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801411e:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014120:	2300      	movs	r3, #0
 8014122:	461a      	mov	r2, r3
 8014124:	21d1      	movs	r1, #209	@ 0xd1
 8014126:	4803      	ldr	r0, [pc, #12]	@ (8014134 <SUBGRF_SetTxContinuousWave+0x1c>)
 8014128:	f7f4 fa40 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801412c:	f384 8810 	msr	PRIMASK, r4
}
 8014130:	bd10      	pop	{r4, pc}
 8014132:	bf00      	nop
 8014134:	20000318 	.word	0x20000318

08014138 <SUBGRF_SetTxInfinitePreamble>:
{
 8014138:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801413a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801413e:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014140:	2300      	movs	r3, #0
 8014142:	461a      	mov	r2, r3
 8014144:	21d2      	movs	r1, #210	@ 0xd2
 8014146:	4803      	ldr	r0, [pc, #12]	@ (8014154 <SUBGRF_SetTxInfinitePreamble+0x1c>)
 8014148:	f7f4 fa30 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801414c:	f384 8810 	msr	PRIMASK, r4
}
 8014150:	bd10      	pop	{r4, pc}
 8014152:	bf00      	nop
 8014154:	20000318 	.word	0x20000318

08014158 <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 8014158:	b510      	push	{r4, lr}
 801415a:	b082      	sub	sp, #8
 801415c:	f88d 0007 	strb.w	r0, [sp, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014160:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014164:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014166:	2301      	movs	r3, #1
 8014168:	f10d 0207 	add.w	r2, sp, #7
 801416c:	219f      	movs	r1, #159	@ 0x9f
 801416e:	4803      	ldr	r0, [pc, #12]	@ (801417c <SUBGRF_SetStopRxTimerOnPreambleDetect+0x24>)
 8014170:	f7f4 fa1c 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014174:	f384 8810 	msr	PRIMASK, r4
}
 8014178:	b002      	add	sp, #8
 801417a:	bd10      	pop	{r4, pc}
 801417c:	20000318 	.word	0x20000318

08014180 <SUBGRF_SetLoRaSymbNumTimeout>:
{
 8014180:	b510      	push	{r4, lr}
 8014182:	b084      	sub	sp, #16
 8014184:	f88d 0007 	strb.w	r0, [sp, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014188:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801418c:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 801418e:	2301      	movs	r3, #1
 8014190:	f10d 0207 	add.w	r2, sp, #7
 8014194:	21a0      	movs	r1, #160	@ 0xa0
 8014196:	480d      	ldr	r0, [pc, #52]	@ (80141cc <SUBGRF_SetLoRaSymbNumTimeout+0x4c>)
 8014198:	f7f4 fa08 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801419c:	f384 8810 	msr	PRIMASK, r4
    if( symbNum >= 64 )
 80141a0:	f89d c007 	ldrb.w	ip, [sp, #7]
 80141a4:	f1bc 0f3f 	cmp.w	ip, #63	@ 0x3f
 80141a8:	d90d      	bls.n	80141c6 <SUBGRF_SetLoRaSymbNumTimeout+0x46>
        reg = exp + ( mant << 3 );
 80141aa:	f00c 0cf8 	and.w	ip, ip, #248	@ 0xf8
 80141ae:	f10c 0c01 	add.w	ip, ip, #1
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 80141b2:	4806      	ldr	r0, [pc, #24]	@ (80141cc <SUBGRF_SetLoRaSymbNumTimeout+0x4c>)
 80141b4:	f88d c00f 	strb.w	ip, [sp, #15]
 80141b8:	2301      	movs	r3, #1
 80141ba:	f10d 020f 	add.w	r2, sp, #15
 80141be:	f240 7106 	movw	r1, #1798	@ 0x706
 80141c2:	f7f4 fa5b 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
}
 80141c6:	b004      	add	sp, #16
 80141c8:	bd10      	pop	{r4, pc}
 80141ca:	bf00      	nop
 80141cc:	20000318 	.word	0x20000318

080141d0 <SUBGRF_SetRegulatorMode>:
{
 80141d0:	b510      	push	{r4, lr}
 80141d2:	b082      	sub	sp, #8
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 80141d4:	f7f5 ffe6 	bl	800a1a4 <RBI_IsDCDC>
 80141d8:	f1a0 0001 	sub.w	r0, r0, #1
 80141dc:	fab0 f080 	clz	r0, r0
 80141e0:	0940      	lsrs	r0, r0, #5
 80141e2:	f88d 0007 	strb.w	r0, [sp, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80141e6:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80141ea:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80141ec:	2301      	movs	r3, #1
 80141ee:	f10d 0207 	add.w	r2, sp, #7
 80141f2:	2196      	movs	r1, #150	@ 0x96
 80141f4:	4803      	ldr	r0, [pc, #12]	@ (8014204 <SUBGRF_SetRegulatorMode+0x34>)
 80141f6:	f7f4 f9d9 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80141fa:	f384 8810 	msr	PRIMASK, r4
}
 80141fe:	b002      	add	sp, #8
 8014200:	bd10      	pop	{r4, pc}
 8014202:	bf00      	nop
 8014204:	20000318 	.word	0x20000318

08014208 <SUBGRF_SetDioIrqParams>:
{
 8014208:	b510      	push	{r4, lr}
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 801420a:	ea4f 2c10 	mov.w	ip, r0, lsr #8
 801420e:	2400      	movs	r4, #0
 8014210:	f36c 0407 	bfi	r4, ip, #0, #8
 8014214:	f360 240f 	bfi	r4, r0, #8, #8
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 8014218:	0a08      	lsrs	r0, r1, #8
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 801421a:	ea4f 2c12 	mov.w	ip, r2, lsr #8
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 801421e:	f360 4417 	bfi	r4, r0, #16, #8
 8014222:	2000      	movs	r0, #0
 8014224:	f36c 0007 	bfi	r0, ip, #0, #8
 8014228:	f362 200f 	bfi	r0, r2, #8, #8
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 801422c:	0a1a      	lsrs	r2, r3, #8
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 801422e:	f362 4017 	bfi	r0, r2, #16, #8
{
 8014232:	b082      	sub	sp, #8
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 8014234:	f361 641f 	bfi	r4, r1, #24, #8
 8014238:	f363 601f 	bfi	r0, r3, #24, #8
 801423c:	e9cd 4000 	strd	r4, r0, [sp]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014240:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014244:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014246:	2308      	movs	r3, #8
 8014248:	466a      	mov	r2, sp
 801424a:	4619      	mov	r1, r3
 801424c:	4803      	ldr	r0, [pc, #12]	@ (801425c <SUBGRF_SetDioIrqParams+0x54>)
 801424e:	f7f4 f9ad 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014252:	f384 8810 	msr	PRIMASK, r4
}
 8014256:	b002      	add	sp, #8
 8014258:	bd10      	pop	{r4, pc}
 801425a:	bf00      	nop
 801425c:	20000318 	.word	0x20000318

08014260 <SUBGRF_SetRfFrequency>:
{
 8014260:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( ImageCalibrated == false )
 8014262:	4e26      	ldr	r6, [pc, #152]	@ (80142fc <SUBGRF_SetRfFrequency+0x9c>)
 8014264:	7833      	ldrb	r3, [r6, #0]
{
 8014266:	b083      	sub	sp, #12
 8014268:	4604      	mov	r4, r0
    if( ImageCalibrated == false )
 801426a:	b1ab      	cbz	r3, 8014298 <SUBGRF_SetRfFrequency+0x38>
 801426c:	ad01      	add	r5, sp, #4
    SX_FREQ_TO_CHANNEL(chan, frequency);
 801426e:	4a24      	ldr	r2, [pc, #144]	@ (8014300 <SUBGRF_SetRfFrequency+0xa0>)
 8014270:	2300      	movs	r3, #0
 8014272:	0660      	lsls	r0, r4, #25
 8014274:	09e1      	lsrs	r1, r4, #7
 8014276:	f7ec fb77 	bl	8000968 <__aeabi_uldivmod>
 801427a:	ba00      	rev	r0, r0
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 801427c:	9001      	str	r0, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801427e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014282:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014284:	2304      	movs	r3, #4
 8014286:	462a      	mov	r2, r5
 8014288:	2186      	movs	r1, #134	@ 0x86
 801428a:	481e      	ldr	r0, [pc, #120]	@ (8014304 <SUBGRF_SetRfFrequency+0xa4>)
 801428c:	f7f4 f98e 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014290:	f384 8810 	msr	PRIMASK, r4
}
 8014294:	b003      	add	sp, #12
 8014296:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( freq > 900000000 )
 8014298:	4b1b      	ldr	r3, [pc, #108]	@ (8014308 <SUBGRF_SetRfFrequency+0xa8>)
 801429a:	4298      	cmp	r0, r3
 801429c:	d914      	bls.n	80142c8 <SUBGRF_SetRfFrequency+0x68>
 801429e:	22e1      	movs	r2, #225	@ 0xe1
 80142a0:	23e9      	movs	r3, #233	@ 0xe9
        calFreq[0] = 0xE1;
 80142a2:	f88d 2004 	strb.w	r2, [sp, #4]
        calFreq[1] = 0xE9;
 80142a6:	f88d 3005 	strb.w	r3, [sp, #5]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80142aa:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80142ae:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80142b0:	ad01      	add	r5, sp, #4
 80142b2:	2302      	movs	r3, #2
 80142b4:	462a      	mov	r2, r5
 80142b6:	2198      	movs	r1, #152	@ 0x98
 80142b8:	4812      	ldr	r0, [pc, #72]	@ (8014304 <SUBGRF_SetRfFrequency+0xa4>)
 80142ba:	f7f4 f977 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80142be:	f387 8810 	msr	PRIMASK, r7
        ImageCalibrated = true;
 80142c2:	2301      	movs	r3, #1
 80142c4:	7033      	strb	r3, [r6, #0]
 80142c6:	e7d2      	b.n	801426e <SUBGRF_SetRfFrequency+0xe>
    else if( freq > 850000000 )
 80142c8:	4b10      	ldr	r3, [pc, #64]	@ (801430c <SUBGRF_SetRfFrequency+0xac>)
 80142ca:	4298      	cmp	r0, r3
 80142cc:	d80d      	bhi.n	80142ea <SUBGRF_SetRfFrequency+0x8a>
    else if( freq > 770000000 )
 80142ce:	4b10      	ldr	r3, [pc, #64]	@ (8014310 <SUBGRF_SetRfFrequency+0xb0>)
 80142d0:	4298      	cmp	r0, r3
 80142d2:	d80d      	bhi.n	80142f0 <SUBGRF_SetRfFrequency+0x90>
    else if( freq > 460000000 )
 80142d4:	4b0f      	ldr	r3, [pc, #60]	@ (8014314 <SUBGRF_SetRfFrequency+0xb4>)
 80142d6:	4298      	cmp	r0, r3
 80142d8:	d80d      	bhi.n	80142f6 <SUBGRF_SetRfFrequency+0x96>
    else if( freq > 425000000 )
 80142da:	4b0f      	ldr	r3, [pc, #60]	@ (8014318 <SUBGRF_SetRfFrequency+0xb8>)
 80142dc:	4298      	cmp	r0, r3
 80142de:	bf8b      	itete	hi
 80142e0:	226b      	movhi	r2, #107	@ 0x6b
 80142e2:	2229      	movls	r2, #41	@ 0x29
 80142e4:	236f      	movhi	r3, #111	@ 0x6f
 80142e6:	232b      	movls	r3, #43	@ 0x2b
 80142e8:	e7db      	b.n	80142a2 <SUBGRF_SetRfFrequency+0x42>
 80142ea:	22d7      	movs	r2, #215	@ 0xd7
 80142ec:	23db      	movs	r3, #219	@ 0xdb
 80142ee:	e7d8      	b.n	80142a2 <SUBGRF_SetRfFrequency+0x42>
 80142f0:	22c1      	movs	r2, #193	@ 0xc1
 80142f2:	23c5      	movs	r3, #197	@ 0xc5
 80142f4:	e7d5      	b.n	80142a2 <SUBGRF_SetRfFrequency+0x42>
 80142f6:	2275      	movs	r2, #117	@ 0x75
 80142f8:	2381      	movs	r3, #129	@ 0x81
 80142fa:	e7d2      	b.n	80142a2 <SUBGRF_SetRfFrequency+0x42>
 80142fc:	200015b8 	.word	0x200015b8
 8014300:	01e84800 	.word	0x01e84800
 8014304:	20000318 	.word	0x20000318
 8014308:	35a4e900 	.word	0x35a4e900
 801430c:	32a9f880 	.word	0x32a9f880
 8014310:	2de54480 	.word	0x2de54480
 8014314:	1b6b0b00 	.word	0x1b6b0b00
 8014318:	1954fc40 	.word	0x1954fc40

0801431c <SUBGRF_SetPacketType>:
{
 801431c:	b510      	push	{r4, lr}
    PacketType = packetType;
 801431e:	4b10      	ldr	r3, [pc, #64]	@ (8014360 <SUBGRF_SetPacketType+0x44>)
{
 8014320:	b084      	sub	sp, #16
    PacketType = packetType;
 8014322:	7018      	strb	r0, [r3, #0]
{
 8014324:	f88d 0007 	strb.w	r0, [sp, #7]
    if( packetType == PACKET_TYPE_GFSK )
 8014328:	b168      	cbz	r0, 8014346 <SUBGRF_SetPacketType+0x2a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801432a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801432e:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014330:	2301      	movs	r3, #1
 8014332:	f10d 0207 	add.w	r2, sp, #7
 8014336:	218a      	movs	r1, #138	@ 0x8a
 8014338:	480a      	ldr	r0, [pc, #40]	@ (8014364 <SUBGRF_SetPacketType+0x48>)
 801433a:	f7f4 f937 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801433e:	f384 8810 	msr	PRIMASK, r4
}
 8014342:	b004      	add	sp, #16
 8014344:	bd10      	pop	{r4, pc}
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 8014346:	4604      	mov	r4, r0
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8014348:	2301      	movs	r3, #1
 801434a:	f10d 020f 	add.w	r2, sp, #15
 801434e:	f240 61ac 	movw	r1, #1708	@ 0x6ac
 8014352:	4804      	ldr	r0, [pc, #16]	@ (8014364 <SUBGRF_SetPacketType+0x48>)
 8014354:	f88d 400f 	strb.w	r4, [sp, #15]
 8014358:	f7f4 f990 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 801435c:	e7e5      	b.n	801432a <SUBGRF_SetPacketType+0xe>
 801435e:	bf00      	nop
 8014360:	200015c1 	.word	0x200015c1
 8014364:	20000318 	.word	0x20000318

08014368 <SUBGRF_SetTxParams>:
{
 8014368:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (paSelect == RFO_LP)
 801436c:	2801      	cmp	r0, #1
{
 801436e:	b082      	sub	sp, #8
 8014370:	460c      	mov	r4, r1
 8014372:	4617      	mov	r7, r2
    if (paSelect == RFO_LP)
 8014374:	d055      	beq.n	8014422 <SUBGRF_SetTxParams+0xba>
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8014376:	ae01      	add	r6, sp, #4
 8014378:	2301      	movs	r3, #1
 801437a:	4632      	mov	r2, r6
 801437c:	f640 01d8 	movw	r1, #2264	@ 0x8d8
 8014380:	4866      	ldr	r0, [pc, #408]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 8014382:	f7f4 f9e3 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8014386:	f89d 2004 	ldrb.w	r2, [sp, #4]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 801438a:	4864      	ldr	r0, [pc, #400]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
        SUBGRF_WriteRegister(REG_TX_CLAMP, SUBGRF_ReadRegister(REG_TX_CLAMP) | (0x0F << 1));
 801438c:	f042 021e 	orr.w	r2, r2, #30
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8014390:	2301      	movs	r3, #1
 8014392:	f88d 2004 	strb.w	r2, [sp, #4]
 8014396:	f640 01d8 	movw	r1, #2264	@ 0x8d8
 801439a:	4632      	mov	r2, r6
 801439c:	f7f4 f96e 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_HP_MAXPOWER);
 80143a0:	2001      	movs	r0, #1
 80143a2:	f7f5 ff01 	bl	800a1a8 <RBI_GetRFOMaxPowerConfig>
        if (power > max_power)
 80143a6:	42a0      	cmp	r0, r4
            power = max_power;
 80143a8:	bfb8      	it	lt
 80143aa:	b244      	sxtblt	r4, r0
        if (max_power == 20)
 80143ac:	2814      	cmp	r0, #20
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_HP_MAXPOWER);
 80143ae:	4605      	mov	r5, r0
        if (max_power == 20)
 80143b0:	f000 8095 	beq.w	80144de <SUBGRF_SetTxParams+0x176>
        else if (max_power == 17)
 80143b4:	2811      	cmp	r0, #17
 80143b6:	d063      	beq.n	8014480 <SUBGRF_SetTxParams+0x118>
        else if (max_power == 14)
 80143b8:	280e      	cmp	r0, #14
 80143ba:	f000 8082 	beq.w	80144c2 <SUBGRF_SetTxParams+0x15a>
    buf[0] = paDutyCycle;
 80143be:	4b58      	ldr	r3, [pc, #352]	@ (8014520 <SUBGRF_SetTxParams+0x1b8>)
 80143c0:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80143c2:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80143c6:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80143c8:	2304      	movs	r3, #4
 80143ca:	4632      	mov	r2, r6
 80143cc:	2195      	movs	r1, #149	@ 0x95
 80143ce:	4853      	ldr	r0, [pc, #332]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 80143d0:	f7f4 f8ec 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80143d4:	f388 8810 	msr	PRIMASK, r8
            power = 0x16 - (max_power - power);
 80143d8:	f1c5 0516 	rsb	r5, r5, #22
 80143dc:	4425      	add	r5, r4
 80143de:	b26c      	sxtb	r4, r5
        if (power < -9)
 80143e0:	f06f 0208 	mvn.w	r2, #8
 80143e4:	2338      	movs	r3, #56	@ 0x38
 80143e6:	4294      	cmp	r4, r2
 80143e8:	bfb8      	it	lt
 80143ea:	4614      	movlt	r4, r2
        SUBGRF_WriteRegister(REG_OCP, 0x38);   /*current max 160mA for the whole device*/
 80143ec:	f88d 3004 	strb.w	r3, [sp, #4]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 80143f0:	484a      	ldr	r0, [pc, #296]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 80143f2:	2301      	movs	r3, #1
 80143f4:	4632      	mov	r2, r6
 80143f6:	f640 01e7 	movw	r1, #2279	@ 0x8e7
 80143fa:	f7f4 f93f 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
    buf[0] = power;
 80143fe:	f88d 4004 	strb.w	r4, [sp, #4]
    buf[1] = (uint8_t)rampTime;
 8014402:	f88d 7005 	strb.w	r7, [sp, #5]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014406:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801440a:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 801440c:	2302      	movs	r3, #2
 801440e:	4632      	mov	r2, r6
 8014410:	218e      	movs	r1, #142	@ 0x8e
 8014412:	4842      	ldr	r0, [pc, #264]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 8014414:	f7f4 f8ca 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014418:	f384 8810 	msr	PRIMASK, r4
}
 801441c:	b002      	add	sp, #8
 801441e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_LP_MAXPOWER);
 8014422:	2000      	movs	r0, #0
 8014424:	f7f5 fec0 	bl	800a1a8 <RBI_GetRFOMaxPowerConfig>
        if (power >  max_power)
 8014428:	42a0      	cmp	r0, r4
          power = max_power;
 801442a:	bfb8      	it	lt
 801442c:	b244      	sxtblt	r4, r0
        if (max_power == 14)
 801442e:	280e      	cmp	r0, #14
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_LP_MAXPOWER);
 8014430:	4605      	mov	r5, r0
        if (max_power == 14)
 8014432:	d064      	beq.n	80144fe <SUBGRF_SetTxParams+0x196>
        else if (max_power == 10)
 8014434:	280a      	cmp	r0, #10
            power = 0x0D - (max_power - power);
 8014436:	b2e4      	uxtb	r4, r4
        else if (max_power == 10)
 8014438:	d032      	beq.n	80144a0 <SUBGRF_SetTxParams+0x138>
    buf[0] = paDutyCycle;
 801443a:	4b3a      	ldr	r3, [pc, #232]	@ (8014524 <SUBGRF_SetTxParams+0x1bc>)
 801443c:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801443e:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014442:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014444:	ae01      	add	r6, sp, #4
 8014446:	2304      	movs	r3, #4
 8014448:	4632      	mov	r2, r6
 801444a:	2195      	movs	r1, #149	@ 0x95
 801444c:	4833      	ldr	r0, [pc, #204]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 801444e:	f7f4 f8ad 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014452:	f388 8810 	msr	PRIMASK, r8
            power = 0x0E - (max_power - power);
 8014456:	f1c5 050e 	rsb	r5, r5, #14
 801445a:	442c      	add	r4, r5
 801445c:	b264      	sxtb	r4, r4
        if (power < -17)
 801445e:	f06f 0210 	mvn.w	r2, #16
 8014462:	4294      	cmp	r4, r2
 8014464:	f04f 0318 	mov.w	r3, #24
 8014468:	bfb8      	it	lt
 801446a:	4614      	movlt	r4, r2
        SUBGRF_WriteRegister(REG_OCP, 0x18);   /* current max is 80 mA for the whole device*/
 801446c:	f88d 3004 	strb.w	r3, [sp, #4]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 8014470:	4632      	mov	r2, r6
 8014472:	2301      	movs	r3, #1
 8014474:	f640 01e7 	movw	r1, #2279	@ 0x8e7
 8014478:	4828      	ldr	r0, [pc, #160]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 801447a:	f7f4 f8ff 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 801447e:	e7be      	b.n	80143fe <SUBGRF_SetTxParams+0x96>
    buf[0] = paDutyCycle;
 8014480:	4b29      	ldr	r3, [pc, #164]	@ (8014528 <SUBGRF_SetTxParams+0x1c0>)
 8014482:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014484:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014488:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 801448a:	2304      	movs	r3, #4
 801448c:	4632      	mov	r2, r6
 801448e:	2195      	movs	r1, #149	@ 0x95
 8014490:	4822      	ldr	r0, [pc, #136]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 8014492:	f7f4 f88b 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014496:	f385 8810 	msr	PRIMASK, r5
            power = 0x16 - (max_power - power);
 801449a:	3405      	adds	r4, #5
 801449c:	b264      	sxtb	r4, r4
 801449e:	e79f      	b.n	80143e0 <SUBGRF_SetTxParams+0x78>
    buf[0] = paDutyCycle;
 80144a0:	4b22      	ldr	r3, [pc, #136]	@ (801452c <SUBGRF_SetTxParams+0x1c4>)
 80144a2:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80144a4:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80144a8:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80144aa:	ae01      	add	r6, sp, #4
 80144ac:	2304      	movs	r3, #4
 80144ae:	4632      	mov	r2, r6
 80144b0:	2195      	movs	r1, #149	@ 0x95
 80144b2:	481a      	ldr	r0, [pc, #104]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 80144b4:	f7f4 f87a 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80144b8:	f385 8810 	msr	PRIMASK, r5
            power = 0x0D - (max_power - power);
 80144bc:	3403      	adds	r4, #3
 80144be:	b264      	sxtb	r4, r4
 80144c0:	e7cd      	b.n	801445e <SUBGRF_SetTxParams+0xf6>
    buf[0] = paDutyCycle;
 80144c2:	4b1b      	ldr	r3, [pc, #108]	@ (8014530 <SUBGRF_SetTxParams+0x1c8>)
 80144c4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80144c6:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80144ca:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80144cc:	2304      	movs	r3, #4
 80144ce:	4632      	mov	r2, r6
 80144d0:	2195      	movs	r1, #149	@ 0x95
 80144d2:	4812      	ldr	r0, [pc, #72]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 80144d4:	f7f4 f86a 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80144d8:	f385 8810 	msr	PRIMASK, r5
            power = 0x0E - (max_power - power);
 80144dc:	e780      	b.n	80143e0 <SUBGRF_SetTxParams+0x78>
    buf[0] = paDutyCycle;
 80144de:	4b15      	ldr	r3, [pc, #84]	@ (8014534 <SUBGRF_SetTxParams+0x1cc>)
 80144e0:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80144e2:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80144e6:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80144e8:	2304      	movs	r3, #4
 80144ea:	4632      	mov	r2, r6
 80144ec:	2195      	movs	r1, #149	@ 0x95
 80144ee:	480b      	ldr	r0, [pc, #44]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 80144f0:	f7f4 f85c 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80144f4:	f385 8810 	msr	PRIMASK, r5
            power = 0x16 - (max_power - power);
 80144f8:	3402      	adds	r4, #2
 80144fa:	b264      	sxtb	r4, r4
 80144fc:	e770      	b.n	80143e0 <SUBGRF_SetTxParams+0x78>
    buf[0] = paDutyCycle;
 80144fe:	4b0e      	ldr	r3, [pc, #56]	@ (8014538 <SUBGRF_SetTxParams+0x1d0>)
 8014500:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014502:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014506:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014508:	ae01      	add	r6, sp, #4
 801450a:	2304      	movs	r3, #4
 801450c:	4632      	mov	r2, r6
 801450e:	2195      	movs	r1, #149	@ 0x95
 8014510:	4802      	ldr	r0, [pc, #8]	@ (801451c <SUBGRF_SetTxParams+0x1b4>)
 8014512:	f7f4 f84b 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014516:	f385 8810 	msr	PRIMASK, r5
            power = 0x0E - (max_power - power);
 801451a:	e7a0      	b.n	801445e <SUBGRF_SetTxParams+0xf6>
 801451c:	20000318 	.word	0x20000318
 8014520:	01000704 	.word	0x01000704
 8014524:	01010007 	.word	0x01010007
 8014528:	01000302 	.word	0x01000302
 801452c:	01010001 	.word	0x01010001
 8014530:	01000202 	.word	0x01000202
 8014534:	01000503 	.word	0x01000503
 8014538:	01010004 	.word	0x01010004

0801453c <SUBGRF_SetModulationParams>:
{
 801453c:	b570      	push	{r4, r5, r6, lr}
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 801453e:	4b4c      	ldr	r3, [pc, #304]	@ (8014670 <SUBGRF_SetModulationParams+0x134>)
    if( PacketType != modulationParams->PacketType )
 8014540:	4a4c      	ldr	r2, [pc, #304]	@ (8014674 <SUBGRF_SetModulationParams+0x138>)
{
 8014542:	4604      	mov	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 8014544:	e893 0003 	ldmia.w	r3, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 8014548:	7826      	ldrb	r6, [r4, #0]
 801454a:	7813      	ldrb	r3, [r2, #0]
{
 801454c:	b084      	sub	sp, #16
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 801454e:	ad02      	add	r5, sp, #8
    if( PacketType != modulationParams->PacketType )
 8014550:	429e      	cmp	r6, r3
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 8014552:	e885 0003 	stmia.w	r5, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 8014556:	d16e      	bne.n	8014636 <SUBGRF_SetModulationParams+0xfa>
    switch( modulationParams->PacketType )
 8014558:	2b03      	cmp	r3, #3
 801455a:	d822      	bhi.n	80145a2 <SUBGRF_SetModulationParams+0x66>
 801455c:	e8df f003 	tbb	[pc, r3]
 8014560:	02233940 	.word	0x02233940
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 8014564:	6861      	ldr	r1, [r4, #4]
 8014566:	4a44      	ldr	r2, [pc, #272]	@ (8014678 <SUBGRF_SetModulationParams+0x13c>)
 8014568:	fbb2 f2f1 	udiv	r2, r2, r1
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 801456c:	2300      	movs	r3, #0
 801456e:	0c11      	lsrs	r1, r2, #16
 8014570:	f361 0307 	bfi	r3, r1, #0, #8
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 8014574:	0a11      	lsrs	r1, r2, #8
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8014576:	f361 230f 	bfi	r3, r1, #8, #8
 801457a:	7b21      	ldrb	r1, [r4, #12]
 801457c:	f362 4317 	bfi	r3, r2, #16, #8
 8014580:	f361 631f 	bfi	r3, r1, #24, #8
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 8014584:	7b62      	ldrb	r2, [r4, #13]
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8014586:	9302      	str	r3, [sp, #8]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 8014588:	f88d 200c 	strb.w	r2, [sp, #12]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801458c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014590:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014592:	2305      	movs	r3, #5
 8014594:	462a      	mov	r2, r5
 8014596:	218b      	movs	r1, #139	@ 0x8b
 8014598:	4838      	ldr	r0, [pc, #224]	@ (801467c <SUBGRF_SetModulationParams+0x140>)
 801459a:	f7f4 f807 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801459e:	f384 8810 	msr	PRIMASK, r4
}
 80145a2:	b004      	add	sp, #16
 80145a4:	bd70      	pop	{r4, r5, r6, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 80145a6:	6921      	ldr	r1, [r4, #16]
 80145a8:	4a33      	ldr	r2, [pc, #204]	@ (8014678 <SUBGRF_SetModulationParams+0x13c>)
 80145aa:	fbb2 f2f1 	udiv	r2, r2, r1
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 80145ae:	2300      	movs	r3, #0
 80145b0:	0c10      	lsrs	r0, r2, #16
 80145b2:	f360 0307 	bfi	r3, r0, #0, #8
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 80145b6:	0a10      	lsrs	r0, r2, #8
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 80145b8:	7d21      	ldrb	r1, [r4, #20]
 80145ba:	f360 230f 	bfi	r3, r0, #8, #8
 80145be:	f362 4317 	bfi	r3, r2, #16, #8
 80145c2:	f361 631f 	bfi	r3, r1, #24, #8
 80145c6:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80145c8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80145cc:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80145ce:	2304      	movs	r3, #4
 80145d0:	e7e0      	b.n	8014594 <SUBGRF_SetModulationParams+0x58>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 80145d2:	69a3      	ldr	r3, [r4, #24]
 80145d4:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80145d6:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80145da:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80145dc:	2304      	movs	r3, #4
 80145de:	e7d9      	b.n	8014594 <SUBGRF_SetModulationParams+0x58>
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 80145e0:	68a1      	ldr	r1, [r4, #8]
 80145e2:	4a27      	ldr	r2, [pc, #156]	@ (8014680 <SUBGRF_SetModulationParams+0x144>)
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 80145e4:	f8d4 c004 	ldr.w	ip, [r4, #4]
 80145e8:	4e23      	ldr	r6, [pc, #140]	@ (8014678 <SUBGRF_SetModulationParams+0x13c>)
 80145ea:	fbb6 f6fc 	udiv	r6, r6, ip
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 80145ee:	2300      	movs	r3, #0
 80145f0:	0648      	lsls	r0, r1, #25
 80145f2:	09c9      	lsrs	r1, r1, #7
 80145f4:	f7ec f9b8 	bl	8000968 <__aeabi_uldivmod>
        buf[7] = ( tempVal& 0xFF );
 80145f8:	7b62      	ldrb	r2, [r4, #13]
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 80145fa:	7b21      	ldrb	r1, [r4, #12]
 80145fc:	2300      	movs	r3, #0
 80145fe:	0c34      	lsrs	r4, r6, #16
 8014600:	f362 0307 	bfi	r3, r2, #0, #8
 8014604:	2200      	movs	r2, #0
 8014606:	f364 0207 	bfi	r2, r4, #0, #8
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 801460a:	0c04      	lsrs	r4, r0, #16
 801460c:	f364 230f 	bfi	r3, r4, #8, #8
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 8014610:	0a34      	lsrs	r4, r6, #8
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8014612:	f364 220f 	bfi	r2, r4, #8, #8
 8014616:	f366 4217 	bfi	r2, r6, #16, #8
 801461a:	f361 621f 	bfi	r2, r1, #24, #8
 801461e:	9202      	str	r2, [sp, #8]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 8014620:	0a02      	lsrs	r2, r0, #8
 8014622:	f362 4317 	bfi	r3, r2, #16, #8
 8014626:	f360 631f 	bfi	r3, r0, #24, #8
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 801462a:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801462c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014630:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014632:	2308      	movs	r3, #8
 8014634:	e7ae      	b.n	8014594 <SUBGRF_SetModulationParams+0x58>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 8014636:	f88d 6006 	strb.w	r6, [sp, #6]
    PacketType = packetType;
 801463a:	7016      	strb	r6, [r2, #0]
    if( packetType == PACKET_TYPE_GFSK )
 801463c:	b16e      	cbz	r6, 801465a <SUBGRF_SetModulationParams+0x11e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801463e:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014642:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014644:	2301      	movs	r3, #1
 8014646:	f10d 0206 	add.w	r2, sp, #6
 801464a:	218a      	movs	r1, #138	@ 0x8a
 801464c:	480b      	ldr	r0, [pc, #44]	@ (801467c <SUBGRF_SetModulationParams+0x140>)
 801464e:	f7f3 ffad 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014652:	f386 8810 	msr	PRIMASK, r6
    switch( modulationParams->PacketType )
 8014656:	7823      	ldrb	r3, [r4, #0]
 8014658:	e77e      	b.n	8014558 <SUBGRF_SetModulationParams+0x1c>
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 801465a:	2301      	movs	r3, #1
 801465c:	f10d 0207 	add.w	r2, sp, #7
 8014660:	f240 61ac 	movw	r1, #1708	@ 0x6ac
 8014664:	4805      	ldr	r0, [pc, #20]	@ (801467c <SUBGRF_SetModulationParams+0x140>)
 8014666:	f88d 6007 	strb.w	r6, [sp, #7]
 801466a:	f7f4 f807 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 801466e:	e7e6      	b.n	801463e <SUBGRF_SetModulationParams+0x102>
 8014670:	08016814 	.word	0x08016814
 8014674:	200015c1 	.word	0x200015c1
 8014678:	3d090000 	.word	0x3d090000
 801467c:	20000318 	.word	0x20000318
 8014680:	01e84800 	.word	0x01e84800

08014684 <SUBGRF_SetPacketParams>:
{
 8014684:	b570      	push	{r4, r5, r6, lr}
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 8014686:	4b65      	ldr	r3, [pc, #404]	@ (801481c <SUBGRF_SetPacketParams+0x198>)
    if( PacketType != packetParams->PacketType )
 8014688:	4d65      	ldr	r5, [pc, #404]	@ (8014820 <SUBGRF_SetPacketParams+0x19c>)
{
 801468a:	4604      	mov	r4, r0
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 801468c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
{
 8014690:	b086      	sub	sp, #24
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 8014692:	ab03      	add	r3, sp, #12
 8014694:	c303      	stmia	r3!, {r0, r1}
 8014696:	701a      	strb	r2, [r3, #0]
    if( PacketType != packetParams->PacketType )
 8014698:	7822      	ldrb	r2, [r4, #0]
 801469a:	782b      	ldrb	r3, [r5, #0]
 801469c:	429a      	cmp	r2, r3
 801469e:	d151      	bne.n	8014744 <SUBGRF_SetPacketParams+0xc0>
    switch( packetParams->PacketType )
 80146a0:	2b03      	cmp	r3, #3
 80146a2:	d811      	bhi.n	80146c8 <SUBGRF_SetPacketParams+0x44>
 80146a4:	e8df f003 	tbb	[pc, r3]
 80146a8:	12023712 	.word	0x12023712
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 80146ac:	7b23      	ldrb	r3, [r4, #12]
 80146ae:	f88d 300c 	strb.w	r3, [sp, #12]
        break;
 80146b2:	2301      	movs	r3, #1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80146b4:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80146b8:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80146ba:	218c      	movs	r1, #140	@ 0x8c
 80146bc:	aa03      	add	r2, sp, #12
 80146be:	4859      	ldr	r0, [pc, #356]	@ (8014824 <SUBGRF_SetPacketParams+0x1a0>)
 80146c0:	f7f3 ff74 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80146c4:	f384 8810 	msr	PRIMASK, r4
}
 80146c8:	b006      	add	sp, #24
 80146ca:	bd70      	pop	{r4, r5, r6, pc}
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 80146cc:	7a61      	ldrb	r1, [r4, #9]
 80146ce:	29f1      	cmp	r1, #241	@ 0xf1
 80146d0:	d04a      	beq.n	8014768 <SUBGRF_SetPacketParams+0xe4>
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 80146d2:	29f2      	cmp	r1, #242	@ 0xf2
 80146d4:	d07a      	beq.n	80147cc <SUBGRF_SetPacketParams+0x148>
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 80146d6:	79a2      	ldrb	r2, [r4, #6]
 80146d8:	8860      	ldrh	r0, [r4, #2]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 80146da:	2300      	movs	r3, #0
 80146dc:	f362 0307 	bfi	r3, r2, #0, #8
 80146e0:	79e2      	ldrb	r2, [r4, #7]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 80146e2:	0a05      	lsrs	r5, r0, #8
 80146e4:	f362 230f 	bfi	r3, r2, #8, #8
 80146e8:	2200      	movs	r2, #0
 80146ea:	f365 0207 	bfi	r2, r5, #0, #8
 80146ee:	f360 220f 	bfi	r2, r0, #8, #8
 80146f2:	7a20      	ldrb	r0, [r4, #8]
 80146f4:	f360 4317 	bfi	r3, r0, #16, #8
 80146f8:	7920      	ldrb	r0, [r4, #4]
 80146fa:	f361 631f 	bfi	r3, r1, #24, #8
 80146fe:	7961      	ldrb	r1, [r4, #5]
 8014700:	9304      	str	r3, [sp, #16]
 8014702:	f360 4217 	bfi	r2, r0, #16, #8
        buf[8] = packetParams->Params.Gfsk.DcFree;
 8014706:	7aa3      	ldrb	r3, [r4, #10]
 8014708:	f88d 3014 	strb.w	r3, [sp, #20]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 801470c:	f361 621f 	bfi	r2, r1, #24, #8
        break;
 8014710:	2309      	movs	r3, #9
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 8014712:	9203      	str	r2, [sp, #12]
        break;
 8014714:	e7ce      	b.n	80146b4 <SUBGRF_SetPacketParams+0x30>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 8014716:	89e2      	ldrh	r2, [r4, #14]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 8014718:	7c21      	ldrb	r1, [r4, #16]
 801471a:	7c60      	ldrb	r0, [r4, #17]
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 801471c:	ba52      	rev16	r2, r2
 801471e:	f8ad 200c 	strh.w	r2, [sp, #12]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 8014722:	4a41      	ldr	r2, [pc, #260]	@ (8014828 <SUBGRF_SetPacketParams+0x1a4>)
 8014724:	2300      	movs	r3, #0
 8014726:	f361 0307 	bfi	r3, r1, #0, #8
 801472a:	7011      	strb	r1, [r2, #0]
 801472c:	7ca1      	ldrb	r1, [r4, #18]
 801472e:	7ce2      	ldrb	r2, [r4, #19]
 8014730:	f360 230f 	bfi	r3, r0, #8, #8
 8014734:	f361 4317 	bfi	r3, r1, #16, #8
 8014738:	f362 631f 	bfi	r3, r2, #24, #8
 801473c:	f8cd 300e 	str.w	r3, [sp, #14]
        break;
 8014740:	2306      	movs	r3, #6
 8014742:	e7b7      	b.n	80146b4 <SUBGRF_SetPacketParams+0x30>
        SUBGRF_SetPacketType( packetParams->PacketType );
 8014744:	f88d 2007 	strb.w	r2, [sp, #7]
    PacketType = packetType;
 8014748:	702a      	strb	r2, [r5, #0]
    if( packetType == PACKET_TYPE_GFSK )
 801474a:	b1aa      	cbz	r2, 8014778 <SUBGRF_SetPacketParams+0xf4>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801474c:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014750:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8014752:	2301      	movs	r3, #1
 8014754:	f10d 0207 	add.w	r2, sp, #7
 8014758:	218a      	movs	r1, #138	@ 0x8a
 801475a:	4832      	ldr	r0, [pc, #200]	@ (8014824 <SUBGRF_SetPacketParams+0x1a0>)
 801475c:	f7f3 ff26 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014760:	f386 8810 	msr	PRIMASK, r6
    switch( packetParams->PacketType )
 8014764:	7823      	ldrb	r3, [r4, #0]
 8014766:	e79b      	b.n	80146a0 <SUBGRF_SetPacketParams+0x1c>
    switch( SUBGRF_GetPacketType( ) )
 8014768:	782b      	ldrb	r3, [r5, #0]
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 801476a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 801476e:	f8ad 2008 	strh.w	r2, [sp, #8]
    switch( SUBGRF_GetPacketType( ) )
 8014772:	b15b      	cbz	r3, 801478c <SUBGRF_SetPacketParams+0x108>
            crcVal = RADIO_CRC_2_BYTES;
 8014774:	2102      	movs	r1, #2
}
 8014776:	e7ae      	b.n	80146d6 <SUBGRF_SetPacketParams+0x52>
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 8014778:	f88d 2008 	strb.w	r2, [sp, #8]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 801477c:	2301      	movs	r3, #1
 801477e:	aa02      	add	r2, sp, #8
 8014780:	f240 61ac 	movw	r1, #1708	@ 0x6ac
 8014784:	4827      	ldr	r0, [pc, #156]	@ (8014824 <SUBGRF_SetPacketParams+0x1a0>)
 8014786:	f7f3 ff79 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
 801478a:	e7df      	b.n	801474c <SUBGRF_SetPacketParams+0xc8>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801478c:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014790:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 8014792:	2302      	movs	r3, #2
 8014794:	aa02      	add	r2, sp, #8
 8014796:	f240 61bc 	movw	r1, #1724	@ 0x6bc
 801479a:	4822      	ldr	r0, [pc, #136]	@ (8014824 <SUBGRF_SetPacketParams+0x1a0>)
 801479c:	f7f3 ff6e 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80147a0:	f386 8810 	msr	PRIMASK, r6
    return PacketType;
 80147a4:	782b      	ldrb	r3, [r5, #0]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 80147a6:	f44f 62b0 	mov.w	r2, #1408	@ 0x580
 80147aa:	f8ad 2008 	strh.w	r2, [sp, #8]
    switch( SUBGRF_GetPacketType( ) )
 80147ae:	2b00      	cmp	r3, #0
 80147b0:	d1e0      	bne.n	8014774 <SUBGRF_SetPacketParams+0xf0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80147b2:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80147b6:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 80147b8:	2302      	movs	r3, #2
 80147ba:	aa02      	add	r2, sp, #8
 80147bc:	f240 61be 	movw	r1, #1726	@ 0x6be
 80147c0:	4818      	ldr	r0, [pc, #96]	@ (8014824 <SUBGRF_SetPacketParams+0x1a0>)
 80147c2:	f7f3 ff5b 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80147c6:	f385 8810 	msr	PRIMASK, r5
}
 80147ca:	e7d3      	b.n	8014774 <SUBGRF_SetPacketParams+0xf0>
    switch( SUBGRF_GetPacketType( ) )
 80147cc:	782b      	ldrb	r3, [r5, #0]
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 80147ce:	f640 721d 	movw	r2, #3869	@ 0xf1d
 80147d2:	f8ad 2008 	strh.w	r2, [sp, #8]
    switch( SUBGRF_GetPacketType( ) )
 80147d6:	b10b      	cbz	r3, 80147dc <SUBGRF_SetPacketParams+0x158>
            crcVal = RADIO_CRC_2_BYTES_INV;
 80147d8:	2106      	movs	r1, #6
}
 80147da:	e77c      	b.n	80146d6 <SUBGRF_SetPacketParams+0x52>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80147dc:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80147e0:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 80147e2:	2302      	movs	r3, #2
 80147e4:	aa02      	add	r2, sp, #8
 80147e6:	f240 61bc 	movw	r1, #1724	@ 0x6bc
 80147ea:	480e      	ldr	r0, [pc, #56]	@ (8014824 <SUBGRF_SetPacketParams+0x1a0>)
 80147ec:	f7f3 ff46 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80147f0:	f386 8810 	msr	PRIMASK, r6
    return PacketType;
 80147f4:	782b      	ldrb	r3, [r5, #0]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 80147f6:	f242 1210 	movw	r2, #8464	@ 0x2110
 80147fa:	f8ad 2008 	strh.w	r2, [sp, #8]
    switch( SUBGRF_GetPacketType( ) )
 80147fe:	2b00      	cmp	r3, #0
 8014800:	d1ea      	bne.n	80147d8 <SUBGRF_SetPacketParams+0x154>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014802:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014806:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 8014808:	2302      	movs	r3, #2
 801480a:	aa02      	add	r2, sp, #8
 801480c:	f240 61be 	movw	r1, #1726	@ 0x6be
 8014810:	4804      	ldr	r0, [pc, #16]	@ (8014824 <SUBGRF_SetPacketParams+0x1a0>)
 8014812:	f7f3 ff33 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014816:	f385 8810 	msr	PRIMASK, r5
}
 801481a:	e7dd      	b.n	80147d8 <SUBGRF_SetPacketParams+0x154>
 801481c:	0801681c 	.word	0x0801681c
 8014820:	200015c1 	.word	0x200015c1
 8014824:	20000318 	.word	0x20000318
 8014828:	200015c0 	.word	0x200015c0

0801482c <SUBGRF_SetBufferBaseAddress>:
{
 801482c:	b510      	push	{r4, lr}
 801482e:	b082      	sub	sp, #8
    buf[0] = txBaseAddress;
 8014830:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = rxBaseAddress;
 8014834:	f88d 1005 	strb.w	r1, [sp, #5]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014838:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801483c:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 801483e:	2302      	movs	r3, #2
 8014840:	aa01      	add	r2, sp, #4
 8014842:	218f      	movs	r1, #143	@ 0x8f
 8014844:	4803      	ldr	r0, [pc, #12]	@ (8014854 <SUBGRF_SetBufferBaseAddress+0x28>)
 8014846:	f7f3 feb1 	bl	80085ac <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801484a:	f384 8810 	msr	PRIMASK, r4
}
 801484e:	b002      	add	sp, #8
 8014850:	bd10      	pop	{r4, pc}
 8014852:	bf00      	nop
 8014854:	20000318 	.word	0x20000318

08014858 <SUBGRF_GetRssiInst>:
{
 8014858:	b510      	push	{r4, lr}
 801485a:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801485c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014860:	b672      	cpsid	i
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 8014862:	2301      	movs	r3, #1
 8014864:	aa01      	add	r2, sp, #4
 8014866:	2115      	movs	r1, #21
 8014868:	4805      	ldr	r0, [pc, #20]	@ (8014880 <SUBGRF_GetRssiInst+0x28>)
 801486a:	f7f3 fe41 	bl	80084f0 <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801486e:	f384 8810 	msr	PRIMASK, r4
    rssi = -buf[0] >> 1;
 8014872:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8014876:	4240      	negs	r0, r0
}
 8014878:	1040      	asrs	r0, r0, #1
 801487a:	b002      	add	sp, #8
 801487c:	bd10      	pop	{r4, pc}
 801487e:	bf00      	nop
 8014880:	20000318 	.word	0x20000318

08014884 <SUBGRF_GetPacketStatus>:
{
 8014884:	b530      	push	{r4, r5, lr}
 8014886:	4604      	mov	r4, r0
 8014888:	b083      	sub	sp, #12
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801488a:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801488e:	b672      	cpsid	i
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 8014890:	2303      	movs	r3, #3
 8014892:	aa01      	add	r2, sp, #4
 8014894:	2114      	movs	r1, #20
 8014896:	481c      	ldr	r0, [pc, #112]	@ (8014908 <SUBGRF_GetPacketStatus+0x84>)
 8014898:	f7f3 fe2a 	bl	80084f0 <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801489c:	f385 8810 	msr	PRIMASK, r5
    return PacketType;
 80148a0:	4b1a      	ldr	r3, [pc, #104]	@ (801490c <SUBGRF_GetPacketStatus+0x88>)
 80148a2:	781b      	ldrb	r3, [r3, #0]
    pktStatus->packetType = SUBGRF_GetPacketType( );
 80148a4:	7023      	strb	r3, [r4, #0]
    switch( pktStatus->packetType )
 80148a6:	b153      	cbz	r3, 80148be <SUBGRF_GetPacketStatus+0x3a>
 80148a8:	2b01      	cmp	r3, #1
 80148aa:	d018      	beq.n	80148de <SUBGRF_GetPacketStatus+0x5a>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 80148ac:	2214      	movs	r2, #20
 80148ae:	2100      	movs	r1, #0
 80148b0:	4620      	mov	r0, r4
 80148b2:	f000 fa4b 	bl	8014d4c <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 80148b6:	230f      	movs	r3, #15
 80148b8:	7023      	strb	r3, [r4, #0]
}
 80148ba:	b003      	add	sp, #12
 80148bc:	bd30      	pop	{r4, r5, pc}
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 80148be:	f89d 1005 	ldrb.w	r1, [sp, #5]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 80148c2:	f89d 2006 	ldrb.w	r2, [sp, #6]
            pktStatus->Params.Gfsk.RxStatus = status[0];
 80148c6:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80148ca:	7120      	strb	r0, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 80148cc:	4249      	negs	r1, r1
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 80148ce:	4252      	negs	r2, r2
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 80148d0:	1049      	asrs	r1, r1, #1
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 80148d2:	1052      	asrs	r2, r2, #1
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 80148d4:	71a1      	strb	r1, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 80148d6:	7162      	strb	r2, [r4, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 80148d8:	60a3      	str	r3, [r4, #8]
}
 80148da:	b003      	add	sp, #12
 80148dc:	bd30      	pop	{r4, r5, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 80148de:	f89d 1004 	ldrb.w	r1, [sp, #4]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 80148e2:	f99d 2005 	ldrsb.w	r2, [sp, #5]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 80148e6:	f89d 3006 	ldrb.w	r3, [sp, #6]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 80148ea:	4809      	ldr	r0, [pc, #36]	@ (8014910 <SUBGRF_GetPacketStatus+0x8c>)
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 80148ec:	4249      	negs	r1, r1
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 80148ee:	6800      	ldr	r0, [r0, #0]
 80148f0:	6120      	str	r0, [r4, #16]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 80148f2:	3202      	adds	r2, #2
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 80148f4:	425b      	negs	r3, r3
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 80148f6:	1049      	asrs	r1, r1, #1
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 80148f8:	1092      	asrs	r2, r2, #2
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 80148fa:	105b      	asrs	r3, r3, #1
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 80148fc:	7321      	strb	r1, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 80148fe:	7362      	strb	r2, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 8014900:	73a3      	strb	r3, [r4, #14]
}
 8014902:	b003      	add	sp, #12
 8014904:	bd30      	pop	{r4, r5, pc}
 8014906:	bf00      	nop
 8014908:	20000318 	.word	0x20000318
 801490c:	200015c1 	.word	0x200015c1
 8014910:	200015bc 	.word	0x200015bc

08014914 <SUBGRF_WriteRegister>:
{
 8014914:	b500      	push	{lr}
 8014916:	4686      	mov	lr, r0
 8014918:	b083      	sub	sp, #12
 801491a:	468c      	mov	ip, r1
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 801491c:	2301      	movs	r3, #1
 801491e:	f10d 0207 	add.w	r2, sp, #7
 8014922:	4671      	mov	r1, lr
 8014924:	4803      	ldr	r0, [pc, #12]	@ (8014934 <SUBGRF_WriteRegister+0x20>)
{
 8014926:	f88d c007 	strb.w	ip, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 801492a:	f7f3 fea7 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
}
 801492e:	b003      	add	sp, #12
 8014930:	f85d fb04 	ldr.w	pc, [sp], #4
 8014934:	20000318 	.word	0x20000318

08014938 <SUBGRF_ReadRegister>:
{
 8014938:	b500      	push	{lr}
 801493a:	b083      	sub	sp, #12
 801493c:	4601      	mov	r1, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 801493e:	2301      	movs	r3, #1
 8014940:	f10d 0207 	add.w	r2, sp, #7
 8014944:	4803      	ldr	r0, [pc, #12]	@ (8014954 <SUBGRF_ReadRegister+0x1c>)
 8014946:	f7f3 ff01 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
}
 801494a:	f89d 0007 	ldrb.w	r0, [sp, #7]
 801494e:	b003      	add	sp, #12
 8014950:	f85d fb04 	ldr.w	pc, [sp], #4
 8014954:	20000318 	.word	0x20000318

08014958 <SUBGRF_WriteRegisters>:
{
 8014958:	b510      	push	{r4, lr}
 801495a:	4684      	mov	ip, r0
 801495c:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801495e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014962:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 8014964:	4803      	ldr	r0, [pc, #12]	@ (8014974 <SUBGRF_WriteRegisters+0x1c>)
 8014966:	460a      	mov	r2, r1
 8014968:	4661      	mov	r1, ip
 801496a:	f7f3 fe87 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801496e:	f384 8810 	msr	PRIMASK, r4
}
 8014972:	bd10      	pop	{r4, pc}
 8014974:	20000318 	.word	0x20000318

08014978 <SUBGRF_ReadRegisters>:
{
 8014978:	b510      	push	{r4, lr}
 801497a:	4684      	mov	ip, r0
 801497c:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801497e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014982:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 8014984:	4803      	ldr	r0, [pc, #12]	@ (8014994 <SUBGRF_ReadRegisters+0x1c>)
 8014986:	460a      	mov	r2, r1
 8014988:	4661      	mov	r1, ip
 801498a:	f7f3 fedf 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801498e:	f384 8810 	msr	PRIMASK, r4
}
 8014992:	bd10      	pop	{r4, pc}
 8014994:	20000318 	.word	0x20000318

08014998 <SUBGRF_SetSwitch>:
    if (rxtx == RFSWITCH_TX)
 8014998:	2901      	cmp	r1, #1
 801499a:	d003      	beq.n	80149a4 <SUBGRF_SetSwitch+0xc>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 801499c:	2101      	movs	r1, #1
    RBI_ConfigRFSwitch(state);
 801499e:	4608      	mov	r0, r1
 80149a0:	f7f5 bbe4 	b.w	800a16c <RBI_ConfigRFSwitch>
        if (paSelect == RFO_LP)
 80149a4:	2801      	cmp	r0, #1
 80149a6:	d005      	beq.n	80149b4 <SUBGRF_SetSwitch+0x1c>
            state = RBI_SWITCH_RFO_HP;
 80149a8:	2802      	cmp	r0, #2
 80149aa:	bf08      	it	eq
 80149ac:	2103      	moveq	r1, #3
    RBI_ConfigRFSwitch(state);
 80149ae:	4608      	mov	r0, r1
 80149b0:	f7f5 bbdc 	b.w	800a16c <RBI_ConfigRFSwitch>
{
 80149b4:	b510      	push	{r4, lr}
 80149b6:	b082      	sub	sp, #8
  if ( 1U == RBI_IsDCDC() )
 80149b8:	f7f5 fbf4 	bl	800a1a4 <RBI_IsDCDC>
 80149bc:	2801      	cmp	r0, #1
 80149be:	4604      	mov	r4, r0
 80149c0:	d006      	beq.n	80149d0 <SUBGRF_SetSwitch+0x38>
            state = RBI_SWITCH_RFO_LP;
 80149c2:	2102      	movs	r1, #2
    RBI_ConfigRFSwitch(state);
 80149c4:	4608      	mov	r0, r1
}
 80149c6:	b002      	add	sp, #8
 80149c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    RBI_ConfigRFSwitch(state);
 80149cc:	f7f5 bbce 	b.w	800a16c <RBI_ConfigRFSwitch>
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 80149d0:	4603      	mov	r3, r0
 80149d2:	f10d 0207 	add.w	r2, sp, #7
 80149d6:	f640 1123 	movw	r1, #2339	@ 0x923
 80149da:	480a      	ldr	r0, [pc, #40]	@ (8014a04 <SUBGRF_SetSwitch+0x6c>)
 80149dc:	f7f3 feb6 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 80149e0:	f89d c007 	ldrb.w	ip, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 80149e4:	4807      	ldr	r0, [pc, #28]	@ (8014a04 <SUBGRF_SetSwitch+0x6c>)
    modReg&= (~SMPS_DRV_MASK);
 80149e6:	f02c 0c06 	bic.w	ip, ip, #6
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 80149ea:	f04c 0c04 	orr.w	ip, ip, #4
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 80149ee:	4623      	mov	r3, r4
 80149f0:	f10d 0207 	add.w	r2, sp, #7
 80149f4:	f640 1123 	movw	r1, #2339	@ 0x923
 80149f8:	f88d c007 	strb.w	ip, [sp, #7]
 80149fc:	f7f3 fe3e 	bl	800867c <HAL_SUBGHZ_WriteRegisters>
        if (paSelect == RFO_HP)
 8014a00:	e7df      	b.n	80149c2 <SUBGRF_SetSwitch+0x2a>
 8014a02:	bf00      	nop
 8014a04:	20000318 	.word	0x20000318

08014a08 <SUBGRF_SetRfTxPower>:
{
 8014a08:	b538      	push	{r3, r4, r5, lr}
 8014a0a:	4604      	mov	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 8014a0c:	f7f5 fbc6 	bl	800a19c <RBI_GetTxConfig>
    switch (TxConfig)
 8014a10:	b150      	cbz	r0, 8014a28 <SUBGRF_SetRfTxPower+0x20>
 8014a12:	2802      	cmp	r0, #2
 8014a14:	bf0c      	ite	eq
 8014a16:	2502      	moveq	r5, #2
 8014a18:	2501      	movne	r5, #1
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 8014a1a:	4628      	mov	r0, r5
 8014a1c:	2202      	movs	r2, #2
 8014a1e:	4621      	mov	r1, r4
 8014a20:	f7ff fca2 	bl	8014368 <SUBGRF_SetTxParams>
}
 8014a24:	4628      	mov	r0, r5
 8014a26:	bd38      	pop	{r3, r4, r5, pc}
                paSelect = RFO_HP;
 8014a28:	2c10      	cmp	r4, #16
 8014a2a:	bfb4      	ite	lt
 8014a2c:	2501      	movlt	r5, #1
 8014a2e:	2502      	movge	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 8014a30:	4628      	mov	r0, r5
 8014a32:	2202      	movs	r2, #2
 8014a34:	4621      	mov	r1, r4
 8014a36:	f7ff fc97 	bl	8014368 <SUBGRF_SetTxParams>
}
 8014a3a:	4628      	mov	r0, r5
 8014a3c:	bd38      	pop	{r3, r4, r5, pc}
 8014a3e:	bf00      	nop

08014a40 <SUBGRF_GetRadioWakeUpTime>:
}
 8014a40:	2001      	movs	r0, #1
 8014a42:	4770      	bx	lr

08014a44 <HAL_SUBGHZ_TxCpltCallback>:
    RadioOnDioIrqCb( IRQ_TX_DONE );
 8014a44:	4b01      	ldr	r3, [pc, #4]	@ (8014a4c <HAL_SUBGHZ_TxCpltCallback+0x8>)
 8014a46:	2001      	movs	r0, #1
 8014a48:	681b      	ldr	r3, [r3, #0]
 8014a4a:	4718      	bx	r3
 8014a4c:	200015b4 	.word	0x200015b4

08014a50 <HAL_SUBGHZ_RxCpltCallback>:
    RadioOnDioIrqCb( IRQ_RX_DONE );
 8014a50:	4b01      	ldr	r3, [pc, #4]	@ (8014a58 <HAL_SUBGHZ_RxCpltCallback+0x8>)
 8014a52:	2002      	movs	r0, #2
 8014a54:	681b      	ldr	r3, [r3, #0]
 8014a56:	4718      	bx	r3
 8014a58:	200015b4 	.word	0x200015b4

08014a5c <HAL_SUBGHZ_CRCErrorCallback>:
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 8014a5c:	4b01      	ldr	r3, [pc, #4]	@ (8014a64 <HAL_SUBGHZ_CRCErrorCallback+0x8>)
 8014a5e:	2040      	movs	r0, #64	@ 0x40
 8014a60:	681b      	ldr	r3, [r3, #0]
 8014a62:	4718      	bx	r3
 8014a64:	200015b4 	.word	0x200015b4

08014a68 <HAL_SUBGHZ_CADStatusCallback>:
    switch (cadstatus)
 8014a68:	b139      	cbz	r1, 8014a7a <HAL_SUBGHZ_CADStatusCallback+0x12>
 8014a6a:	2901      	cmp	r1, #1
 8014a6c:	d104      	bne.n	8014a78 <HAL_SUBGHZ_CADStatusCallback+0x10>
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 8014a6e:	4b05      	ldr	r3, [pc, #20]	@ (8014a84 <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 8014a70:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8014a74:	681b      	ldr	r3, [r3, #0]
 8014a76:	4718      	bx	r3
 8014a78:	4770      	bx	lr
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 8014a7a:	4b02      	ldr	r3, [pc, #8]	@ (8014a84 <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 8014a7c:	2080      	movs	r0, #128	@ 0x80
 8014a7e:	681b      	ldr	r3, [r3, #0]
 8014a80:	4718      	bx	r3
 8014a82:	bf00      	nop
 8014a84:	200015b4 	.word	0x200015b4

08014a88 <HAL_SUBGHZ_RxTxTimeoutCallback>:
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 8014a88:	4b02      	ldr	r3, [pc, #8]	@ (8014a94 <HAL_SUBGHZ_RxTxTimeoutCallback+0xc>)
 8014a8a:	f44f 7000 	mov.w	r0, #512	@ 0x200
 8014a8e:	681b      	ldr	r3, [r3, #0]
 8014a90:	4718      	bx	r3
 8014a92:	bf00      	nop
 8014a94:	200015b4 	.word	0x200015b4

08014a98 <HAL_SUBGHZ_HeaderErrorCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 8014a98:	4b01      	ldr	r3, [pc, #4]	@ (8014aa0 <HAL_SUBGHZ_HeaderErrorCallback+0x8>)
 8014a9a:	2020      	movs	r0, #32
 8014a9c:	681b      	ldr	r3, [r3, #0]
 8014a9e:	4718      	bx	r3
 8014aa0:	200015b4 	.word	0x200015b4

08014aa4 <HAL_SUBGHZ_PreambleDetectedCallback>:
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 8014aa4:	4b01      	ldr	r3, [pc, #4]	@ (8014aac <HAL_SUBGHZ_PreambleDetectedCallback+0x8>)
 8014aa6:	2004      	movs	r0, #4
 8014aa8:	681b      	ldr	r3, [r3, #0]
 8014aaa:	4718      	bx	r3
 8014aac:	200015b4 	.word	0x200015b4

08014ab0 <HAL_SUBGHZ_SyncWordValidCallback>:
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 8014ab0:	4b01      	ldr	r3, [pc, #4]	@ (8014ab8 <HAL_SUBGHZ_SyncWordValidCallback+0x8>)
 8014ab2:	2008      	movs	r0, #8
 8014ab4:	681b      	ldr	r3, [r3, #0]
 8014ab6:	4718      	bx	r3
 8014ab8:	200015b4 	.word	0x200015b4

08014abc <HAL_SUBGHZ_HeaderValidCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 8014abc:	4b01      	ldr	r3, [pc, #4]	@ (8014ac4 <HAL_SUBGHZ_HeaderValidCallback+0x8>)
 8014abe:	2010      	movs	r0, #16
 8014ac0:	681b      	ldr	r3, [r3, #0]
 8014ac2:	4718      	bx	r3
 8014ac4:	200015b4 	.word	0x200015b4

08014ac8 <HAL_SUBGHZ_LrFhssHopCallback>:
    RadioOnDioIrqCb( IRQ_LR_FHSS_HOP );
 8014ac8:	4b02      	ldr	r3, [pc, #8]	@ (8014ad4 <HAL_SUBGHZ_LrFhssHopCallback+0xc>)
 8014aca:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 8014ace:	681b      	ldr	r3, [r3, #0]
 8014ad0:	4718      	bx	r3
 8014ad2:	bf00      	nop
 8014ad4:	200015b4 	.word	0x200015b4

08014ad8 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
    uint8_t i;

    if( bandwidth == 0 )
 8014ad8:	b180      	cbz	r0, 8014afc <SUBGRF_GetFskBandwidthRegValue+0x24>
 8014ada:	4909      	ldr	r1, [pc, #36]	@ (8014b00 <SUBGRF_GetFskBandwidthRegValue+0x28>)
 8014adc:	2300      	movs	r3, #0
 8014ade:	e001      	b.n	8014ae4 <SUBGRF_GetFskBandwidthRegValue+0xc>
    {
        return( 0x1F );
    }

    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 8014ae0:	2b16      	cmp	r3, #22
 8014ae2:	d00a      	beq.n	8014afa <SUBGRF_GetFskBandwidthRegValue+0x22>
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 8014ae4:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
 8014ae8:	4282      	cmp	r2, r0
 8014aea:	eb01 0cc3 	add.w	ip, r1, r3, lsl #3
 8014aee:	f103 0301 	add.w	r3, r3, #1
 8014af2:	d9f5      	bls.n	8014ae0 <SUBGRF_GetFskBandwidthRegValue+0x8>
        {
            return FskBandwidths[i].RegValue;
 8014af4:	f89c 0004 	ldrb.w	r0, [ip, #4]
 8014af8:	4770      	bx	lr
        }
    }
    // ERROR: Value not found
    while( 1 );
 8014afa:	e7fe      	b.n	8014afa <SUBGRF_GetFskBandwidthRegValue+0x22>
        return( 0x1F );
 8014afc:	201f      	movs	r0, #31
}
 8014afe:	4770      	bx	lr
 8014b00:	080176e4 	.word	0x080176e4

08014b04 <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 8014b04:	b570      	push	{r4, r5, r6, lr}
 8014b06:	b082      	sub	sp, #8
  uint8_t BwMant[] = {4, 8, 10, 12};
 8014b08:	4a24      	ldr	r2, [pc, #144]	@ (8014b9c <SUBGRF_GetCFO+0x98>)
 8014b0a:	9201      	str	r2, [sp, #4]
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8014b0c:	2301      	movs	r3, #1
{
 8014b0e:	4605      	mov	r5, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8014b10:	f10d 0203 	add.w	r2, sp, #3
 8014b14:	4822      	ldr	r0, [pc, #136]	@ (8014ba0 <SUBGRF_GetCFO+0x9c>)
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSELR ));
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
  uint8_t bandwidth_exp = reg & 0x7;
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp + 1 )));
 8014b16:	4c23      	ldr	r4, [pc, #140]	@ (8014ba4 <SUBGRF_GetCFO+0xa0>)
{
 8014b18:	460e      	mov	r6, r1
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8014b1a:	f640 0107 	movw	r1, #2055	@ 0x807
 8014b1e:	f7f3 fe15 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8014b22:	f89d 3003 	ldrb.w	r3, [sp, #3]
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 8014b26:	f3c3 02c1 	ubfx	r2, r3, #3, #2
 8014b2a:	3208      	adds	r2, #8
 8014b2c:	446a      	add	r2, sp
  uint8_t bandwidth_exp = reg & 0x7;
 8014b2e:	f003 0307 	and.w	r3, r3, #7
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp + 1 )));
 8014b32:	f812 2c04 	ldrb.w	r2, [r2, #-4]
 8014b36:	3301      	adds	r3, #1
 8014b38:	fa02 f303 	lsl.w	r3, r2, r3
 8014b3c:	fbb4 f4f3 	udiv	r4, r4, r3
  uint32_t cf_osr = cf_fs / bitRate;
 8014b40:	fbb4 f0f5 	udiv	r0, r4, r5
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 8014b44:	2807      	cmp	r0, #7
 8014b46:	d804      	bhi.n	8014b52 <SUBGRF_GetCFO+0x4e>
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 8014b48:	0040      	lsls	r0, r0, #1
 8014b4a:	2803      	cmp	r0, #3
  {
    interp = 4;
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
 8014b4c:	bf8c      	ite	hi
 8014b4e:	0064      	lslhi	r4, r4, #1
 8014b50:	00a4      	lslls	r4, r4, #2
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8014b52:	f10d 0203 	add.w	r2, sp, #3
 8014b56:	2301      	movs	r3, #1
 8014b58:	f44f 61d6 	mov.w	r1, #1712	@ 0x6b0
 8014b5c:	4810      	ldr	r0, [pc, #64]	@ (8014ba0 <SUBGRF_GetCFO+0x9c>)
 8014b5e:	f7f3 fdf5 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
    return data;
 8014b62:	f89d 5003 	ldrb.w	r5, [sp, #3]
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8014b66:	480e      	ldr	r0, [pc, #56]	@ (8014ba0 <SUBGRF_GetCFO+0x9c>)
 8014b68:	f10d 0203 	add.w	r2, sp, #3
 8014b6c:	2301      	movs	r3, #1
 8014b6e:	f240 61b1 	movw	r1, #1713	@ 0x6b1
 8014b72:	f7f3 fdeb 	bl	800874c <HAL_SUBGHZ_ReadRegisters>
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_GCFORH ) & 0xF ) << 8;
 8014b76:	022d      	lsls	r5, r5, #8
    return data;
 8014b78:	f89d 3003 	ldrb.w	r3, [sp, #3]
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_GCFORH ) & 0xF ) << 8;
 8014b7c:	f405 6570 	and.w	r5, r5, #3840	@ 0xf00
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_GCFORL );
 8014b80:	432b      	orrs	r3, r5
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 8014b82:	052a      	lsls	r2, r5, #20
 8014b84:	bf44      	itt	mi
 8014b86:	ea6f 5303 	mvnmi.w	r3, r3, lsl #20
 8014b8a:	ea6f 5313 	mvnmi.w	r3, r3, lsr #20
  {
    cfo_bin |= 0xFFFFF000;
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 8014b8e:	0964      	lsrs	r4, r4, #5
 8014b90:	fb03 f404 	mul.w	r4, r3, r4
 8014b94:	11e4      	asrs	r4, r4, #7
 8014b96:	6034      	str	r4, [r6, #0]
}
 8014b98:	b002      	add	sp, #8
 8014b9a:	bd70      	pop	{r4, r5, r6, pc}
 8014b9c:	0c0a0804 	.word	0x0c0a0804
 8014ba0:	20000318 	.word	0x20000318
 8014ba4:	01e84800 	.word	0x01e84800

08014ba8 <RFW_TransmitLongPacket>:
    }
#else
    status = -1;
#endif /* RFW_LONGPACKET_ENABLE == 1 */
    return status;
}
 8014ba8:	f04f 30ff 	mov.w	r0, #4294967295
 8014bac:	4770      	bx	lr
 8014bae:	bf00      	nop

08014bb0 <RFW_ReceiveLongPacket>:
    }
#else
    status = -1;
#endif /* RFW_LONGPACKET_ENABLE == 1 */
    return status;
}
 8014bb0:	f04f 30ff 	mov.w	r0, #4294967295
 8014bb4:	4770      	bx	lr
 8014bb6:	bf00      	nop

08014bb8 <RFW_Init>:
    TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
    return 0;
#else
    return -1;
#endif /* RFW_ENABLE == 1 */
}
 8014bb8:	f04f 30ff 	mov.w	r0, #4294967295
 8014bbc:	4770      	bx	lr
 8014bbe:	bf00      	nop

08014bc0 <RFW_DeInit>:
void RFW_DeInit( void )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.Init.Enable = 0; /*Disable the RFWPacket decoding*/
#endif /* RFW_ENABLE == 1 */
}
 8014bc0:	4770      	bx	lr
 8014bc2:	bf00      	nop

08014bc4 <RFW_Is_Init>:
#if (RFW_ENABLE == 1 )
    return RFWPacket.Init.Enable;
#else
    return 0;
#endif /* RFW_ENABLE == 1 */
}
 8014bc4:	2000      	movs	r0, #0
 8014bc6:	4770      	bx	lr

08014bc8 <RFW_Is_LongPacketModeEnabled>:

uint8_t RFW_Is_LongPacketModeEnabled( void )
 8014bc8:	2000      	movs	r0, #0
 8014bca:	4770      	bx	lr

08014bcc <RFW_SetAntSwitch>:
#else
    return 0;
#endif /* RFW_ENABLE == 1 */
}

void RFW_SetAntSwitch( uint8_t AntSwitch )
 8014bcc:	4770      	bx	lr
 8014bce:	bf00      	nop

08014bd0 <RFW_TransmitInit>:

        status = 0;
    }
#endif /* RFW_ENABLE == 1 */
    return status;
}
 8014bd0:	f04f 30ff 	mov.w	r0, #4294967295
 8014bd4:	4770      	bx	lr
 8014bd6:	bf00      	nop

08014bd8 <RFW_ReceiveInit>:
    RFWPacket.LongPacketModeEnable = 0;
    return 0;
#else
    return -1;
#endif /* RFW_ENABLE == 1 */
}
 8014bd8:	f04f 30ff 	mov.w	r0, #4294967295
 8014bdc:	4770      	bx	lr
 8014bde:	bf00      	nop

08014be0 <RFW_DeInit_TxLongPacket>:

void RFW_DeInit_TxLongPacket( void )
 8014be0:	4770      	bx	lr
 8014be2:	bf00      	nop

08014be4 <RFW_ReceivePayload>:
    SUBGRF_WriteRegister( SUBGHZ_GPKTCTL1AR, reg & ~0x02 ); /* clear infinite_sequence bit */
    SUBGRF_WriteRegister( SUBGHZ_GRTXPLDLEN, 0xFF ); /* RxTxPldLen: reset to 0xFF */
#endif /* RFW_LONGPACKET_ENABLE == 1 */
}

void RFW_ReceivePayload( void )
 8014be4:	4770      	bx	lr
 8014be6:	bf00      	nop

08014be8 <RFW_SetRadioModem>:
void RFW_SetRadioModem( RadioModems_t Modem )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.Init.Modem = Modem;
#endif /* RFW_ENABLE == 1 */
}
 8014be8:	4770      	bx	lr
 8014bea:	bf00      	nop

08014bec <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 8014bec:	4902      	ldr	r1, [pc, #8]	@ (8014bf8 <UTIL_LPM_Init+0xc>)
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 8014bee:	4a03      	ldr	r2, [pc, #12]	@ (8014bfc <UTIL_LPM_Init+0x10>)
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 8014bf0:	2300      	movs	r3, #0
 8014bf2:	600b      	str	r3, [r1, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 8014bf4:	6013      	str	r3, [r2, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 8014bf6:	4770      	bx	lr
 8014bf8:	200015c8 	.word	0x200015c8
 8014bfc:	200015c4 	.word	0x200015c4

08014c00 <UTIL_LPM_SetStopMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014c00:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014c04:	b672      	cpsid	i

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 8014c06:	b141      	cbz	r1, 8014c1a <UTIL_LPM_SetStopMode+0x1a>
 8014c08:	2901      	cmp	r1, #1
 8014c0a:	d103      	bne.n	8014c14 <UTIL_LPM_SetStopMode+0x14>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 8014c0c:	4907      	ldr	r1, [pc, #28]	@ (8014c2c <UTIL_LPM_SetStopMode+0x2c>)
 8014c0e:	680a      	ldr	r2, [r1, #0]
 8014c10:	4302      	orrs	r2, r0
 8014c12:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014c14:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8014c18:	4770      	bx	lr
      StopModeDisable &= ( ~lpm_id_bm );
 8014c1a:	4904      	ldr	r1, [pc, #16]	@ (8014c2c <UTIL_LPM_SetStopMode+0x2c>)
 8014c1c:	680a      	ldr	r2, [r1, #0]
 8014c1e:	ea22 0200 	bic.w	r2, r2, r0
 8014c22:	600a      	str	r2, [r1, #0]
 8014c24:	f383 8810 	msr	PRIMASK, r3
}
 8014c28:	4770      	bx	lr
 8014c2a:	bf00      	nop
 8014c2c:	200015c8 	.word	0x200015c8

08014c30 <UTIL_LPM_SetOffMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014c30:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014c34:	b672      	cpsid	i

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 8014c36:	b141      	cbz	r1, 8014c4a <UTIL_LPM_SetOffMode+0x1a>
 8014c38:	2901      	cmp	r1, #1
 8014c3a:	d103      	bne.n	8014c44 <UTIL_LPM_SetOffMode+0x14>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 8014c3c:	4907      	ldr	r1, [pc, #28]	@ (8014c5c <UTIL_LPM_SetOffMode+0x2c>)
 8014c3e:	680a      	ldr	r2, [r1, #0]
 8014c40:	4302      	orrs	r2, r0
 8014c42:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014c44:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8014c48:	4770      	bx	lr
      OffModeDisable &= ( ~lpm_id_bm );
 8014c4a:	4904      	ldr	r1, [pc, #16]	@ (8014c5c <UTIL_LPM_SetOffMode+0x2c>)
 8014c4c:	680a      	ldr	r2, [r1, #0]
 8014c4e:	ea22 0200 	bic.w	r2, r2, r0
 8014c52:	600a      	str	r2, [r1, #0]
 8014c54:	f383 8810 	msr	PRIMASK, r3
}
 8014c58:	4770      	bx	lr
 8014c5a:	bf00      	nop
 8014c5c:	200015c4 	.word	0x200015c4

08014c60 <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 8014c60:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014c62:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8014c66:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 8014c68:	4b0e      	ldr	r3, [pc, #56]	@ (8014ca4 <UTIL_LPM_EnterLowPower+0x44>)
 8014c6a:	681b      	ldr	r3, [r3, #0]
 8014c6c:	b13b      	cbz	r3, 8014c7e <UTIL_LPM_EnterLowPower+0x1e>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 8014c6e:	4d0e      	ldr	r5, [pc, #56]	@ (8014ca8 <UTIL_LPM_EnterLowPower+0x48>)
 8014c70:	682b      	ldr	r3, [r5, #0]
 8014c72:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 8014c74:	686b      	ldr	r3, [r5, #4]
 8014c76:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014c78:	f384 8810 	msr	PRIMASK, r4
      UTIL_PowerDriver.ExitOffMode( );
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 8014c7c:	bd38      	pop	{r3, r4, r5, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 8014c7e:	4b0b      	ldr	r3, [pc, #44]	@ (8014cac <UTIL_LPM_EnterLowPower+0x4c>)
        UTIL_PowerDriver.EnterStopMode( );
 8014c80:	4d09      	ldr	r5, [pc, #36]	@ (8014ca8 <UTIL_LPM_EnterLowPower+0x48>)
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 8014c82:	681b      	ldr	r3, [r3, #0]
 8014c84:	b133      	cbz	r3, 8014c94 <UTIL_LPM_EnterLowPower+0x34>
        UTIL_PowerDriver.EnterStopMode( );
 8014c86:	68ab      	ldr	r3, [r5, #8]
 8014c88:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 8014c8a:	68eb      	ldr	r3, [r5, #12]
 8014c8c:	4798      	blx	r3
 8014c8e:	f384 8810 	msr	PRIMASK, r4
}
 8014c92:	bd38      	pop	{r3, r4, r5, pc}
      UTIL_PowerDriver.EnterOffMode( );
 8014c94:	692b      	ldr	r3, [r5, #16]
 8014c96:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 8014c98:	696b      	ldr	r3, [r5, #20]
 8014c9a:	4798      	blx	r3
 8014c9c:	f384 8810 	msr	PRIMASK, r4
}
 8014ca0:	bd38      	pop	{r3, r4, r5, pc}
 8014ca2:	bf00      	nop
 8014ca4:	200015c8 	.word	0x200015c8
 8014ca8:	080169e8 	.word	0x080169e8
 8014cac:	200015c4 	.word	0x200015c4

08014cb0 <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 8014cb0:	2a00      	cmp	r2, #0
 8014cb2:	d049      	beq.n	8014d48 <UTIL_MEM_cpy_8+0x98>
 8014cb4:	f102 3cff 	add.w	ip, r2, #4294967295
 8014cb8:	fa1f fc8c 	uxth.w	ip, ip
 8014cbc:	f1bc 0f05 	cmp.w	ip, #5
 8014cc0:	d935      	bls.n	8014d2e <UTIL_MEM_cpy_8+0x7e>
 8014cc2:	1c4b      	adds	r3, r1, #1
{
 8014cc4:	b530      	push	{r4, r5, lr}
 8014cc6:	1ac4      	subs	r4, r0, r3
 8014cc8:	2c02      	cmp	r4, #2
 8014cca:	d80c      	bhi.n	8014ce6 <UTIL_MEM_cpy_8+0x36>
 8014ccc:	f10c 0c01 	add.w	ip, ip, #1
 8014cd0:	3801      	subs	r0, #1
 8014cd2:	4461      	add	r1, ip
 8014cd4:	e000      	b.n	8014cd8 <UTIL_MEM_cpy_8+0x28>
 8014cd6:	3301      	adds	r3, #1
    {
        *dst8++ = *src8++;
 8014cd8:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 8014cdc:	f800 2f01 	strb.w	r2, [r0, #1]!
  while( size-- )
 8014ce0:	4299      	cmp	r1, r3
 8014ce2:	d1f8      	bne.n	8014cd6 <UTIL_MEM_cpy_8+0x26>
    }
}
 8014ce4:	bd30      	pop	{r4, r5, pc}
 8014ce6:	0895      	lsrs	r5, r2, #2
 8014ce8:	460b      	mov	r3, r1
 8014cea:	eb01 0585 	add.w	r5, r1, r5, lsl #2
 8014cee:	4686      	mov	lr, r0
        *dst8++ = *src8++;
 8014cf0:	f853 4b04 	ldr.w	r4, [r3], #4
 8014cf4:	f84e 4b04 	str.w	r4, [lr], #4
  while( size-- )
 8014cf8:	42ab      	cmp	r3, r5
 8014cfa:	d1f9      	bne.n	8014cf0 <UTIL_MEM_cpy_8+0x40>
 8014cfc:	f022 0403 	bic.w	r4, r2, #3
 8014d00:	ebac 0c04 	sub.w	ip, ip, r4
 8014d04:	0792      	lsls	r2, r2, #30
 8014d06:	fa1f f38c 	uxth.w	r3, ip
 8014d0a:	b2a5      	uxth	r5, r4
 8014d0c:	eb00 0c04 	add.w	ip, r0, r4
 8014d10:	440c      	add	r4, r1
 8014d12:	d0e7      	beq.n	8014ce4 <UTIL_MEM_cpy_8+0x34>
        *dst8++ = *src8++;
 8014d14:	5d4a      	ldrb	r2, [r1, r5]
 8014d16:	5542      	strb	r2, [r0, r5]
  while( size-- )
 8014d18:	2b00      	cmp	r3, #0
 8014d1a:	d0e3      	beq.n	8014ce4 <UTIL_MEM_cpy_8+0x34>
        *dst8++ = *src8++;
 8014d1c:	7862      	ldrb	r2, [r4, #1]
 8014d1e:	f88c 2001 	strb.w	r2, [ip, #1]
  while( size-- )
 8014d22:	2b01      	cmp	r3, #1
 8014d24:	d0de      	beq.n	8014ce4 <UTIL_MEM_cpy_8+0x34>
        *dst8++ = *src8++;
 8014d26:	78a3      	ldrb	r3, [r4, #2]
 8014d28:	f88c 3002 	strb.w	r3, [ip, #2]
}
 8014d2c:	bd30      	pop	{r4, r5, pc}
 8014d2e:	f10c 0c01 	add.w	ip, ip, #1
 8014d32:	1c4b      	adds	r3, r1, #1
 8014d34:	3801      	subs	r0, #1
 8014d36:	4461      	add	r1, ip
 8014d38:	e000      	b.n	8014d3c <UTIL_MEM_cpy_8+0x8c>
 8014d3a:	3301      	adds	r3, #1
        *dst8++ = *src8++;
 8014d3c:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 8014d40:	f800 2f01 	strb.w	r2, [r0, #1]!
  while( size-- )
 8014d44:	4299      	cmp	r1, r3
 8014d46:	d1f8      	bne.n	8014d3a <UTIL_MEM_cpy_8+0x8a>
 8014d48:	4770      	bx	lr
 8014d4a:	bf00      	nop

08014d4c <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 8014d4c:	b10a      	cbz	r2, 8014d52 <UTIL_MEM_set_8+0x6>
  {
    *dst8++ = value;
 8014d4e:	f001 b9bb 	b.w	80160c8 <memset>
  }
}
 8014d52:	4770      	bx	lr

08014d54 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 8014d54:	b082      	sub	sp, #8
 8014d56:	b082      	sub	sp, #8
 8014d58:	f10d 0c08 	add.w	ip, sp, #8
 8014d5c:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds + b.Seconds;
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8014d60:	f8bd c010 	ldrh.w	ip, [sp, #16]
 8014d64:	f8bd 2004 	ldrh.w	r2, [sp, #4]
{
 8014d68:	9303      	str	r3, [sp, #12]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8014d6a:	4462      	add	r2, ip
  c.Seconds = a.Seconds + b.Seconds;
 8014d6c:	440b      	add	r3, r1
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8014d6e:	b211      	sxth	r1, r2
  if( c.SubSeconds >= 1000 )
 8014d70:	f5b1 7f7a 	cmp.w	r1, #1000	@ 0x3e8
 8014d74:	db04      	blt.n	8014d80 <SysTimeAdd+0x2c>
 8014d76:	b292      	uxth	r2, r2
  {
    c.Seconds++;
    c.SubSeconds -= 1000;
 8014d78:	f5a2 727a 	sub.w	r2, r2, #1000	@ 0x3e8
    c.Seconds++;
 8014d7c:	3301      	adds	r3, #1
    c.SubSeconds -= 1000;
 8014d7e:	b211      	sxth	r1, r2
  }
  return c;
 8014d80:	6003      	str	r3, [r0, #0]
 8014d82:	8081      	strh	r1, [r0, #4]
}
 8014d84:	b002      	add	sp, #8
 8014d86:	b002      	add	sp, #8
 8014d88:	4770      	bx	lr
 8014d8a:	bf00      	nop

08014d8c <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 8014d8c:	b082      	sub	sp, #8
 8014d8e:	b082      	sub	sp, #8
 8014d90:	f10d 0c08 	add.w	ip, sp, #8
 8014d94:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds - b.Seconds;
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014d98:	f8bd c010 	ldrh.w	ip, [sp, #16]
 8014d9c:	f8bd 2004 	ldrh.w	r2, [sp, #4]
{
 8014da0:	9303      	str	r3, [sp, #12]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014da2:	eba2 020c 	sub.w	r2, r2, ip
  c.Seconds = a.Seconds - b.Seconds;
 8014da6:	1acb      	subs	r3, r1, r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014da8:	b211      	sxth	r1, r2
  if( c.SubSeconds < 0 )
 8014daa:	2900      	cmp	r1, #0
 8014dac:	da04      	bge.n	8014db8 <SysTimeSub+0x2c>
 8014dae:	b292      	uxth	r2, r2
  {
    c.Seconds--;
    c.SubSeconds += 1000;
 8014db0:	f502 727a 	add.w	r2, r2, #1000	@ 0x3e8
    c.Seconds--;
 8014db4:	3b01      	subs	r3, #1
    c.SubSeconds += 1000;
 8014db6:	b211      	sxth	r1, r2
  }
  return c;
 8014db8:	6003      	str	r3, [r0, #0]
 8014dba:	8081      	strh	r1, [r0, #4]
}
 8014dbc:	b002      	add	sp, #8
 8014dbe:	b002      	add	sp, #8
 8014dc0:	4770      	bx	lr
 8014dc2:	bf00      	nop

08014dc4 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 8014dc4:	b530      	push	{r4, r5, lr}
  SysTime_t DeltaTime;

  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014dc6:	4d11      	ldr	r5, [pc, #68]	@ (8014e0c <SysTimeSet+0x48>)
{
 8014dc8:	b085      	sub	sp, #20
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8014dca:	2300      	movs	r3, #0
{
 8014dcc:	466a      	mov	r2, sp
 8014dce:	e882 0003 	stmia.w	r2, {r0, r1}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8014dd2:	9302      	str	r3, [sp, #8]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014dd4:	692a      	ldr	r2, [r5, #16]
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8014dd6:	f8ad 300c 	strh.w	r3, [sp, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014dda:	a803      	add	r0, sp, #12
 8014ddc:	4790      	blx	r2
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014dde:	f8bd 4004 	ldrh.w	r4, [sp, #4]
 8014de2:	f8bd 200c 	ldrh.w	r2, [sp, #12]
  c.Seconds = a.Seconds - b.Seconds;
 8014de6:	9b00      	ldr	r3, [sp, #0]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014de8:	9002      	str	r0, [sp, #8]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014dea:	1aa4      	subs	r4, r4, r2
  c.Seconds = a.Seconds - b.Seconds;
 8014dec:	1a18      	subs	r0, r3, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014dee:	b2a3      	uxth	r3, r4
 8014df0:	b224      	sxth	r4, r4
  if( c.SubSeconds < 0 )
 8014df2:	2c00      	cmp	r4, #0
 8014df4:	da03      	bge.n	8014dfe <SysTimeSet+0x3a>
    c.SubSeconds += 1000;
 8014df6:	f503 737a 	add.w	r3, r3, #1000	@ 0x3e8
    c.Seconds--;
 8014dfa:	3801      	subs	r0, #1
    c.SubSeconds += 1000;
 8014dfc:	b21c      	sxth	r4, r3

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 8014dfe:	682b      	ldr	r3, [r5, #0]
 8014e00:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 8014e02:	68ab      	ldr	r3, [r5, #8]
 8014e04:	4620      	mov	r0, r4
 8014e06:	4798      	blx	r3
}
 8014e08:	b005      	add	sp, #20
 8014e0a:	bd30      	pop	{r4, r5, pc}
 8014e0c:	08016aac 	.word	0x08016aac

08014e10 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 8014e10:	b530      	push	{r4, r5, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014e12:	4c11      	ldr	r4, [pc, #68]	@ (8014e58 <SysTimeGet+0x48>)
{
 8014e14:	b083      	sub	sp, #12
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8014e16:	2300      	movs	r3, #0
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014e18:	6922      	ldr	r2, [r4, #16]
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8014e1a:	9300      	str	r3, [sp, #0]
 8014e1c:	f8ad 3004 	strh.w	r3, [sp, #4]
{
 8014e20:	4605      	mov	r5, r0
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014e22:	a801      	add	r0, sp, #4
 8014e24:	4790      	blx	r2

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014e26:	68e3      	ldr	r3, [r4, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014e28:	9000      	str	r0, [sp, #0]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014e2a:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8014e2c:	6863      	ldr	r3, [r4, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014e2e:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8014e30:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8014e32:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  c.Seconds = a.Seconds + b.Seconds;
 8014e36:	9900      	ldr	r1, [sp, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8014e38:	4423      	add	r3, r4
 8014e3a:	b21a      	sxth	r2, r3
  if( c.SubSeconds >= 1000 )
 8014e3c:	f5b2 7f7a 	cmp.w	r2, #1000	@ 0x3e8
  c.Seconds = a.Seconds + b.Seconds;
 8014e40:	4408      	add	r0, r1
  if( c.SubSeconds >= 1000 )
 8014e42:	db04      	blt.n	8014e4e <SysTimeGet+0x3e>
 8014e44:	b29b      	uxth	r3, r3
    c.SubSeconds -= 1000;
 8014e46:	f5a3 737a 	sub.w	r3, r3, #1000	@ 0x3e8
    c.Seconds++;
 8014e4a:	3001      	adds	r0, #1
    c.SubSeconds -= 1000;
 8014e4c:	b21a      	sxth	r2, r3

  sysTime = SysTimeAdd( DeltaTime, calendarTime );

  return sysTime;
 8014e4e:	6028      	str	r0, [r5, #0]
}
 8014e50:	4628      	mov	r0, r5
  return sysTime;
 8014e52:	80aa      	strh	r2, [r5, #4]
}
 8014e54:	b003      	add	sp, #12
 8014e56:	bd30      	pop	{r4, r5, pc}
 8014e58:	08016aac 	.word	0x08016aac

08014e5c <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 8014e5c:	b510      	push	{r4, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014e5e:	4a09      	ldr	r2, [pc, #36]	@ (8014e84 <SysTimeGetMcuTime+0x28>)
{
 8014e60:	b082      	sub	sp, #8
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8014e62:	2300      	movs	r3, #0
{
 8014e64:	4604      	mov	r4, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8014e66:	9300      	str	r3, [sp, #0]
 8014e68:	f8ad 3004 	strh.w	r3, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8014e6c:	6912      	ldr	r2, [r2, #16]
 8014e6e:	a801      	add	r0, sp, #4
 8014e70:	4790      	blx	r2
 8014e72:	466b      	mov	r3, sp
 8014e74:	9000      	str	r0, [sp, #0]

  return calendarTime;
 8014e76:	e893 0003 	ldmia.w	r3, {r0, r1}
 8014e7a:	e884 0003 	stmia.w	r4, {r0, r1}
}
 8014e7e:	4620      	mov	r0, r4
 8014e80:	b002      	add	sp, #8
 8014e82:	bd10      	pop	{r4, pc}
 8014e84:	08016aac 	.word	0x08016aac

08014e88 <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 8014e88:	b510      	push	{r4, lr}
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014e8a:	4c0f      	ldr	r4, [pc, #60]	@ (8014ec8 <SysTimeToMs+0x40>)
{
 8014e8c:	b082      	sub	sp, #8
 8014e8e:	ab02      	add	r3, sp, #8
 8014e90:	e903 0003 	stmdb	r3, {r0, r1}
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014e94:	68e3      	ldr	r3, [r4, #12]
 8014e96:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8014e98:	6863      	ldr	r3, [r4, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014e9a:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8014e9c:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014e9e:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  c.Seconds = a.Seconds - b.Seconds;
 8014ea2:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8014ea4:	1b1b      	subs	r3, r3, r4
 8014ea6:	b219      	sxth	r1, r3
  if( c.SubSeconds < 0 )
 8014ea8:	2900      	cmp	r1, #0
  c.Seconds = a.Seconds - b.Seconds;
 8014eaa:	eba2 0200 	sub.w	r2, r2, r0
  if( c.SubSeconds < 0 )
 8014eae:	da04      	bge.n	8014eba <SysTimeToMs+0x32>
 8014eb0:	b29b      	uxth	r3, r3
    c.SubSeconds += 1000;
 8014eb2:	f503 737a 	add.w	r3, r3, #1000	@ 0x3e8
    c.Seconds--;
 8014eb6:	3a01      	subs	r2, #1
    c.SubSeconds += 1000;
 8014eb8:	b219      	sxth	r1, r3

  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
 8014eba:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
}
 8014ebe:	fb00 1002 	mla	r0, r0, r2, r1
 8014ec2:	b002      	add	sp, #8
 8014ec4:	bd10      	pop	{r4, pc}
 8014ec6:	bf00      	nop
 8014ec8:	08016aac 	.word	0x08016aac

08014ecc <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 8014ecc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t seconds = timeMs / 1000;
 8014ed0:	4d12      	ldr	r5, [pc, #72]	@ (8014f1c <SysTimeFromMs+0x50>)
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
  SysTime_t DeltaTime = { 0 };

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014ed2:	f8df 804c 	ldr.w	r8, [pc, #76]	@ 8014f20 <SysTimeFromMs+0x54>
  uint32_t seconds = timeMs / 1000;
 8014ed6:	fba5 3501 	umull	r3, r5, r5, r1
 8014eda:	09ad      	lsrs	r5, r5, #6
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 8014edc:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
 8014ee0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8014ee4:	eba1 01c3 	sub.w	r1, r1, r3, lsl #3
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014ee8:	f8d8 300c 	ldr.w	r3, [r8, #12]
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 8014eec:	b28c      	uxth	r4, r1
{
 8014eee:	4606      	mov	r6, r0
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014ef0:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8014ef2:	f8d8 3004 	ldr.w	r3, [r8, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8014ef6:	4607      	mov	r7, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8014ef8:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8014efa:	19e1      	adds	r1, r4, r7
 8014efc:	b20b      	sxth	r3, r1
  if( c.SubSeconds >= 1000 )
 8014efe:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
  c.Seconds = a.Seconds + b.Seconds;
 8014f02:	4428      	add	r0, r5
  if( c.SubSeconds >= 1000 )
 8014f04:	db04      	blt.n	8014f10 <SysTimeFromMs+0x44>
 8014f06:	b289      	uxth	r1, r1
    c.SubSeconds -= 1000;
 8014f08:	f5a1 717a 	sub.w	r1, r1, #1000	@ 0x3e8
    c.Seconds++;
 8014f0c:	3001      	adds	r0, #1
    c.SubSeconds -= 1000;
 8014f0e:	b20b      	sxth	r3, r1
  return c;
 8014f10:	6030      	str	r0, [r6, #0]
 8014f12:	80b3      	strh	r3, [r6, #4]
  return SysTimeAdd( sysTime, DeltaTime );
}
 8014f14:	4630      	mov	r0, r6
 8014f16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014f1a:	bf00      	nop
 8014f1c:	10624dd3 	.word	0x10624dd3
 8014f20:	08016aac 	.word	0x08016aac

08014f24 <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 8014f24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014f28:	b099      	sub	sp, #100	@ 0x64
 8014f2a:	4693      	mov	fp, r2

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 8014f2c:	1e0a      	subs	r2, r1, #0
 8014f2e:	9201      	str	r2, [sp, #4]
 8014f30:	f340 81d3 	ble.w	80152da <tiny_vsnprintf_like+0x3b6>
 8014f34:	4681      	mov	r9, r0
 8014f36:	9300      	str	r3, [sp, #0]
  {
    return 0;
  }

  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8014f38:	4604      	mov	r4, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 8014f3a:	f04f 0a20 	mov.w	sl, #32
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8014f3e:	f89b 3000 	ldrb.w	r3, [fp]
  {
    CHECK_STR_SIZE(buf, str, size);
 8014f42:	eba4 0009 	sub.w	r0, r4, r9
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8014f46:	b923      	cbnz	r3, 8014f52 <tiny_vsnprintf_like+0x2e>
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
  }

  *str = '\0';
 8014f48:	2300      	movs	r3, #0
 8014f4a:	7023      	strb	r3, [r4, #0]
  return str - buf;
}
 8014f4c:	b019      	add	sp, #100	@ 0x64
 8014f4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CHECK_STR_SIZE(buf, str, size);
 8014f52:	9a01      	ldr	r2, [sp, #4]
 8014f54:	1e57      	subs	r7, r2, #1
 8014f56:	4287      	cmp	r7, r0
 8014f58:	ddf6      	ble.n	8014f48 <tiny_vsnprintf_like+0x24>
    if (*fmt != '%')
 8014f5a:	2b25      	cmp	r3, #37	@ 0x25
    fmt++;
 8014f5c:	f10b 0601 	add.w	r6, fp, #1
    if (*fmt != '%')
 8014f60:	d142      	bne.n	8014fe8 <tiny_vsnprintf_like+0xc4>
    if (*fmt == '0')
 8014f62:	f89b 3001 	ldrb.w	r3, [fp, #1]
 8014f66:	2b30      	cmp	r3, #48	@ 0x30
 8014f68:	d042      	beq.n	8014ff0 <tiny_vsnprintf_like+0xcc>
    if (is_digit(*fmt))
 8014f6a:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 8014f6e:	2a09      	cmp	r2, #9
    flags = 0;
 8014f70:	bf98      	it	ls
 8014f72:	f04f 0e00 	movls.w	lr, #0
    if (is_digit(*fmt))
 8014f76:	d93d      	bls.n	8014ff4 <tiny_vsnprintf_like+0xd0>
    switch (*fmt)
 8014f78:	f1a3 0258 	sub.w	r2, r3, #88	@ 0x58
 8014f7c:	2a20      	cmp	r2, #32
 8014f7e:	d822      	bhi.n	8014fc6 <tiny_vsnprintf_like+0xa2>
 8014f80:	e8df f012 	tbh	[pc, r2, lsl #1]
 8014f84:	0021013d 	.word	0x0021013d
 8014f88:	00210021 	.word	0x00210021
 8014f8c:	00210021 	.word	0x00210021
 8014f90:	00210021 	.word	0x00210021
 8014f94:	00210021 	.word	0x00210021
 8014f98:	01ed0021 	.word	0x01ed0021
 8014f9c:	00210090 	.word	0x00210090
 8014fa0:	00210021 	.word	0x00210021
 8014fa4:	00900021 	.word	0x00900021
 8014fa8:	00210021 	.word	0x00210021
 8014fac:	00210021 	.word	0x00210021
 8014fb0:	00210021 	.word	0x00210021
 8014fb4:	00210021 	.word	0x00210021
 8014fb8:	01f50021 	.word	0x01f50021
 8014fbc:	01ef0021 	.word	0x01ef0021
 8014fc0:	00210021 	.word	0x00210021
 8014fc4:	00e6      	.short	0x00e6
 8014fc6:	f04f 0e00 	mov.w	lr, #0
 8014fca:	f04f 35ff 	mov.w	r5, #4294967295
        if (*fmt != '%') *str++ = '%';
 8014fce:	2b25      	cmp	r3, #37	@ 0x25
 8014fd0:	f000 8177 	beq.w	80152c2 <tiny_vsnprintf_like+0x39e>
 8014fd4:	2325      	movs	r3, #37	@ 0x25
 8014fd6:	f804 3b01 	strb.w	r3, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 8014fda:	eba4 0009 	sub.w	r0, r4, r9
 8014fde:	4287      	cmp	r7, r0
 8014fe0:	f300 81d0 	bgt.w	8015384 <tiny_vsnprintf_like+0x460>
 8014fe4:	210a      	movs	r1, #10
 8014fe6:	e0b8      	b.n	801515a <tiny_vsnprintf_like+0x236>
      *str++ = *fmt;
 8014fe8:	f804 3b01 	strb.w	r3, [r4], #1
      continue;
 8014fec:	46b3      	mov	fp, r6
 8014fee:	e7a6      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
      flags |= ZEROPAD;
 8014ff0:	f04f 0e01 	mov.w	lr, #1
  int i = 0;
 8014ff4:	2500      	movs	r5, #0
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 8014ff6:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8014ffa:	eb03 0245 	add.w	r2, r3, r5, lsl #1
 8014ffe:	46b3      	mov	fp, r6
 8015000:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 8015004:	f1a3 0130 	sub.w	r1, r3, #48	@ 0x30
 8015008:	2909      	cmp	r1, #9
 801500a:	f1a2 0530 	sub.w	r5, r2, #48	@ 0x30
 801500e:	d9f2      	bls.n	8014ff6 <tiny_vsnprintf_like+0xd2>
    switch (*fmt)
 8015010:	f1a3 0158 	sub.w	r1, r3, #88	@ 0x58
 8015014:	2920      	cmp	r1, #32
 8015016:	d8da      	bhi.n	8014fce <tiny_vsnprintf_like+0xaa>
 8015018:	f20f 0c04 	addw	ip, pc, #4
 801501c:	f85c f021 	ldr.w	pc, [ip, r1, lsl #2]
 8015020:	080150f5 	.word	0x080150f5
 8015024:	08014fcf 	.word	0x08014fcf
 8015028:	08014fcf 	.word	0x08014fcf
 801502c:	08014fcf 	.word	0x08014fcf
 8015030:	08014fcf 	.word	0x08014fcf
 8015034:	08014fcf 	.word	0x08014fcf
 8015038:	08014fcf 	.word	0x08014fcf
 801503c:	08014fcf 	.word	0x08014fcf
 8015040:	08014fcf 	.word	0x08014fcf
 8015044:	08014fcf 	.word	0x08014fcf
 8015048:	08014fcf 	.word	0x08014fcf
 801504c:	08015167 	.word	0x08015167
 8015050:	080150ad 	.word	0x080150ad
 8015054:	08014fcf 	.word	0x08014fcf
 8015058:	08014fcf 	.word	0x08014fcf
 801505c:	08014fcf 	.word	0x08014fcf
 8015060:	08014fcf 	.word	0x08014fcf
 8015064:	080150ad 	.word	0x080150ad
 8015068:	08014fcf 	.word	0x08014fcf
 801506c:	08014fcf 	.word	0x08014fcf
 8015070:	08014fcf 	.word	0x08014fcf
 8015074:	08014fcf 	.word	0x08014fcf
 8015078:	08014fcf 	.word	0x08014fcf
 801507c:	08014fcf 	.word	0x08014fcf
 8015080:	08014fcf 	.word	0x08014fcf
 8015084:	08014fcf 	.word	0x08014fcf
 8015088:	08014fcf 	.word	0x08014fcf
 801508c:	08015191 	.word	0x08015191
 8015090:	08014fcf 	.word	0x08014fcf
 8015094:	08014fe5 	.word	0x08014fe5
 8015098:	08014fcf 	.word	0x08014fcf
 801509c:	08014fcf 	.word	0x08014fcf
 80150a0:	08015159 	.word	0x08015159
 80150a4:	f04f 0e00 	mov.w	lr, #0
 80150a8:	f04f 35ff 	mov.w	r5, #4294967295
      num = va_arg(args, int);
 80150ac:	9a00      	ldr	r2, [sp, #0]
 80150ae:	f852 3b04 	ldr.w	r3, [r2], #4
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 80150b2:	1a38      	subs	r0, r7, r0
 80150b4:	210a      	movs	r1, #10
    else if (flags & SIGN)
 80150b6:	2702      	movs	r7, #2
  char *dig = lower_digits;
 80150b8:	f8df 82e8 	ldr.w	r8, [pc, #744]	@ 80153a4 <tiny_vsnprintf_like+0x480>
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 80150bc:	f106 0b01 	add.w	fp, r6, #1
  c = (type & ZEROPAD) ? '0' : ' ';
 80150c0:	f1be 0f00 	cmp.w	lr, #0
 80150c4:	f040 80cb 	bne.w	801525e <tiny_vsnprintf_like+0x33a>
 80150c8:	2620      	movs	r6, #32
  if (type & SIGN)
 80150ca:	2f00      	cmp	r7, #0
 80150cc:	f000 80a2 	beq.w	8015214 <tiny_vsnprintf_like+0x2f0>
    if (num < 0)
 80150d0:	2b00      	cmp	r3, #0
 80150d2:	f2c0 80ce 	blt.w	8015272 <tiny_vsnprintf_like+0x34e>
  if (num == 0)
 80150d6:	f040 80d3 	bne.w	8015280 <tiny_vsnprintf_like+0x35c>
    tmp[i++] = '0';
 80150da:	2330      	movs	r3, #48	@ 0x30
  size -= precision;
 80150dc:	3d01      	subs	r5, #1
    tmp[i++] = '0';
 80150de:	f88d 301c 	strb.w	r3, [sp, #28]
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 80150e2:	9200      	str	r2, [sp, #0]
 80150e4:	f1be 0f00 	cmp.w	lr, #0
 80150e8:	f040 8122 	bne.w	8015330 <tiny_vsnprintf_like+0x40c>
 80150ec:	46f4      	mov	ip, lr
 80150ee:	9402      	str	r4, [sp, #8]
    tmp[i++] = '0';
 80150f0:	2201      	movs	r2, #1
 80150f2:	e09b      	b.n	801522c <tiny_vsnprintf_like+0x308>
      num = va_arg(args, unsigned int);
 80150f4:	9a00      	ldr	r2, [sp, #0]
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 80150f6:	1a38      	subs	r0, r7, r0
 80150f8:	f852 3b04 	ldr.w	r3, [r2], #4
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 80150fc:	f10b 0b02 	add.w	fp, fp, #2
  c = (type & ZEROPAD) ? '0' : ' ';
 8015100:	f1be 0f00 	cmp.w	lr, #0
 8015104:	f000 8083 	beq.w	801520e <tiny_vsnprintf_like+0x2ea>
  if (type & UPPERCASE)  dig = upper_digits;
 8015108:	f8df 829c 	ldr.w	r8, [pc, #668]	@ 80153a8 <tiny_vsnprintf_like+0x484>
  c = (type & ZEROPAD) ? '0' : ' ';
 801510c:	2110      	movs	r1, #16
  if (num == 0)
 801510e:	2b00      	cmp	r3, #0
 8015110:	f040 8117 	bne.w	8015342 <tiny_vsnprintf_like+0x41e>
    tmp[i++] = '0';
 8015114:	2630      	movs	r6, #48	@ 0x30
  size -= precision;
 8015116:	9200      	str	r2, [sp, #0]
 8015118:	3d01      	subs	r5, #1
    tmp[i++] = '0';
 801511a:	f88d 601c 	strb.w	r6, [sp, #28]
 801511e:	2201      	movs	r2, #1
 8015120:	4425      	add	r5, r4
 8015122:	e004      	b.n	801512e <tiny_vsnprintf_like+0x20a>
  while (size-- > 0) ASSIGN_STR(c);
 8015124:	3801      	subs	r0, #1
 8015126:	f804 6b01 	strb.w	r6, [r4], #1
 801512a:	f43f af08 	beq.w	8014f3e <tiny_vsnprintf_like+0x1a>
 801512e:	1b2b      	subs	r3, r5, r4
 8015130:	2b00      	cmp	r3, #0
 8015132:	dcf7      	bgt.n	8015124 <tiny_vsnprintf_like+0x200>
 8015134:	a907      	add	r1, sp, #28
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 8015136:	4420      	add	r0, r4
 8015138:	440a      	add	r2, r1
 801513a:	e006      	b.n	801514a <tiny_vsnprintf_like+0x226>
 801513c:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
 8015140:	f804 3b01 	strb.w	r3, [r4], #1
 8015144:	4284      	cmp	r4, r0
 8015146:	f43f aefa 	beq.w	8014f3e <tiny_vsnprintf_like+0x1a>
 801514a:	428a      	cmp	r2, r1
 801514c:	d1f6      	bne.n	801513c <tiny_vsnprintf_like+0x218>
 801514e:	e6f6      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
    switch (*fmt)
 8015150:	f04f 0e00 	mov.w	lr, #0
 8015154:	f04f 35ff 	mov.w	r5, #4294967295
 8015158:	2110      	movs	r1, #16
      num = va_arg(args, unsigned int);
 801515a:	9a00      	ldr	r2, [sp, #0]
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 801515c:	1a38      	subs	r0, r7, r0
 801515e:	f852 3b04 	ldr.w	r3, [r2], #4
 8015162:	2700      	movs	r7, #0
 8015164:	e7a8      	b.n	80150b8 <tiny_vsnprintf_like+0x194>
          while (--field_width > 0) *str++ = ' ';
 8015166:	2a31      	cmp	r2, #49	@ 0x31
 8015168:	f340 80f9 	ble.w	801535e <tiny_vsnprintf_like+0x43a>
 801516c:	f1a2 0531 	sub.w	r5, r2, #49	@ 0x31
 8015170:	462a      	mov	r2, r5
 8015172:	2120      	movs	r1, #32
 8015174:	4620      	mov	r0, r4
 8015176:	f000 ffa7 	bl	80160c8 <memset>
 801517a:	1962      	adds	r2, r4, r5
        *str++ = (unsigned char) va_arg(args, int);
 801517c:	9b00      	ldr	r3, [sp, #0]
 801517e:	4614      	mov	r4, r2
 8015180:	f853 2b04 	ldr.w	r2, [r3], #4
 8015184:	f804 2b01 	strb.w	r2, [r4], #1
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8015188:	f106 0b01 	add.w	fp, r6, #1
        *str++ = (unsigned char) va_arg(args, int);
 801518c:	9300      	str	r3, [sp, #0]
        continue;
 801518e:	e6d6      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
        s = va_arg(args, char *);
 8015190:	9f00      	ldr	r7, [sp, #0]
 8015192:	f857 8b04 	ldr.w	r8, [r7], #4
          while (len < field_width--) *str++ = ' ';
 8015196:	f1a2 0b31 	sub.w	fp, r2, #49	@ 0x31
        if (!s) s = "<NULL>";
 801519a:	f1b8 0f00 	cmp.w	r8, #0
 801519e:	f000 80d8 	beq.w	8015352 <tiny_vsnprintf_like+0x42e>
        len = strlen(s);
 80151a2:	4640      	mov	r0, r8
 80151a4:	f7ea ffe8 	bl	8000178 <strlen>
          while (len < field_width--) *str++ = ' ';
 80151a8:	42a8      	cmp	r0, r5
        len = strlen(s);
 80151aa:	4603      	mov	r3, r0
          while (len < field_width--) *str++ = ' ';
 80151ac:	da0c      	bge.n	80151c8 <tiny_vsnprintf_like+0x2a4>
 80151ae:	f10b 0201 	add.w	r2, fp, #1
 80151b2:	1ad2      	subs	r2, r2, r3
 80151b4:	455b      	cmp	r3, fp
 80151b6:	bfc8      	it	gt
 80151b8:	2201      	movgt	r2, #1
 80151ba:	4620      	mov	r0, r4
 80151bc:	2120      	movs	r1, #32
 80151be:	9300      	str	r3, [sp, #0]
 80151c0:	4414      	add	r4, r2
 80151c2:	f000 ff81 	bl	80160c8 <memset>
 80151c6:	9b00      	ldr	r3, [sp, #0]
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 80151c8:	f106 0b01 	add.w	fp, r6, #1
        for (i = 0; i < len; ++i) *str++ = *s++;
 80151cc:	2b00      	cmp	r3, #0
 80151ce:	f000 80de 	beq.w	801538e <tiny_vsnprintf_like+0x46a>
 80151d2:	1e5a      	subs	r2, r3, #1
 80151d4:	2a05      	cmp	r2, #5
 80151d6:	4618      	mov	r0, r3
 80151d8:	f108 0201 	add.w	r2, r8, #1
 80151dc:	d902      	bls.n	80151e4 <tiny_vsnprintf_like+0x2c0>
 80151de:	1aa1      	subs	r1, r4, r2
 80151e0:	2902      	cmp	r1, #2
 80151e2:	d87e      	bhi.n	80152e2 <tiny_vsnprintf_like+0x3be>
 80151e4:	4480      	add	r8, r0
 80151e6:	1e63      	subs	r3, r4, #1
 80151e8:	e000      	b.n	80151ec <tiny_vsnprintf_like+0x2c8>
 80151ea:	3201      	adds	r2, #1
 80151ec:	f812 1c01 	ldrb.w	r1, [r2, #-1]
 80151f0:	f803 1f01 	strb.w	r1, [r3, #1]!
 80151f4:	4590      	cmp	r8, r2
 80151f6:	d1f8      	bne.n	80151ea <tiny_vsnprintf_like+0x2c6>
 80151f8:	4404      	add	r4, r0
 80151fa:	9700      	str	r7, [sp, #0]
 80151fc:	e69f      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
      num = va_arg(args, unsigned int);
 80151fe:	9a00      	ldr	r2, [sp, #0]
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 8015200:	f852 3b04 	ldr.w	r3, [r2], #4
 8015204:	1a38      	subs	r0, r7, r0
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8015206:	f10b 0b02 	add.w	fp, fp, #2
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 801520a:	f04f 35ff 	mov.w	r5, #4294967295
  if (type & UPPERCASE)  dig = upper_digits;
 801520e:	f8df 8198 	ldr.w	r8, [pc, #408]	@ 80153a8 <tiny_vsnprintf_like+0x484>
 8015212:	2110      	movs	r1, #16
  if (num == 0)
 8015214:	2b00      	cmp	r3, #0
 8015216:	f040 808d 	bne.w	8015334 <tiny_vsnprintf_like+0x410>
  size -= precision;
 801521a:	469c      	mov	ip, r3
    tmp[i++] = '0';
 801521c:	2330      	movs	r3, #48	@ 0x30
  size -= precision;
 801521e:	9200      	str	r2, [sp, #0]
 8015220:	3d01      	subs	r5, #1
    tmp[i++] = '0';
 8015222:	f88d 301c 	strb.w	r3, [sp, #28]
  size -= precision;
 8015226:	9402      	str	r4, [sp, #8]
  c = (type & ZEROPAD) ? '0' : ' ';
 8015228:	2620      	movs	r6, #32
    tmp[i++] = '0';
 801522a:	2201      	movs	r2, #1
 801522c:	1961      	adds	r1, r4, r5
 801522e:	e004      	b.n	801523a <tiny_vsnprintf_like+0x316>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 8015230:	3801      	subs	r0, #1
 8015232:	f804 ab01 	strb.w	sl, [r4], #1
 8015236:	f43f ae82 	beq.w	8014f3e <tiny_vsnprintf_like+0x1a>
 801523a:	1b0b      	subs	r3, r1, r4
 801523c:	2b00      	cmp	r3, #0
 801523e:	dcf7      	bgt.n	8015230 <tiny_vsnprintf_like+0x30c>
 8015240:	9b02      	ldr	r3, [sp, #8]
 8015242:	3b01      	subs	r3, #1
 8015244:	442b      	add	r3, r5
 8015246:	1b1d      	subs	r5, r3, r4
  if (sign) ASSIGN_STR(sign);
 8015248:	f1bc 0f00 	cmp.w	ip, #0
 801524c:	f43f af68 	beq.w	8015120 <tiny_vsnprintf_like+0x1fc>
 8015250:	232d      	movs	r3, #45	@ 0x2d
 8015252:	3801      	subs	r0, #1
 8015254:	f804 3b01 	strb.w	r3, [r4], #1
 8015258:	f47f af62 	bne.w	8015120 <tiny_vsnprintf_like+0x1fc>
 801525c:	e66f      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
  if (type & SIGN)
 801525e:	2f00      	cmp	r7, #0
 8015260:	f43f af55 	beq.w	801510e <tiny_vsnprintf_like+0x1ea>
    if (num < 0)
 8015264:	2b00      	cmp	r3, #0
  if (type & SIGN)
 8015266:	f04f 0e01 	mov.w	lr, #1
  c = (type & ZEROPAD) ? '0' : ' ';
 801526a:	f04f 0630 	mov.w	r6, #48	@ 0x30
    if (num < 0)
 801526e:	f6bf af32 	bge.w	80150d6 <tiny_vsnprintf_like+0x1b2>
      num = -num;
 8015272:	425b      	negs	r3, r3
      size--;
 8015274:	3d01      	subs	r5, #1
 8015276:	9200      	str	r2, [sp, #0]
 8015278:	9402      	str	r4, [sp, #8]
      sign = '-';
 801527a:	f04f 0c2d 	mov.w	ip, #45	@ 0x2d
 801527e:	e003      	b.n	8015288 <tiny_vsnprintf_like+0x364>
 8015280:	9200      	str	r2, [sp, #0]
 8015282:	9402      	str	r4, [sp, #8]
 8015284:	f04f 0c00 	mov.w	ip, #0
  i = 0;
 8015288:	e9cd c403 	strd	ip, r4, [sp, #12]
 801528c:	af07      	add	r7, sp, #28
 801528e:	2200      	movs	r2, #0
 8015290:	f8cd e014 	str.w	lr, [sp, #20]
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 8015294:	fbb3 f4f1 	udiv	r4, r3, r1
 8015298:	fb01 3e14 	mls	lr, r1, r4, r3
 801529c:	469c      	mov	ip, r3
    while (num != 0)
 801529e:	458c      	cmp	ip, r1
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 80152a0:	f818 300e 	ldrb.w	r3, [r8, lr]
 80152a4:	f807 3b01 	strb.w	r3, [r7], #1
 80152a8:	f102 0201 	add.w	r2, r2, #1
      num = ((unsigned long) num) / (unsigned) base;
 80152ac:	4623      	mov	r3, r4
    while (num != 0)
 80152ae:	d2f1      	bcs.n	8015294 <tiny_vsnprintf_like+0x370>
  size -= precision;
 80152b0:	f8dd e014 	ldr.w	lr, [sp, #20]
 80152b4:	e9dd c403 	ldrd	ip, r4, [sp, #12]
 80152b8:	1aad      	subs	r5, r5, r2
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 80152ba:	f1be 0f00 	cmp.w	lr, #0
 80152be:	d1c3      	bne.n	8015248 <tiny_vsnprintf_like+0x324>
 80152c0:	e7b4      	b.n	801522c <tiny_vsnprintf_like+0x308>
          *str++ = *fmt;
 80152c2:	f804 3b01 	strb.w	r3, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 80152c6:	eba4 0009 	sub.w	r0, r4, r9
 80152ca:	4287      	cmp	r7, r0
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 80152cc:	bfc8      	it	gt
 80152ce:	f106 0b01 	addgt.w	fp, r6, #1
        CHECK_STR_SIZE(buf, str, size);
 80152d2:	f73f ae34 	bgt.w	8014f3e <tiny_vsnprintf_like+0x1a>
 80152d6:	210a      	movs	r1, #10
 80152d8:	e73f      	b.n	801515a <tiny_vsnprintf_like+0x236>
    return 0;
 80152da:	2000      	movs	r0, #0
}
 80152dc:	b019      	add	sp, #100	@ 0x64
 80152de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80152e2:	f023 0603 	bic.w	r6, r3, #3
 80152e6:	4426      	add	r6, r4
 80152e8:	4622      	mov	r2, r4
 80152ea:	4641      	mov	r1, r8
        for (i = 0; i < len; ++i) *str++ = *s++;
 80152ec:	f851 5b04 	ldr.w	r5, [r1], #4
 80152f0:	f842 5b04 	str.w	r5, [r2], #4
 80152f4:	42b2      	cmp	r2, r6
 80152f6:	d1f9      	bne.n	80152ec <tiny_vsnprintf_like+0x3c8>
 80152f8:	0799      	lsls	r1, r3, #30
 80152fa:	f023 0203 	bic.w	r2, r3, #3
 80152fe:	f43f af7b 	beq.w	80151f8 <tiny_vsnprintf_like+0x2d4>
 8015302:	f818 1002 	ldrb.w	r1, [r8, r2]
 8015306:	54a1      	strb	r1, [r4, r2]
 8015308:	1c51      	adds	r1, r2, #1
 801530a:	428b      	cmp	r3, r1
 801530c:	4490      	add	r8, r2
 801530e:	eb04 0502 	add.w	r5, r4, r2
 8015312:	f77f af71 	ble.w	80151f8 <tiny_vsnprintf_like+0x2d4>
 8015316:	3202      	adds	r2, #2
 8015318:	f898 1001 	ldrb.w	r1, [r8, #1]
 801531c:	7069      	strb	r1, [r5, #1]
 801531e:	429a      	cmp	r2, r3
 8015320:	f6bf af6a 	bge.w	80151f8 <tiny_vsnprintf_like+0x2d4>
 8015324:	f898 3002 	ldrb.w	r3, [r8, #2]
 8015328:	70ab      	strb	r3, [r5, #2]
 801532a:	4404      	add	r4, r0
 801532c:	9700      	str	r7, [sp, #0]
 801532e:	e606      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
    tmp[i++] = '0';
 8015330:	4672      	mov	r2, lr
 8015332:	e6f5      	b.n	8015120 <tiny_vsnprintf_like+0x1fc>
  if (num == 0)
 8015334:	f04f 0e00 	mov.w	lr, #0
 8015338:	9200      	str	r2, [sp, #0]
 801533a:	9402      	str	r4, [sp, #8]
  c = (type & ZEROPAD) ? '0' : ' ';
 801533c:	2620      	movs	r6, #32
  if (num == 0)
 801533e:	46f4      	mov	ip, lr
 8015340:	e7a2      	b.n	8015288 <tiny_vsnprintf_like+0x364>
 8015342:	9200      	str	r2, [sp, #0]
 8015344:	9402      	str	r4, [sp, #8]
 8015346:	f04f 0e01 	mov.w	lr, #1
  c = (type & ZEROPAD) ? '0' : ' ';
 801534a:	2630      	movs	r6, #48	@ 0x30
  if (num == 0)
 801534c:	f04f 0c00 	mov.w	ip, #0
 8015350:	e79a      	b.n	8015288 <tiny_vsnprintf_like+0x364>
          while (len < field_width--) *str++ = ' ';
 8015352:	2d06      	cmp	r5, #6
 8015354:	dd1d      	ble.n	8015392 <tiny_vsnprintf_like+0x46e>
        if (!s) s = "<NULL>";
 8015356:	f8df 8054 	ldr.w	r8, [pc, #84]	@ 80153ac <tiny_vsnprintf_like+0x488>
          while (len < field_width--) *str++ = ' ';
 801535a:	2306      	movs	r3, #6
 801535c:	e727      	b.n	80151ae <tiny_vsnprintf_like+0x28a>
    switch (*fmt)
 801535e:	4622      	mov	r2, r4
 8015360:	e70c      	b.n	801517c <tiny_vsnprintf_like+0x258>
 8015362:	f04f 0e00 	mov.w	lr, #0
 8015366:	210a      	movs	r1, #10
 8015368:	f04f 35ff 	mov.w	r5, #4294967295
 801536c:	e6f5      	b.n	801515a <tiny_vsnprintf_like+0x236>
        s = va_arg(args, char *);
 801536e:	9f00      	ldr	r7, [sp, #0]
 8015370:	f857 8b04 	ldr.w	r8, [r7], #4
        if (!s) s = "<NULL>";
 8015374:	f1b8 0f00 	cmp.w	r8, #0
 8015378:	d00b      	beq.n	8015392 <tiny_vsnprintf_like+0x46e>
 801537a:	f04f 35ff 	mov.w	r5, #4294967295
 801537e:	f06f 0b01 	mvn.w	fp, #1
 8015382:	e70e      	b.n	80151a2 <tiny_vsnprintf_like+0x27e>
        if (*fmt)
 8015384:	7833      	ldrb	r3, [r6, #0]
 8015386:	2b00      	cmp	r3, #0
 8015388:	d19b      	bne.n	80152c2 <tiny_vsnprintf_like+0x39e>
 801538a:	46b3      	mov	fp, r6
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 801538c:	e5d7      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
        for (i = 0; i < len; ++i) *str++ = *s++;
 801538e:	9700      	str	r7, [sp, #0]
 8015390:	e5d5      	b.n	8014f3e <tiny_vsnprintf_like+0x1a>
        if (!s) s = "<NULL>";
 8015392:	f8df 8018 	ldr.w	r8, [pc, #24]	@ 80153ac <tiny_vsnprintf_like+0x488>
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8015396:	f106 0b01 	add.w	fp, r6, #1
 801539a:	2006      	movs	r0, #6
 801539c:	f108 0201 	add.w	r2, r8, #1
 80153a0:	e720      	b.n	80151e4 <tiny_vsnprintf_like+0x2c0>
 80153a2:	bf00      	nop
 80153a4:	0801779c 	.word	0x0801779c
 80153a8:	080177c4 	.word	0x080177c4
 80153ac:	08017794 	.word	0x08017794

080153b0 <UTIL_SEQ_RegTask>:

  return;
}

void UTIL_SEQ_RegTask(UTIL_SEQ_bm_t TaskId_bm, uint32_t Flags, void (*Task)( void ))
{
 80153b0:	b430      	push	{r4, r5}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80153b2:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80153b6:	b672      	cpsid	i
uint8_t SEQ_BitPosition(uint32_t Value)
{
uint8_t n = 0U;
uint32_t lvalue = Value;

  if ((lvalue & 0xFFFF0000U) == 0U)  { n  = 16U; lvalue <<= 16U;  }
 80153b8:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 80153bc:	d21b      	bcs.n	80153f6 <UTIL_SEQ_RegTask+0x46>
 80153be:	0400      	lsls	r0, r0, #16
 80153c0:	2418      	movs	r4, #24
 80153c2:	2310      	movs	r3, #16
  if ((lvalue & 0xFF000000U) == 0U)  { n +=  8U; lvalue <<=  8U;  }
 80153c4:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 80153c8:	bf3c      	itt	cc
 80153ca:	0200      	lslcc	r0, r0, #8
 80153cc:	4623      	movcc	r3, r4
  if ((lvalue & 0xF0000000U) == 0U)  { n +=  4U; lvalue <<=  4U;  }
 80153ce:	f1b0 5f80 	cmp.w	r0, #268435456	@ 0x10000000
 80153d2:	d202      	bcs.n	80153da <UTIL_SEQ_RegTask+0x2a>
 80153d4:	3304      	adds	r3, #4
 80153d6:	b2db      	uxtb	r3, r3
 80153d8:	0100      	lsls	r0, r0, #4

  n += SEQ_clz_table_4bit[lvalue >> (32-4)];
 80153da:	4d08      	ldr	r5, [pc, #32]	@ (80153fc <UTIL_SEQ_RegTask+0x4c>)
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 80153dc:	4c08      	ldr	r4, [pc, #32]	@ (8015400 <UTIL_SEQ_RegTask+0x50>)
  n += SEQ_clz_table_4bit[lvalue >> (32-4)];
 80153de:	0f00      	lsrs	r0, r0, #28

  return (uint8_t)(31U-n);
 80153e0:	f1c3 031f 	rsb	r3, r3, #31
 80153e4:	5c28      	ldrb	r0, [r5, r0]
 80153e6:	1a1b      	subs	r3, r3, r0
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 80153e8:	b2db      	uxtb	r3, r3
 80153ea:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80153ee:	f381 8810 	msr	PRIMASK, r1
}
 80153f2:	bc30      	pop	{r4, r5}
 80153f4:	4770      	bx	lr
 80153f6:	2408      	movs	r4, #8
uint8_t n = 0U;
 80153f8:	2300      	movs	r3, #0
 80153fa:	e7e3      	b.n	80153c4 <UTIL_SEQ_RegTask+0x14>
 80153fc:	080177ec 	.word	0x080177ec
 8015400:	200015d4 	.word	0x200015d4

08015404 <UTIL_SEQ_SetTask>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015404:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015408:	b672      	cpsid	i
  TaskSet |= TaskId_bm;
 801540a:	4a06      	ldr	r2, [pc, #24]	@ (8015424 <UTIL_SEQ_SetTask+0x20>)
 801540c:	6813      	ldr	r3, [r2, #0]
 801540e:	4303      	orrs	r3, r0
 8015410:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 8015412:	4a05      	ldr	r2, [pc, #20]	@ (8015428 <UTIL_SEQ_SetTask+0x24>)
 8015414:	f852 3031 	ldr.w	r3, [r2, r1, lsl #3]
 8015418:	4303      	orrs	r3, r0
 801541a:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801541e:	f38c 8810 	msr	PRIMASK, ip
}
 8015422:	4770      	bx	lr
 8015424:	200015f0 	.word	0x200015f0
 8015428:	200015cc 	.word	0x200015cc

0801542c <UTIL_SEQ_PreIdle>:
__WEAK void UTIL_SEQ_PreIdle( void )
 801542c:	4770      	bx	lr
 801542e:	bf00      	nop

08015430 <UTIL_SEQ_PostIdle>:
__WEAK void UTIL_SEQ_PostIdle( void )
 8015430:	4770      	bx	lr
 8015432:	bf00      	nop

08015434 <UTIL_SEQ_Run>:
{
 8015434:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  super_mask_backup = SuperMask;
 8015438:	4d4b      	ldr	r5, [pc, #300]	@ (8015568 <UTIL_SEQ_Run+0x134>)
  local_taskset = TaskSet;
 801543a:	f8df b130 	ldr.w	fp, [pc, #304]	@ 801556c <UTIL_SEQ_Run+0x138>
  local_evtset = EvtSet;
 801543e:	4e4c      	ldr	r6, [pc, #304]	@ (8015570 <UTIL_SEQ_Run+0x13c>)
  local_taskmask = TaskMask;
 8015440:	4f4c      	ldr	r7, [pc, #304]	@ (8015574 <UTIL_SEQ_Run+0x140>)
  local_taskset = TaskSet;
 8015442:	f8db 3000 	ldr.w	r3, [fp]
  super_mask_backup = SuperMask;
 8015446:	682a      	ldr	r2, [r5, #0]
  local_evtset = EvtSet;
 8015448:	6834      	ldr	r4, [r6, #0]
  local_taskmask = TaskMask;
 801544a:	6839      	ldr	r1, [r7, #0]
  local_evtwaited =  EvtWaited;
 801544c:	f8df 8128 	ldr.w	r8, [pc, #296]	@ 8015578 <UTIL_SEQ_Run+0x144>
  SuperMask &= Mask_bm;
 8015450:	4010      	ands	r0, r2
{
 8015452:	b083      	sub	sp, #12
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8015454:	400b      	ands	r3, r1
 8015456:	4203      	tst	r3, r0
  super_mask_backup = SuperMask;
 8015458:	9201      	str	r2, [sp, #4]
  SuperMask &= Mask_bm;
 801545a:	6028      	str	r0, [r5, #0]
  local_evtwaited =  EvtWaited;
 801545c:	f8d8 2000 	ldr.w	r2, [r8]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8015460:	d05e      	beq.n	8015520 <UTIL_SEQ_Run+0xec>
 8015462:	4214      	tst	r4, r2
 8015464:	d15c      	bne.n	8015520 <UTIL_SEQ_Run+0xec>
 8015466:	f8df 9114 	ldr.w	r9, [pc, #276]	@ 801557c <UTIL_SEQ_Run+0x148>
 801546a:	4c45      	ldr	r4, [pc, #276]	@ (8015580 <UTIL_SEQ_Run+0x14c>)
 801546c:	f8df a114 	ldr.w	sl, [pc, #276]	@ 8015584 <UTIL_SEQ_Run+0x150>
 8015470:	e044      	b.n	80154fc <UTIL_SEQ_Run+0xc8>
  if ((lvalue & 0xFFFF0000U) == 0U)  { n  = 16U; lvalue <<= 16U;  }
 8015472:	0412      	lsls	r2, r2, #16
 8015474:	2118      	movs	r1, #24
 8015476:	2310      	movs	r3, #16
  if ((lvalue & 0xFF000000U) == 0U)  { n +=  8U; lvalue <<=  8U;  }
 8015478:	f1b2 7f80 	cmp.w	r2, #16777216	@ 0x1000000
 801547c:	bf3c      	itt	cc
 801547e:	0212      	lslcc	r2, r2, #8
 8015480:	460b      	movcc	r3, r1
  if ((lvalue & 0xF0000000U) == 0U)  { n +=  4U; lvalue <<=  4U;  }
 8015482:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
 8015486:	d202      	bcs.n	801548e <UTIL_SEQ_Run+0x5a>
 8015488:	3304      	adds	r3, #4
 801548a:	b2db      	uxtb	r3, r3
 801548c:	0112      	lsls	r2, r2, #4
  n += SEQ_clz_table_4bit[lvalue >> (32-4)];
 801548e:	0f12      	lsrs	r2, r2, #28
  return (uint8_t)(31U-n);
 8015490:	f1c3 031f 	rsb	r3, r3, #31
 8015494:	f81a 2002 	ldrb.w	r2, [sl, r2]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 8015498:	6861      	ldr	r1, [r4, #4]
  return (uint8_t)(31U-n);
 801549a:	1a9b      	subs	r3, r3, r2
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 801549c:	b2db      	uxtb	r3, r3
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 801549e:	2201      	movs	r2, #1
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 80154a0:	f8c9 3000 	str.w	r3, [r9]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 80154a4:	fa02 f303 	lsl.w	r3, r2, r3
 80154a8:	ea21 0303 	bic.w	r3, r1, r3
 80154ac:	6063      	str	r3, [r4, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80154ae:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80154b2:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 80154b4:	f8d9 3000 	ldr.w	r3, [r9]
 80154b8:	fa02 f303 	lsl.w	r3, r2, r3
 80154bc:	f8db 2000 	ldr.w	r2, [fp]
 80154c0:	ea22 0203 	bic.w	r2, r2, r3
 80154c4:	f8cb 2000 	str.w	r2, [fp]
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 80154c8:	6822      	ldr	r2, [r4, #0]
 80154ca:	ea22 0303 	bic.w	r3, r2, r3
 80154ce:	6023      	str	r3, [r4, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80154d0:	f381 8810 	msr	PRIMASK, r1
    TaskCb[CurrentTaskIdx]( );
 80154d4:	4a2c      	ldr	r2, [pc, #176]	@ (8015588 <UTIL_SEQ_Run+0x154>)
 80154d6:	f8d9 3000 	ldr.w	r3, [r9]
 80154da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80154de:	4798      	blx	r3
    local_taskset = TaskSet;
 80154e0:	f8db 3000 	ldr.w	r3, [fp]
    local_evtset = EvtSet;
 80154e4:	f8d6 c000 	ldr.w	ip, [r6]
    local_taskmask = TaskMask;
 80154e8:	6839      	ldr	r1, [r7, #0]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 80154ea:	6828      	ldr	r0, [r5, #0]
    local_evtwaited = EvtWaited;
 80154ec:	f8d8 2000 	ldr.w	r2, [r8]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 80154f0:	400b      	ands	r3, r1
 80154f2:	4203      	tst	r3, r0
 80154f4:	d016      	beq.n	8015524 <UTIL_SEQ_Run+0xf0>
 80154f6:	ea1c 0f02 	tst.w	ip, r2
 80154fa:	d113      	bne.n	8015524 <UTIL_SEQ_Run+0xf0>
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 80154fc:	6823      	ldr	r3, [r4, #0]
    current_task_set = TaskPrio[counter].priority & local_taskmask & SuperMask;
 80154fe:	6823      	ldr	r3, [r4, #0]
 8015500:	4008      	ands	r0, r1
 8015502:	4018      	ands	r0, r3
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 8015504:	6863      	ldr	r3, [r4, #4]
 8015506:	4203      	tst	r3, r0
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 8015508:	bf04      	itt	eq
 801550a:	f04f 33ff 	moveq.w	r3, #4294967295
 801550e:	6063      	streq	r3, [r4, #4]
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 8015510:	6862      	ldr	r2, [r4, #4]
 8015512:	4002      	ands	r2, r0
  if ((lvalue & 0xFFFF0000U) == 0U)  { n  = 16U; lvalue <<= 16U;  }
 8015514:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 8015518:	d3ab      	bcc.n	8015472 <UTIL_SEQ_Run+0x3e>
 801551a:	2108      	movs	r1, #8
uint8_t n = 0U;
 801551c:	2300      	movs	r3, #0
 801551e:	e7ab      	b.n	8015478 <UTIL_SEQ_Run+0x44>
 8015520:	f8df 9058 	ldr.w	r9, [pc, #88]	@ 801557c <UTIL_SEQ_Run+0x148>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 8015524:	f04f 33ff 	mov.w	r3, #4294967295
 8015528:	f8c9 3000 	str.w	r3, [r9]
  UTIL_SEQ_PreIdle( );
 801552c:	f7ff ff7e 	bl	801542c <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015530:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015534:	b672      	cpsid	i
  local_taskset = TaskSet;
 8015536:	f8db 3000 	ldr.w	r3, [fp]
  local_evtset = EvtSet;
 801553a:	6831      	ldr	r1, [r6, #0]
  local_taskmask = TaskMask;
 801553c:	683a      	ldr	r2, [r7, #0]
  if ((local_taskset & local_taskmask & SuperMask) == 0U)
 801553e:	4013      	ands	r3, r2
 8015540:	682a      	ldr	r2, [r5, #0]
 8015542:	4213      	tst	r3, r2
 8015544:	d103      	bne.n	801554e <UTIL_SEQ_Run+0x11a>
    if ((local_evtset & EvtWaited)== 0U)
 8015546:	f8d8 3000 	ldr.w	r3, [r8]
 801554a:	420b      	tst	r3, r1
 801554c:	d008      	beq.n	8015560 <UTIL_SEQ_Run+0x12c>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801554e:	f384 8810 	msr	PRIMASK, r4
  UTIL_SEQ_PostIdle( );
 8015552:	f7ff ff6d 	bl	8015430 <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 8015556:	9b01      	ldr	r3, [sp, #4]
 8015558:	602b      	str	r3, [r5, #0]
}
 801555a:	b003      	add	sp, #12
 801555c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      UTIL_SEQ_Idle( );
 8015560:	f7ec faae 	bl	8001ac0 <UTIL_SEQ_Idle>
 8015564:	e7f3      	b.n	801554e <UTIL_SEQ_Run+0x11a>
 8015566:	bf00      	nop
 8015568:	20000114 	.word	0x20000114
 801556c:	200015f0 	.word	0x200015f0
 8015570:	200015ec 	.word	0x200015ec
 8015574:	20000118 	.word	0x20000118
 8015578:	200015e8 	.word	0x200015e8
 801557c:	200015e4 	.word	0x200015e4
 8015580:	200015cc 	.word	0x200015cc
 8015584:	080177ec 	.word	0x080177ec
 8015588:	200015d4 	.word	0x200015d4

0801558c <UTIL_TIMER_Start.part.0>:
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}

UTIL_TIMER_Status_t UTIL_TIMER_Start( UTIL_TIMER_Object_t *TimerObject)
 801558c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8015590:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015592:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015596:	b672      	cpsid	i
    
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
  {
    UTIL_TIMER_ENTER_CRITICAL_SECTION();
    ticks = TimerObject->ReloadValue;
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 8015598:	4f37      	ldr	r7, [pc, #220]	@ (8015678 <UTIL_TIMER_Start.part.0+0xec>)
    ticks = TimerObject->ReloadValue;
 801559a:	6845      	ldr	r5, [r0, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 801559c:	f8d7 9020 	ldr.w	r9, [r7, #32]
    
    TimerObject->Timestamp = ticks;
    TimerObject->IsPending = 0U;
    TimerObject->IsRunning = 1U;
    TimerObject->IsReloadStopped = 0U;
    if( TimerListHead == NULL )
 80155a0:	f8df 80d8 	ldr.w	r8, [pc, #216]	@ 801567c <UTIL_TIMER_Start.part.0+0xf0>
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 80155a4:	47c8      	blx	r9
    TimerObject->Timestamp = ticks;
 80155a6:	42a8      	cmp	r0, r5
 80155a8:	bf38      	it	cc
 80155aa:	4628      	movcc	r0, r5
    if( TimerListHead == NULL )
 80155ac:	f8d8 5000 	ldr.w	r5, [r8]
    TimerObject->Timestamp = ticks;
 80155b0:	6020      	str	r0, [r4, #0]
    TimerObject->IsPending = 0U;
 80155b2:	f44f 7380 	mov.w	r3, #256	@ 0x100
    TimerObject->IsReloadStopped = 0U;
 80155b6:	f04f 0a00 	mov.w	sl, #0
    TimerObject->IsPending = 0U;
 80155ba:	8123      	strh	r3, [r4, #8]
    TimerObject->IsReloadStopped = 0U;
 80155bc:	f884 a00a 	strb.w	sl, [r4, #10]
    if( TimerListHead == NULL )
 80155c0:	2d00      	cmp	r5, #0
 80155c2:	d033      	beq.n	801562c <UTIL_TIMER_Start.part.0+0xa0>
      UTIL_TimerDriver.SetTimerContext();
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
    }
    else 
    {
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 80155c4:	69bd      	ldr	r5, [r7, #24]
 80155c6:	47a8      	blx	r5
      TimerObject->Timestamp += elapsedTime;
 80155c8:	6823      	ldr	r3, [r4, #0]
      
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 80155ca:	f8d8 1000 	ldr.w	r1, [r8]
      TimerObject->Timestamp += elapsedTime;
 80155ce:	4418      	add	r0, r3
 80155d0:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 80155d2:	680b      	ldr	r3, [r1, #0]
 80155d4:	4298      	cmp	r0, r3
 80155d6:	d311      	bcc.n	80155fc <UTIL_TIMER_Start.part.0+0x70>
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 80155d8:	694b      	ldr	r3, [r1, #20]

  while (cur->Next != NULL )
 80155da:	b92b      	cbnz	r3, 80155e8 <UTIL_TIMER_Start.part.0+0x5c>
 80155dc:	e03f      	b.n	801565e <UTIL_TIMER_Start.part.0+0xd2>
  {  
    if( TimerObject->Timestamp  > next->Timestamp )
    {
        cur = next;
        next = next->Next;
 80155de:	695a      	ldr	r2, [r3, #20]
  while (cur->Next != NULL )
 80155e0:	4619      	mov	r1, r3
 80155e2:	2a00      	cmp	r2, #0
 80155e4:	d03c      	beq.n	8015660 <UTIL_TIMER_Start.part.0+0xd4>
        next = next->Next;
 80155e6:	4613      	mov	r3, r2
    if( TimerObject->Timestamp  > next->Timestamp )
 80155e8:	681a      	ldr	r2, [r3, #0]
 80155ea:	4290      	cmp	r0, r2
 80155ec:	d8f7      	bhi.n	80155de <UTIL_TIMER_Start.part.0+0x52>
    }
    else
    {
        cur->Next = TimerObject;
 80155ee:	614c      	str	r4, [r1, #20]
        TimerObject->Next = next;
 80155f0:	6163      	str	r3, [r4, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80155f2:	f386 8810 	msr	PRIMASK, r6
}
 80155f6:	2000      	movs	r0, #0
 80155f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
{
  UTIL_TIMER_Object_t* cur = TimerListHead;

  if( cur != NULL )
  {
    cur->IsPending = 0;
 80155fc:	f881 a008 	strb.w	sl, [r1, #8]
  }

  TimerObject->Next = cur;
 8015600:	6161      	str	r1, [r4, #20]
  TimerListHead = TimerObject;
 8015602:	f8c8 4000 	str.w	r4, [r8]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 8015606:	47c8      	blx	r9
  TimerObject->IsPending = 1;
 8015608:	2301      	movs	r3, #1
 801560a:	7223      	strb	r3, [r4, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 801560c:	f8d4 9000 	ldr.w	r9, [r4]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 8015610:	4680      	mov	r8, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8015612:	47a8      	blx	r5
 8015614:	eb08 0300 	add.w	r3, r8, r0
 8015618:	4599      	cmp	r9, r3
 801561a:	d329      	bcc.n	8015670 <UTIL_TIMER_Start.part.0+0xe4>
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 801561c:	6820      	ldr	r0, [r4, #0]
 801561e:	68bb      	ldr	r3, [r7, #8]
 8015620:	4798      	blx	r3
 8015622:	f386 8810 	msr	PRIMASK, r6
}
 8015626:	2000      	movs	r0, #0
 8015628:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      UTIL_TimerDriver.SetTimerContext();
 801562c:	693b      	ldr	r3, [r7, #16]
 801562e:	4798      	blx	r3
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8015630:	f8d8 3000 	ldr.w	r3, [r8]
  if( cur != NULL )
 8015634:	b103      	cbz	r3, 8015638 <UTIL_TIMER_Start.part.0+0xac>
    cur->IsPending = 0;
 8015636:	721d      	strb	r5, [r3, #8]
  TimerObject->Next = cur;
 8015638:	6163      	str	r3, [r4, #20]
  TimerListHead = TimerObject;
 801563a:	f8c8 4000 	str.w	r4, [r8]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 801563e:	47c8      	blx	r9
  TimerObject->IsPending = 1;
 8015640:	2301      	movs	r3, #1
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8015642:	f8d7 8018 	ldr.w	r8, [r7, #24]
  TimerObject->IsPending = 1;
 8015646:	7223      	strb	r3, [r4, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8015648:	f8d4 9000 	ldr.w	r9, [r4]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 801564c:	4605      	mov	r5, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 801564e:	47c0      	blx	r8
 8015650:	4428      	add	r0, r5
 8015652:	4581      	cmp	r9, r0
 8015654:	d2e2      	bcs.n	801561c <UTIL_TIMER_Start.part.0+0x90>
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 8015656:	47c0      	blx	r8
 8015658:	4428      	add	r0, r5
 801565a:	6020      	str	r0, [r4, #0]
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 801565c:	e7df      	b.n	801561e <UTIL_TIMER_Start.part.0+0x92>
  while (cur->Next != NULL )
 801565e:	460b      	mov	r3, r1
  TimerObject->Next = NULL;
 8015660:	2200      	movs	r2, #0
  cur->Next = TimerObject;
 8015662:	615c      	str	r4, [r3, #20]
  TimerObject->Next = NULL;
 8015664:	6162      	str	r2, [r4, #20]
 8015666:	f386 8810 	msr	PRIMASK, r6
}
 801566a:	2000      	movs	r0, #0
 801566c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 8015670:	47a8      	blx	r5
 8015672:	4440      	add	r0, r8
 8015674:	6020      	str	r0, [r4, #0]
 8015676:	e7d2      	b.n	801561e <UTIL_TIMER_Start.part.0+0x92>
 8015678:	08016ac0 	.word	0x08016ac0
 801567c:	200015f4 	.word	0x200015f4

08015680 <UTIL_TIMER_Init>:
  return UTIL_TimerDriver.InitTimer();
 8015680:	4b02      	ldr	r3, [pc, #8]	@ (801568c <UTIL_TIMER_Init+0xc>)
  TimerListHead = NULL;
 8015682:	4a03      	ldr	r2, [pc, #12]	@ (8015690 <UTIL_TIMER_Init+0x10>)
  return UTIL_TimerDriver.InitTimer();
 8015684:	681b      	ldr	r3, [r3, #0]
  TimerListHead = NULL;
 8015686:	2100      	movs	r1, #0
 8015688:	6011      	str	r1, [r2, #0]
  return UTIL_TimerDriver.InitTimer();
 801568a:	4718      	bx	r3
 801568c:	08016ac0 	.word	0x08016ac0
 8015690:	200015f4 	.word	0x200015f4

08015694 <UTIL_TIMER_Create>:
{
 8015694:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015696:	4604      	mov	r4, r0
  if((TimerObject != NULL) && (Callback != NULL))
 8015698:	b190      	cbz	r0, 80156c0 <UTIL_TIMER_Create+0x2c>
 801569a:	461e      	mov	r6, r3
 801569c:	b183      	cbz	r3, 80156c0 <UTIL_TIMER_Create+0x2c>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 801569e:	4b09      	ldr	r3, [pc, #36]	@ (80156c4 <UTIL_TIMER_Create+0x30>)
    TimerObject->Timestamp = 0U;
 80156a0:	2500      	movs	r5, #0
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 80156a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    TimerObject->Timestamp = 0U;
 80156a4:	6025      	str	r5, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 80156a6:	4608      	mov	r0, r1
 80156a8:	4617      	mov	r7, r2
 80156aa:	4798      	blx	r3
    TimerObject->argument = Argument;
 80156ac:	9b06      	ldr	r3, [sp, #24]
    TimerObject->IsPending = 0U;
 80156ae:	8125      	strh	r5, [r4, #8]
    TimerObject->IsReloadStopped = 0U;
 80156b0:	72a5      	strb	r5, [r4, #10]
    TimerObject->Mode = Mode;
 80156b2:	72e7      	strb	r7, [r4, #11]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 80156b4:	6060      	str	r0, [r4, #4]
    TimerObject->Callback = Callback;
 80156b6:	60e6      	str	r6, [r4, #12]
    TimerObject->argument = Argument;
 80156b8:	6123      	str	r3, [r4, #16]
    TimerObject->Next = NULL;
 80156ba:	6165      	str	r5, [r4, #20]
    return UTIL_TIMER_OK;
 80156bc:	4628      	mov	r0, r5
}
 80156be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 80156c0:	2001      	movs	r0, #1
}
 80156c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80156c4:	08016ac0 	.word	0x08016ac0

080156c8 <UTIL_TIMER_Start>:
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 80156c8:	b138      	cbz	r0, 80156da <UTIL_TIMER_Start+0x12>
  UTIL_TIMER_Object_t* cur = TimerListHead;
 80156ca:	4b07      	ldr	r3, [pc, #28]	@ (80156e8 <UTIL_TIMER_Start+0x20>)
 80156cc:	681b      	ldr	r3, [r3, #0]
  while( cur != NULL )
 80156ce:	b913      	cbnz	r3, 80156d6 <UTIL_TIMER_Start+0xe>
 80156d0:	e005      	b.n	80156de <UTIL_TIMER_Start+0x16>
    cur = cur->Next;
 80156d2:	695b      	ldr	r3, [r3, #20]
  while( cur != NULL )
 80156d4:	b11b      	cbz	r3, 80156de <UTIL_TIMER_Start+0x16>
    if( cur == TimerObject )
 80156d6:	4298      	cmp	r0, r3
 80156d8:	d1fb      	bne.n	80156d2 <UTIL_TIMER_Start+0xa>
}
 80156da:	2001      	movs	r0, #1
 80156dc:	4770      	bx	lr
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 80156de:	7a43      	ldrb	r3, [r0, #9]
 80156e0:	2b00      	cmp	r3, #0
 80156e2:	d1fa      	bne.n	80156da <UTIL_TIMER_Start+0x12>
 80156e4:	f7ff bf52 	b.w	801558c <UTIL_TIMER_Start.part.0>
 80156e8:	200015f4 	.word	0x200015f4

080156ec <UTIL_TIMER_Stop>:
  if (NULL != TimerObject)
 80156ec:	b1d0      	cbz	r0, 8015724 <UTIL_TIMER_Stop+0x38>
{
 80156ee:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80156f2:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80156f6:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 80156f8:	4c1f      	ldr	r4, [pc, #124]	@ (8015778 <UTIL_TIMER_Stop+0x8c>)
 80156fa:	6823      	ldr	r3, [r4, #0]
    TimerObject->IsReloadStopped = 1U;
 80156fc:	2501      	movs	r5, #1
 80156fe:	7285      	strb	r5, [r0, #10]
    if(NULL != TimerListHead)
 8015700:	b15b      	cbz	r3, 801571a <UTIL_TIMER_Stop+0x2e>
      TimerObject->IsRunning = 0U;
 8015702:	2200      	movs	r2, #0
 8015704:	7242      	strb	r2, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 8015706:	4298      	cmp	r0, r3
          if( TimerListHead->Next != NULL )
 8015708:	695f      	ldr	r7, [r3, #20]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 801570a:	d102      	bne.n	8015712 <UTIL_TIMER_Stop+0x26>
 801570c:	e013      	b.n	8015736 <UTIL_TIMER_Stop+0x4a>
          if( cur == TimerObject )
 801570e:	4298      	cmp	r0, r3
 8015710:	d00a      	beq.n	8015728 <UTIL_TIMER_Stop+0x3c>
            cur = cur->Next;
 8015712:	461a      	mov	r2, r3
 8015714:	695b      	ldr	r3, [r3, #20]
        while( cur != NULL )
 8015716:	2b00      	cmp	r3, #0
 8015718:	d1f9      	bne.n	801570e <UTIL_TIMER_Stop+0x22>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801571a:	f386 8810 	msr	PRIMASK, r6
}
 801571e:	2000      	movs	r0, #0
}
 8015720:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ret = UTIL_TIMER_INVALID_PARAM;
 8015724:	2001      	movs	r0, #1
}
 8015726:	4770      	bx	lr
            if( cur->Next != NULL )
 8015728:	6943      	ldr	r3, [r0, #20]
              prev->Next = cur;
 801572a:	6153      	str	r3, [r2, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801572c:	f386 8810 	msr	PRIMASK, r6
}
 8015730:	2000      	movs	r0, #0
}
 8015732:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          TimerListHead->IsPending = 0;
 8015736:	7202      	strb	r2, [r0, #8]
          if( TimerListHead->Next != NULL )
 8015738:	b1a7      	cbz	r7, 8015764 <UTIL_TIMER_Stop+0x78>
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 801573a:	f8df 8040 	ldr.w	r8, [pc, #64]	@ 801577c <UTIL_TIMER_Stop+0x90>
            TimerListHead = TimerListHead->Next;
 801573e:	6027      	str	r7, [r4, #0]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 8015740:	f8d8 3020 	ldr.w	r3, [r8, #32]
 8015744:	4798      	blx	r3
  TimerObject->IsPending = 1;
 8015746:	723d      	strb	r5, [r7, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8015748:	f8d8 5018 	ldr.w	r5, [r8, #24]
 801574c:	f8d7 9000 	ldr.w	r9, [r7]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 8015750:	4604      	mov	r4, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8015752:	47a8      	blx	r5
 8015754:	4420      	add	r0, r4
 8015756:	4581      	cmp	r9, r0
 8015758:	d309      	bcc.n	801576e <UTIL_TIMER_Stop+0x82>
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 801575a:	6838      	ldr	r0, [r7, #0]
 801575c:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8015760:	4798      	blx	r3
}
 8015762:	e7da      	b.n	801571a <UTIL_TIMER_Stop+0x2e>
            UTIL_TimerDriver.StopTimerEvt( );
 8015764:	4b05      	ldr	r3, [pc, #20]	@ (801577c <UTIL_TIMER_Stop+0x90>)
 8015766:	68db      	ldr	r3, [r3, #12]
 8015768:	4798      	blx	r3
            TimerListHead = NULL;
 801576a:	6027      	str	r7, [r4, #0]
 801576c:	e7d5      	b.n	801571a <UTIL_TIMER_Stop+0x2e>
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 801576e:	47a8      	blx	r5
 8015770:	4420      	add	r0, r4
 8015772:	6038      	str	r0, [r7, #0]
 8015774:	e7f2      	b.n	801575c <UTIL_TIMER_Stop+0x70>
 8015776:	bf00      	nop
 8015778:	200015f4 	.word	0x200015f4
 801577c:	08016ac0 	.word	0x08016ac0

08015780 <UTIL_TIMER_SetPeriod>:
{
 8015780:	b538      	push	{r3, r4, r5, lr}
 8015782:	4604      	mov	r4, r0
  if(NULL == TimerObject)
 8015784:	b1b0      	cbz	r0, 80157b4 <UTIL_TIMER_SetPeriod+0x34>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 8015786:	4b11      	ldr	r3, [pc, #68]	@ (80157cc <UTIL_TIMER_SetPeriod+0x4c>)
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8015788:	4d11      	ldr	r5, [pc, #68]	@ (80157d0 <UTIL_TIMER_SetPeriod+0x50>)
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 801578a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801578c:	4608      	mov	r0, r1
 801578e:	4798      	blx	r3
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8015790:	682b      	ldr	r3, [r5, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 8015792:	6060      	str	r0, [r4, #4]
  while( cur != NULL )
 8015794:	b913      	cbnz	r3, 801579c <UTIL_TIMER_SetPeriod+0x1c>
 8015796:	e00f      	b.n	80157b8 <UTIL_TIMER_SetPeriod+0x38>
    cur = cur->Next;
 8015798:	695b      	ldr	r3, [r3, #20]
  while( cur != NULL )
 801579a:	b16b      	cbz	r3, 80157b8 <UTIL_TIMER_SetPeriod+0x38>
    if( cur == TimerObject )
 801579c:	429c      	cmp	r4, r3
 801579e:	d1fb      	bne.n	8015798 <UTIL_TIMER_SetPeriod+0x18>
      (void)UTIL_TIMER_Stop(TimerObject);
 80157a0:	4620      	mov	r0, r4
 80157a2:	f7ff ffa3 	bl	80156ec <UTIL_TIMER_Stop>
  UTIL_TIMER_Object_t* cur = TimerListHead;
 80157a6:	682b      	ldr	r3, [r5, #0]
  while( cur != NULL )
 80157a8:	b913      	cbnz	r3, 80157b0 <UTIL_TIMER_SetPeriod+0x30>
 80157aa:	e007      	b.n	80157bc <UTIL_TIMER_SetPeriod+0x3c>
    cur = cur->Next;
 80157ac:	695b      	ldr	r3, [r3, #20]
  while( cur != NULL )
 80157ae:	b12b      	cbz	r3, 80157bc <UTIL_TIMER_SetPeriod+0x3c>
    if( cur == TimerObject )
 80157b0:	429c      	cmp	r4, r3
 80157b2:	d1fb      	bne.n	80157ac <UTIL_TIMER_SetPeriod+0x2c>
    ret =  UTIL_TIMER_INVALID_PARAM;
 80157b4:	2001      	movs	r0, #1
}
 80157b6:	bd38      	pop	{r3, r4, r5, pc}
  UTIL_TIMER_Status_t  ret = UTIL_TIMER_OK;
 80157b8:	4618      	mov	r0, r3
}
 80157ba:	bd38      	pop	{r3, r4, r5, pc}
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 80157bc:	7a63      	ldrb	r3, [r4, #9]
 80157be:	2b00      	cmp	r3, #0
 80157c0:	d1f8      	bne.n	80157b4 <UTIL_TIMER_SetPeriod+0x34>
 80157c2:	4620      	mov	r0, r4
}
 80157c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80157c8:	f7ff bee0 	b.w	801558c <UTIL_TIMER_Start.part.0>
 80157cc:	08016ac0 	.word	0x08016ac0
 80157d0:	200015f4 	.word	0x200015f4

080157d4 <UTIL_TIMER_IRQ_Handler>:
{
 80157d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80157d8:	f3ef 8910 	mrs	r9, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80157dc:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 80157de:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 80158b4 <UTIL_TIMER_IRQ_Handler+0xe0>
  if ( TimerListHead != NULL )
 80157e2:	4d35      	ldr	r5, [pc, #212]	@ (80158b8 <UTIL_TIMER_IRQ_Handler+0xe4>)
  old  =  UTIL_TimerDriver.GetTimerContext( );
 80157e4:	f8d8 3014 	ldr.w	r3, [r8, #20]
 80157e8:	4798      	blx	r3
  now  =  UTIL_TimerDriver.SetTimerContext( );
 80157ea:	f8d8 3010 	ldr.w	r3, [r8, #16]
  old  =  UTIL_TimerDriver.GetTimerContext( );
 80157ee:	4606      	mov	r6, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 80157f0:	4798      	blx	r3
  if ( TimerListHead != NULL )
 80157f2:	682c      	ldr	r4, [r5, #0]
 80157f4:	b164      	cbz	r4, 8015810 <UTIL_TIMER_IRQ_Handler+0x3c>
  DeltaContext = now  - old; /*intentional wrap around */
 80157f6:	1b87      	subs	r7, r0, r6
        cur->Timestamp -= DeltaContext;
 80157f8:	1a31      	subs	r1, r6, r0
  DeltaContext = now  - old; /*intentional wrap around */
 80157fa:	4623      	mov	r3, r4
 80157fc:	2600      	movs	r6, #0
      if (cur->Timestamp > DeltaContext)
 80157fe:	681a      	ldr	r2, [r3, #0]
 8015800:	4297      	cmp	r7, r2
        cur->Timestamp -= DeltaContext;
 8015802:	eb01 0002 	add.w	r0, r1, r2
      if (cur->Timestamp > DeltaContext)
 8015806:	d21e      	bcs.n	8015846 <UTIL_TIMER_IRQ_Handler+0x72>
 8015808:	6018      	str	r0, [r3, #0]
      cur = cur->Next;
 801580a:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 801580c:	2b00      	cmp	r3, #0
 801580e:	d1f6      	bne.n	80157fe <UTIL_TIMER_IRQ_Handler+0x2a>
      cur->IsPending = 0;
 8015810:	2700      	movs	r7, #0
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 8015812:	b1a4      	cbz	r4, 801583e <UTIL_TIMER_IRQ_Handler+0x6a>
 8015814:	6826      	ldr	r6, [r4, #0]
 8015816:	b12e      	cbz	r6, 8015824 <UTIL_TIMER_IRQ_Handler+0x50>
 8015818:	f8d8 4018 	ldr.w	r4, [r8, #24]
 801581c:	47a0      	blx	r4
 801581e:	4286      	cmp	r6, r0
 8015820:	d217      	bcs.n	8015852 <UTIL_TIMER_IRQ_Handler+0x7e>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 8015822:	682c      	ldr	r4, [r5, #0]
      TimerListHead = TimerListHead->Next;
 8015824:	6962      	ldr	r2, [r4, #20]
      cur->IsPending = 0;
 8015826:	8127      	strh	r7, [r4, #8]
      cur->Callback(cur->argument);
 8015828:	e9d4 3003 	ldrd	r3, r0, [r4, #12]
      TimerListHead = TimerListHead->Next;
 801582c:	602a      	str	r2, [r5, #0]
      cur->Callback(cur->argument);
 801582e:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 8015830:	8963      	ldrh	r3, [r4, #10]
 8015832:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8015836:	d025      	beq.n	8015884 <UTIL_TIMER_IRQ_Handler+0xb0>
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8015838:	682c      	ldr	r4, [r5, #0]
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 801583a:	2c00      	cmp	r4, #0
 801583c:	d1ea      	bne.n	8015814 <UTIL_TIMER_IRQ_Handler+0x40>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801583e:	f389 8810 	msr	PRIMASK, r9
}
 8015842:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8015846:	601e      	str	r6, [r3, #0]
      cur = cur->Next;
 8015848:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 801584a:	2b00      	cmp	r3, #0
 801584c:	d1d7      	bne.n	80157fe <UTIL_TIMER_IRQ_Handler+0x2a>
      cur->IsPending = 0;
 801584e:	2700      	movs	r7, #0
 8015850:	e7df      	b.n	8015812 <UTIL_TIMER_IRQ_Handler+0x3e>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 8015852:	682d      	ldr	r5, [r5, #0]
 8015854:	2d00      	cmp	r5, #0
 8015856:	d0f2      	beq.n	801583e <UTIL_TIMER_IRQ_Handler+0x6a>
 8015858:	7a2b      	ldrb	r3, [r5, #8]
 801585a:	2b00      	cmp	r3, #0
 801585c:	d1ef      	bne.n	801583e <UTIL_TIMER_IRQ_Handler+0x6a>
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 801585e:	f8d8 3020 	ldr.w	r3, [r8, #32]
 8015862:	4798      	blx	r3
  TimerObject->IsPending = 1;
 8015864:	2301      	movs	r3, #1
 8015866:	722b      	strb	r3, [r5, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8015868:	682f      	ldr	r7, [r5, #0]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 801586a:	4606      	mov	r6, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 801586c:	47a0      	blx	r4
 801586e:	1833      	adds	r3, r6, r0
 8015870:	429f      	cmp	r7, r3
 8015872:	d31a      	bcc.n	80158aa <UTIL_TIMER_IRQ_Handler+0xd6>
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 8015874:	6828      	ldr	r0, [r5, #0]
 8015876:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801587a:	4798      	blx	r3
 801587c:	f389 8810 	msr	PRIMASK, r9
}
 8015880:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8015884:	682a      	ldr	r2, [r5, #0]
  while( cur != NULL )
 8015886:	b142      	cbz	r2, 801589a <UTIL_TIMER_IRQ_Handler+0xc6>
    if( cur == TimerObject )
 8015888:	42a2      	cmp	r2, r4
 801588a:	d00c      	beq.n	80158a6 <UTIL_TIMER_IRQ_Handler+0xd2>
  UTIL_TIMER_Object_t* cur = TimerListHead;
 801588c:	4613      	mov	r3, r2
 801588e:	e001      	b.n	8015894 <UTIL_TIMER_IRQ_Handler+0xc0>
    if( cur == TimerObject )
 8015890:	42a3      	cmp	r3, r4
 8015892:	d008      	beq.n	80158a6 <UTIL_TIMER_IRQ_Handler+0xd2>
    cur = cur->Next;
 8015894:	695b      	ldr	r3, [r3, #20]
  while( cur != NULL )
 8015896:	2b00      	cmp	r3, #0
 8015898:	d1fa      	bne.n	8015890 <UTIL_TIMER_IRQ_Handler+0xbc>
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 801589a:	7a63      	ldrb	r3, [r4, #9]
 801589c:	b91b      	cbnz	r3, 80158a6 <UTIL_TIMER_IRQ_Handler+0xd2>
 801589e:	4620      	mov	r0, r4
 80158a0:	f7ff fe74 	bl	801558c <UTIL_TIMER_Start.part.0>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 80158a4:	682a      	ldr	r2, [r5, #0]
    if( cur == TimerObject )
 80158a6:	4614      	mov	r4, r2
 80158a8:	e7b3      	b.n	8015812 <UTIL_TIMER_IRQ_Handler+0x3e>
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 80158aa:	47a0      	blx	r4
 80158ac:	4430      	add	r0, r6
 80158ae:	6028      	str	r0, [r5, #0]
 80158b0:	e7e1      	b.n	8015876 <UTIL_TIMER_IRQ_Handler+0xa2>
 80158b2:	bf00      	nop
 80158b4:	08016ac0 	.word	0x08016ac0
 80158b8:	200015f4 	.word	0x200015f4

080158bc <UTIL_TIMER_GetCurrentTime>:
{
 80158bc:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 80158be:	4c03      	ldr	r4, [pc, #12]	@ (80158cc <UTIL_TIMER_GetCurrentTime+0x10>)
 80158c0:	69e3      	ldr	r3, [r4, #28]
 80158c2:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 80158c4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
}
 80158c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return  UTIL_TimerDriver.Tick2ms(now);
 80158ca:	4718      	bx	r3
 80158cc:	08016ac0 	.word	0x08016ac0

080158d0 <UTIL_TIMER_GetElapsedTime>:
{
 80158d0:	b570      	push	{r4, r5, r6, lr}
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 80158d2:	4d06      	ldr	r5, [pc, #24]	@ (80158ec <UTIL_TIMER_GetElapsedTime+0x1c>)
 80158d4:	69eb      	ldr	r3, [r5, #28]
{
 80158d6:	4606      	mov	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 80158d8:	4798      	blx	r3
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 80158da:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 80158dc:	4604      	mov	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 80158de:	4630      	mov	r0, r6
 80158e0:	4798      	blx	r3
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 80158e2:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 80158e4:	1a20      	subs	r0, r4, r0
}
 80158e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 80158ea:	4718      	bx	r3
 80158ec:	08016ac0 	.word	0x08016ac0

080158f0 <UTIL_ADV_TRACE_Init>:

/** @addtogroup ADV_TRACE_exported_function
 *  @{
 */
UTIL_ADV_TRACE_Status_t UTIL_ADV_TRACE_Init(void)
{
 80158f0:	b510      	push	{r4, lr}
  /* initialize the Ptr for Read/Write */
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 80158f2:	4808      	ldr	r0, [pc, #32]	@ (8015914 <UTIL_ADV_TRACE_Init+0x24>)
 80158f4:	2218      	movs	r2, #24
 80158f6:	2100      	movs	r1, #0
 80158f8:	f7ff fa28 	bl	8014d4c <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 80158fc:	4806      	ldr	r0, [pc, #24]	@ (8015918 <UTIL_ADV_TRACE_Init+0x28>)
 80158fe:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8015902:	2100      	movs	r1, #0
 8015904:	f7ff fa22 	bl	8014d4c <UTIL_MEM_set_8>
#endif
  /* Allocate Lock resource */
  UTIL_ADV_TRACE_INIT_CRITICAL_SECTION();

  /* Initialize the Low Level interface */
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 8015908:	4b04      	ldr	r3, [pc, #16]	@ (801591c <UTIL_ADV_TRACE_Init+0x2c>)
 801590a:	4805      	ldr	r0, [pc, #20]	@ (8015920 <UTIL_ADV_TRACE_Init+0x30>)
 801590c:	681b      	ldr	r3, [r3, #0]
}
 801590e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 8015912:	4718      	bx	r3
 8015914:	20001bf8 	.word	0x20001bf8
 8015918:	200017f8 	.word	0x200017f8
 801591c:	08016aec 	.word	0x08016aec
 8015920:	08015c2d 	.word	0x08015c2d

08015924 <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
#endif

#if defined(UTIL_ADV_TRACE_CONDITIONNAL)
void UTIL_ADV_TRACE_RegisterTimeStampFunction(cb_timestamp *cb)
{
  ADV_TRACE_Ctx.timestamp_func = *cb;
 8015924:	4b01      	ldr	r3, [pc, #4]	@ (801592c <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 8015926:	6058      	str	r0, [r3, #4]
}
 8015928:	4770      	bx	lr
 801592a:	bf00      	nop
 801592c:	20001bf8 	.word	0x20001bf8

08015930 <UTIL_ADV_TRACE_SetVerboseLevel>:

void UTIL_ADV_TRACE_SetVerboseLevel(uint8_t Level)
{
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 8015930:	4b01      	ldr	r3, [pc, #4]	@ (8015938 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 8015932:	7218      	strb	r0, [r3, #8]
}
 8015934:	4770      	bx	lr
 8015936:	bf00      	nop
 8015938:	20001bf8 	.word	0x20001bf8

0801593c <TRACE_Send>:
/**
 * @brief send the data of the trace to low layer
 * @retval Status based on @ref UTIL_ADV_TRACE_Status_t
 */
static UTIL_ADV_TRACE_Status_t TRACE_Send(void)
{
 801593c:	b530      	push	{r4, r5, lr}
 801593e:	b083      	sub	sp, #12
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015940:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015944:	b672      	cpsid	i
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 8015946:	4c28      	ldr	r4, [pc, #160]	@ (80159e8 <TRACE_Send+0xac>)
  if(TRACE_IsLocked() == 0u)
 8015948:	8ae2      	ldrh	r2, [r4, #22]
 801594a:	b9fa      	cbnz	r2, 801598c <TRACE_Send+0x50>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801594c:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015950:	b672      	cpsid	i
  ADV_TRACE_Ctx.TraceLock++;
 8015952:	8ae3      	ldrh	r3, [r4, #22]
 8015954:	3301      	adds	r3, #1
 8015956:	82e3      	strh	r3, [r4, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8015958:	f380 8810 	msr	PRIMASK, r0
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 801595c:	8a23      	ldrh	r3, [r4, #16]
 801595e:	f8b4 c012 	ldrh.w	ip, [r4, #18]
 8015962:	4563      	cmp	r3, ip
 8015964:	d017      	beq.n	8015996 <TRACE_Send+0x5a>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8015966:	78a0      	ldrb	r0, [r4, #2]
 8015968:	2801      	cmp	r0, #1
 801596a:	d02d      	beq.n	80159c8 <TRACE_Send+0x8c>
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 801596c:	4d1f      	ldr	r5, [pc, #124]	@ (80159ec <TRACE_Send+0xb0>)
 801596e:	441d      	add	r5, r3
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8015970:	b310      	cbz	r0, 80159b8 <TRACE_Send+0x7c>
 8015972:	f381 8810 	msr	PRIMASK, r1
      UTIL_ADV_TRACE_PreSendHook();
 8015976:	f7ec f91d 	bl	8001bb4 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 801597a:	4b1d      	ldr	r3, [pc, #116]	@ (80159f0 <TRACE_Send+0xb4>)
 801597c:	8aa1      	ldrh	r1, [r4, #20]
 801597e:	68db      	ldr	r3, [r3, #12]
 8015980:	9301      	str	r3, [sp, #4]
 8015982:	4628      	mov	r0, r5
}
 8015984:	b003      	add	sp, #12
 8015986:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 801598a:	4718      	bx	r3
 801598c:	f381 8810 	msr	PRIMASK, r1
}
 8015990:	2000      	movs	r0, #0
 8015992:	b003      	add	sp, #12
 8015994:	bd30      	pop	{r4, r5, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015996:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801599a:	b672      	cpsid	i
  ADV_TRACE_Ctx.TraceLock--;
 801599c:	8ae3      	ldrh	r3, [r4, #22]
 801599e:	3b01      	subs	r3, #1
 80159a0:	82e3      	strh	r3, [r4, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80159a2:	f382 8810 	msr	PRIMASK, r2
 80159a6:	f381 8810 	msr	PRIMASK, r1
}
 80159aa:	2000      	movs	r0, #0
 80159ac:	b003      	add	sp, #12
 80159ae:	bd30      	pop	{r4, r5, pc}
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 80159b0:	4d0e      	ldr	r5, [pc, #56]	@ (80159ec <TRACE_Send+0xb0>)
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 80159b2:	70a2      	strb	r2, [r4, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 80159b4:	8222      	strh	r2, [r4, #16]
 80159b6:	4613      	mov	r3, r2
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 80159b8:	459c      	cmp	ip, r3
 80159ba:	d911      	bls.n	80159e0 <TRACE_Send+0xa4>
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 80159bc:	ebac 0c03 	sub.w	ip, ip, r3
 80159c0:	fa1f f38c 	uxth.w	r3, ip
 80159c4:	82a3      	strh	r3, [r4, #20]
 80159c6:	e7d4      	b.n	8015972 <TRACE_Send+0x36>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 80159c8:	8820      	ldrh	r0, [r4, #0]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 80159ca:	8022      	strh	r2, [r4, #0]
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 80159cc:	1ac2      	subs	r2, r0, r3
 80159ce:	b292      	uxth	r2, r2
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 80159d0:	2002      	movs	r0, #2
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 80159d2:	82a2      	strh	r2, [r4, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 80159d4:	70a0      	strb	r0, [r4, #2]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 80159d6:	2a00      	cmp	r2, #0
 80159d8:	d0ea      	beq.n	80159b0 <TRACE_Send+0x74>
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 80159da:	4d04      	ldr	r5, [pc, #16]	@ (80159ec <TRACE_Send+0xb0>)
 80159dc:	441d      	add	r5, r3
 80159de:	e7c8      	b.n	8015972 <TRACE_Send+0x36>
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 80159e0:	f5c3 6380 	rsb	r3, r3, #1024	@ 0x400
 80159e4:	b29b      	uxth	r3, r3
 80159e6:	e7ed      	b.n	80159c4 <TRACE_Send+0x88>
 80159e8:	20001bf8 	.word	0x20001bf8
 80159ec:	200017f8 	.word	0x200017f8
 80159f0:	08016aec 	.word	0x08016aec

080159f4 <UTIL_ADV_TRACE_COND_FSend>:
{
 80159f4:	b408      	push	{r3}
 80159f6:	b530      	push	{r4, r5, lr}
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 80159f8:	4c89      	ldr	r4, [pc, #548]	@ (8015c20 <UTIL_ADV_TRACE_COND_FSend+0x22c>)
{
 80159fa:	b086      	sub	sp, #24
  uint16_t timestamp_size = 0u;
 80159fc:	2300      	movs	r3, #0
 80159fe:	f8ad 3002 	strh.w	r3, [sp, #2]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 8015a02:	7a23      	ldrb	r3, [r4, #8]
{
 8015a04:	9d09      	ldr	r5, [sp, #36]	@ 0x24
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 8015a06:	4283      	cmp	r3, r0
 8015a08:	f0c0 8107 	bcc.w	8015c1a <UTIL_ADV_TRACE_COND_FSend+0x226>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 8015a0c:	68e3      	ldr	r3, [r4, #12]
 8015a0e:	4399      	bics	r1, r3
 8015a10:	f040 8100 	bne.w	8015c14 <UTIL_ADV_TRACE_COND_FSend+0x220>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 8015a14:	6863      	ldr	r3, [r4, #4]
 8015a16:	b113      	cbz	r3, 8015a1e <UTIL_ADV_TRACE_COND_FSend+0x2a>
 8015a18:	2a00      	cmp	r2, #0
 8015a1a:	f040 80ca 	bne.w	8015bb2 <UTIL_ADV_TRACE_COND_FSend+0x1be>
  va_start( vaArgs, strFormat);
 8015a1e:	ab0a      	add	r3, sp, #40	@ 0x28
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8015a20:	462a      	mov	r2, r5
 8015a22:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8015a26:	487f      	ldr	r0, [pc, #508]	@ (8015c24 <UTIL_ADV_TRACE_COND_FSend+0x230>)
  va_start( vaArgs, strFormat);
 8015a28:	9301      	str	r3, [sp, #4]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8015a2a:	f7ff fa7b 	bl	8014f24 <tiny_vsnprintf_like>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015a2e:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015a32:	b672      	cpsid	i
  ADV_TRACE_Ctx.TraceLock++;
 8015a34:	8ae3      	ldrh	r3, [r4, #22]
 8015a36:	3301      	adds	r3, #1
 8015a38:	82e3      	strh	r3, [r4, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8015a3a:	f382 8810 	msr	PRIMASK, r2
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 8015a3e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8015a42:	4403      	add	r3, r0
 8015a44:	b29b      	uxth	r3, r3
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015a46:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015a4a:	b672      	cpsid	i
  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 8015a4c:	8a62      	ldrh	r2, [r4, #18]
 8015a4e:	8a21      	ldrh	r1, [r4, #16]
 8015a50:	428a      	cmp	r2, r1
 8015a52:	f000 80c0 	beq.w	8015bd6 <UTIL_ADV_TRACE_COND_FSend+0x1e2>
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8015a56:	f200 80b1 	bhi.w	8015bbc <UTIL_ADV_TRACE_COND_FSend+0x1c8>
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 8015a5a:	1a89      	subs	r1, r1, r2
  if(freesize > Size)
 8015a5c:	b289      	uxth	r1, r1
 8015a5e:	428b      	cmp	r3, r1
 8015a60:	f080 80c7 	bcs.w	8015bf2 <UTIL_ADV_TRACE_COND_FSend+0x1fe>
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 8015a64:	4413      	add	r3, r2
 8015a66:	b29b      	uxth	r3, r3
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8015a68:	4610      	mov	r0, r2
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 8015a6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8015a6e:	8263      	strh	r3, [r4, #18]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8015a70:	f38c 8810 	msr	PRIMASK, ip
    for (idx = 0u; idx < timestamp_size; idx++)
 8015a74:	f8bd 3002 	ldrh.w	r3, [sp, #2]
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015a78:	496b      	ldr	r1, [pc, #428]	@ (8015c28 <UTIL_ADV_TRACE_COND_FSend+0x234>)
    for (idx = 0u; idx < timestamp_size; idx++)
 8015a7a:	2b00      	cmp	r3, #0
 8015a7c:	f000 8083 	beq.w	8015b86 <UTIL_ADV_TRACE_COND_FSend+0x192>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015a80:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8015a84:	5488      	strb	r0, [r1, r2]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015a86:	2b01      	cmp	r3, #1
      writepos = writepos + 1u;
 8015a88:	f102 0001 	add.w	r0, r2, #1
 8015a8c:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015a8e:	d078      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015a90:	f89d c009 	ldrb.w	ip, [sp, #9]
 8015a94:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015a98:	2b02      	cmp	r3, #2
      writepos = writepos + 1u;
 8015a9a:	f102 0002 	add.w	r0, r2, #2
 8015a9e:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015aa0:	d06f      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015aa2:	f89d c00a 	ldrb.w	ip, [sp, #10]
 8015aa6:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015aaa:	2b03      	cmp	r3, #3
      writepos = writepos + 1u;
 8015aac:	f102 0003 	add.w	r0, r2, #3
 8015ab0:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015ab2:	d066      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015ab4:	f89d c00b 	ldrb.w	ip, [sp, #11]
 8015ab8:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015abc:	2b04      	cmp	r3, #4
      writepos = writepos + 1u;
 8015abe:	f102 0004 	add.w	r0, r2, #4
 8015ac2:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015ac4:	d05d      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015ac6:	f89d c00c 	ldrb.w	ip, [sp, #12]
 8015aca:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015ace:	2b05      	cmp	r3, #5
      writepos = writepos + 1u;
 8015ad0:	f102 0005 	add.w	r0, r2, #5
 8015ad4:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015ad6:	d054      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015ad8:	f89d c00d 	ldrb.w	ip, [sp, #13]
 8015adc:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015ae0:	2b06      	cmp	r3, #6
      writepos = writepos + 1u;
 8015ae2:	f102 0006 	add.w	r0, r2, #6
 8015ae6:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015ae8:	d04b      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015aea:	f89d c00e 	ldrb.w	ip, [sp, #14]
 8015aee:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015af2:	2b07      	cmp	r3, #7
      writepos = writepos + 1u;
 8015af4:	f102 0007 	add.w	r0, r2, #7
 8015af8:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015afa:	d042      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015afc:	f89d c00f 	ldrb.w	ip, [sp, #15]
 8015b00:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b04:	2b08      	cmp	r3, #8
      writepos = writepos + 1u;
 8015b06:	f102 0008 	add.w	r0, r2, #8
 8015b0a:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b0c:	d039      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015b0e:	f89d c010 	ldrb.w	ip, [sp, #16]
 8015b12:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b16:	2b09      	cmp	r3, #9
      writepos = writepos + 1u;
 8015b18:	f102 0009 	add.w	r0, r2, #9
 8015b1c:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b1e:	d030      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015b20:	f89d c011 	ldrb.w	ip, [sp, #17]
 8015b24:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b28:	2b0a      	cmp	r3, #10
      writepos = writepos + 1u;
 8015b2a:	f102 000a 	add.w	r0, r2, #10
 8015b2e:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b30:	d027      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015b32:	f89d c012 	ldrb.w	ip, [sp, #18]
 8015b36:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b3a:	2b0b      	cmp	r3, #11
      writepos = writepos + 1u;
 8015b3c:	f102 000b 	add.w	r0, r2, #11
 8015b40:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b42:	d01e      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015b44:	f89d c013 	ldrb.w	ip, [sp, #19]
 8015b48:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b4c:	2b0c      	cmp	r3, #12
      writepos = writepos + 1u;
 8015b4e:	f102 000c 	add.w	r0, r2, #12
 8015b52:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b54:	d015      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015b56:	f89d c014 	ldrb.w	ip, [sp, #20]
 8015b5a:	f801 c000 	strb.w	ip, [r1, r0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b5e:	2b0d      	cmp	r3, #13
      writepos = writepos + 1u;
 8015b60:	f102 000d 	add.w	r0, r2, #13
 8015b64:	b280      	uxth	r0, r0
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b66:	d00c      	beq.n	8015b82 <UTIL_ADV_TRACE_COND_FSend+0x18e>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015b68:	f89d c015 	ldrb.w	ip, [sp, #21]
 8015b6c:	f801 c000 	strb.w	ip, [r1, r0]
      writepos = writepos + 1u;
 8015b70:	f102 000e 	add.w	r0, r2, #14
    for (idx = 0u; idx < timestamp_size; idx++)
 8015b74:	2b0e      	cmp	r3, #14
      writepos = writepos + 1u;
 8015b76:	b280      	uxth	r0, r0
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8015b78:	bf1c      	itt	ne
 8015b7a:	f89d c016 	ldrbne.w	ip, [sp, #22]
 8015b7e:	f801 c000 	strbne.w	ip, [r1, r0]
      writepos = writepos + 1u;
 8015b82:	4413      	add	r3, r2
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8015b84:	b298      	uxth	r0, r3
 8015b86:	9b01      	ldr	r3, [sp, #4]
 8015b88:	4408      	add	r0, r1
 8015b8a:	462a      	mov	r2, r5
 8015b8c:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8015b90:	f7ff f9c8 	bl	8014f24 <tiny_vsnprintf_like>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015b94:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015b98:	b672      	cpsid	i
  ADV_TRACE_Ctx.TraceLock--;
 8015b9a:	8ae3      	ldrh	r3, [r4, #22]
 8015b9c:	3b01      	subs	r3, #1
 8015b9e:	82e3      	strh	r3, [r4, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8015ba0:	f382 8810 	msr	PRIMASK, r2
    return TRACE_Send();
 8015ba4:	f7ff feca 	bl	801593c <TRACE_Send>
}
 8015ba8:	b006      	add	sp, #24
 8015baa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8015bae:	b001      	add	sp, #4
 8015bb0:	4770      	bx	lr
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 8015bb2:	f10d 0102 	add.w	r1, sp, #2
 8015bb6:	a802      	add	r0, sp, #8
 8015bb8:	4798      	blx	r3
 8015bba:	e730      	b.n	8015a1e <UTIL_ADV_TRACE_COND_FSend+0x2a>
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 8015bbc:	f5c2 6080 	rsb	r0, r2, #1024	@ 0x400
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 8015bc0:	b280      	uxth	r0, r0
 8015bc2:	4283      	cmp	r3, r0
 8015bc4:	f4ff af4e 	bcc.w	8015a64 <UTIL_ADV_TRACE_COND_FSend+0x70>
 8015bc8:	428b      	cmp	r3, r1
 8015bca:	d212      	bcs.n	8015bf2 <UTIL_ADV_TRACE_COND_FSend+0x1fe>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8015bcc:	2101      	movs	r1, #1
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8015bce:	8022      	strh	r2, [r4, #0]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8015bd0:	70a1      	strb	r1, [r4, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8015bd2:	2200      	movs	r2, #0
 8015bd4:	e746      	b.n	8015a64 <UTIL_ADV_TRACE_COND_FSend+0x70>
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 8015bd6:	f5c2 6180 	rsb	r1, r2, #1024	@ 0x400
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 8015bda:	b289      	uxth	r1, r1
 8015bdc:	428b      	cmp	r3, r1
 8015bde:	f4ff af41 	bcc.w	8015a64 <UTIL_ADV_TRACE_COND_FSend+0x70>
 8015be2:	4293      	cmp	r3, r2
 8015be4:	d205      	bcs.n	8015bf2 <UTIL_ADV_TRACE_COND_FSend+0x1fe>
      ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8015be6:	8022      	strh	r2, [r4, #0]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8015be8:	2101      	movs	r1, #1
      ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8015bea:	2200      	movs	r2, #0
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8015bec:	70a1      	strb	r1, [r4, #2]
      ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8015bee:	4610      	mov	r0, r2
 8015bf0:	e73b      	b.n	8015a6a <UTIL_ADV_TRACE_COND_FSend+0x76>
 8015bf2:	f38c 8810 	msr	PRIMASK, ip
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015bf6:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015bfa:	b672      	cpsid	i
  ADV_TRACE_Ctx.TraceLock--;
 8015bfc:	8ae3      	ldrh	r3, [r4, #22]
 8015bfe:	3b01      	subs	r3, #1
 8015c00:	82e3      	strh	r3, [r4, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8015c02:	f382 8810 	msr	PRIMASK, r2
  return UTIL_ADV_TRACE_MEM_FULL;
 8015c06:	f06f 0002 	mvn.w	r0, #2
}
 8015c0a:	b006      	add	sp, #24
 8015c0c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8015c10:	b001      	add	sp, #4
 8015c12:	4770      	bx	lr
    return UTIL_ADV_TRACE_REGIONMASKED;
 8015c14:	f06f 0005 	mvn.w	r0, #5
 8015c18:	e7c6      	b.n	8015ba8 <UTIL_ADV_TRACE_COND_FSend+0x1b4>
    return UTIL_ADV_TRACE_GIVEUP;
 8015c1a:	f06f 0004 	mvn.w	r0, #4
 8015c1e:	e7c3      	b.n	8015ba8 <UTIL_ADV_TRACE_COND_FSend+0x1b4>
 8015c20:	20001bf8 	.word	0x20001bf8
 8015c24:	200015f8 	.word	0x200015f8
 8015c28:	200017f8 	.word	0x200017f8

08015c2c <TRACE_TxCpltCallback>:
{
 8015c2c:	b510      	push	{r4, lr}
 8015c2e:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015c30:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015c34:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 8015c36:	4c25      	ldr	r4, [pc, #148]	@ (8015ccc <TRACE_TxCpltCallback+0xa0>)
 8015c38:	78a2      	ldrb	r2, [r4, #2]
 8015c3a:	2a02      	cmp	r2, #2
 8015c3c:	d019      	beq.n	8015c72 <TRACE_TxCpltCallback+0x46>
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 8015c3e:	8a23      	ldrh	r3, [r4, #16]
 8015c40:	8aa1      	ldrh	r1, [r4, #20]
 8015c42:	440b      	add	r3, r1
 8015c44:	f3c3 0309 	ubfx	r3, r3, #0, #10
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 8015c48:	8a61      	ldrh	r1, [r4, #18]
 8015c4a:	8223      	strh	r3, [r4, #16]
 8015c4c:	4299      	cmp	r1, r3
 8015c4e:	d002      	beq.n	8015c56 <TRACE_TxCpltCallback+0x2a>
 8015c50:	8ae0      	ldrh	r0, [r4, #22]
 8015c52:	2801      	cmp	r0, #1
 8015c54:	d011      	beq.n	8015c7a <TRACE_TxCpltCallback+0x4e>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8015c56:	f38c 8810 	msr	PRIMASK, ip
    UTIL_ADV_TRACE_PostSendHook();
 8015c5a:	f7eb ffaf 	bl	8001bbc <UTIL_ADV_TRACE_PostSendHook>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8015c5e:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8015c62:	b672      	cpsid	i
  ADV_TRACE_Ctx.TraceLock--;
 8015c64:	8ae3      	ldrh	r3, [r4, #22]
 8015c66:	3b01      	subs	r3, #1
 8015c68:	82e3      	strh	r3, [r4, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8015c6a:	f382 8810 	msr	PRIMASK, r2
}
 8015c6e:	b002      	add	sp, #8
 8015c70:	bd10      	pop	{r4, pc}
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8015c72:	2300      	movs	r3, #0
 8015c74:	461a      	mov	r2, r3
 8015c76:	70a3      	strb	r3, [r4, #2]
    UTIL_ADV_TRACE_DEBUG("\nTRACE_TxCpltCallback::unchunk complete\n");
 8015c78:	e7e6      	b.n	8015c48 <TRACE_TxCpltCallback+0x1c>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8015c7a:	2a01      	cmp	r2, #1
 8015c7c:	d011      	beq.n	8015ca2 <TRACE_TxCpltCallback+0x76>
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8015c7e:	4814      	ldr	r0, [pc, #80]	@ (8015cd0 <TRACE_TxCpltCallback+0xa4>)
 8015c80:	4418      	add	r0, r3
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8015c82:	b922      	cbnz	r2, 8015c8e <TRACE_TxCpltCallback+0x62>
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8015c84:	4299      	cmp	r1, r3
 8015c86:	d91a      	bls.n	8015cbe <TRACE_TxCpltCallback+0x92>
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8015c88:	1ac9      	subs	r1, r1, r3
 8015c8a:	b28b      	uxth	r3, r1
 8015c8c:	82a3      	strh	r3, [r4, #20]
 8015c8e:	f38c 8810 	msr	PRIMASK, ip
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8015c92:	4b10      	ldr	r3, [pc, #64]	@ (8015cd4 <TRACE_TxCpltCallback+0xa8>)
 8015c94:	8aa1      	ldrh	r1, [r4, #20]
 8015c96:	68db      	ldr	r3, [r3, #12]
 8015c98:	9301      	str	r3, [sp, #4]
}
 8015c9a:	b002      	add	sp, #8
 8015c9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8015ca0:	4718      	bx	r3
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 8015ca2:	8822      	ldrh	r2, [r4, #0]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 8015ca4:	2002      	movs	r0, #2
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 8015ca6:	1ad2      	subs	r2, r2, r3
 8015ca8:	b292      	uxth	r2, r2
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 8015caa:	70a0      	strb	r0, [r4, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 8015cac:	2000      	movs	r0, #0
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 8015cae:	82a2      	strh	r2, [r4, #20]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 8015cb0:	8020      	strh	r0, [r4, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8015cb2:	b942      	cbnz	r2, 8015cc6 <TRACE_TxCpltCallback+0x9a>
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 8015cb4:	4806      	ldr	r0, [pc, #24]	@ (8015cd0 <TRACE_TxCpltCallback+0xa4>)
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8015cb6:	70a2      	strb	r2, [r4, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 8015cb8:	8222      	strh	r2, [r4, #16]
 8015cba:	4613      	mov	r3, r2
 8015cbc:	e7e2      	b.n	8015c84 <TRACE_TxCpltCallback+0x58>
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 8015cbe:	f5c3 6380 	rsb	r3, r3, #1024	@ 0x400
 8015cc2:	b29b      	uxth	r3, r3
 8015cc4:	e7e2      	b.n	8015c8c <TRACE_TxCpltCallback+0x60>
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8015cc6:	4802      	ldr	r0, [pc, #8]	@ (8015cd0 <TRACE_TxCpltCallback+0xa4>)
 8015cc8:	4418      	add	r0, r3
 8015cca:	e7e0      	b.n	8015c8e <TRACE_TxCpltCallback+0x62>
 8015ccc:	20001bf8 	.word	0x20001bf8
 8015cd0:	200017f8 	.word	0x200017f8
 8015cd4:	08016aec 	.word	0x08016aec

08015cd8 <std>:
 8015cd8:	2300      	movs	r3, #0
 8015cda:	b510      	push	{r4, lr}
 8015cdc:	4604      	mov	r4, r0
 8015cde:	e9c0 3300 	strd	r3, r3, [r0]
 8015ce2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8015ce6:	6083      	str	r3, [r0, #8]
 8015ce8:	8181      	strh	r1, [r0, #12]
 8015cea:	6643      	str	r3, [r0, #100]	@ 0x64
 8015cec:	81c2      	strh	r2, [r0, #14]
 8015cee:	6183      	str	r3, [r0, #24]
 8015cf0:	4619      	mov	r1, r3
 8015cf2:	2208      	movs	r2, #8
 8015cf4:	305c      	adds	r0, #92	@ 0x5c
 8015cf6:	f000 f9e7 	bl	80160c8 <memset>
 8015cfa:	4b0d      	ldr	r3, [pc, #52]	@ (8015d30 <std+0x58>)
 8015cfc:	6263      	str	r3, [r4, #36]	@ 0x24
 8015cfe:	4b0d      	ldr	r3, [pc, #52]	@ (8015d34 <std+0x5c>)
 8015d00:	62a3      	str	r3, [r4, #40]	@ 0x28
 8015d02:	4b0d      	ldr	r3, [pc, #52]	@ (8015d38 <std+0x60>)
 8015d04:	62e3      	str	r3, [r4, #44]	@ 0x2c
 8015d06:	4b0d      	ldr	r3, [pc, #52]	@ (8015d3c <std+0x64>)
 8015d08:	6323      	str	r3, [r4, #48]	@ 0x30
 8015d0a:	4b0d      	ldr	r3, [pc, #52]	@ (8015d40 <std+0x68>)
 8015d0c:	6224      	str	r4, [r4, #32]
 8015d0e:	429c      	cmp	r4, r3
 8015d10:	d006      	beq.n	8015d20 <std+0x48>
 8015d12:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8015d16:	4294      	cmp	r4, r2
 8015d18:	d002      	beq.n	8015d20 <std+0x48>
 8015d1a:	33d0      	adds	r3, #208	@ 0xd0
 8015d1c:	429c      	cmp	r4, r3
 8015d1e:	d105      	bne.n	8015d2c <std+0x54>
 8015d20:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8015d24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8015d28:	f000 ba46 	b.w	80161b8 <__retarget_lock_init_recursive>
 8015d2c:	bd10      	pop	{r4, pc}
 8015d2e:	bf00      	nop
 8015d30:	08015f19 	.word	0x08015f19
 8015d34:	08015f3b 	.word	0x08015f3b
 8015d38:	08015f73 	.word	0x08015f73
 8015d3c:	08015f97 	.word	0x08015f97
 8015d40:	20001c10 	.word	0x20001c10

08015d44 <stdio_exit_handler>:
 8015d44:	4a02      	ldr	r2, [pc, #8]	@ (8015d50 <stdio_exit_handler+0xc>)
 8015d46:	4903      	ldr	r1, [pc, #12]	@ (8015d54 <stdio_exit_handler+0x10>)
 8015d48:	4803      	ldr	r0, [pc, #12]	@ (8015d58 <stdio_exit_handler+0x14>)
 8015d4a:	f000 b869 	b.w	8015e20 <_fwalk_sglue>
 8015d4e:	bf00      	nop
 8015d50:	2000011c 	.word	0x2000011c
 8015d54:	080164b1 	.word	0x080164b1
 8015d58:	2000012c 	.word	0x2000012c

08015d5c <cleanup_stdio>:
 8015d5c:	6841      	ldr	r1, [r0, #4]
 8015d5e:	4b0c      	ldr	r3, [pc, #48]	@ (8015d90 <cleanup_stdio+0x34>)
 8015d60:	4299      	cmp	r1, r3
 8015d62:	b510      	push	{r4, lr}
 8015d64:	4604      	mov	r4, r0
 8015d66:	d001      	beq.n	8015d6c <cleanup_stdio+0x10>
 8015d68:	f000 fba2 	bl	80164b0 <_fflush_r>
 8015d6c:	68a1      	ldr	r1, [r4, #8]
 8015d6e:	4b09      	ldr	r3, [pc, #36]	@ (8015d94 <cleanup_stdio+0x38>)
 8015d70:	4299      	cmp	r1, r3
 8015d72:	d002      	beq.n	8015d7a <cleanup_stdio+0x1e>
 8015d74:	4620      	mov	r0, r4
 8015d76:	f000 fb9b 	bl	80164b0 <_fflush_r>
 8015d7a:	68e1      	ldr	r1, [r4, #12]
 8015d7c:	4b06      	ldr	r3, [pc, #24]	@ (8015d98 <cleanup_stdio+0x3c>)
 8015d7e:	4299      	cmp	r1, r3
 8015d80:	d004      	beq.n	8015d8c <cleanup_stdio+0x30>
 8015d82:	4620      	mov	r0, r4
 8015d84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8015d88:	f000 bb92 	b.w	80164b0 <_fflush_r>
 8015d8c:	bd10      	pop	{r4, pc}
 8015d8e:	bf00      	nop
 8015d90:	20001c10 	.word	0x20001c10
 8015d94:	20001c78 	.word	0x20001c78
 8015d98:	20001ce0 	.word	0x20001ce0

08015d9c <global_stdio_init.part.0>:
 8015d9c:	b510      	push	{r4, lr}
 8015d9e:	4b0b      	ldr	r3, [pc, #44]	@ (8015dcc <global_stdio_init.part.0+0x30>)
 8015da0:	4c0b      	ldr	r4, [pc, #44]	@ (8015dd0 <global_stdio_init.part.0+0x34>)
 8015da2:	4a0c      	ldr	r2, [pc, #48]	@ (8015dd4 <global_stdio_init.part.0+0x38>)
 8015da4:	601a      	str	r2, [r3, #0]
 8015da6:	4620      	mov	r0, r4
 8015da8:	2200      	movs	r2, #0
 8015daa:	2104      	movs	r1, #4
 8015dac:	f7ff ff94 	bl	8015cd8 <std>
 8015db0:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8015db4:	2201      	movs	r2, #1
 8015db6:	2109      	movs	r1, #9
 8015db8:	f7ff ff8e 	bl	8015cd8 <std>
 8015dbc:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8015dc0:	2202      	movs	r2, #2
 8015dc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8015dc6:	2112      	movs	r1, #18
 8015dc8:	f7ff bf86 	b.w	8015cd8 <std>
 8015dcc:	20001d48 	.word	0x20001d48
 8015dd0:	20001c10 	.word	0x20001c10
 8015dd4:	08015d45 	.word	0x08015d45

08015dd8 <__sfp_lock_acquire>:
 8015dd8:	4801      	ldr	r0, [pc, #4]	@ (8015de0 <__sfp_lock_acquire+0x8>)
 8015dda:	f000 b9ee 	b.w	80161ba <__retarget_lock_acquire_recursive>
 8015dde:	bf00      	nop
 8015de0:	20001d51 	.word	0x20001d51

08015de4 <__sfp_lock_release>:
 8015de4:	4801      	ldr	r0, [pc, #4]	@ (8015dec <__sfp_lock_release+0x8>)
 8015de6:	f000 b9e9 	b.w	80161bc <__retarget_lock_release_recursive>
 8015dea:	bf00      	nop
 8015dec:	20001d51 	.word	0x20001d51

08015df0 <__sinit>:
 8015df0:	b510      	push	{r4, lr}
 8015df2:	4604      	mov	r4, r0
 8015df4:	f7ff fff0 	bl	8015dd8 <__sfp_lock_acquire>
 8015df8:	6a23      	ldr	r3, [r4, #32]
 8015dfa:	b11b      	cbz	r3, 8015e04 <__sinit+0x14>
 8015dfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8015e00:	f7ff bff0 	b.w	8015de4 <__sfp_lock_release>
 8015e04:	4b04      	ldr	r3, [pc, #16]	@ (8015e18 <__sinit+0x28>)
 8015e06:	6223      	str	r3, [r4, #32]
 8015e08:	4b04      	ldr	r3, [pc, #16]	@ (8015e1c <__sinit+0x2c>)
 8015e0a:	681b      	ldr	r3, [r3, #0]
 8015e0c:	2b00      	cmp	r3, #0
 8015e0e:	d1f5      	bne.n	8015dfc <__sinit+0xc>
 8015e10:	f7ff ffc4 	bl	8015d9c <global_stdio_init.part.0>
 8015e14:	e7f2      	b.n	8015dfc <__sinit+0xc>
 8015e16:	bf00      	nop
 8015e18:	08015d5d 	.word	0x08015d5d
 8015e1c:	20001d48 	.word	0x20001d48

08015e20 <_fwalk_sglue>:
 8015e20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015e24:	4607      	mov	r7, r0
 8015e26:	4688      	mov	r8, r1
 8015e28:	4614      	mov	r4, r2
 8015e2a:	2600      	movs	r6, #0
 8015e2c:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8015e30:	f1b9 0901 	subs.w	r9, r9, #1
 8015e34:	d505      	bpl.n	8015e42 <_fwalk_sglue+0x22>
 8015e36:	6824      	ldr	r4, [r4, #0]
 8015e38:	2c00      	cmp	r4, #0
 8015e3a:	d1f7      	bne.n	8015e2c <_fwalk_sglue+0xc>
 8015e3c:	4630      	mov	r0, r6
 8015e3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8015e42:	89ab      	ldrh	r3, [r5, #12]
 8015e44:	2b01      	cmp	r3, #1
 8015e46:	d907      	bls.n	8015e58 <_fwalk_sglue+0x38>
 8015e48:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8015e4c:	3301      	adds	r3, #1
 8015e4e:	d003      	beq.n	8015e58 <_fwalk_sglue+0x38>
 8015e50:	4629      	mov	r1, r5
 8015e52:	4638      	mov	r0, r7
 8015e54:	47c0      	blx	r8
 8015e56:	4306      	orrs	r6, r0
 8015e58:	3568      	adds	r5, #104	@ 0x68
 8015e5a:	e7e9      	b.n	8015e30 <_fwalk_sglue+0x10>

08015e5c <_puts_r>:
 8015e5c:	6a03      	ldr	r3, [r0, #32]
 8015e5e:	b570      	push	{r4, r5, r6, lr}
 8015e60:	6884      	ldr	r4, [r0, #8]
 8015e62:	4605      	mov	r5, r0
 8015e64:	460e      	mov	r6, r1
 8015e66:	b90b      	cbnz	r3, 8015e6c <_puts_r+0x10>
 8015e68:	f7ff ffc2 	bl	8015df0 <__sinit>
 8015e6c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8015e6e:	07db      	lsls	r3, r3, #31
 8015e70:	d405      	bmi.n	8015e7e <_puts_r+0x22>
 8015e72:	89a3      	ldrh	r3, [r4, #12]
 8015e74:	0598      	lsls	r0, r3, #22
 8015e76:	d402      	bmi.n	8015e7e <_puts_r+0x22>
 8015e78:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8015e7a:	f000 f99e 	bl	80161ba <__retarget_lock_acquire_recursive>
 8015e7e:	89a3      	ldrh	r3, [r4, #12]
 8015e80:	0719      	lsls	r1, r3, #28
 8015e82:	d502      	bpl.n	8015e8a <_puts_r+0x2e>
 8015e84:	6923      	ldr	r3, [r4, #16]
 8015e86:	2b00      	cmp	r3, #0
 8015e88:	d135      	bne.n	8015ef6 <_puts_r+0x9a>
 8015e8a:	4621      	mov	r1, r4
 8015e8c:	4628      	mov	r0, r5
 8015e8e:	f000 f8c5 	bl	801601c <__swsetup_r>
 8015e92:	b380      	cbz	r0, 8015ef6 <_puts_r+0x9a>
 8015e94:	f04f 35ff 	mov.w	r5, #4294967295
 8015e98:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8015e9a:	07da      	lsls	r2, r3, #31
 8015e9c:	d405      	bmi.n	8015eaa <_puts_r+0x4e>
 8015e9e:	89a3      	ldrh	r3, [r4, #12]
 8015ea0:	059b      	lsls	r3, r3, #22
 8015ea2:	d402      	bmi.n	8015eaa <_puts_r+0x4e>
 8015ea4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8015ea6:	f000 f989 	bl	80161bc <__retarget_lock_release_recursive>
 8015eaa:	4628      	mov	r0, r5
 8015eac:	bd70      	pop	{r4, r5, r6, pc}
 8015eae:	2b00      	cmp	r3, #0
 8015eb0:	da04      	bge.n	8015ebc <_puts_r+0x60>
 8015eb2:	69a2      	ldr	r2, [r4, #24]
 8015eb4:	429a      	cmp	r2, r3
 8015eb6:	dc17      	bgt.n	8015ee8 <_puts_r+0x8c>
 8015eb8:	290a      	cmp	r1, #10
 8015eba:	d015      	beq.n	8015ee8 <_puts_r+0x8c>
 8015ebc:	6823      	ldr	r3, [r4, #0]
 8015ebe:	1c5a      	adds	r2, r3, #1
 8015ec0:	6022      	str	r2, [r4, #0]
 8015ec2:	7019      	strb	r1, [r3, #0]
 8015ec4:	68a3      	ldr	r3, [r4, #8]
 8015ec6:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8015eca:	3b01      	subs	r3, #1
 8015ecc:	60a3      	str	r3, [r4, #8]
 8015ece:	2900      	cmp	r1, #0
 8015ed0:	d1ed      	bne.n	8015eae <_puts_r+0x52>
 8015ed2:	2b00      	cmp	r3, #0
 8015ed4:	da11      	bge.n	8015efa <_puts_r+0x9e>
 8015ed6:	4622      	mov	r2, r4
 8015ed8:	210a      	movs	r1, #10
 8015eda:	4628      	mov	r0, r5
 8015edc:	f000 f85f 	bl	8015f9e <__swbuf_r>
 8015ee0:	3001      	adds	r0, #1
 8015ee2:	d0d7      	beq.n	8015e94 <_puts_r+0x38>
 8015ee4:	250a      	movs	r5, #10
 8015ee6:	e7d7      	b.n	8015e98 <_puts_r+0x3c>
 8015ee8:	4622      	mov	r2, r4
 8015eea:	4628      	mov	r0, r5
 8015eec:	f000 f857 	bl	8015f9e <__swbuf_r>
 8015ef0:	3001      	adds	r0, #1
 8015ef2:	d1e7      	bne.n	8015ec4 <_puts_r+0x68>
 8015ef4:	e7ce      	b.n	8015e94 <_puts_r+0x38>
 8015ef6:	3e01      	subs	r6, #1
 8015ef8:	e7e4      	b.n	8015ec4 <_puts_r+0x68>
 8015efa:	6823      	ldr	r3, [r4, #0]
 8015efc:	1c5a      	adds	r2, r3, #1
 8015efe:	6022      	str	r2, [r4, #0]
 8015f00:	220a      	movs	r2, #10
 8015f02:	701a      	strb	r2, [r3, #0]
 8015f04:	e7ee      	b.n	8015ee4 <_puts_r+0x88>
	...

08015f08 <puts>:
 8015f08:	4b02      	ldr	r3, [pc, #8]	@ (8015f14 <puts+0xc>)
 8015f0a:	4601      	mov	r1, r0
 8015f0c:	6818      	ldr	r0, [r3, #0]
 8015f0e:	f7ff bfa5 	b.w	8015e5c <_puts_r>
 8015f12:	bf00      	nop
 8015f14:	20000128 	.word	0x20000128

08015f18 <__sread>:
 8015f18:	b510      	push	{r4, lr}
 8015f1a:	460c      	mov	r4, r1
 8015f1c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015f20:	f000 f8fc 	bl	801611c <_read_r>
 8015f24:	2800      	cmp	r0, #0
 8015f26:	bfab      	itete	ge
 8015f28:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8015f2a:	89a3      	ldrhlt	r3, [r4, #12]
 8015f2c:	181b      	addge	r3, r3, r0
 8015f2e:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 8015f32:	bfac      	ite	ge
 8015f34:	6563      	strge	r3, [r4, #84]	@ 0x54
 8015f36:	81a3      	strhlt	r3, [r4, #12]
 8015f38:	bd10      	pop	{r4, pc}

08015f3a <__swrite>:
 8015f3a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015f3e:	461f      	mov	r7, r3
 8015f40:	898b      	ldrh	r3, [r1, #12]
 8015f42:	05db      	lsls	r3, r3, #23
 8015f44:	4605      	mov	r5, r0
 8015f46:	460c      	mov	r4, r1
 8015f48:	4616      	mov	r6, r2
 8015f4a:	d505      	bpl.n	8015f58 <__swrite+0x1e>
 8015f4c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015f50:	2302      	movs	r3, #2
 8015f52:	2200      	movs	r2, #0
 8015f54:	f000 f8d0 	bl	80160f8 <_lseek_r>
 8015f58:	89a3      	ldrh	r3, [r4, #12]
 8015f5a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8015f5e:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8015f62:	81a3      	strh	r3, [r4, #12]
 8015f64:	4632      	mov	r2, r6
 8015f66:	463b      	mov	r3, r7
 8015f68:	4628      	mov	r0, r5
 8015f6a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8015f6e:	f000 b8e7 	b.w	8016140 <_write_r>

08015f72 <__sseek>:
 8015f72:	b510      	push	{r4, lr}
 8015f74:	460c      	mov	r4, r1
 8015f76:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015f7a:	f000 f8bd 	bl	80160f8 <_lseek_r>
 8015f7e:	1c43      	adds	r3, r0, #1
 8015f80:	89a3      	ldrh	r3, [r4, #12]
 8015f82:	bf15      	itete	ne
 8015f84:	6560      	strne	r0, [r4, #84]	@ 0x54
 8015f86:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8015f8a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8015f8e:	81a3      	strheq	r3, [r4, #12]
 8015f90:	bf18      	it	ne
 8015f92:	81a3      	strhne	r3, [r4, #12]
 8015f94:	bd10      	pop	{r4, pc}

08015f96 <__sclose>:
 8015f96:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015f9a:	f000 b89d 	b.w	80160d8 <_close_r>

08015f9e <__swbuf_r>:
 8015f9e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015fa0:	460e      	mov	r6, r1
 8015fa2:	4614      	mov	r4, r2
 8015fa4:	4605      	mov	r5, r0
 8015fa6:	b118      	cbz	r0, 8015fb0 <__swbuf_r+0x12>
 8015fa8:	6a03      	ldr	r3, [r0, #32]
 8015faa:	b90b      	cbnz	r3, 8015fb0 <__swbuf_r+0x12>
 8015fac:	f7ff ff20 	bl	8015df0 <__sinit>
 8015fb0:	69a3      	ldr	r3, [r4, #24]
 8015fb2:	60a3      	str	r3, [r4, #8]
 8015fb4:	89a3      	ldrh	r3, [r4, #12]
 8015fb6:	071a      	lsls	r2, r3, #28
 8015fb8:	d501      	bpl.n	8015fbe <__swbuf_r+0x20>
 8015fba:	6923      	ldr	r3, [r4, #16]
 8015fbc:	b943      	cbnz	r3, 8015fd0 <__swbuf_r+0x32>
 8015fbe:	4621      	mov	r1, r4
 8015fc0:	4628      	mov	r0, r5
 8015fc2:	f000 f82b 	bl	801601c <__swsetup_r>
 8015fc6:	b118      	cbz	r0, 8015fd0 <__swbuf_r+0x32>
 8015fc8:	f04f 37ff 	mov.w	r7, #4294967295
 8015fcc:	4638      	mov	r0, r7
 8015fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015fd0:	6823      	ldr	r3, [r4, #0]
 8015fd2:	6922      	ldr	r2, [r4, #16]
 8015fd4:	1a98      	subs	r0, r3, r2
 8015fd6:	6963      	ldr	r3, [r4, #20]
 8015fd8:	b2f6      	uxtb	r6, r6
 8015fda:	4283      	cmp	r3, r0
 8015fdc:	4637      	mov	r7, r6
 8015fde:	dc05      	bgt.n	8015fec <__swbuf_r+0x4e>
 8015fe0:	4621      	mov	r1, r4
 8015fe2:	4628      	mov	r0, r5
 8015fe4:	f000 fa64 	bl	80164b0 <_fflush_r>
 8015fe8:	2800      	cmp	r0, #0
 8015fea:	d1ed      	bne.n	8015fc8 <__swbuf_r+0x2a>
 8015fec:	68a3      	ldr	r3, [r4, #8]
 8015fee:	3b01      	subs	r3, #1
 8015ff0:	60a3      	str	r3, [r4, #8]
 8015ff2:	6823      	ldr	r3, [r4, #0]
 8015ff4:	1c5a      	adds	r2, r3, #1
 8015ff6:	6022      	str	r2, [r4, #0]
 8015ff8:	701e      	strb	r6, [r3, #0]
 8015ffa:	6962      	ldr	r2, [r4, #20]
 8015ffc:	1c43      	adds	r3, r0, #1
 8015ffe:	429a      	cmp	r2, r3
 8016000:	d004      	beq.n	801600c <__swbuf_r+0x6e>
 8016002:	89a3      	ldrh	r3, [r4, #12]
 8016004:	07db      	lsls	r3, r3, #31
 8016006:	d5e1      	bpl.n	8015fcc <__swbuf_r+0x2e>
 8016008:	2e0a      	cmp	r6, #10
 801600a:	d1df      	bne.n	8015fcc <__swbuf_r+0x2e>
 801600c:	4621      	mov	r1, r4
 801600e:	4628      	mov	r0, r5
 8016010:	f000 fa4e 	bl	80164b0 <_fflush_r>
 8016014:	2800      	cmp	r0, #0
 8016016:	d0d9      	beq.n	8015fcc <__swbuf_r+0x2e>
 8016018:	e7d6      	b.n	8015fc8 <__swbuf_r+0x2a>
	...

0801601c <__swsetup_r>:
 801601c:	b538      	push	{r3, r4, r5, lr}
 801601e:	4b29      	ldr	r3, [pc, #164]	@ (80160c4 <__swsetup_r+0xa8>)
 8016020:	4605      	mov	r5, r0
 8016022:	6818      	ldr	r0, [r3, #0]
 8016024:	460c      	mov	r4, r1
 8016026:	b118      	cbz	r0, 8016030 <__swsetup_r+0x14>
 8016028:	6a03      	ldr	r3, [r0, #32]
 801602a:	b90b      	cbnz	r3, 8016030 <__swsetup_r+0x14>
 801602c:	f7ff fee0 	bl	8015df0 <__sinit>
 8016030:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8016034:	0719      	lsls	r1, r3, #28
 8016036:	d422      	bmi.n	801607e <__swsetup_r+0x62>
 8016038:	06da      	lsls	r2, r3, #27
 801603a:	d407      	bmi.n	801604c <__swsetup_r+0x30>
 801603c:	2209      	movs	r2, #9
 801603e:	602a      	str	r2, [r5, #0]
 8016040:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016044:	81a3      	strh	r3, [r4, #12]
 8016046:	f04f 30ff 	mov.w	r0, #4294967295
 801604a:	e033      	b.n	80160b4 <__swsetup_r+0x98>
 801604c:	0758      	lsls	r0, r3, #29
 801604e:	d512      	bpl.n	8016076 <__swsetup_r+0x5a>
 8016050:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8016052:	b141      	cbz	r1, 8016066 <__swsetup_r+0x4a>
 8016054:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8016058:	4299      	cmp	r1, r3
 801605a:	d002      	beq.n	8016062 <__swsetup_r+0x46>
 801605c:	4628      	mov	r0, r5
 801605e:	f000 f8af 	bl	80161c0 <_free_r>
 8016062:	2300      	movs	r3, #0
 8016064:	6363      	str	r3, [r4, #52]	@ 0x34
 8016066:	89a3      	ldrh	r3, [r4, #12]
 8016068:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 801606c:	81a3      	strh	r3, [r4, #12]
 801606e:	2300      	movs	r3, #0
 8016070:	6063      	str	r3, [r4, #4]
 8016072:	6923      	ldr	r3, [r4, #16]
 8016074:	6023      	str	r3, [r4, #0]
 8016076:	89a3      	ldrh	r3, [r4, #12]
 8016078:	f043 0308 	orr.w	r3, r3, #8
 801607c:	81a3      	strh	r3, [r4, #12]
 801607e:	6923      	ldr	r3, [r4, #16]
 8016080:	b94b      	cbnz	r3, 8016096 <__swsetup_r+0x7a>
 8016082:	89a3      	ldrh	r3, [r4, #12]
 8016084:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8016088:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801608c:	d003      	beq.n	8016096 <__swsetup_r+0x7a>
 801608e:	4621      	mov	r1, r4
 8016090:	4628      	mov	r0, r5
 8016092:	f000 fa5b 	bl	801654c <__smakebuf_r>
 8016096:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801609a:	f013 0201 	ands.w	r2, r3, #1
 801609e:	d00a      	beq.n	80160b6 <__swsetup_r+0x9a>
 80160a0:	2200      	movs	r2, #0
 80160a2:	60a2      	str	r2, [r4, #8]
 80160a4:	6962      	ldr	r2, [r4, #20]
 80160a6:	4252      	negs	r2, r2
 80160a8:	61a2      	str	r2, [r4, #24]
 80160aa:	6922      	ldr	r2, [r4, #16]
 80160ac:	b942      	cbnz	r2, 80160c0 <__swsetup_r+0xa4>
 80160ae:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 80160b2:	d1c5      	bne.n	8016040 <__swsetup_r+0x24>
 80160b4:	bd38      	pop	{r3, r4, r5, pc}
 80160b6:	0799      	lsls	r1, r3, #30
 80160b8:	bf58      	it	pl
 80160ba:	6962      	ldrpl	r2, [r4, #20]
 80160bc:	60a2      	str	r2, [r4, #8]
 80160be:	e7f4      	b.n	80160aa <__swsetup_r+0x8e>
 80160c0:	2000      	movs	r0, #0
 80160c2:	e7f7      	b.n	80160b4 <__swsetup_r+0x98>
 80160c4:	20000128 	.word	0x20000128

080160c8 <memset>:
 80160c8:	4402      	add	r2, r0
 80160ca:	4603      	mov	r3, r0
 80160cc:	4293      	cmp	r3, r2
 80160ce:	d100      	bne.n	80160d2 <memset+0xa>
 80160d0:	4770      	bx	lr
 80160d2:	f803 1b01 	strb.w	r1, [r3], #1
 80160d6:	e7f9      	b.n	80160cc <memset+0x4>

080160d8 <_close_r>:
 80160d8:	b538      	push	{r3, r4, r5, lr}
 80160da:	4d06      	ldr	r5, [pc, #24]	@ (80160f4 <_close_r+0x1c>)
 80160dc:	2300      	movs	r3, #0
 80160de:	4604      	mov	r4, r0
 80160e0:	4608      	mov	r0, r1
 80160e2:	602b      	str	r3, [r5, #0]
 80160e4:	f7eb fdca 	bl	8001c7c <_close>
 80160e8:	1c43      	adds	r3, r0, #1
 80160ea:	d102      	bne.n	80160f2 <_close_r+0x1a>
 80160ec:	682b      	ldr	r3, [r5, #0]
 80160ee:	b103      	cbz	r3, 80160f2 <_close_r+0x1a>
 80160f0:	6023      	str	r3, [r4, #0]
 80160f2:	bd38      	pop	{r3, r4, r5, pc}
 80160f4:	20001d4c 	.word	0x20001d4c

080160f8 <_lseek_r>:
 80160f8:	b538      	push	{r3, r4, r5, lr}
 80160fa:	4d07      	ldr	r5, [pc, #28]	@ (8016118 <_lseek_r+0x20>)
 80160fc:	4604      	mov	r4, r0
 80160fe:	4608      	mov	r0, r1
 8016100:	4611      	mov	r1, r2
 8016102:	2200      	movs	r2, #0
 8016104:	602a      	str	r2, [r5, #0]
 8016106:	461a      	mov	r2, r3
 8016108:	f7eb fdc4 	bl	8001c94 <_lseek>
 801610c:	1c43      	adds	r3, r0, #1
 801610e:	d102      	bne.n	8016116 <_lseek_r+0x1e>
 8016110:	682b      	ldr	r3, [r5, #0]
 8016112:	b103      	cbz	r3, 8016116 <_lseek_r+0x1e>
 8016114:	6023      	str	r3, [r4, #0]
 8016116:	bd38      	pop	{r3, r4, r5, pc}
 8016118:	20001d4c 	.word	0x20001d4c

0801611c <_read_r>:
 801611c:	b538      	push	{r3, r4, r5, lr}
 801611e:	4d07      	ldr	r5, [pc, #28]	@ (801613c <_read_r+0x20>)
 8016120:	4604      	mov	r4, r0
 8016122:	4608      	mov	r0, r1
 8016124:	4611      	mov	r1, r2
 8016126:	2200      	movs	r2, #0
 8016128:	602a      	str	r2, [r5, #0]
 801612a:	461a      	mov	r2, r3
 801612c:	f7eb fd8a 	bl	8001c44 <_read>
 8016130:	1c43      	adds	r3, r0, #1
 8016132:	d102      	bne.n	801613a <_read_r+0x1e>
 8016134:	682b      	ldr	r3, [r5, #0]
 8016136:	b103      	cbz	r3, 801613a <_read_r+0x1e>
 8016138:	6023      	str	r3, [r4, #0]
 801613a:	bd38      	pop	{r3, r4, r5, pc}
 801613c:	20001d4c 	.word	0x20001d4c

08016140 <_write_r>:
 8016140:	b538      	push	{r3, r4, r5, lr}
 8016142:	4d07      	ldr	r5, [pc, #28]	@ (8016160 <_write_r+0x20>)
 8016144:	4604      	mov	r4, r0
 8016146:	4608      	mov	r0, r1
 8016148:	4611      	mov	r1, r2
 801614a:	2200      	movs	r2, #0
 801614c:	602a      	str	r2, [r5, #0]
 801614e:	461a      	mov	r2, r3
 8016150:	f7eb fd86 	bl	8001c60 <_write>
 8016154:	1c43      	adds	r3, r0, #1
 8016156:	d102      	bne.n	801615e <_write_r+0x1e>
 8016158:	682b      	ldr	r3, [r5, #0]
 801615a:	b103      	cbz	r3, 801615e <_write_r+0x1e>
 801615c:	6023      	str	r3, [r4, #0]
 801615e:	bd38      	pop	{r3, r4, r5, pc}
 8016160:	20001d4c 	.word	0x20001d4c

08016164 <__errno>:
 8016164:	4b01      	ldr	r3, [pc, #4]	@ (801616c <__errno+0x8>)
 8016166:	6818      	ldr	r0, [r3, #0]
 8016168:	4770      	bx	lr
 801616a:	bf00      	nop
 801616c:	20000128 	.word	0x20000128

08016170 <__libc_init_array>:
 8016170:	b570      	push	{r4, r5, r6, lr}
 8016172:	4d0d      	ldr	r5, [pc, #52]	@ (80161a8 <__libc_init_array+0x38>)
 8016174:	4c0d      	ldr	r4, [pc, #52]	@ (80161ac <__libc_init_array+0x3c>)
 8016176:	1b64      	subs	r4, r4, r5
 8016178:	10a4      	asrs	r4, r4, #2
 801617a:	2600      	movs	r6, #0
 801617c:	42a6      	cmp	r6, r4
 801617e:	d109      	bne.n	8016194 <__libc_init_array+0x24>
 8016180:	4d0b      	ldr	r5, [pc, #44]	@ (80161b0 <__libc_init_array+0x40>)
 8016182:	4c0c      	ldr	r4, [pc, #48]	@ (80161b4 <__libc_init_array+0x44>)
 8016184:	f000 fad0 	bl	8016728 <_init>
 8016188:	1b64      	subs	r4, r4, r5
 801618a:	10a4      	asrs	r4, r4, #2
 801618c:	2600      	movs	r6, #0
 801618e:	42a6      	cmp	r6, r4
 8016190:	d105      	bne.n	801619e <__libc_init_array+0x2e>
 8016192:	bd70      	pop	{r4, r5, r6, pc}
 8016194:	f855 3b04 	ldr.w	r3, [r5], #4
 8016198:	4798      	blx	r3
 801619a:	3601      	adds	r6, #1
 801619c:	e7ee      	b.n	801617c <__libc_init_array+0xc>
 801619e:	f855 3b04 	ldr.w	r3, [r5], #4
 80161a2:	4798      	blx	r3
 80161a4:	3601      	adds	r6, #1
 80161a6:	e7f2      	b.n	801618e <__libc_init_array+0x1e>
 80161a8:	080178dc 	.word	0x080178dc
 80161ac:	080178dc 	.word	0x080178dc
 80161b0:	080178dc 	.word	0x080178dc
 80161b4:	080178e0 	.word	0x080178e0

080161b8 <__retarget_lock_init_recursive>:
 80161b8:	4770      	bx	lr

080161ba <__retarget_lock_acquire_recursive>:
 80161ba:	4770      	bx	lr

080161bc <__retarget_lock_release_recursive>:
 80161bc:	4770      	bx	lr
	...

080161c0 <_free_r>:
 80161c0:	b538      	push	{r3, r4, r5, lr}
 80161c2:	4605      	mov	r5, r0
 80161c4:	2900      	cmp	r1, #0
 80161c6:	d041      	beq.n	801624c <_free_r+0x8c>
 80161c8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80161cc:	1f0c      	subs	r4, r1, #4
 80161ce:	2b00      	cmp	r3, #0
 80161d0:	bfb8      	it	lt
 80161d2:	18e4      	addlt	r4, r4, r3
 80161d4:	f000 f8e0 	bl	8016398 <__malloc_lock>
 80161d8:	4a1d      	ldr	r2, [pc, #116]	@ (8016250 <_free_r+0x90>)
 80161da:	6813      	ldr	r3, [r2, #0]
 80161dc:	b933      	cbnz	r3, 80161ec <_free_r+0x2c>
 80161de:	6063      	str	r3, [r4, #4]
 80161e0:	6014      	str	r4, [r2, #0]
 80161e2:	4628      	mov	r0, r5
 80161e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80161e8:	f000 b8dc 	b.w	80163a4 <__malloc_unlock>
 80161ec:	42a3      	cmp	r3, r4
 80161ee:	d908      	bls.n	8016202 <_free_r+0x42>
 80161f0:	6820      	ldr	r0, [r4, #0]
 80161f2:	1821      	adds	r1, r4, r0
 80161f4:	428b      	cmp	r3, r1
 80161f6:	bf01      	itttt	eq
 80161f8:	6819      	ldreq	r1, [r3, #0]
 80161fa:	685b      	ldreq	r3, [r3, #4]
 80161fc:	1809      	addeq	r1, r1, r0
 80161fe:	6021      	streq	r1, [r4, #0]
 8016200:	e7ed      	b.n	80161de <_free_r+0x1e>
 8016202:	461a      	mov	r2, r3
 8016204:	685b      	ldr	r3, [r3, #4]
 8016206:	b10b      	cbz	r3, 801620c <_free_r+0x4c>
 8016208:	42a3      	cmp	r3, r4
 801620a:	d9fa      	bls.n	8016202 <_free_r+0x42>
 801620c:	6811      	ldr	r1, [r2, #0]
 801620e:	1850      	adds	r0, r2, r1
 8016210:	42a0      	cmp	r0, r4
 8016212:	d10b      	bne.n	801622c <_free_r+0x6c>
 8016214:	6820      	ldr	r0, [r4, #0]
 8016216:	4401      	add	r1, r0
 8016218:	1850      	adds	r0, r2, r1
 801621a:	4283      	cmp	r3, r0
 801621c:	6011      	str	r1, [r2, #0]
 801621e:	d1e0      	bne.n	80161e2 <_free_r+0x22>
 8016220:	6818      	ldr	r0, [r3, #0]
 8016222:	685b      	ldr	r3, [r3, #4]
 8016224:	6053      	str	r3, [r2, #4]
 8016226:	4408      	add	r0, r1
 8016228:	6010      	str	r0, [r2, #0]
 801622a:	e7da      	b.n	80161e2 <_free_r+0x22>
 801622c:	d902      	bls.n	8016234 <_free_r+0x74>
 801622e:	230c      	movs	r3, #12
 8016230:	602b      	str	r3, [r5, #0]
 8016232:	e7d6      	b.n	80161e2 <_free_r+0x22>
 8016234:	6820      	ldr	r0, [r4, #0]
 8016236:	1821      	adds	r1, r4, r0
 8016238:	428b      	cmp	r3, r1
 801623a:	bf04      	itt	eq
 801623c:	6819      	ldreq	r1, [r3, #0]
 801623e:	685b      	ldreq	r3, [r3, #4]
 8016240:	6063      	str	r3, [r4, #4]
 8016242:	bf04      	itt	eq
 8016244:	1809      	addeq	r1, r1, r0
 8016246:	6021      	streq	r1, [r4, #0]
 8016248:	6054      	str	r4, [r2, #4]
 801624a:	e7ca      	b.n	80161e2 <_free_r+0x22>
 801624c:	bd38      	pop	{r3, r4, r5, pc}
 801624e:	bf00      	nop
 8016250:	20001d58 	.word	0x20001d58

08016254 <sbrk_aligned>:
 8016254:	b570      	push	{r4, r5, r6, lr}
 8016256:	4e0f      	ldr	r6, [pc, #60]	@ (8016294 <sbrk_aligned+0x40>)
 8016258:	460c      	mov	r4, r1
 801625a:	6831      	ldr	r1, [r6, #0]
 801625c:	4605      	mov	r5, r0
 801625e:	b911      	cbnz	r1, 8016266 <sbrk_aligned+0x12>
 8016260:	f000 f9d2 	bl	8016608 <_sbrk_r>
 8016264:	6030      	str	r0, [r6, #0]
 8016266:	4621      	mov	r1, r4
 8016268:	4628      	mov	r0, r5
 801626a:	f000 f9cd 	bl	8016608 <_sbrk_r>
 801626e:	1c43      	adds	r3, r0, #1
 8016270:	d103      	bne.n	801627a <sbrk_aligned+0x26>
 8016272:	f04f 34ff 	mov.w	r4, #4294967295
 8016276:	4620      	mov	r0, r4
 8016278:	bd70      	pop	{r4, r5, r6, pc}
 801627a:	1cc4      	adds	r4, r0, #3
 801627c:	f024 0403 	bic.w	r4, r4, #3
 8016280:	42a0      	cmp	r0, r4
 8016282:	d0f8      	beq.n	8016276 <sbrk_aligned+0x22>
 8016284:	1a21      	subs	r1, r4, r0
 8016286:	4628      	mov	r0, r5
 8016288:	f000 f9be 	bl	8016608 <_sbrk_r>
 801628c:	3001      	adds	r0, #1
 801628e:	d1f2      	bne.n	8016276 <sbrk_aligned+0x22>
 8016290:	e7ef      	b.n	8016272 <sbrk_aligned+0x1e>
 8016292:	bf00      	nop
 8016294:	20001d54 	.word	0x20001d54

08016298 <_malloc_r>:
 8016298:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801629c:	1ccd      	adds	r5, r1, #3
 801629e:	f025 0503 	bic.w	r5, r5, #3
 80162a2:	3508      	adds	r5, #8
 80162a4:	2d0c      	cmp	r5, #12
 80162a6:	bf38      	it	cc
 80162a8:	250c      	movcc	r5, #12
 80162aa:	2d00      	cmp	r5, #0
 80162ac:	4606      	mov	r6, r0
 80162ae:	db01      	blt.n	80162b4 <_malloc_r+0x1c>
 80162b0:	42a9      	cmp	r1, r5
 80162b2:	d904      	bls.n	80162be <_malloc_r+0x26>
 80162b4:	230c      	movs	r3, #12
 80162b6:	6033      	str	r3, [r6, #0]
 80162b8:	2000      	movs	r0, #0
 80162ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80162be:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8016394 <_malloc_r+0xfc>
 80162c2:	f000 f869 	bl	8016398 <__malloc_lock>
 80162c6:	f8d8 3000 	ldr.w	r3, [r8]
 80162ca:	461c      	mov	r4, r3
 80162cc:	bb44      	cbnz	r4, 8016320 <_malloc_r+0x88>
 80162ce:	4629      	mov	r1, r5
 80162d0:	4630      	mov	r0, r6
 80162d2:	f7ff ffbf 	bl	8016254 <sbrk_aligned>
 80162d6:	1c43      	adds	r3, r0, #1
 80162d8:	4604      	mov	r4, r0
 80162da:	d158      	bne.n	801638e <_malloc_r+0xf6>
 80162dc:	f8d8 4000 	ldr.w	r4, [r8]
 80162e0:	4627      	mov	r7, r4
 80162e2:	2f00      	cmp	r7, #0
 80162e4:	d143      	bne.n	801636e <_malloc_r+0xd6>
 80162e6:	2c00      	cmp	r4, #0
 80162e8:	d04b      	beq.n	8016382 <_malloc_r+0xea>
 80162ea:	6823      	ldr	r3, [r4, #0]
 80162ec:	4639      	mov	r1, r7
 80162ee:	4630      	mov	r0, r6
 80162f0:	eb04 0903 	add.w	r9, r4, r3
 80162f4:	f000 f988 	bl	8016608 <_sbrk_r>
 80162f8:	4581      	cmp	r9, r0
 80162fa:	d142      	bne.n	8016382 <_malloc_r+0xea>
 80162fc:	6821      	ldr	r1, [r4, #0]
 80162fe:	1a6d      	subs	r5, r5, r1
 8016300:	4629      	mov	r1, r5
 8016302:	4630      	mov	r0, r6
 8016304:	f7ff ffa6 	bl	8016254 <sbrk_aligned>
 8016308:	3001      	adds	r0, #1
 801630a:	d03a      	beq.n	8016382 <_malloc_r+0xea>
 801630c:	6823      	ldr	r3, [r4, #0]
 801630e:	442b      	add	r3, r5
 8016310:	6023      	str	r3, [r4, #0]
 8016312:	f8d8 3000 	ldr.w	r3, [r8]
 8016316:	685a      	ldr	r2, [r3, #4]
 8016318:	bb62      	cbnz	r2, 8016374 <_malloc_r+0xdc>
 801631a:	f8c8 7000 	str.w	r7, [r8]
 801631e:	e00f      	b.n	8016340 <_malloc_r+0xa8>
 8016320:	6822      	ldr	r2, [r4, #0]
 8016322:	1b52      	subs	r2, r2, r5
 8016324:	d420      	bmi.n	8016368 <_malloc_r+0xd0>
 8016326:	2a0b      	cmp	r2, #11
 8016328:	d917      	bls.n	801635a <_malloc_r+0xc2>
 801632a:	1961      	adds	r1, r4, r5
 801632c:	42a3      	cmp	r3, r4
 801632e:	6025      	str	r5, [r4, #0]
 8016330:	bf18      	it	ne
 8016332:	6059      	strne	r1, [r3, #4]
 8016334:	6863      	ldr	r3, [r4, #4]
 8016336:	bf08      	it	eq
 8016338:	f8c8 1000 	streq.w	r1, [r8]
 801633c:	5162      	str	r2, [r4, r5]
 801633e:	604b      	str	r3, [r1, #4]
 8016340:	4630      	mov	r0, r6
 8016342:	f000 f82f 	bl	80163a4 <__malloc_unlock>
 8016346:	f104 000b 	add.w	r0, r4, #11
 801634a:	1d23      	adds	r3, r4, #4
 801634c:	f020 0007 	bic.w	r0, r0, #7
 8016350:	1ac2      	subs	r2, r0, r3
 8016352:	bf1c      	itt	ne
 8016354:	1a1b      	subne	r3, r3, r0
 8016356:	50a3      	strne	r3, [r4, r2]
 8016358:	e7af      	b.n	80162ba <_malloc_r+0x22>
 801635a:	6862      	ldr	r2, [r4, #4]
 801635c:	42a3      	cmp	r3, r4
 801635e:	bf0c      	ite	eq
 8016360:	f8c8 2000 	streq.w	r2, [r8]
 8016364:	605a      	strne	r2, [r3, #4]
 8016366:	e7eb      	b.n	8016340 <_malloc_r+0xa8>
 8016368:	4623      	mov	r3, r4
 801636a:	6864      	ldr	r4, [r4, #4]
 801636c:	e7ae      	b.n	80162cc <_malloc_r+0x34>
 801636e:	463c      	mov	r4, r7
 8016370:	687f      	ldr	r7, [r7, #4]
 8016372:	e7b6      	b.n	80162e2 <_malloc_r+0x4a>
 8016374:	461a      	mov	r2, r3
 8016376:	685b      	ldr	r3, [r3, #4]
 8016378:	42a3      	cmp	r3, r4
 801637a:	d1fb      	bne.n	8016374 <_malloc_r+0xdc>
 801637c:	2300      	movs	r3, #0
 801637e:	6053      	str	r3, [r2, #4]
 8016380:	e7de      	b.n	8016340 <_malloc_r+0xa8>
 8016382:	230c      	movs	r3, #12
 8016384:	6033      	str	r3, [r6, #0]
 8016386:	4630      	mov	r0, r6
 8016388:	f000 f80c 	bl	80163a4 <__malloc_unlock>
 801638c:	e794      	b.n	80162b8 <_malloc_r+0x20>
 801638e:	6005      	str	r5, [r0, #0]
 8016390:	e7d6      	b.n	8016340 <_malloc_r+0xa8>
 8016392:	bf00      	nop
 8016394:	20001d58 	.word	0x20001d58

08016398 <__malloc_lock>:
 8016398:	4801      	ldr	r0, [pc, #4]	@ (80163a0 <__malloc_lock+0x8>)
 801639a:	f7ff bf0e 	b.w	80161ba <__retarget_lock_acquire_recursive>
 801639e:	bf00      	nop
 80163a0:	20001d50 	.word	0x20001d50

080163a4 <__malloc_unlock>:
 80163a4:	4801      	ldr	r0, [pc, #4]	@ (80163ac <__malloc_unlock+0x8>)
 80163a6:	f7ff bf09 	b.w	80161bc <__retarget_lock_release_recursive>
 80163aa:	bf00      	nop
 80163ac:	20001d50 	.word	0x20001d50

080163b0 <__sflush_r>:
 80163b0:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 80163b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80163b6:	0716      	lsls	r6, r2, #28
 80163b8:	4605      	mov	r5, r0
 80163ba:	460c      	mov	r4, r1
 80163bc:	d454      	bmi.n	8016468 <__sflush_r+0xb8>
 80163be:	684b      	ldr	r3, [r1, #4]
 80163c0:	2b00      	cmp	r3, #0
 80163c2:	dc02      	bgt.n	80163ca <__sflush_r+0x1a>
 80163c4:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 80163c6:	2b00      	cmp	r3, #0
 80163c8:	dd48      	ble.n	801645c <__sflush_r+0xac>
 80163ca:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 80163cc:	2e00      	cmp	r6, #0
 80163ce:	d045      	beq.n	801645c <__sflush_r+0xac>
 80163d0:	2300      	movs	r3, #0
 80163d2:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 80163d6:	682f      	ldr	r7, [r5, #0]
 80163d8:	6a21      	ldr	r1, [r4, #32]
 80163da:	602b      	str	r3, [r5, #0]
 80163dc:	d030      	beq.n	8016440 <__sflush_r+0x90>
 80163de:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 80163e0:	89a3      	ldrh	r3, [r4, #12]
 80163e2:	0759      	lsls	r1, r3, #29
 80163e4:	d505      	bpl.n	80163f2 <__sflush_r+0x42>
 80163e6:	6863      	ldr	r3, [r4, #4]
 80163e8:	1ad2      	subs	r2, r2, r3
 80163ea:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80163ec:	b10b      	cbz	r3, 80163f2 <__sflush_r+0x42>
 80163ee:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 80163f0:	1ad2      	subs	r2, r2, r3
 80163f2:	2300      	movs	r3, #0
 80163f4:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 80163f6:	6a21      	ldr	r1, [r4, #32]
 80163f8:	4628      	mov	r0, r5
 80163fa:	47b0      	blx	r6
 80163fc:	1c43      	adds	r3, r0, #1
 80163fe:	89a3      	ldrh	r3, [r4, #12]
 8016400:	d106      	bne.n	8016410 <__sflush_r+0x60>
 8016402:	6829      	ldr	r1, [r5, #0]
 8016404:	291d      	cmp	r1, #29
 8016406:	d82b      	bhi.n	8016460 <__sflush_r+0xb0>
 8016408:	4a28      	ldr	r2, [pc, #160]	@ (80164ac <__sflush_r+0xfc>)
 801640a:	410a      	asrs	r2, r1
 801640c:	07d6      	lsls	r6, r2, #31
 801640e:	d427      	bmi.n	8016460 <__sflush_r+0xb0>
 8016410:	2200      	movs	r2, #0
 8016412:	6062      	str	r2, [r4, #4]
 8016414:	04d9      	lsls	r1, r3, #19
 8016416:	6922      	ldr	r2, [r4, #16]
 8016418:	6022      	str	r2, [r4, #0]
 801641a:	d504      	bpl.n	8016426 <__sflush_r+0x76>
 801641c:	1c42      	adds	r2, r0, #1
 801641e:	d101      	bne.n	8016424 <__sflush_r+0x74>
 8016420:	682b      	ldr	r3, [r5, #0]
 8016422:	b903      	cbnz	r3, 8016426 <__sflush_r+0x76>
 8016424:	6560      	str	r0, [r4, #84]	@ 0x54
 8016426:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8016428:	602f      	str	r7, [r5, #0]
 801642a:	b1b9      	cbz	r1, 801645c <__sflush_r+0xac>
 801642c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8016430:	4299      	cmp	r1, r3
 8016432:	d002      	beq.n	801643a <__sflush_r+0x8a>
 8016434:	4628      	mov	r0, r5
 8016436:	f7ff fec3 	bl	80161c0 <_free_r>
 801643a:	2300      	movs	r3, #0
 801643c:	6363      	str	r3, [r4, #52]	@ 0x34
 801643e:	e00d      	b.n	801645c <__sflush_r+0xac>
 8016440:	2301      	movs	r3, #1
 8016442:	4628      	mov	r0, r5
 8016444:	47b0      	blx	r6
 8016446:	4602      	mov	r2, r0
 8016448:	1c50      	adds	r0, r2, #1
 801644a:	d1c9      	bne.n	80163e0 <__sflush_r+0x30>
 801644c:	682b      	ldr	r3, [r5, #0]
 801644e:	2b00      	cmp	r3, #0
 8016450:	d0c6      	beq.n	80163e0 <__sflush_r+0x30>
 8016452:	2b1d      	cmp	r3, #29
 8016454:	d001      	beq.n	801645a <__sflush_r+0xaa>
 8016456:	2b16      	cmp	r3, #22
 8016458:	d11d      	bne.n	8016496 <__sflush_r+0xe6>
 801645a:	602f      	str	r7, [r5, #0]
 801645c:	2000      	movs	r0, #0
 801645e:	e021      	b.n	80164a4 <__sflush_r+0xf4>
 8016460:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016464:	b21b      	sxth	r3, r3
 8016466:	e01a      	b.n	801649e <__sflush_r+0xee>
 8016468:	690f      	ldr	r7, [r1, #16]
 801646a:	2f00      	cmp	r7, #0
 801646c:	d0f6      	beq.n	801645c <__sflush_r+0xac>
 801646e:	0793      	lsls	r3, r2, #30
 8016470:	680e      	ldr	r6, [r1, #0]
 8016472:	bf08      	it	eq
 8016474:	694b      	ldreq	r3, [r1, #20]
 8016476:	600f      	str	r7, [r1, #0]
 8016478:	bf18      	it	ne
 801647a:	2300      	movne	r3, #0
 801647c:	1bf6      	subs	r6, r6, r7
 801647e:	608b      	str	r3, [r1, #8]
 8016480:	2e00      	cmp	r6, #0
 8016482:	ddeb      	ble.n	801645c <__sflush_r+0xac>
 8016484:	6a21      	ldr	r1, [r4, #32]
 8016486:	f8d4 c028 	ldr.w	ip, [r4, #40]	@ 0x28
 801648a:	4633      	mov	r3, r6
 801648c:	463a      	mov	r2, r7
 801648e:	4628      	mov	r0, r5
 8016490:	47e0      	blx	ip
 8016492:	2800      	cmp	r0, #0
 8016494:	dc07      	bgt.n	80164a6 <__sflush_r+0xf6>
 8016496:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801649a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801649e:	81a3      	strh	r3, [r4, #12]
 80164a0:	f04f 30ff 	mov.w	r0, #4294967295
 80164a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80164a6:	4407      	add	r7, r0
 80164a8:	1a36      	subs	r6, r6, r0
 80164aa:	e7e9      	b.n	8016480 <__sflush_r+0xd0>
 80164ac:	dfbffffe 	.word	0xdfbffffe

080164b0 <_fflush_r>:
 80164b0:	b538      	push	{r3, r4, r5, lr}
 80164b2:	690b      	ldr	r3, [r1, #16]
 80164b4:	4605      	mov	r5, r0
 80164b6:	460c      	mov	r4, r1
 80164b8:	b913      	cbnz	r3, 80164c0 <_fflush_r+0x10>
 80164ba:	2500      	movs	r5, #0
 80164bc:	4628      	mov	r0, r5
 80164be:	bd38      	pop	{r3, r4, r5, pc}
 80164c0:	b118      	cbz	r0, 80164ca <_fflush_r+0x1a>
 80164c2:	6a03      	ldr	r3, [r0, #32]
 80164c4:	b90b      	cbnz	r3, 80164ca <_fflush_r+0x1a>
 80164c6:	f7ff fc93 	bl	8015df0 <__sinit>
 80164ca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80164ce:	2b00      	cmp	r3, #0
 80164d0:	d0f3      	beq.n	80164ba <_fflush_r+0xa>
 80164d2:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 80164d4:	07d0      	lsls	r0, r2, #31
 80164d6:	d404      	bmi.n	80164e2 <_fflush_r+0x32>
 80164d8:	0599      	lsls	r1, r3, #22
 80164da:	d402      	bmi.n	80164e2 <_fflush_r+0x32>
 80164dc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 80164de:	f7ff fe6c 	bl	80161ba <__retarget_lock_acquire_recursive>
 80164e2:	4628      	mov	r0, r5
 80164e4:	4621      	mov	r1, r4
 80164e6:	f7ff ff63 	bl	80163b0 <__sflush_r>
 80164ea:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 80164ec:	07da      	lsls	r2, r3, #31
 80164ee:	4605      	mov	r5, r0
 80164f0:	d4e4      	bmi.n	80164bc <_fflush_r+0xc>
 80164f2:	89a3      	ldrh	r3, [r4, #12]
 80164f4:	059b      	lsls	r3, r3, #22
 80164f6:	d4e1      	bmi.n	80164bc <_fflush_r+0xc>
 80164f8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 80164fa:	f7ff fe5f 	bl	80161bc <__retarget_lock_release_recursive>
 80164fe:	e7dd      	b.n	80164bc <_fflush_r+0xc>

08016500 <__swhatbuf_r>:
 8016500:	b570      	push	{r4, r5, r6, lr}
 8016502:	460c      	mov	r4, r1
 8016504:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8016508:	2900      	cmp	r1, #0
 801650a:	b096      	sub	sp, #88	@ 0x58
 801650c:	4615      	mov	r5, r2
 801650e:	461e      	mov	r6, r3
 8016510:	da0d      	bge.n	801652e <__swhatbuf_r+0x2e>
 8016512:	89a3      	ldrh	r3, [r4, #12]
 8016514:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8016518:	f04f 0100 	mov.w	r1, #0
 801651c:	bf14      	ite	ne
 801651e:	2340      	movne	r3, #64	@ 0x40
 8016520:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8016524:	2000      	movs	r0, #0
 8016526:	6031      	str	r1, [r6, #0]
 8016528:	602b      	str	r3, [r5, #0]
 801652a:	b016      	add	sp, #88	@ 0x58
 801652c:	bd70      	pop	{r4, r5, r6, pc}
 801652e:	466a      	mov	r2, sp
 8016530:	f000 f848 	bl	80165c4 <_fstat_r>
 8016534:	2800      	cmp	r0, #0
 8016536:	dbec      	blt.n	8016512 <__swhatbuf_r+0x12>
 8016538:	9901      	ldr	r1, [sp, #4]
 801653a:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 801653e:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 8016542:	4259      	negs	r1, r3
 8016544:	4159      	adcs	r1, r3
 8016546:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801654a:	e7eb      	b.n	8016524 <__swhatbuf_r+0x24>

0801654c <__smakebuf_r>:
 801654c:	898b      	ldrh	r3, [r1, #12]
 801654e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8016550:	079d      	lsls	r5, r3, #30
 8016552:	4606      	mov	r6, r0
 8016554:	460c      	mov	r4, r1
 8016556:	d507      	bpl.n	8016568 <__smakebuf_r+0x1c>
 8016558:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 801655c:	6023      	str	r3, [r4, #0]
 801655e:	6123      	str	r3, [r4, #16]
 8016560:	2301      	movs	r3, #1
 8016562:	6163      	str	r3, [r4, #20]
 8016564:	b003      	add	sp, #12
 8016566:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016568:	ab01      	add	r3, sp, #4
 801656a:	466a      	mov	r2, sp
 801656c:	f7ff ffc8 	bl	8016500 <__swhatbuf_r>
 8016570:	9f00      	ldr	r7, [sp, #0]
 8016572:	4605      	mov	r5, r0
 8016574:	4639      	mov	r1, r7
 8016576:	4630      	mov	r0, r6
 8016578:	f7ff fe8e 	bl	8016298 <_malloc_r>
 801657c:	b948      	cbnz	r0, 8016592 <__smakebuf_r+0x46>
 801657e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8016582:	059a      	lsls	r2, r3, #22
 8016584:	d4ee      	bmi.n	8016564 <__smakebuf_r+0x18>
 8016586:	f023 0303 	bic.w	r3, r3, #3
 801658a:	f043 0302 	orr.w	r3, r3, #2
 801658e:	81a3      	strh	r3, [r4, #12]
 8016590:	e7e2      	b.n	8016558 <__smakebuf_r+0xc>
 8016592:	89a3      	ldrh	r3, [r4, #12]
 8016594:	6020      	str	r0, [r4, #0]
 8016596:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801659a:	81a3      	strh	r3, [r4, #12]
 801659c:	9b01      	ldr	r3, [sp, #4]
 801659e:	e9c4 0704 	strd	r0, r7, [r4, #16]
 80165a2:	b15b      	cbz	r3, 80165bc <__smakebuf_r+0x70>
 80165a4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80165a8:	4630      	mov	r0, r6
 80165aa:	f000 f81d 	bl	80165e8 <_isatty_r>
 80165ae:	b128      	cbz	r0, 80165bc <__smakebuf_r+0x70>
 80165b0:	89a3      	ldrh	r3, [r4, #12]
 80165b2:	f023 0303 	bic.w	r3, r3, #3
 80165b6:	f043 0301 	orr.w	r3, r3, #1
 80165ba:	81a3      	strh	r3, [r4, #12]
 80165bc:	89a3      	ldrh	r3, [r4, #12]
 80165be:	431d      	orrs	r5, r3
 80165c0:	81a5      	strh	r5, [r4, #12]
 80165c2:	e7cf      	b.n	8016564 <__smakebuf_r+0x18>

080165c4 <_fstat_r>:
 80165c4:	b538      	push	{r3, r4, r5, lr}
 80165c6:	4d07      	ldr	r5, [pc, #28]	@ (80165e4 <_fstat_r+0x20>)
 80165c8:	2300      	movs	r3, #0
 80165ca:	4604      	mov	r4, r0
 80165cc:	4608      	mov	r0, r1
 80165ce:	4611      	mov	r1, r2
 80165d0:	602b      	str	r3, [r5, #0]
 80165d2:	f7eb fb57 	bl	8001c84 <_fstat>
 80165d6:	1c43      	adds	r3, r0, #1
 80165d8:	d102      	bne.n	80165e0 <_fstat_r+0x1c>
 80165da:	682b      	ldr	r3, [r5, #0]
 80165dc:	b103      	cbz	r3, 80165e0 <_fstat_r+0x1c>
 80165de:	6023      	str	r3, [r4, #0]
 80165e0:	bd38      	pop	{r3, r4, r5, pc}
 80165e2:	bf00      	nop
 80165e4:	20001d4c 	.word	0x20001d4c

080165e8 <_isatty_r>:
 80165e8:	b538      	push	{r3, r4, r5, lr}
 80165ea:	4d06      	ldr	r5, [pc, #24]	@ (8016604 <_isatty_r+0x1c>)
 80165ec:	2300      	movs	r3, #0
 80165ee:	4604      	mov	r4, r0
 80165f0:	4608      	mov	r0, r1
 80165f2:	602b      	str	r3, [r5, #0]
 80165f4:	f7eb fb4c 	bl	8001c90 <_isatty>
 80165f8:	1c43      	adds	r3, r0, #1
 80165fa:	d102      	bne.n	8016602 <_isatty_r+0x1a>
 80165fc:	682b      	ldr	r3, [r5, #0]
 80165fe:	b103      	cbz	r3, 8016602 <_isatty_r+0x1a>
 8016600:	6023      	str	r3, [r4, #0]
 8016602:	bd38      	pop	{r3, r4, r5, pc}
 8016604:	20001d4c 	.word	0x20001d4c

08016608 <_sbrk_r>:
 8016608:	b538      	push	{r3, r4, r5, lr}
 801660a:	4d06      	ldr	r5, [pc, #24]	@ (8016624 <_sbrk_r+0x1c>)
 801660c:	2300      	movs	r3, #0
 801660e:	4604      	mov	r4, r0
 8016610:	4608      	mov	r0, r1
 8016612:	602b      	str	r3, [r5, #0]
 8016614:	f7eb fb40 	bl	8001c98 <_sbrk>
 8016618:	1c43      	adds	r3, r0, #1
 801661a:	d102      	bne.n	8016622 <_sbrk_r+0x1a>
 801661c:	682b      	ldr	r3, [r5, #0]
 801661e:	b103      	cbz	r3, 8016622 <_sbrk_r+0x1a>
 8016620:	6023      	str	r3, [r4, #0]
 8016622:	bd38      	pop	{r3, r4, r5, pc}
 8016624:	20001d4c 	.word	0x20001d4c

08016628 <floor>:
 8016628:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801662c:	f3c1 570a 	ubfx	r7, r1, #20, #11
 8016630:	f2a7 36ff 	subw	r6, r7, #1023	@ 0x3ff
 8016634:	2e13      	cmp	r6, #19
 8016636:	4602      	mov	r2, r0
 8016638:	460b      	mov	r3, r1
 801663a:	460c      	mov	r4, r1
 801663c:	4605      	mov	r5, r0
 801663e:	4680      	mov	r8, r0
 8016640:	dc35      	bgt.n	80166ae <floor+0x86>
 8016642:	2e00      	cmp	r6, #0
 8016644:	da17      	bge.n	8016676 <floor+0x4e>
 8016646:	a334      	add	r3, pc, #208	@ (adr r3, 8016718 <floor+0xf0>)
 8016648:	e9d3 2300 	ldrd	r2, r3, [r3]
 801664c:	f7e9 fda2 	bl	8000194 <__adddf3>
 8016650:	2200      	movs	r2, #0
 8016652:	2300      	movs	r3, #0
 8016654:	f7e9 ffd2 	bl	80005fc <__aeabi_dcmpgt>
 8016658:	b150      	cbz	r0, 8016670 <floor+0x48>
 801665a:	2c00      	cmp	r4, #0
 801665c:	da57      	bge.n	801670e <floor+0xe6>
 801665e:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8016662:	432c      	orrs	r4, r5
 8016664:	2500      	movs	r5, #0
 8016666:	42ac      	cmp	r4, r5
 8016668:	4c2d      	ldr	r4, [pc, #180]	@ (8016720 <floor+0xf8>)
 801666a:	bf08      	it	eq
 801666c:	f04f 4400 	moveq.w	r4, #2147483648	@ 0x80000000
 8016670:	4623      	mov	r3, r4
 8016672:	462a      	mov	r2, r5
 8016674:	e024      	b.n	80166c0 <floor+0x98>
 8016676:	4f2b      	ldr	r7, [pc, #172]	@ (8016724 <floor+0xfc>)
 8016678:	4137      	asrs	r7, r6
 801667a:	ea01 0c07 	and.w	ip, r1, r7
 801667e:	ea5c 0c00 	orrs.w	ip, ip, r0
 8016682:	d01d      	beq.n	80166c0 <floor+0x98>
 8016684:	a324      	add	r3, pc, #144	@ (adr r3, 8016718 <floor+0xf0>)
 8016686:	e9d3 2300 	ldrd	r2, r3, [r3]
 801668a:	f7e9 fd83 	bl	8000194 <__adddf3>
 801668e:	2200      	movs	r2, #0
 8016690:	2300      	movs	r3, #0
 8016692:	f7e9 ffb3 	bl	80005fc <__aeabi_dcmpgt>
 8016696:	2800      	cmp	r0, #0
 8016698:	d0ea      	beq.n	8016670 <floor+0x48>
 801669a:	2c00      	cmp	r4, #0
 801669c:	bfbe      	ittt	lt
 801669e:	f44f 1380 	movlt.w	r3, #1048576	@ 0x100000
 80166a2:	4133      	asrlt	r3, r6
 80166a4:	18e4      	addlt	r4, r4, r3
 80166a6:	ea24 0407 	bic.w	r4, r4, r7
 80166aa:	2500      	movs	r5, #0
 80166ac:	e7e0      	b.n	8016670 <floor+0x48>
 80166ae:	2e33      	cmp	r6, #51	@ 0x33
 80166b0:	dd0a      	ble.n	80166c8 <floor+0xa0>
 80166b2:	f5b6 6f80 	cmp.w	r6, #1024	@ 0x400
 80166b6:	d103      	bne.n	80166c0 <floor+0x98>
 80166b8:	f7e9 fd6c 	bl	8000194 <__adddf3>
 80166bc:	4602      	mov	r2, r0
 80166be:	460b      	mov	r3, r1
 80166c0:	4610      	mov	r0, r2
 80166c2:	4619      	mov	r1, r3
 80166c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80166c8:	f2a7 4713 	subw	r7, r7, #1043	@ 0x413
 80166cc:	f04f 3cff 	mov.w	ip, #4294967295
 80166d0:	fa2c f707 	lsr.w	r7, ip, r7
 80166d4:	4207      	tst	r7, r0
 80166d6:	d0f3      	beq.n	80166c0 <floor+0x98>
 80166d8:	a30f      	add	r3, pc, #60	@ (adr r3, 8016718 <floor+0xf0>)
 80166da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80166de:	f7e9 fd59 	bl	8000194 <__adddf3>
 80166e2:	2200      	movs	r2, #0
 80166e4:	2300      	movs	r3, #0
 80166e6:	f7e9 ff89 	bl	80005fc <__aeabi_dcmpgt>
 80166ea:	2800      	cmp	r0, #0
 80166ec:	d0c0      	beq.n	8016670 <floor+0x48>
 80166ee:	2c00      	cmp	r4, #0
 80166f0:	da0a      	bge.n	8016708 <floor+0xe0>
 80166f2:	2e14      	cmp	r6, #20
 80166f4:	d101      	bne.n	80166fa <floor+0xd2>
 80166f6:	3401      	adds	r4, #1
 80166f8:	e006      	b.n	8016708 <floor+0xe0>
 80166fa:	f1c6 0634 	rsb	r6, r6, #52	@ 0x34
 80166fe:	2301      	movs	r3, #1
 8016700:	40b3      	lsls	r3, r6
 8016702:	441d      	add	r5, r3
 8016704:	4545      	cmp	r5, r8
 8016706:	d3f6      	bcc.n	80166f6 <floor+0xce>
 8016708:	ea25 0507 	bic.w	r5, r5, r7
 801670c:	e7b0      	b.n	8016670 <floor+0x48>
 801670e:	2500      	movs	r5, #0
 8016710:	462c      	mov	r4, r5
 8016712:	e7ad      	b.n	8016670 <floor+0x48>
 8016714:	f3af 8000 	nop.w
 8016718:	8800759c 	.word	0x8800759c
 801671c:	7e37e43c 	.word	0x7e37e43c
 8016720:	bff00000 	.word	0xbff00000
 8016724:	000fffff 	.word	0x000fffff

08016728 <_init>:
 8016728:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801672a:	bf00      	nop
 801672c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801672e:	bc08      	pop	{r3}
 8016730:	469e      	mov	lr, r3
 8016732:	4770      	bx	lr

08016734 <_fini>:
 8016734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8016736:	bf00      	nop
 8016738:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801673a:	bc08      	pop	{r3}
 801673c:	469e      	mov	lr, r3
 801673e:	4770      	bx	lr
